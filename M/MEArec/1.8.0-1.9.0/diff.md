# Comparing `tmp/MEArec-1.8.0.tar.gz` & `tmp/MEArec-1.9.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "MEArec-1.8.0.tar", last modified: Mon Jul 18 16:37:51 2022, max compression
+gzip compressed data, was "MEArec-1.9.0.tar", last modified: Tue May 23 13:26:17 2023, max compression
```

## Comparing `MEArec-1.8.0.tar` & `MEArec-1.9.0.tar`

### file list

```diff
@@ -1,608 +1,595 @@
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.395014 MEArec-1.8.0/
--rw-r--r--   0 runner    (1001) docker     (121)    35147 2022-07-18 16:23:51.000000 MEArec-1.8.0/LICENSE
--rw-r--r--   0 runner    (1001) docker     (121)      121 2022-07-18 16:23:51.000000 MEArec-1.8.0/MANIFEST.in
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.331013 MEArec-1.8.0/MEArec/
--rw-r--r--   0 runner    (1001) docker     (121)      949 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.327013 MEArec-1.8.0/MEArec/cell_models/
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.331013 MEArec-1.8.0/MEArec/cell_models/bbp/
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.335013 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/
--rw-r--r--   0 runner    (1001) docker     (121)      132 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/.provenance.json
--rw-r--r--   0 runner    (1001) docker     (121)      492 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/CHANGELOG
--rw-r--r--   0 runner    (1001) docker     (121)     1571 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/LICENSE
--rw-r--r--   0 runner    (1001) docker     (121)     4471 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/README
--rw-r--r--   0 runner    (1001) docker     (121)       18 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/VERSION
--rw-r--r--   0 runner    (1001) docker     (121)     5711 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/biophysics.hoc
--rw-r--r--   0 runner    (1001) docker     (121)      269 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/cellinfo.json
--rw-r--r--   0 runner    (1001) docker     (121)     1619 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/constants.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     6084 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/creategui.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     4264 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/createsimulation.hoc
--rw-r--r--   0 runner    (1001) docker     (121)       36 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/current_amps.dat
--rw-r--r--   0 runner    (1001) docker     (121)     3391 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/init.hoc
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.335013 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/
--rw-r--r--   0 runner    (1001) docker     (121)     1002 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/Ca.mod
--rw-r--r--   0 runner    (1001) docker     (121)      681 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/CaDynamics_E2.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1106 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/Ca_LVAst.mod
--rw-r--r--   0 runner    (1001) docker     (121)      787 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/Ih.mod
--rw-r--r--   0 runner    (1001) docker     (121)      853 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/Im.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1221 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/K_Pst.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1109 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/K_Tst.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1088 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/NaTa_t.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1166 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/NaTs2_t.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1429 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/Nap_Et2.mod
--rw-r--r--   0 runner    (1001) docker     (121)    12651 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/ProbAMPANMDA_EMS.mod
--rw-r--r--   0 runner    (1001) docker     (121)    12261 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/ProbGABAAB_EMS.mod
--rw-r--r--   0 runner    (1001) docker     (121)      980 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/SK_E2.mod
--rw-r--r--   0 runner    (1001) docker     (121)      807 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/SKv3_1.mod
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.335013 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/morphology/
--rw-r--r--   0 runner    (1001) docker     (121)    89239 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/morphology/C240300C1_-_Scale_x1.000_y1.050_z1.000_-_Clone_17.asc
--rw-r--r--   0 runner    (1001) docker     (121)     1571 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/morphology.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     2030 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/mosinit.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     2203 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/ringplot.hoc
--rwxr-xr-x   0 runner    (1001) docker     (121)     5456 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/run.py
--rwxr-xr-x   0 runner    (1001) docker     (121)     7088 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/run_RmpRiTau.py
--rwxr-xr-x   0 runner    (1001) docker     (121)       44 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/run_RmpRiTau_py.sh
--rwxr-xr-x   0 runner    (1001) docker     (121)       42 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/run_hoc.sh
--rwxr-xr-x   0 runner    (1001) docker     (121)      114 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/run_py.sh
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.335013 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/synapses/
--rw-r--r--   0 runner    (1001) docker     (121)      559 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/synapses/mtype_map.tsv
--rw-r--r--   0 runner    (1001) docker     (121)    15838 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/synapses/synapses.hoc
--rw-r--r--   0 runner    (1001) docker     (121)    49137 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/synapses/synapses.tsv
--rw-r--r--   0 runner    (1001) docker     (121)     3259 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/synapses/synconf.txt
--rw-r--r--   0 runner    (1001) docker     (121)    11198 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/template.hoc
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.339013 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/
--rw-r--r--   0 runner    (1001) docker     (121)      133 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/.provenance.json
--rw-r--r--   0 runner    (1001) docker     (121)      492 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/CHANGELOG
--rw-r--r--   0 runner    (1001) docker     (121)     1571 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/LICENSE
--rw-r--r--   0 runner    (1001) docker     (121)     4471 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/README
--rw-r--r--   0 runner    (1001) docker     (121)       18 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/VERSION
--rw-r--r--   0 runner    (1001) docker     (121)     5718 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/biophysics.hoc
--rw-r--r--   0 runner    (1001) docker     (121)      273 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/cellinfo.json
--rw-r--r--   0 runner    (1001) docker     (121)     1619 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/constants.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     6084 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/creategui.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     4268 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/createsimulation.hoc
--rw-r--r--   0 runner    (1001) docker     (121)       39 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/current_amps.dat
--rw-r--r--   0 runner    (1001) docker     (121)     3391 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/init.hoc
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.339013 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/
--rw-r--r--   0 runner    (1001) docker     (121)     1002 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/Ca.mod
--rw-r--r--   0 runner    (1001) docker     (121)      681 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/CaDynamics_E2.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1106 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/Ca_LVAst.mod
--rw-r--r--   0 runner    (1001) docker     (121)      787 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/Ih.mod
--rw-r--r--   0 runner    (1001) docker     (121)      853 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/Im.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1221 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/K_Pst.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1109 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/K_Tst.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1088 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/NaTa_t.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1166 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/NaTs2_t.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1429 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/Nap_Et2.mod
--rw-r--r--   0 runner    (1001) docker     (121)    12651 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/ProbAMPANMDA_EMS.mod
--rw-r--r--   0 runner    (1001) docker     (121)    12261 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/ProbGABAAB_EMS.mod
--rw-r--r--   0 runner    (1001) docker     (121)      980 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/SK_E2.mod
--rw-r--r--   0 runner    (1001) docker     (121)      807 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/SKv3_1.mod
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.339013 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/morphology/
--rw-r--r--   0 runner    (1001) docker     (121)    72103 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/morphology/C160998B-I_-_Scale_x1.000_y1.050_z1.000_-_Clone_5.asc
--rw-r--r--   0 runner    (1001) docker     (121)     1571 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/morphology.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     2030 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mosinit.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     2203 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/ringplot.hoc
--rwxr-xr-x   0 runner    (1001) docker     (121)     5458 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/run.py
--rwxr-xr-x   0 runner    (1001) docker     (121)     7090 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/run_RmpRiTau.py
--rwxr-xr-x   0 runner    (1001) docker     (121)       44 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/run_RmpRiTau_py.sh
--rwxr-xr-x   0 runner    (1001) docker     (121)       42 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/run_hoc.sh
--rwxr-xr-x   0 runner    (1001) docker     (121)      114 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/run_py.sh
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.339013 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/synapses/
--rw-r--r--   0 runner    (1001) docker     (121)      559 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/synapses/mtype_map.tsv
--rw-r--r--   0 runner    (1001) docker     (121)    15839 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/synapses/synapses.hoc
--rw-r--r--   0 runner    (1001) docker     (121)   151542 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/synapses/synapses.tsv
--rw-r--r--   0 runner    (1001) docker     (121)    10683 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/synapses/synconf.txt
--rw-r--r--   0 runner    (1001) docker     (121)    11200 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/template.hoc
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.343013 MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/
--rw-r--r--   0 runner    (1001) docker     (121)      132 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/.provenance.json
--rw-r--r--   0 runner    (1001) docker     (121)      492 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/CHANGELOG
--rw-r--r--   0 runner    (1001) docker     (121)     1571 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/LICENSE
--rw-r--r--   0 runner    (1001) docker     (121)     4471 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/README
--rw-r--r--   0 runner    (1001) docker     (121)       18 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/VERSION
--rw-r--r--   0 runner    (1001) docker     (121)     5715 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/biophysics.hoc
--rw-r--r--   0 runner    (1001) docker     (121)      277 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/cellinfo.json
--rw-r--r--   0 runner    (1001) docker     (121)     1619 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/constants.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     6084 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/creategui.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     4271 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/createsimulation.hoc
--rw-r--r--   0 runner    (1001) docker     (121)       39 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/current_amps.dat
--rw-r--r--   0 runner    (1001) docker     (121)     3391 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/init.hoc
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.343013 MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/
--rw-r--r--   0 runner    (1001) docker     (121)     1002 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/Ca.mod
--rw-r--r--   0 runner    (1001) docker     (121)      681 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/CaDynamics_E2.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1106 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/Ca_LVAst.mod
--rw-r--r--   0 runner    (1001) docker     (121)      787 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/Ih.mod
--rw-r--r--   0 runner    (1001) docker     (121)      853 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/Im.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1221 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/K_Pst.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1109 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/K_Tst.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1088 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/NaTa_t.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1166 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/NaTs2_t.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1429 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/Nap_Et2.mod
--rw-r--r--   0 runner    (1001) docker     (121)    12651 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/ProbAMPANMDA_EMS.mod
--rw-r--r--   0 runner    (1001) docker     (121)    12261 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/ProbGABAAB_EMS.mod
--rw-r--r--   0 runner    (1001) docker     (121)      980 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/SK_E2.mod
--rw-r--r--   0 runner    (1001) docker     (121)      807 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/SKv3_1.mod
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.343013 MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/morphology/
--rw-r--r--   0 runner    (1001) docker     (121)   409097 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/morphology/C091000D-I3_-_Scale_x1.000_y1.025_z1.000_-_Clone_6.asc
--rw-r--r--   0 runner    (1001) docker     (121)     1572 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/morphology.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     2030 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mosinit.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     2203 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/ringplot.hoc
--rwxr-xr-x   0 runner    (1001) docker     (121)     5464 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/run.py
--rwxr-xr-x   0 runner    (1001) docker     (121)     7096 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/run_RmpRiTau.py
--rwxr-xr-x   0 runner    (1001) docker     (121)       44 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/run_RmpRiTau_py.sh
--rwxr-xr-x   0 runner    (1001) docker     (121)       42 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/run_hoc.sh
--rwxr-xr-x   0 runner    (1001) docker     (121)      114 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/run_py.sh
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.343013 MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/synapses/
--rw-r--r--   0 runner    (1001) docker     (121)      559 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/synapses/mtype_map.tsv
--rw-r--r--   0 runner    (1001) docker     (121)    15838 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/synapses/synapses.hoc
--rw-r--r--   0 runner    (1001) docker     (121)   244967 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/synapses/synapses.tsv
--rw-r--r--   0 runner    (1001) docker     (121)    18852 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/synapses/synconf.txt
--rw-r--r--   0 runner    (1001) docker     (121)    11209 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/template.hoc
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.347013 MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/
--rw-r--r--   0 runner    (1001) docker     (121)      133 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/.provenance.json
--rw-r--r--   0 runner    (1001) docker     (121)      492 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/CHANGELOG
--rw-r--r--   0 runner    (1001) docker     (121)     1571 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/LICENSE
--rw-r--r--   0 runner    (1001) docker     (121)     4471 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/README
--rw-r--r--   0 runner    (1001) docker     (121)       18 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/VERSION
--rw-r--r--   0 runner    (1001) docker     (121)     5718 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/biophysics.hoc
--rw-r--r--   0 runner    (1001) docker     (121)      283 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/cellinfo.json
--rw-r--r--   0 runner    (1001) docker     (121)     1619 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/constants.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     6084 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/creategui.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     4265 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/createsimulation.hoc
--rw-r--r--   0 runner    (1001) docker     (121)       36 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/current_amps.dat
--rw-r--r--   0 runner    (1001) docker     (121)     3391 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/init.hoc
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.347013 MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/
--rw-r--r--   0 runner    (1001) docker     (121)     1002 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/Ca.mod
--rw-r--r--   0 runner    (1001) docker     (121)      681 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/CaDynamics_E2.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1106 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/Ca_LVAst.mod
--rw-r--r--   0 runner    (1001) docker     (121)      787 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/Ih.mod
--rw-r--r--   0 runner    (1001) docker     (121)      853 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/Im.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1221 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/K_Pst.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1109 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/K_Tst.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1088 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/NaTa_t.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1166 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/NaTs2_t.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1429 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/Nap_Et2.mod
--rw-r--r--   0 runner    (1001) docker     (121)    12651 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/ProbAMPANMDA_EMS.mod
--rw-r--r--   0 runner    (1001) docker     (121)    12261 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/ProbGABAAB_EMS.mod
--rw-r--r--   0 runner    (1001) docker     (121)      980 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/SK_E2.mod
--rw-r--r--   0 runner    (1001) docker     (121)      807 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/SKv3_1.mod
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.347013 MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/morphology/
--rw-r--r--   0 runner    (1001) docker     (121)   732565 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/morphology/rp100428-12_idC_-_Scale_x1.000_y1.025_z1.000_-_Clone_1.asc
--rw-r--r--   0 runner    (1001) docker     (121)     1576 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/morphology.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     2030 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mosinit.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     2203 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/ringplot.hoc
--rwxr-xr-x   0 runner    (1001) docker     (121)     5458 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/run.py
--rwxr-xr-x   0 runner    (1001) docker     (121)     7090 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/run_RmpRiTau.py
--rwxr-xr-x   0 runner    (1001) docker     (121)       44 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/run_RmpRiTau_py.sh
--rwxr-xr-x   0 runner    (1001) docker     (121)       42 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/run_hoc.sh
--rwxr-xr-x   0 runner    (1001) docker     (121)      114 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/run_py.sh
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.347013 MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/synapses/
--rw-r--r--   0 runner    (1001) docker     (121)      559 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/synapses/mtype_map.tsv
--rw-r--r--   0 runner    (1001) docker     (121)    15839 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/synapses/synapses.hoc
--rw-r--r--   0 runner    (1001) docker     (121)    69674 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/synapses/synapses.tsv
--rw-r--r--   0 runner    (1001) docker     (121)     4960 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/synapses/synconf.txt
--rw-r--r--   0 runner    (1001) docker     (121)    11200 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/template.hoc
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.355013 MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/
--rw-r--r--   0 runner    (1001) docker     (121)      133 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/.provenance.json
--rw-r--r--   0 runner    (1001) docker     (121)      492 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/CHANGELOG
--rw-r--r--   0 runner    (1001) docker     (121)     1571 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/LICENSE
--rw-r--r--   0 runner    (1001) docker     (121)     4471 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/README
--rw-r--r--   0 runner    (1001) docker     (121)       18 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/VERSION
--rw-r--r--   0 runner    (1001) docker     (121)     5718 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/biophysics.hoc
--rw-r--r--   0 runner    (1001) docker     (121)      285 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/cellinfo.json
--rw-r--r--   0 runner    (1001) docker     (121)     1619 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/constants.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     6084 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/creategui.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     4268 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/createsimulation.hoc
--rw-r--r--   0 runner    (1001) docker     (121)       39 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/current_amps.dat
--rw-r--r--   0 runner    (1001) docker     (121)     3391 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/init.hoc
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.359013 MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/
--rw-r--r--   0 runner    (1001) docker     (121)     1002 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/Ca.mod
--rw-r--r--   0 runner    (1001) docker     (121)      681 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/CaDynamics_E2.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1106 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/Ca_LVAst.mod
--rw-r--r--   0 runner    (1001) docker     (121)      787 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/Ih.mod
--rw-r--r--   0 runner    (1001) docker     (121)      853 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/Im.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1221 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/K_Pst.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1109 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/K_Tst.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1088 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/NaTa_t.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1166 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/NaTs2_t.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1429 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/Nap_Et2.mod
--rw-r--r--   0 runner    (1001) docker     (121)    12651 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/ProbAMPANMDA_EMS.mod
--rw-r--r--   0 runner    (1001) docker     (121)    12261 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/ProbGABAAB_EMS.mod
--rw-r--r--   0 runner    (1001) docker     (121)      980 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/SK_E2.mod
--rw-r--r--   0 runner    (1001) docker     (121)      807 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/SKv3_1.mod
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.359013 MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/morphology/
--rw-r--r--   0 runner    (1001) docker     (121)   780506 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/morphology/og061123b1-3_idB_-_Scale_x1.000_y0.975_z1.000_-_Clone_4.asc
--rw-r--r--   0 runner    (1001) docker     (121)     1577 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/morphology.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     2030 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mosinit.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     2203 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/ringplot.hoc
--rwxr-xr-x   0 runner    (1001) docker     (121)     5458 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/run.py
--rwxr-xr-x   0 runner    (1001) docker     (121)     7090 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/run_RmpRiTau.py
--rwxr-xr-x   0 runner    (1001) docker     (121)       44 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/run_RmpRiTau_py.sh
--rwxr-xr-x   0 runner    (1001) docker     (121)       42 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/run_hoc.sh
--rwxr-xr-x   0 runner    (1001) docker     (121)      114 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/run_py.sh
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.359013 MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/synapses/
--rw-r--r--   0 runner    (1001) docker     (121)      559 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/synapses/mtype_map.tsv
--rw-r--r--   0 runner    (1001) docker     (121)    15839 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/synapses/synapses.hoc
--rw-r--r--   0 runner    (1001) docker     (121)   358510 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/synapses/synapses.tsv
--rw-r--r--   0 runner    (1001) docker     (121)    28325 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/synapses/synconf.txt
--rw-r--r--   0 runner    (1001) docker     (121)    11200 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/template.hoc
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.359013 MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/
--rw-r--r--   0 runner    (1001) docker     (121)      132 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/.provenance.json
--rw-r--r--   0 runner    (1001) docker     (121)      492 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/CHANGELOG
--rw-r--r--   0 runner    (1001) docker     (121)     1571 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/LICENSE
--rw-r--r--   0 runner    (1001) docker     (121)     4471 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/README
--rw-r--r--   0 runner    (1001) docker     (121)       18 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/VERSION
--rw-r--r--   0 runner    (1001) docker     (121)     5718 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/biophysics.hoc
--rw-r--r--   0 runner    (1001) docker     (121)      185 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/cellinfo.json
--rw-r--r--   0 runner    (1001) docker     (121)     1619 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/constants.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     6084 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/creategui.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     4267 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/createsimulation.hoc
--rw-r--r--   0 runner    (1001) docker     (121)       39 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/current_amps.dat
--rw-r--r--   0 runner    (1001) docker     (121)     3391 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/init.hoc
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.363014 MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/
--rw-r--r--   0 runner    (1001) docker     (121)     1002 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/Ca.mod
--rw-r--r--   0 runner    (1001) docker     (121)      681 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/CaDynamics_E2.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1106 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/Ca_LVAst.mod
--rw-r--r--   0 runner    (1001) docker     (121)      787 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/Ih.mod
--rw-r--r--   0 runner    (1001) docker     (121)      853 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/Im.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1221 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/K_Pst.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1109 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/K_Tst.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1088 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/NaTa_t.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1166 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/NaTs2_t.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1429 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/Nap_Et2.mod
--rw-r--r--   0 runner    (1001) docker     (121)    12651 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/ProbAMPANMDA_EMS.mod
--rw-r--r--   0 runner    (1001) docker     (121)    12261 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/ProbGABAAB_EMS.mod
--rw-r--r--   0 runner    (1001) docker     (121)      980 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/SK_E2.mod
--rw-r--r--   0 runner    (1001) docker     (121)      807 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/SKv3_1.mod
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.363014 MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/morphology/
--rw-r--r--   0 runner    (1001) docker     (121)   604368 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/morphology/C040601.asc
--rw-r--r--   0 runner    (1001) docker     (121)     1529 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/morphology.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     2030 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/mosinit.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     2203 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/ringplot.hoc
--rwxr-xr-x   0 runner    (1001) docker     (121)     5456 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/run.py
--rwxr-xr-x   0 runner    (1001) docker     (121)     7088 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/run_RmpRiTau.py
--rwxr-xr-x   0 runner    (1001) docker     (121)       44 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/run_RmpRiTau_py.sh
--rwxr-xr-x   0 runner    (1001) docker     (121)       42 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/run_hoc.sh
--rwxr-xr-x   0 runner    (1001) docker     (121)      114 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/run_py.sh
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.363014 MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/synapses/
--rw-r--r--   0 runner    (1001) docker     (121)      559 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/synapses/mtype_map.tsv
--rw-r--r--   0 runner    (1001) docker     (121)    15838 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/synapses/synapses.hoc
--rw-r--r--   0 runner    (1001) docker     (121)   231703 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/synapses/synapses.tsv
--rw-r--r--   0 runner    (1001) docker     (121)    18146 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/synapses/synconf.txt
--rw-r--r--   0 runner    (1001) docker     (121)    11198 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/template.hoc
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.367014 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/
--rw-r--r--   0 runner    (1001) docker     (121)      132 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/.provenance.json
--rw-r--r--   0 runner    (1001) docker     (121)      492 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/CHANGELOG
--rw-r--r--   0 runner    (1001) docker     (121)     1571 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/LICENSE
--rw-r--r--   0 runner    (1001) docker     (121)     4471 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/README
--rw-r--r--   0 runner    (1001) docker     (121)       18 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/VERSION
--rw-r--r--   0 runner    (1001) docker     (121)     5718 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/biophysics.hoc
--rw-r--r--   0 runner    (1001) docker     (121)      270 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/cellinfo.json
--rw-r--r--   0 runner    (1001) docker     (121)     1619 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/constants.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     6084 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/creategui.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     4268 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/createsimulation.hoc
--rw-r--r--   0 runner    (1001) docker     (121)       39 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/current_amps.dat
--rw-r--r--   0 runner    (1001) docker     (121)     3391 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/init.hoc
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.367014 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/
--rw-r--r--   0 runner    (1001) docker     (121)     1002 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/Ca.mod
--rw-r--r--   0 runner    (1001) docker     (121)      681 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/CaDynamics_E2.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1106 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/Ca_LVAst.mod
--rw-r--r--   0 runner    (1001) docker     (121)      787 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/Ih.mod
--rw-r--r--   0 runner    (1001) docker     (121)      853 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/Im.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1221 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/K_Pst.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1109 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/K_Tst.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1088 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/NaTa_t.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1166 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/NaTs2_t.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1429 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/Nap_Et2.mod
--rw-r--r--   0 runner    (1001) docker     (121)    12651 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/ProbAMPANMDA_EMS.mod
--rw-r--r--   0 runner    (1001) docker     (121)    12261 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/ProbGABAAB_EMS.mod
--rw-r--r--   0 runner    (1001) docker     (121)      980 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/SK_E2.mod
--rw-r--r--   0 runner    (1001) docker     (121)      807 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/SKv3_1.mod
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.367014 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/morphology/
--rw-r--r--   0 runner    (1001) docker     (121)   323350 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/morphology/C080301B1_-_Scale_x1.000_y1.050_z1.000_-_Clone_2.asc
--rw-r--r--   0 runner    (1001) docker     (121)     1570 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/morphology.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     2030 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mosinit.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     2203 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/ringplot.hoc
--rwxr-xr-x   0 runner    (1001) docker     (121)     5458 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/run.py
--rwxr-xr-x   0 runner    (1001) docker     (121)     7090 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/run_RmpRiTau.py
--rwxr-xr-x   0 runner    (1001) docker     (121)       44 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/run_RmpRiTau_py.sh
--rwxr-xr-x   0 runner    (1001) docker     (121)       42 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/run_hoc.sh
--rwxr-xr-x   0 runner    (1001) docker     (121)      114 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/run_py.sh
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.367014 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/synapses/
--rw-r--r--   0 runner    (1001) docker     (121)      559 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/synapses/mtype_map.tsv
--rw-r--r--   0 runner    (1001) docker     (121)    15838 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/synapses/synapses.hoc
--rw-r--r--   0 runner    (1001) docker     (121)   376717 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/synapses/synapses.tsv
--rw-r--r--   0 runner    (1001) docker     (121)    30392 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/synapses/synconf.txt
--rw-r--r--   0 runner    (1001) docker     (121)    11200 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/template.hoc
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.371014 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/
--rw-r--r--   0 runner    (1001) docker     (121)      132 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/.provenance.json
--rw-r--r--   0 runner    (1001) docker     (121)      492 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/CHANGELOG
--rw-r--r--   0 runner    (1001) docker     (121)     1571 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/LICENSE
--rw-r--r--   0 runner    (1001) docker     (121)     4471 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/README
--rw-r--r--   0 runner    (1001) docker     (121)       18 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/VERSION
--rw-r--r--   0 runner    (1001) docker     (121)     5711 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/biophysics.hoc
--rw-r--r--   0 runner    (1001) docker     (121)      291 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/cellinfo.json
--rw-r--r--   0 runner    (1001) docker     (121)     1619 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/constants.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     6084 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/creategui.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     4267 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/createsimulation.hoc
--rw-r--r--   0 runner    (1001) docker     (121)       37 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/current_amps.dat
--rw-r--r--   0 runner    (1001) docker     (121)     3391 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/init.hoc
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.371014 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/
--rw-r--r--   0 runner    (1001) docker     (121)     1002 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/Ca.mod
--rw-r--r--   0 runner    (1001) docker     (121)      681 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/CaDynamics_E2.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1106 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/Ca_LVAst.mod
--rw-r--r--   0 runner    (1001) docker     (121)      787 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/Ih.mod
--rw-r--r--   0 runner    (1001) docker     (121)      853 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/Im.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1221 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/K_Pst.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1109 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/K_Tst.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1088 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/NaTa_t.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1166 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/NaTs2_t.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1429 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/Nap_Et2.mod
--rw-r--r--   0 runner    (1001) docker     (121)    12651 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/ProbAMPANMDA_EMS.mod
--rw-r--r--   0 runner    (1001) docker     (121)    12261 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/ProbGABAAB_EMS.mod
--rw-r--r--   0 runner    (1001) docker     (121)      980 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/SK_E2.mod
--rw-r--r--   0 runner    (1001) docker     (121)      807 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/SKv3_1.mod
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.371014 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/morphology/
--rw-r--r--   0 runner    (1001) docker     (121)   334377 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/morphology/rp110125_L5-2_idA_-_Scale_x1.000_y0.950_z1.000_-_Clone_42.asc
--rw-r--r--   0 runner    (1001) docker     (121)     1579 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/morphology.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     2030 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mosinit.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     2203 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/ringplot.hoc
--rwxr-xr-x   0 runner    (1001) docker     (121)     5460 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/run.py
--rwxr-xr-x   0 runner    (1001) docker     (121)     7092 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/run_RmpRiTau.py
--rwxr-xr-x   0 runner    (1001) docker     (121)       44 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/run_RmpRiTau_py.sh
--rwxr-xr-x   0 runner    (1001) docker     (121)       42 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/run_hoc.sh
--rwxr-xr-x   0 runner    (1001) docker     (121)      114 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/run_py.sh
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.371014 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/synapses/
--rw-r--r--   0 runner    (1001) docker     (121)      559 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/synapses/mtype_map.tsv
--rw-r--r--   0 runner    (1001) docker     (121)    15838 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/synapses/synapses.hoc
--rw-r--r--   0 runner    (1001) docker     (121)    40598 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/synapses/synapses.tsv
--rw-r--r--   0 runner    (1001) docker     (121)     2697 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/synapses/synconf.txt
--rw-r--r--   0 runner    (1001) docker     (121)    11203 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/template.hoc
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.375014 MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/
--rw-r--r--   0 runner    (1001) docker     (121)      132 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/.provenance.json
--rw-r--r--   0 runner    (1001) docker     (121)      492 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/CHANGELOG
--rw-r--r--   0 runner    (1001) docker     (121)     1571 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/LICENSE
--rw-r--r--   0 runner    (1001) docker     (121)     4471 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/README
--rw-r--r--   0 runner    (1001) docker     (121)       18 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/VERSION
--rw-r--r--   0 runner    (1001) docker     (121)     5711 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/biophysics.hoc
--rw-r--r--   0 runner    (1001) docker     (121)      283 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/cellinfo.json
--rw-r--r--   0 runner    (1001) docker     (121)     1619 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/constants.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     6084 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/creategui.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     4269 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/createsimulation.hoc
--rw-r--r--   0 runner    (1001) docker     (121)       39 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/current_amps.dat
--rw-r--r--   0 runner    (1001) docker     (121)     3391 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/init.hoc
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.375014 MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/
--rw-r--r--   0 runner    (1001) docker     (121)     1002 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/Ca.mod
--rw-r--r--   0 runner    (1001) docker     (121)      681 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/CaDynamics_E2.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1106 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/Ca_LVAst.mod
--rw-r--r--   0 runner    (1001) docker     (121)      787 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/Ih.mod
--rw-r--r--   0 runner    (1001) docker     (121)      853 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/Im.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1221 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/K_Pst.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1109 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/K_Tst.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1088 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/NaTa_t.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1166 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/NaTs2_t.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1429 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/Nap_Et2.mod
--rw-r--r--   0 runner    (1001) docker     (121)    12651 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/ProbAMPANMDA_EMS.mod
--rw-r--r--   0 runner    (1001) docker     (121)    12261 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/ProbGABAAB_EMS.mod
--rw-r--r--   0 runner    (1001) docker     (121)      980 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/SK_E2.mod
--rw-r--r--   0 runner    (1001) docker     (121)      807 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/SKv3_1.mod
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.375014 MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/morphology/
--rw-r--r--   0 runner    (1001) docker     (121)   266052 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/morphology/og061106a1_idA_-_Scale_x1.000_y1.050_z1.000_-_Clone_5.asc
--rw-r--r--   0 runner    (1001) docker     (121)     1575 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/morphology.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     2030 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mosinit.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     2203 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/ringplot.hoc
--rwxr-xr-x   0 runner    (1001) docker     (121)     5460 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/run.py
--rwxr-xr-x   0 runner    (1001) docker     (121)     7092 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/run_RmpRiTau.py
--rwxr-xr-x   0 runner    (1001) docker     (121)       44 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/run_RmpRiTau_py.sh
--rwxr-xr-x   0 runner    (1001) docker     (121)       42 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/run_hoc.sh
--rwxr-xr-x   0 runner    (1001) docker     (121)      114 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/run_py.sh
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.375014 MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/synapses/
--rw-r--r--   0 runner    (1001) docker     (121)      559 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/synapses/mtype_map.tsv
--rw-r--r--   0 runner    (1001) docker     (121)    15838 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/synapses/synapses.hoc
--rw-r--r--   0 runner    (1001) docker     (121)   121199 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/synapses/synapses.tsv
--rw-r--r--   0 runner    (1001) docker     (121)     8724 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/synapses/synconf.txt
--rw-r--r--   0 runner    (1001) docker     (121)    11203 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/template.hoc
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.379014 MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/
--rw-r--r--   0 runner    (1001) docker     (121)      132 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/.provenance.json
--rw-r--r--   0 runner    (1001) docker     (121)      492 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/CHANGELOG
--rw-r--r--   0 runner    (1001) docker     (121)     1571 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/LICENSE
--rw-r--r--   0 runner    (1001) docker     (121)     4471 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/README
--rw-r--r--   0 runner    (1001) docker     (121)       18 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/VERSION
--rw-r--r--   0 runner    (1001) docker     (121)     4250 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/biophysics.hoc
--rw-r--r--   0 runner    (1001) docker     (121)      268 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/cellinfo.json
--rw-r--r--   0 runner    (1001) docker     (121)     1619 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/constants.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     6084 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/creategui.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     4257 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/createsimulation.hoc
--rw-r--r--   0 runner    (1001) docker     (121)       24 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/current_amps.dat
--rw-r--r--   0 runner    (1001) docker     (121)     3391 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/init.hoc
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.379014 MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/
--rw-r--r--   0 runner    (1001) docker     (121)      681 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/CaDynamics_E2.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1022 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/Ca_HVA.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1106 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/Ca_LVAst.mod
--rw-r--r--   0 runner    (1001) docker     (121)      787 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/Ih.mod
--rw-r--r--   0 runner    (1001) docker     (121)      853 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/Im.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1221 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/K_Pst.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1109 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/K_Tst.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1088 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/NaTa_t.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1166 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/NaTs2_t.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1429 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/Nap_Et2.mod
--rw-r--r--   0 runner    (1001) docker     (121)    12651 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/ProbAMPANMDA_EMS.mod
--rw-r--r--   0 runner    (1001) docker     (121)    12261 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/ProbGABAAB_EMS.mod
--rw-r--r--   0 runner    (1001) docker     (121)      980 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/SK_E2.mod
--rw-r--r--   0 runner    (1001) docker     (121)      807 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/SKv3_1.mod
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.379014 MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/morphology/
--rw-r--r--   0 runner    (1001) docker     (121)   200764 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/morphology/dend-C231296A-P3_axon-C231296A-P3_-_Clone_9.asc
--rw-r--r--   0 runner    (1001) docker     (121)     1565 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/morphology.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     2030 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mosinit.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     2203 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/ringplot.hoc
--rwxr-xr-x   0 runner    (1001) docker     (121)     5466 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/run.py
--rwxr-xr-x   0 runner    (1001) docker     (121)     7098 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/run_RmpRiTau.py
--rwxr-xr-x   0 runner    (1001) docker     (121)       44 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/run_RmpRiTau_py.sh
--rwxr-xr-x   0 runner    (1001) docker     (121)       42 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/run_hoc.sh
--rwxr-xr-x   0 runner    (1001) docker     (121)      114 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/run_py.sh
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.379014 MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/synapses/
--rw-r--r--   0 runner    (1001) docker     (121)      559 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/synapses/mtype_map.tsv
--rw-r--r--   0 runner    (1001) docker     (121)    15838 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/synapses/synapses.hoc
--rw-r--r--   0 runner    (1001) docker     (121)   628013 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/synapses/synapses.tsv
--rw-r--r--   0 runner    (1001) docker     (121)    50783 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/synapses/synconf.txt
--rw-r--r--   0 runner    (1001) docker     (121)    11211 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/template.hoc
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.383014 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/
--rw-r--r--   0 runner    (1001) docker     (121)      132 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/.provenance.json
--rw-r--r--   0 runner    (1001) docker     (121)      492 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/CHANGELOG
--rw-r--r--   0 runner    (1001) docker     (121)     1571 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/LICENSE
--rw-r--r--   0 runner    (1001) docker     (121)     4471 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/README
--rw-r--r--   0 runner    (1001) docker     (121)       18 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/VERSION
--rw-r--r--   0 runner    (1001) docker     (121)     4250 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/biophysics.hoc
--rw-r--r--   0 runner    (1001) docker     (121)      243 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/cellinfo.json
--rw-r--r--   0 runner    (1001) docker     (121)     1619 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/constants.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     6084 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/creategui.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     4270 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/createsimulation.hoc
--rw-r--r--   0 runner    (1001) docker     (121)       36 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/current_amps.dat
--rw-r--r--   0 runner    (1001) docker     (121)     3391 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/init.hoc
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.383014 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/
--rw-r--r--   0 runner    (1001) docker     (121)      681 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/CaDynamics_E2.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1022 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/Ca_HVA.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1106 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/Ca_LVAst.mod
--rw-r--r--   0 runner    (1001) docker     (121)      787 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/Ih.mod
--rw-r--r--   0 runner    (1001) docker     (121)      853 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/Im.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1221 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/K_Pst.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1109 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/K_Tst.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1088 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/NaTa_t.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1166 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/NaTs2_t.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1429 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/Nap_Et2.mod
--rw-r--r--   0 runner    (1001) docker     (121)    12651 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/ProbAMPANMDA_EMS.mod
--rw-r--r--   0 runner    (1001) docker     (121)    12261 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/ProbGABAAB_EMS.mod
--rw-r--r--   0 runner    (1001) docker     (121)      980 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/SK_E2.mod
--rw-r--r--   0 runner    (1001) docker     (121)      807 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/SKv3_1.mod
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.383014 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/morphology/
--rw-r--r--   0 runner    (1001) docker     (121)   954647 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/morphology/dend-C060114A2_axon-C060114A5.asc
--rw-r--r--   0 runner    (1001) docker     (121)     1551 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/morphology.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     2030 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mosinit.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     2203 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/ringplot.hoc
--rwxr-xr-x   0 runner    (1001) docker     (121)     5468 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/run.py
--rwxr-xr-x   0 runner    (1001) docker     (121)     7100 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/run_RmpRiTau.py
--rwxr-xr-x   0 runner    (1001) docker     (121)       44 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/run_RmpRiTau_py.sh
--rwxr-xr-x   0 runner    (1001) docker     (121)       42 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/run_hoc.sh
--rwxr-xr-x   0 runner    (1001) docker     (121)      114 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/run_py.sh
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.387014 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/synapses/
--rw-r--r--   0 runner    (1001) docker     (121)      559 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/synapses/mtype_map.tsv
--rw-r--r--   0 runner    (1001) docker     (121)    15838 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/synapses/synapses.hoc
--rw-r--r--   0 runner    (1001) docker     (121)   931577 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/synapses/synapses.tsv
--rw-r--r--   0 runner    (1001) docker     (121)    84112 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/synapses/synconf.txt
--rw-r--r--   0 runner    (1001) docker     (121)    11213 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/template.hoc
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.387014 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/
--rw-r--r--   0 runner    (1001) docker     (121)      132 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/.provenance.json
--rw-r--r--   0 runner    (1001) docker     (121)      492 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/CHANGELOG
--rw-r--r--   0 runner    (1001) docker     (121)     1571 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/LICENSE
--rw-r--r--   0 runner    (1001) docker     (121)     4471 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/README
--rw-r--r--   0 runner    (1001) docker     (121)       18 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/VERSION
--rw-r--r--   0 runner    (1001) docker     (121)     4250 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/biophysics.hoc
--rw-r--r--   0 runner    (1001) docker     (121)      263 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/cellinfo.json
--rw-r--r--   0 runner    (1001) docker     (121)     1619 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/constants.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     6084 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/creategui.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     4273 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/createsimulation.hoc
--rw-r--r--   0 runner    (1001) docker     (121)       39 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/current_amps.dat
--rw-r--r--   0 runner    (1001) docker     (121)     3391 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/init.hoc
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.387014 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/
--rw-r--r--   0 runner    (1001) docker     (121)      681 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/CaDynamics_E2.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1022 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/Ca_HVA.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1106 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/Ca_LVAst.mod
--rw-r--r--   0 runner    (1001) docker     (121)      787 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/Ih.mod
--rw-r--r--   0 runner    (1001) docker     (121)      853 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/Im.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1221 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/K_Pst.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1109 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/K_Tst.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1088 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/NaTa_t.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1166 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/NaTs2_t.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1429 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/Nap_Et2.mod
--rw-r--r--   0 runner    (1001) docker     (121)    12651 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/ProbAMPANMDA_EMS.mod
--rw-r--r--   0 runner    (1001) docker     (121)    12261 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/ProbGABAAB_EMS.mod
--rw-r--r--   0 runner    (1001) docker     (121)      980 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/SK_E2.mod
--rw-r--r--   0 runner    (1001) docker     (121)      807 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/SKv3_1.mod
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.391014 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/morphology/
--rw-r--r--   0 runner    (1001) docker     (121)   728920 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/morphology/dend-C060114A7_axon-C060116A3_-_Clone_2.asc
--rw-r--r--   0 runner    (1001) docker     (121)     1561 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/morphology.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     2030 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mosinit.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     2203 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/ringplot.hoc
--rwxr-xr-x   0 runner    (1001) docker     (121)     5468 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/run.py
--rwxr-xr-x   0 runner    (1001) docker     (121)     7100 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/run_RmpRiTau.py
--rwxr-xr-x   0 runner    (1001) docker     (121)       44 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/run_RmpRiTau_py.sh
--rwxr-xr-x   0 runner    (1001) docker     (121)       42 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/run_hoc.sh
--rwxr-xr-x   0 runner    (1001) docker     (121)      114 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/run_py.sh
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.391014 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/synapses/
--rw-r--r--   0 runner    (1001) docker     (121)      559 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/synapses/mtype_map.tsv
--rw-r--r--   0 runner    (1001) docker     (121)    15838 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/synapses/synapses.hoc
--rw-r--r--   0 runner    (1001) docker     (121)   835414 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/synapses/synapses.tsv
--rw-r--r--   0 runner    (1001) docker     (121)    79007 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/synapses/synconf.txt
--rw-r--r--   0 runner    (1001) docker     (121)    11213 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/template.hoc
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.391014 MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/
--rw-r--r--   0 runner    (1001) docker     (121)      133 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/.provenance.json
--rw-r--r--   0 runner    (1001) docker     (121)      492 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/CHANGELOG
--rw-r--r--   0 runner    (1001) docker     (121)     1571 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/LICENSE
--rw-r--r--   0 runner    (1001) docker     (121)     4471 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/README
--rw-r--r--   0 runner    (1001) docker     (121)       18 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/VERSION
--rw-r--r--   0 runner    (1001) docker     (121)     4250 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/biophysics.hoc
--rw-r--r--   0 runner    (1001) docker     (121)      329 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/cellinfo.json
--rw-r--r--   0 runner    (1001) docker     (121)     1619 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/constants.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     6084 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/creategui.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     4272 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/createsimulation.hoc
--rw-r--r--   0 runner    (1001) docker     (121)       39 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/current_amps.dat
--rw-r--r--   0 runner    (1001) docker     (121)     3391 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/init.hoc
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.395014 MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/
--rw-r--r--   0 runner    (1001) docker     (121)      681 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/CaDynamics_E2.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1022 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/Ca_HVA.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1106 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/Ca_LVAst.mod
--rw-r--r--   0 runner    (1001) docker     (121)      787 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/Ih.mod
--rw-r--r--   0 runner    (1001) docker     (121)      853 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/Im.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1221 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/K_Pst.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1109 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/K_Tst.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1088 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/NaTa_t.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1166 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/NaTs2_t.mod
--rw-r--r--   0 runner    (1001) docker     (121)     1429 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/Nap_Et2.mod
--rw-r--r--   0 runner    (1001) docker     (121)    12651 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/ProbAMPANMDA_EMS.mod
--rw-r--r--   0 runner    (1001) docker     (121)    12261 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/ProbGABAAB_EMS.mod
--rw-r--r--   0 runner    (1001) docker     (121)      980 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/SK_E2.mod
--rw-r--r--   0 runner    (1001) docker     (121)      807 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/SKv3_1.mod
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.395014 MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/morphology/
--rw-r--r--   0 runner    (1001) docker     (121)   575337 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/morphology/dend-Fluo15_left_axon-Fluo15_left_-_Scale_x1.000_y0.950_z1.000_-_Clone_30.asc
--rw-r--r--   0 runner    (1001) docker     (121)     1595 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/morphology.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     2030 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mosinit.hoc
--rw-r--r--   0 runner    (1001) docker     (121)     2203 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/ringplot.hoc
--rwxr-xr-x   0 runner    (1001) docker     (121)     5466 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/run.py
--rwxr-xr-x   0 runner    (1001) docker     (121)     7098 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/run_RmpRiTau.py
--rwxr-xr-x   0 runner    (1001) docker     (121)       44 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/run_RmpRiTau_py.sh
--rwxr-xr-x   0 runner    (1001) docker     (121)       42 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/run_hoc.sh
--rwxr-xr-x   0 runner    (1001) docker     (121)      114 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/run_py.sh
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.395014 MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/synapses/
--rw-r--r--   0 runner    (1001) docker     (121)      559 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/synapses/mtype_map.tsv
--rw-r--r--   0 runner    (1001) docker     (121)    15839 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/synapses/synapses.hoc
--rw-r--r--   0 runner    (1001) docker     (121)   248218 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/synapses/synapses.tsv
--rw-r--r--   0 runner    (1001) docker     (121)    18612 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/synapses/synconf.txt
--rw-r--r--   0 runner    (1001) docker     (121)    11211 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/template.hoc
--rw-r--r--   0 runner    (1001) docker     (121)    27257 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/cli.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.395014 MEArec-1.8.0/MEArec/default_params/
--rw-r--r--   0 runner    (1001) docker     (121)     6311 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/default_params/recordings_params.yaml
--rw-r--r--   0 runner    (1001) docker     (121)     2185 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/default_params/templates_params.yaml
--rw-r--r--   0 runner    (1001) docker     (121)     8439 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/drift_tools.py
--rw-r--r--   0 runner    (1001) docker     (121)    10403 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/generation_tools.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.395014 MEArec-1.8.0/MEArec/generators/
--rw-r--r--   0 runner    (1001) docker     (121)      153 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/generators/__init__.py
--rw-r--r--   0 runner    (1001) docker     (121)    12583 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/generators/recgensteps.py
--rw-r--r--   0 runner    (1001) docker     (121)    66798 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/generators/recordinggenerator.py
--rw-r--r--   0 runner    (1001) docker     (121)    13375 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/generators/spiketraingenerator.py
--rw-r--r--   0 runner    (1001) docker     (121)    12675 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/generators/templategenerator.py
--rw-r--r--   0 runner    (1001) docker     (121)    54817 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/simulate_cells.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.395014 MEArec-1.8.0/MEArec/tests/
--rw-r--r--   0 runner    (1001) docker     (121)        0 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (121)    45224 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/tests/test_generators.py
--rwxr-xr-x   0 runner    (1001) docker     (121)   139969 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/tools.py
--rw-r--r--   0 runner    (1001) docker     (121)       18 2022-07-18 16:23:51.000000 MEArec-1.8.0/MEArec/version.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-07-18 16:37:51.335013 MEArec-1.8.0/MEArec.egg-info/
--rw-r--r--   0 runner    (1001) docker     (121)     2064 2022-07-18 16:37:50.000000 MEArec-1.8.0/MEArec.egg-info/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (121)    31480 2022-07-18 16:37:51.000000 MEArec-1.8.0/MEArec.egg-info/SOURCES.txt
--rw-r--r--   0 runner    (1001) docker     (121)        1 2022-07-18 16:37:50.000000 MEArec-1.8.0/MEArec.egg-info/dependency_links.txt
--rw-r--r--   0 runner    (1001) docker     (121)       42 2022-07-18 16:37:51.000000 MEArec-1.8.0/MEArec.egg-info/entry_points.txt
--rw-r--r--   0 runner    (1001) docker     (121)       86 2022-07-18 16:37:51.000000 MEArec-1.8.0/MEArec.egg-info/requires.txt
--rw-r--r--   0 runner    (1001) docker     (121)        7 2022-07-18 16:37:51.000000 MEArec-1.8.0/MEArec.egg-info/top_level.txt
--rw-r--r--   0 runner    (1001) docker     (121)     2064 2022-07-18 16:37:51.395014 MEArec-1.8.0/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (121)     1539 2022-07-18 16:23:51.000000 MEArec-1.8.0/README.md
--rw-r--r--   0 runner    (1001) docker     (121)       38 2022-07-18 16:37:51.395014 MEArec-1.8.0/setup.cfg
--rw-r--r--   0 runner    (1001) docker     (121)     1084 2022-07-18 16:23:51.000000 MEArec-1.8.0/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.382394 MEArec-1.9.0/
+-rw-r--r--   0 runner    (1001) docker     (123)    35147 2023-05-23 13:11:28.000000 MEArec-1.9.0/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)     2426 2023-05-23 13:26:17.382394 MEArec-1.9.0/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)     1563 2023-05-23 13:11:28.000000 MEArec-1.9.0/README.md
+-rw-r--r--   0 runner    (1001) docker     (123)     1751 2023-05-23 13:11:28.000000 MEArec-1.9.0/pyproject.toml
+-rw-r--r--   0 runner    (1001) docker     (123)       38 2023-05-23 13:26:17.382394 MEArec-1.9.0/setup.cfg
+-rw-r--r--   0 runner    (1001) docker     (123)      218 2023-05-23 13:11:28.000000 MEArec-1.9.0/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.294393 MEArec-1.9.0/src/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.298393 MEArec-1.9.0/src/MEArec/
+-rw-r--r--   0 runner    (1001) docker     (123)     1554 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.294393 MEArec-1.9.0/src/MEArec/cell_models/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.298393 MEArec-1.9.0/src/MEArec/cell_models/bbp/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.302393 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/
+-rw-r--r--   0 runner    (1001) docker     (123)      492 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/CHANGELOG
+-rw-r--r--   0 runner    (1001) docker     (123)     1571 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)     4471 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/README
+-rw-r--r--   0 runner    (1001) docker     (123)       18 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/VERSION
+-rw-r--r--   0 runner    (1001) docker     (123)     5711 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/biophysics.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)      269 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/cellinfo.json
+-rw-r--r--   0 runner    (1001) docker     (123)     1619 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/constants.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     6084 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/creategui.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     4264 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/createsimulation.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)       36 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/current_amps.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     3391 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/init.hoc
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.306393 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/
+-rw-r--r--   0 runner    (1001) docker     (123)     1002 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/Ca.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      681 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/CaDynamics_E2.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1106 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/Ca_LVAst.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      787 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/Ih.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      853 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/Im.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1221 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/K_Pst.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1109 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/K_Tst.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1088 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/NaTa_t.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1166 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/NaTs2_t.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1429 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/Nap_Et2.mod
+-rw-r--r--   0 runner    (1001) docker     (123)    12651 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/ProbAMPANMDA_EMS.mod
+-rw-r--r--   0 runner    (1001) docker     (123)    12261 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/ProbGABAAB_EMS.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      980 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/SK_E2.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      807 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/SKv3_1.mod
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.306393 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/morphology/
+-rw-r--r--   0 runner    (1001) docker     (123)    89239 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/morphology/C240300C1_-_Scale_x1.000_y1.050_z1.000_-_Clone_17.asc
+-rw-r--r--   0 runner    (1001) docker     (123)     1571 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/morphology.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     2030 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/mosinit.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     2203 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/ringplot.hoc
+-rwxr-xr-x   0 runner    (1001) docker     (123)     5331 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/run.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)     6801 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/run_RmpRiTau.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)       44 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/run_RmpRiTau_py.sh
+-rwxr-xr-x   0 runner    (1001) docker     (123)       42 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/run_hoc.sh
+-rwxr-xr-x   0 runner    (1001) docker     (123)      114 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/run_py.sh
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.306393 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/synapses/
+-rw-r--r--   0 runner    (1001) docker     (123)      559 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/synapses/mtype_map.tsv
+-rw-r--r--   0 runner    (1001) docker     (123)    15838 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/synapses/synapses.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)    49137 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/synapses/synapses.tsv
+-rw-r--r--   0 runner    (1001) docker     (123)     3259 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/synapses/synconf.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    11198 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/template.hoc
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.306393 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/
+-rw-r--r--   0 runner    (1001) docker     (123)      492 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/CHANGELOG
+-rw-r--r--   0 runner    (1001) docker     (123)     1571 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)     4471 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/README
+-rw-r--r--   0 runner    (1001) docker     (123)       18 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/VERSION
+-rw-r--r--   0 runner    (1001) docker     (123)     5718 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/biophysics.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)      273 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/cellinfo.json
+-rw-r--r--   0 runner    (1001) docker     (123)     1619 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/constants.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     6084 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/creategui.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     4268 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/createsimulation.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)       39 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/current_amps.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     3391 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/init.hoc
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.310393 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/
+-rw-r--r--   0 runner    (1001) docker     (123)     1002 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/Ca.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      681 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/CaDynamics_E2.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1106 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/Ca_LVAst.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      787 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/Ih.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      853 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/Im.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1221 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/K_Pst.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1109 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/K_Tst.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1088 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/NaTa_t.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1166 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/NaTs2_t.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1429 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/Nap_Et2.mod
+-rw-r--r--   0 runner    (1001) docker     (123)    12651 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/ProbAMPANMDA_EMS.mod
+-rw-r--r--   0 runner    (1001) docker     (123)    12261 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/ProbGABAAB_EMS.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      980 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/SK_E2.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      807 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/SKv3_1.mod
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.310393 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/morphology/
+-rw-r--r--   0 runner    (1001) docker     (123)    72103 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/morphology/C160998B-I_-_Scale_x1.000_y1.050_z1.000_-_Clone_5.asc
+-rw-r--r--   0 runner    (1001) docker     (123)     1571 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/morphology.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     2030 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mosinit.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     2203 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/ringplot.hoc
+-rwxr-xr-x   0 runner    (1001) docker     (123)     5333 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/run.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)     6803 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/run_RmpRiTau.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)       44 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/run_RmpRiTau_py.sh
+-rwxr-xr-x   0 runner    (1001) docker     (123)       42 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/run_hoc.sh
+-rwxr-xr-x   0 runner    (1001) docker     (123)      114 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/run_py.sh
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.310393 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/synapses/
+-rw-r--r--   0 runner    (1001) docker     (123)      559 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/synapses/mtype_map.tsv
+-rw-r--r--   0 runner    (1001) docker     (123)    15839 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/synapses/synapses.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)   151542 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/synapses/synapses.tsv
+-rw-r--r--   0 runner    (1001) docker     (123)    10683 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/synapses/synconf.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    11200 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/template.hoc
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.314394 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/
+-rw-r--r--   0 runner    (1001) docker     (123)      492 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/CHANGELOG
+-rw-r--r--   0 runner    (1001) docker     (123)     1571 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)     4471 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/README
+-rw-r--r--   0 runner    (1001) docker     (123)       18 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/VERSION
+-rw-r--r--   0 runner    (1001) docker     (123)     5715 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/biophysics.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)      277 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/cellinfo.json
+-rw-r--r--   0 runner    (1001) docker     (123)     1619 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/constants.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     6084 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/creategui.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     4271 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/createsimulation.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)       39 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/current_amps.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     3391 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/init.hoc
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.314394 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/
+-rw-r--r--   0 runner    (1001) docker     (123)     1002 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/Ca.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      681 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/CaDynamics_E2.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1106 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/Ca_LVAst.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      787 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/Ih.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      853 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/Im.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1221 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/K_Pst.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1109 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/K_Tst.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1088 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/NaTa_t.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1166 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/NaTs2_t.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1429 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/Nap_Et2.mod
+-rw-r--r--   0 runner    (1001) docker     (123)    12651 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/ProbAMPANMDA_EMS.mod
+-rw-r--r--   0 runner    (1001) docker     (123)    12261 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/ProbGABAAB_EMS.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      980 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/SK_E2.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      807 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/SKv3_1.mod
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.314394 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/morphology/
+-rw-r--r--   0 runner    (1001) docker     (123)   409097 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/morphology/C091000D-I3_-_Scale_x1.000_y1.025_z1.000_-_Clone_6.asc
+-rw-r--r--   0 runner    (1001) docker     (123)     1572 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/morphology.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     2030 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mosinit.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     2203 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/ringplot.hoc
+-rwxr-xr-x   0 runner    (1001) docker     (123)     5339 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/run.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)     6809 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/run_RmpRiTau.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)       44 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/run_RmpRiTau_py.sh
+-rwxr-xr-x   0 runner    (1001) docker     (123)       42 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/run_hoc.sh
+-rwxr-xr-x   0 runner    (1001) docker     (123)      114 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/run_py.sh
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.318394 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/synapses/
+-rw-r--r--   0 runner    (1001) docker     (123)      559 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/synapses/mtype_map.tsv
+-rw-r--r--   0 runner    (1001) docker     (123)    15838 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/synapses/synapses.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)   244967 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/synapses/synapses.tsv
+-rw-r--r--   0 runner    (1001) docker     (123)    18852 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/synapses/synconf.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    11209 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/template.hoc
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.318394 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/
+-rw-r--r--   0 runner    (1001) docker     (123)      492 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/CHANGELOG
+-rw-r--r--   0 runner    (1001) docker     (123)     1571 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)     4471 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/README
+-rw-r--r--   0 runner    (1001) docker     (123)       18 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/VERSION
+-rw-r--r--   0 runner    (1001) docker     (123)     5718 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/biophysics.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)      283 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/cellinfo.json
+-rw-r--r--   0 runner    (1001) docker     (123)     1619 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/constants.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     6084 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/creategui.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     4265 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/createsimulation.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)       36 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/current_amps.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     3391 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/init.hoc
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.322394 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/
+-rw-r--r--   0 runner    (1001) docker     (123)     1002 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/Ca.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      681 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/CaDynamics_E2.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1106 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/Ca_LVAst.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      787 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/Ih.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      853 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/Im.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1221 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/K_Pst.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1109 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/K_Tst.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1088 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/NaTa_t.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1166 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/NaTs2_t.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1429 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/Nap_Et2.mod
+-rw-r--r--   0 runner    (1001) docker     (123)    12651 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/ProbAMPANMDA_EMS.mod
+-rw-r--r--   0 runner    (1001) docker     (123)    12261 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/ProbGABAAB_EMS.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      980 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/SK_E2.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      807 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/SKv3_1.mod
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.322394 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/morphology/
+-rw-r--r--   0 runner    (1001) docker     (123)   732565 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/morphology/rp100428-12_idC_-_Scale_x1.000_y1.025_z1.000_-_Clone_1.asc
+-rw-r--r--   0 runner    (1001) docker     (123)     1576 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/morphology.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     2030 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mosinit.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     2203 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/ringplot.hoc
+-rwxr-xr-x   0 runner    (1001) docker     (123)     5333 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/run.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)     6803 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/run_RmpRiTau.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)       44 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/run_RmpRiTau_py.sh
+-rwxr-xr-x   0 runner    (1001) docker     (123)       42 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/run_hoc.sh
+-rwxr-xr-x   0 runner    (1001) docker     (123)      114 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/run_py.sh
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.322394 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/synapses/
+-rw-r--r--   0 runner    (1001) docker     (123)      559 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/synapses/mtype_map.tsv
+-rw-r--r--   0 runner    (1001) docker     (123)    15839 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/synapses/synapses.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)    69674 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/synapses/synapses.tsv
+-rw-r--r--   0 runner    (1001) docker     (123)     4960 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/synapses/synconf.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    11200 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/template.hoc
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.326394 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/
+-rw-r--r--   0 runner    (1001) docker     (123)      492 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/CHANGELOG
+-rw-r--r--   0 runner    (1001) docker     (123)     1571 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)     4471 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/README
+-rw-r--r--   0 runner    (1001) docker     (123)       18 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/VERSION
+-rw-r--r--   0 runner    (1001) docker     (123)     5718 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/biophysics.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)      285 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/cellinfo.json
+-rw-r--r--   0 runner    (1001) docker     (123)     1619 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/constants.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     6084 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/creategui.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     4268 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/createsimulation.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)       39 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/current_amps.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     3391 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/init.hoc
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.326394 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/
+-rw-r--r--   0 runner    (1001) docker     (123)     1002 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/Ca.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      681 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/CaDynamics_E2.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1106 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/Ca_LVAst.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      787 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/Ih.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      853 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/Im.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1221 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/K_Pst.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1109 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/K_Tst.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1088 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/NaTa_t.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1166 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/NaTs2_t.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1429 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/Nap_Et2.mod
+-rw-r--r--   0 runner    (1001) docker     (123)    12651 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/ProbAMPANMDA_EMS.mod
+-rw-r--r--   0 runner    (1001) docker     (123)    12261 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/ProbGABAAB_EMS.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      980 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/SK_E2.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      807 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/SKv3_1.mod
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.326394 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/morphology/
+-rw-r--r--   0 runner    (1001) docker     (123)   780506 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/morphology/og061123b1-3_idB_-_Scale_x1.000_y0.975_z1.000_-_Clone_4.asc
+-rw-r--r--   0 runner    (1001) docker     (123)     1577 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/morphology.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     2030 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mosinit.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     2203 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/ringplot.hoc
+-rwxr-xr-x   0 runner    (1001) docker     (123)     5333 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/run.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)     6803 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/run_RmpRiTau.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)       44 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/run_RmpRiTau_py.sh
+-rwxr-xr-x   0 runner    (1001) docker     (123)       42 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/run_hoc.sh
+-rwxr-xr-x   0 runner    (1001) docker     (123)      114 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/run_py.sh
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.330394 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/synapses/
+-rw-r--r--   0 runner    (1001) docker     (123)      559 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/synapses/mtype_map.tsv
+-rw-r--r--   0 runner    (1001) docker     (123)    15839 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/synapses/synapses.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)   358510 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/synapses/synapses.tsv
+-rw-r--r--   0 runner    (1001) docker     (123)    28325 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/synapses/synconf.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    11200 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/template.hoc
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.330394 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/
+-rw-r--r--   0 runner    (1001) docker     (123)      492 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/CHANGELOG
+-rw-r--r--   0 runner    (1001) docker     (123)     1571 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)     4471 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/README
+-rw-r--r--   0 runner    (1001) docker     (123)       18 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/VERSION
+-rw-r--r--   0 runner    (1001) docker     (123)     5718 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/biophysics.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)      185 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/cellinfo.json
+-rw-r--r--   0 runner    (1001) docker     (123)     1619 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/constants.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     6084 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/creategui.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     4267 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/createsimulation.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)       39 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/current_amps.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     3391 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/init.hoc
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.334394 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/
+-rw-r--r--   0 runner    (1001) docker     (123)     1002 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/Ca.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      681 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/CaDynamics_E2.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1106 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/Ca_LVAst.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      787 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/Ih.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      853 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/Im.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1221 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/K_Pst.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1109 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/K_Tst.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1088 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/NaTa_t.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1166 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/NaTs2_t.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1429 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/Nap_Et2.mod
+-rw-r--r--   0 runner    (1001) docker     (123)    12651 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/ProbAMPANMDA_EMS.mod
+-rw-r--r--   0 runner    (1001) docker     (123)    12261 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/ProbGABAAB_EMS.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      980 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/SK_E2.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      807 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/SKv3_1.mod
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.334394 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/morphology/
+-rw-r--r--   0 runner    (1001) docker     (123)   604368 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/morphology/C040601.asc
+-rw-r--r--   0 runner    (1001) docker     (123)     1529 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/morphology.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     2030 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/mosinit.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     2203 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/ringplot.hoc
+-rwxr-xr-x   0 runner    (1001) docker     (123)     5331 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/run.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)     6801 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/run_RmpRiTau.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)       44 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/run_RmpRiTau_py.sh
+-rwxr-xr-x   0 runner    (1001) docker     (123)       42 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/run_hoc.sh
+-rwxr-xr-x   0 runner    (1001) docker     (123)      114 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/run_py.sh
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.334394 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/synapses/
+-rw-r--r--   0 runner    (1001) docker     (123)      559 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/synapses/mtype_map.tsv
+-rw-r--r--   0 runner    (1001) docker     (123)    15838 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/synapses/synapses.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)   231703 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/synapses/synapses.tsv
+-rw-r--r--   0 runner    (1001) docker     (123)    18146 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/synapses/synconf.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    11198 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/template.hoc
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.338394 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/
+-rw-r--r--   0 runner    (1001) docker     (123)      492 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/CHANGELOG
+-rw-r--r--   0 runner    (1001) docker     (123)     1571 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)     4471 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/README
+-rw-r--r--   0 runner    (1001) docker     (123)       18 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/VERSION
+-rw-r--r--   0 runner    (1001) docker     (123)     5718 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/biophysics.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)      270 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/cellinfo.json
+-rw-r--r--   0 runner    (1001) docker     (123)     1619 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/constants.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     6084 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/creategui.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     4268 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/createsimulation.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)       39 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/current_amps.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     3391 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/init.hoc
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.338394 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/
+-rw-r--r--   0 runner    (1001) docker     (123)     1002 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/Ca.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      681 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/CaDynamics_E2.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1106 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/Ca_LVAst.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      787 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/Ih.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      853 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/Im.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1221 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/K_Pst.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1109 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/K_Tst.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1088 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/NaTa_t.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1166 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/NaTs2_t.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1429 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/Nap_Et2.mod
+-rw-r--r--   0 runner    (1001) docker     (123)    12651 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/ProbAMPANMDA_EMS.mod
+-rw-r--r--   0 runner    (1001) docker     (123)    12261 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/ProbGABAAB_EMS.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      980 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/SK_E2.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      807 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/SKv3_1.mod
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.338394 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/morphology/
+-rw-r--r--   0 runner    (1001) docker     (123)   323350 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/morphology/C080301B1_-_Scale_x1.000_y1.050_z1.000_-_Clone_2.asc
+-rw-r--r--   0 runner    (1001) docker     (123)     1570 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/morphology.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     2030 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mosinit.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     2203 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/ringplot.hoc
+-rwxr-xr-x   0 runner    (1001) docker     (123)     5333 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/run.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)     6803 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/run_RmpRiTau.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)       44 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/run_RmpRiTau_py.sh
+-rwxr-xr-x   0 runner    (1001) docker     (123)       42 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/run_hoc.sh
+-rwxr-xr-x   0 runner    (1001) docker     (123)      114 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/run_py.sh
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.342394 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/synapses/
+-rw-r--r--   0 runner    (1001) docker     (123)      559 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/synapses/mtype_map.tsv
+-rw-r--r--   0 runner    (1001) docker     (123)    15838 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/synapses/synapses.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)   376717 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/synapses/synapses.tsv
+-rw-r--r--   0 runner    (1001) docker     (123)    30392 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/synapses/synconf.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    11200 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/template.hoc
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.342394 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/
+-rw-r--r--   0 runner    (1001) docker     (123)      492 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/CHANGELOG
+-rw-r--r--   0 runner    (1001) docker     (123)     1571 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)     4471 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/README
+-rw-r--r--   0 runner    (1001) docker     (123)       18 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/VERSION
+-rw-r--r--   0 runner    (1001) docker     (123)     5711 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/biophysics.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)      291 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/cellinfo.json
+-rw-r--r--   0 runner    (1001) docker     (123)     1619 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/constants.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     6084 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/creategui.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     4267 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/createsimulation.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)       37 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/current_amps.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     3391 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/init.hoc
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.346394 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/
+-rw-r--r--   0 runner    (1001) docker     (123)     1002 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/Ca.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      681 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/CaDynamics_E2.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1106 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/Ca_LVAst.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      787 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/Ih.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      853 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/Im.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1221 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/K_Pst.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1109 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/K_Tst.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1088 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/NaTa_t.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1166 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/NaTs2_t.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1429 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/Nap_Et2.mod
+-rw-r--r--   0 runner    (1001) docker     (123)    12651 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/ProbAMPANMDA_EMS.mod
+-rw-r--r--   0 runner    (1001) docker     (123)    12261 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/ProbGABAAB_EMS.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      980 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/SK_E2.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      807 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/SKv3_1.mod
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.346394 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/morphology/
+-rw-r--r--   0 runner    (1001) docker     (123)   334377 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/morphology/rp110125_L5-2_idA_-_Scale_x1.000_y0.950_z1.000_-_Clone_42.asc
+-rw-r--r--   0 runner    (1001) docker     (123)     1579 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/morphology.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     2030 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mosinit.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     2203 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/ringplot.hoc
+-rwxr-xr-x   0 runner    (1001) docker     (123)     5335 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/run.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)     6805 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/run_RmpRiTau.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)       44 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/run_RmpRiTau_py.sh
+-rwxr-xr-x   0 runner    (1001) docker     (123)       42 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/run_hoc.sh
+-rwxr-xr-x   0 runner    (1001) docker     (123)      114 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/run_py.sh
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.346394 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/synapses/
+-rw-r--r--   0 runner    (1001) docker     (123)      559 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/synapses/mtype_map.tsv
+-rw-r--r--   0 runner    (1001) docker     (123)    15838 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/synapses/synapses.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)    40598 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/synapses/synapses.tsv
+-rw-r--r--   0 runner    (1001) docker     (123)     2697 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/synapses/synconf.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    11203 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/template.hoc
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.350394 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/
+-rw-r--r--   0 runner    (1001) docker     (123)      492 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/CHANGELOG
+-rw-r--r--   0 runner    (1001) docker     (123)     1571 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)     4471 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/README
+-rw-r--r--   0 runner    (1001) docker     (123)       18 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/VERSION
+-rw-r--r--   0 runner    (1001) docker     (123)     5711 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/biophysics.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)      283 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/cellinfo.json
+-rw-r--r--   0 runner    (1001) docker     (123)     1619 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/constants.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     6084 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/creategui.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     4269 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/createsimulation.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)       39 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/current_amps.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     3391 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/init.hoc
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.350394 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/
+-rw-r--r--   0 runner    (1001) docker     (123)     1002 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/Ca.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      681 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/CaDynamics_E2.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1106 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/Ca_LVAst.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      787 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/Ih.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      853 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/Im.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1221 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/K_Pst.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1109 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/K_Tst.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1088 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/NaTa_t.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1166 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/NaTs2_t.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1429 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/Nap_Et2.mod
+-rw-r--r--   0 runner    (1001) docker     (123)    12651 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/ProbAMPANMDA_EMS.mod
+-rw-r--r--   0 runner    (1001) docker     (123)    12261 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/ProbGABAAB_EMS.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      980 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/SK_E2.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      807 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/SKv3_1.mod
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.350394 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/morphology/
+-rw-r--r--   0 runner    (1001) docker     (123)   266052 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/morphology/og061106a1_idA_-_Scale_x1.000_y1.050_z1.000_-_Clone_5.asc
+-rw-r--r--   0 runner    (1001) docker     (123)     1575 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/morphology.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     2030 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mosinit.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     2203 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/ringplot.hoc
+-rwxr-xr-x   0 runner    (1001) docker     (123)     5335 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/run.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)     6805 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/run_RmpRiTau.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)       44 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/run_RmpRiTau_py.sh
+-rwxr-xr-x   0 runner    (1001) docker     (123)       42 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/run_hoc.sh
+-rwxr-xr-x   0 runner    (1001) docker     (123)      114 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/run_py.sh
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.350394 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/synapses/
+-rw-r--r--   0 runner    (1001) docker     (123)      559 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/synapses/mtype_map.tsv
+-rw-r--r--   0 runner    (1001) docker     (123)    15838 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/synapses/synapses.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)   121199 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/synapses/synapses.tsv
+-rw-r--r--   0 runner    (1001) docker     (123)     8724 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/synapses/synconf.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    11203 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/template.hoc
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.354394 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/
+-rw-r--r--   0 runner    (1001) docker     (123)      492 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/CHANGELOG
+-rw-r--r--   0 runner    (1001) docker     (123)     1571 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)     4471 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/README
+-rw-r--r--   0 runner    (1001) docker     (123)       18 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/VERSION
+-rw-r--r--   0 runner    (1001) docker     (123)     4250 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/biophysics.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)      268 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/cellinfo.json
+-rw-r--r--   0 runner    (1001) docker     (123)     1619 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/constants.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     6084 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/creategui.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     4257 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/createsimulation.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)       24 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/current_amps.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     3391 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/init.hoc
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.354394 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/
+-rw-r--r--   0 runner    (1001) docker     (123)      681 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/CaDynamics_E2.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1022 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/Ca_HVA.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1106 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/Ca_LVAst.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      787 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/Ih.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      853 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/Im.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1221 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/K_Pst.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1109 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/K_Tst.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1088 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/NaTa_t.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1166 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/NaTs2_t.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1429 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/Nap_Et2.mod
+-rw-r--r--   0 runner    (1001) docker     (123)    12651 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/ProbAMPANMDA_EMS.mod
+-rw-r--r--   0 runner    (1001) docker     (123)    12261 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/ProbGABAAB_EMS.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      980 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/SK_E2.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      807 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/SKv3_1.mod
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.354394 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/morphology/
+-rw-r--r--   0 runner    (1001) docker     (123)   200764 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/morphology/dend-C231296A-P3_axon-C231296A-P3_-_Clone_9.asc
+-rw-r--r--   0 runner    (1001) docker     (123)     1565 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/morphology.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     2030 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mosinit.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     2203 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/ringplot.hoc
+-rwxr-xr-x   0 runner    (1001) docker     (123)     5341 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/run.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)     6811 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/run_RmpRiTau.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)       44 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/run_RmpRiTau_py.sh
+-rwxr-xr-x   0 runner    (1001) docker     (123)       42 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/run_hoc.sh
+-rwxr-xr-x   0 runner    (1001) docker     (123)      114 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/run_py.sh
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.358394 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/synapses/
+-rw-r--r--   0 runner    (1001) docker     (123)      559 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/synapses/mtype_map.tsv
+-rw-r--r--   0 runner    (1001) docker     (123)    15838 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/synapses/synapses.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)   628013 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/synapses/synapses.tsv
+-rw-r--r--   0 runner    (1001) docker     (123)    50783 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/synapses/synconf.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    11211 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/template.hoc
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.362394 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/
+-rw-r--r--   0 runner    (1001) docker     (123)      492 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/CHANGELOG
+-rw-r--r--   0 runner    (1001) docker     (123)     1571 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)     4471 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/README
+-rw-r--r--   0 runner    (1001) docker     (123)       18 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/VERSION
+-rw-r--r--   0 runner    (1001) docker     (123)     4250 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/biophysics.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)      243 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/cellinfo.json
+-rw-r--r--   0 runner    (1001) docker     (123)     1619 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/constants.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     6084 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/creategui.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     4270 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/createsimulation.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)       36 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/current_amps.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     3391 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/init.hoc
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.362394 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/
+-rw-r--r--   0 runner    (1001) docker     (123)      681 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/CaDynamics_E2.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1022 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/Ca_HVA.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1106 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/Ca_LVAst.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      787 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/Ih.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      853 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/Im.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1221 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/K_Pst.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1109 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/K_Tst.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1088 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/NaTa_t.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1166 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/NaTs2_t.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1429 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/Nap_Et2.mod
+-rw-r--r--   0 runner    (1001) docker     (123)    12651 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/ProbAMPANMDA_EMS.mod
+-rw-r--r--   0 runner    (1001) docker     (123)    12261 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/ProbGABAAB_EMS.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      980 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/SK_E2.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      807 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/SKv3_1.mod
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.362394 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/morphology/
+-rw-r--r--   0 runner    (1001) docker     (123)   954647 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/morphology/dend-C060114A2_axon-C060114A5.asc
+-rw-r--r--   0 runner    (1001) docker     (123)     1551 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/morphology.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     2030 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mosinit.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     2203 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/ringplot.hoc
+-rwxr-xr-x   0 runner    (1001) docker     (123)     5343 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/run.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)     6813 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/run_RmpRiTau.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)       44 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/run_RmpRiTau_py.sh
+-rwxr-xr-x   0 runner    (1001) docker     (123)       42 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/run_hoc.sh
+-rwxr-xr-x   0 runner    (1001) docker     (123)      114 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/run_py.sh
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.366394 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/synapses/
+-rw-r--r--   0 runner    (1001) docker     (123)      559 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/synapses/mtype_map.tsv
+-rw-r--r--   0 runner    (1001) docker     (123)    15838 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/synapses/synapses.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)   931577 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/synapses/synapses.tsv
+-rw-r--r--   0 runner    (1001) docker     (123)    84112 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/synapses/synconf.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    11213 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/template.hoc
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.370394 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/
+-rw-r--r--   0 runner    (1001) docker     (123)      492 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/CHANGELOG
+-rw-r--r--   0 runner    (1001) docker     (123)     1571 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)     4471 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/README
+-rw-r--r--   0 runner    (1001) docker     (123)       18 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/VERSION
+-rw-r--r--   0 runner    (1001) docker     (123)     4250 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/biophysics.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)      263 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/cellinfo.json
+-rw-r--r--   0 runner    (1001) docker     (123)     1619 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/constants.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     6084 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/creategui.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     4273 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/createsimulation.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)       39 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/current_amps.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     3391 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/init.hoc
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.370394 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/
+-rw-r--r--   0 runner    (1001) docker     (123)      681 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/CaDynamics_E2.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1022 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/Ca_HVA.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1106 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/Ca_LVAst.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      787 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/Ih.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      853 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/Im.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1221 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/K_Pst.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1109 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/K_Tst.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1088 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/NaTa_t.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1166 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/NaTs2_t.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1429 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/Nap_Et2.mod
+-rw-r--r--   0 runner    (1001) docker     (123)    12651 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/ProbAMPANMDA_EMS.mod
+-rw-r--r--   0 runner    (1001) docker     (123)    12261 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/ProbGABAAB_EMS.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      980 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/SK_E2.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      807 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/SKv3_1.mod
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.370394 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/morphology/
+-rw-r--r--   0 runner    (1001) docker     (123)   728920 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/morphology/dend-C060114A7_axon-C060116A3_-_Clone_2.asc
+-rw-r--r--   0 runner    (1001) docker     (123)     1561 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/morphology.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     2030 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mosinit.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     2203 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/ringplot.hoc
+-rwxr-xr-x   0 runner    (1001) docker     (123)     5343 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/run.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)     6813 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/run_RmpRiTau.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)       44 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/run_RmpRiTau_py.sh
+-rwxr-xr-x   0 runner    (1001) docker     (123)       42 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/run_hoc.sh
+-rwxr-xr-x   0 runner    (1001) docker     (123)      114 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/run_py.sh
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.374394 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/synapses/
+-rw-r--r--   0 runner    (1001) docker     (123)      559 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/synapses/mtype_map.tsv
+-rw-r--r--   0 runner    (1001) docker     (123)    15838 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/synapses/synapses.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)   835414 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/synapses/synapses.tsv
+-rw-r--r--   0 runner    (1001) docker     (123)    79007 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/synapses/synconf.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    11213 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/template.hoc
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.378394 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/
+-rw-r--r--   0 runner    (1001) docker     (123)      492 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/CHANGELOG
+-rw-r--r--   0 runner    (1001) docker     (123)     1571 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)     4471 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/README
+-rw-r--r--   0 runner    (1001) docker     (123)       18 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/VERSION
+-rw-r--r--   0 runner    (1001) docker     (123)     4250 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/biophysics.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)      329 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/cellinfo.json
+-rw-r--r--   0 runner    (1001) docker     (123)     1619 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/constants.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     6084 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/creategui.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     4272 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/createsimulation.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)       39 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/current_amps.dat
+-rw-r--r--   0 runner    (1001) docker     (123)     3391 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/init.hoc
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.378394 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/
+-rw-r--r--   0 runner    (1001) docker     (123)      681 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/CaDynamics_E2.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1022 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/Ca_HVA.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1106 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/Ca_LVAst.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      787 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/Ih.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      853 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/Im.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1221 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/K_Pst.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1109 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/K_Tst.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1088 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/NaTa_t.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1166 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/NaTs2_t.mod
+-rw-r--r--   0 runner    (1001) docker     (123)     1429 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/Nap_Et2.mod
+-rw-r--r--   0 runner    (1001) docker     (123)    12651 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/ProbAMPANMDA_EMS.mod
+-rw-r--r--   0 runner    (1001) docker     (123)    12261 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/ProbGABAAB_EMS.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      980 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/SK_E2.mod
+-rw-r--r--   0 runner    (1001) docker     (123)      807 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/SKv3_1.mod
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.378394 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/morphology/
+-rw-r--r--   0 runner    (1001) docker     (123)   575337 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/morphology/dend-Fluo15_left_axon-Fluo15_left_-_Scale_x1.000_y0.950_z1.000_-_Clone_30.asc
+-rw-r--r--   0 runner    (1001) docker     (123)     1595 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/morphology.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     2030 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mosinit.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)     2203 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/ringplot.hoc
+-rwxr-xr-x   0 runner    (1001) docker     (123)     5341 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/run.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)     6811 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/run_RmpRiTau.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)       44 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/run_RmpRiTau_py.sh
+-rwxr-xr-x   0 runner    (1001) docker     (123)       42 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/run_hoc.sh
+-rwxr-xr-x   0 runner    (1001) docker     (123)      114 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/run_py.sh
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.382394 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/synapses/
+-rw-r--r--   0 runner    (1001) docker     (123)      559 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/synapses/mtype_map.tsv
+-rw-r--r--   0 runner    (1001) docker     (123)    15839 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/synapses/synapses.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)   248218 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/synapses/synapses.tsv
+-rw-r--r--   0 runner    (1001) docker     (123)    18612 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/synapses/synconf.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    11211 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/template.hoc
+-rw-r--r--   0 runner    (1001) docker     (123)    25694 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/cli.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.382394 MEArec-1.9.0/src/MEArec/default_params/
+-rw-r--r--   0 runner    (1001) docker     (123)     6777 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/default_params/recordings_params.yaml
+-rw-r--r--   0 runner    (1001) docker     (123)     2285 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/default_params/templates_params.yaml
+-rw-r--r--   0 runner    (1001) docker     (123)    13793 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/drift_tools.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9601 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/generation_tools.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.382394 MEArec-1.9.0/src/MEArec/generators/
+-rw-r--r--   0 runner    (1001) docker     (123)      153 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/generators/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12837 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/generators/recgensteps.py
+-rw-r--r--   0 runner    (1001) docker     (123)    69651 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/generators/recordinggenerator.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13882 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/generators/spiketraingenerator.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14966 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/generators/templategenerator.py
+-rw-r--r--   0 runner    (1001) docker     (123)    48421 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/simulate_cells.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.382394 MEArec-1.9.0/src/MEArec/tests/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    48070 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/tests/test_generators.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)   145191 2023-05-23 13:11:28.000000 MEArec-1.9.0/src/MEArec/tools.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 13:26:17.302393 MEArec-1.9.0/src/MEArec.egg-info/
+-rw-r--r--   0 runner    (1001) docker     (123)     2426 2023-05-23 13:26:17.000000 MEArec-1.9.0/src/MEArec.egg-info/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)    32828 2023-05-23 13:26:17.000000 MEArec-1.9.0/src/MEArec.egg-info/SOURCES.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-05-23 13:26:17.000000 MEArec-1.9.0/src/MEArec.egg-info/dependency_links.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       42 2023-05-23 13:26:17.000000 MEArec-1.9.0/src/MEArec.egg-info/entry_points.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      128 2023-05-23 13:26:17.000000 MEArec-1.9.0/src/MEArec.egg-info/requires.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        7 2023-05-23 13:26:17.000000 MEArec-1.9.0/src/MEArec.egg-info/top_level.txt
```

### Comparing `MEArec-1.8.0/LICENSE` & `MEArec-1.9.0/LICENSE`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/LICENSE` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/LICENSE`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/README` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/README`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/biophysics.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/biophysics.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/constants.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/constants.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/creategui.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/creategui.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/createsimulation.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/createsimulation.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/init.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/init.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/Ca.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/Ca.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/CaDynamics_E2.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/CaDynamics_E2.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/Ca_LVAst.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/Ca_LVAst.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/Ih.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/Ih.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/Im.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/Im.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/K_Pst.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/K_Pst.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/K_Tst.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/K_Tst.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/NaTa_t.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/NaTa_t.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/NaTs2_t.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/NaTs2_t.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/Nap_Et2.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/Nap_Et2.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/ProbAMPANMDA_EMS.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/ProbAMPANMDA_EMS.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/ProbGABAAB_EMS.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/ProbGABAAB_EMS.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/SK_E2.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/SK_E2.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/SKv3_1.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/mechanisms/SKv3_1.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/morphology/C240300C1_-_Scale_x1.000_y1.050_z1.000_-_Clone_17.asc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/morphology/C240300C1_-_Scale_x1.000_y1.050_z1.000_-_Clone_17.asc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/morphology.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/morphology.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/mosinit.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/mosinit.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/ringplot.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/ringplot.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/run.py` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/run.py`

 * *Files 6% similar despite different names*

```diff
@@ -32,158 +32,155 @@
  * @author Werner Van Geit @ BBP
  * @date 2015
 """
 
 # pylint: disable=C0325, W0212, F0401, W0612, F0401
 
 import os
+import sys
+
 import neuron
 import numpy
-import sys
 
 
 def create_cell(add_synapses=True):
     """Create the cell model"""
     # Load morphology
     neuron.h.load_file("morphology.hoc")
     # Load biophysics
     neuron.h.load_file("biophysics.hoc")
     # Load main cell template
     neuron.h.load_file("template.hoc")
 
     # Instantiate the cell from the template
 
-    print("Loading cell bAC217_L5_BP_d0cc8d7615")
-    cell = neuron.h.bAC217_L5_BP_d0cc8d7615(1 if add_synapses else 0)
+    print("Loading cell bAC217_L5_MC_cc2a170ef6")
+    cell = neuron.h.bAC217_L5_MC_cc2a170ef6(1 if add_synapses else 0)
     return cell
 
 
 def create_stimuli(cell, step_number):
     """Create the stimuli"""
 
-    print('Attaching stimulus electrodes')
+    print("Attaching stimulus electrodes")
 
     stimuli = []
     step_amp = [0] * 3
 
-    with open('current_amps.dat', 'r') as current_amps_file:
-        first_line = current_amps_file.read().split('\n')[0].strip()
-        hyp_amp, step_amp[0], step_amp[1], step_amp[2] = first_line.split(' ')
+    with open("current_amps.dat", "r") as current_amps_file:
+        first_line = current_amps_file.read().split("\n")[0].strip()
+        hyp_amp, step_amp[0], step_amp[1], step_amp[2] = first_line.split(" ")
 
     iclamp = neuron.h.IClamp(0.5, sec=cell.soma[0])
     iclamp.delay = 700
     iclamp.dur = 2000
     iclamp.amp = float(step_amp[step_number - 1])
-    print('Setting up step current clamp: '
-          'amp=%f nA, delay=%f ms, duration=%f ms' %
-          (iclamp.amp, iclamp.delay, iclamp.dur))
+    print(
+        "Setting up step current clamp: "
+        "amp=%f nA, delay=%f ms, duration=%f ms" % (iclamp.amp, iclamp.delay, iclamp.dur)
+    )
 
     stimuli.append(iclamp)
 
     hyp_iclamp = neuron.h.IClamp(0.5, sec=cell.soma[0])
     hyp_iclamp.delay = 0
     hyp_iclamp.dur = 3000
     hyp_iclamp.amp = float(hyp_amp)
-    print('Setting up hypamp current clamp: '
-          'amp=%f nA, delay=%f ms, duration=%f ms' %
-          (hyp_iclamp.amp, hyp_iclamp.delay, hyp_iclamp.dur))
+    print(
+        "Setting up hypamp current clamp: "
+        "amp=%f nA, delay=%f ms, duration=%f ms" % (hyp_iclamp.amp, hyp_iclamp.delay, hyp_iclamp.dur)
+    )
 
     stimuli.append(hyp_iclamp)
 
     return stimuli
 
 
 def create_recordings(cell):
     """Create the recordings"""
-    print('Attaching recording electrodes')
+    print("Attaching recording electrodes")
 
     recordings = {}
 
-    recordings['time'] = neuron.h.Vector()
-    recordings['soma(0.5)'] = neuron.h.Vector()
+    recordings["time"] = neuron.h.Vector()
+    recordings["soma(0.5)"] = neuron.h.Vector()
 
-    recordings['time'].record(neuron.h._ref_t, 0.1)
-    recordings['soma(0.5)'].record(cell.soma[0](0.5)._ref_v, 0.1)
+    recordings["time"].record(neuron.h._ref_t, 0.1)
+    recordings["soma(0.5)"].record(cell.soma[0](0.5)._ref_v, 0.1)
 
     return recordings
 
 
 def run_step(step_number, plot_traces=None):
     """Run step current simulation with index step_number"""
 
     cell = create_cell(add_synapses=False)
     stimuli = create_stimuli(cell, step_number)
     recordings = create_recordings(cell)
 
     # Overriding default 30s simulation,
-    print('Setting simulation time to 3s for the step currents')
+    print("Setting simulation time to 3s for the step currents")
     neuron.h.tstop = 3000
 
-    print('Disabling variable timestep integration')
+    print("Disabling variable timestep integration")
     neuron.h.cvode_active(0)
 
-    print('Running for %f ms' % neuron.h.tstop)
+    print("Running for %f ms" % neuron.h.tstop)
     neuron.h.run()
 
-    time = numpy.array(recordings['time'])
-    soma_voltage = numpy.array(recordings['soma(0.5)'])
+    time = numpy.array(recordings["time"])
+    soma_voltage = numpy.array(recordings["soma(0.5)"])
 
-    recordings_dir = 'python_recordings'
+    recordings_dir = "python_recordings"
 
-    soma_voltage_filename = os.path.join(
-        recordings_dir,
-        'soma_voltage_step%d.dat' % step_number)
-    numpy.savetxt(
-            soma_voltage_filename,
-            numpy.transpose(
-               numpy.vstack((
-                    time,
-                    soma_voltage))))
+    soma_voltage_filename = os.path.join(recordings_dir, "soma_voltage_step%d.dat" % step_number)
+    numpy.savetxt(soma_voltage_filename, numpy.transpose(numpy.vstack((time, soma_voltage))))
 
-    print('Soma voltage for step %d saved to: %s'
-          % (step_number, soma_voltage_filename))
+    print("Soma voltage for step %d saved to: %s" % (step_number, soma_voltage_filename))
 
     if plot_traces:
         import pylab
+
         pylab.figure()
-        pylab.plot(recordings['time'], recordings['soma(0.5)'])
-        pylab.xlabel('time (ms)')
-        pylab.ylabel('Vm (mV)')
-        pylab.gcf().canvas.set_window_title('Step %d' % step_number)
+        pylab.plot(recordings["time"], recordings["soma(0.5)"])
+        pylab.xlabel("time (ms)")
+        pylab.ylabel("Vm (mV)")
+        pylab.gcf().canvas.set_window_title("Step %d" % step_number)
 
 
 def init_simulation():
     """Initialise simulation environment"""
 
     neuron.h.load_file("stdrun.hoc")
     neuron.h.load_file("import3d.hoc")
 
-    print('Loading constants')
-    neuron.h.load_file('constants.hoc')
+    print("Loading constants")
+    neuron.h.load_file("constants.hoc")
 
 
 def main(plot_traces=True):
     """Main"""
 
     # Import matplotlib to plot the traces
     if plot_traces:
         import matplotlib
-        matplotlib.rcParams['path.simplify'] = False
+
+        matplotlib.rcParams["path.simplify"] = False
 
     init_simulation()
 
     for step_number in range(1, 4):
         run_step(step_number, plot_traces=plot_traces)
 
     if plot_traces:
         import pylab
+
         pylab.show()
 
-if __name__ == '__main__':
+
+if __name__ == "__main__":
     if len(sys.argv) == 1:
         main(plot_traces=True)
-    elif len(sys.argv) == 2 and sys.argv[1] == '--no-plots':
+    elif len(sys.argv) == 2 and sys.argv[1] == "--no-plots":
         main(plot_traces=False)
     else:
-        raise Exception(
-            "Script only accepts one argument: --no-plots, not %s" %
-            str(sys.argv))
+        raise Exception("Script only accepts one argument: --no-plots, not %s" % str(sys.argv))
```

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/run_RmpRiTau.py` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/run_RmpRiTau.py`

 * *Files 9% similar despite different names*

```diff
@@ -32,17 +32,18 @@
  * @author Werner Van Geit @ BBP
  * @date 2015
 """
 
 # pylint: disable=C0325, W0212, F0401, W0612, F0401
 
 import os
+import sys
+
 import neuron
 import numpy
-import sys
 
 
 def create_cell():
     """Create the cell model"""
     # Load morphology
     neuron.h.load_file("morphology.hoc")
     # Load biophysics
@@ -56,198 +57,176 @@
     cell = neuron.h.bAC217_L5_BP_d0cc8d7615(0)
     return cell
 
 
 def create_stimuli(cell, stim_start, stim_end, current_amplitude):
     """Create the stimuli"""
 
-    print('Attaching stimulus electrodes')
+    print("Attaching stimulus electrodes")
 
     stimuli = []
 
     iclamp = neuron.h.IClamp(0.5, sec=cell.soma[0])
     iclamp.delay = stim_start
     iclamp.dur = stim_end - stim_start
     iclamp.amp = current_amplitude
-    print('Setting up step current clamp: '
-          'amp=%f nA, delay=%f ms, duration=%f ms' %
-          (iclamp.amp, iclamp.delay, iclamp.dur))
+    print(
+        "Setting up step current clamp: "
+        "amp=%f nA, delay=%f ms, duration=%f ms" % (iclamp.amp, iclamp.delay, iclamp.dur)
+    )
 
     stimuli.append(iclamp)
 
     return stimuli
 
 
 def create_recordings(cell):
     """Create the recordings"""
-    print('Attaching recording electrodes')
+    print("Attaching recording electrodes")
 
     recordings = {}
 
-    recordings['time'] = neuron.h.Vector()
-    recordings['soma(0.5)'] = neuron.h.Vector()
+    recordings["time"] = neuron.h.Vector()
+    recordings["soma(0.5)"] = neuron.h.Vector()
 
-    recordings['time'].record(neuron.h._ref_t, 0.1)
-    recordings['soma(0.5)'].record(cell.soma[0](0.5)._ref_v, 0.1)
+    recordings["time"].record(neuron.h._ref_t, 0.1)
+    recordings["soma(0.5)"].record(cell.soma[0](0.5)._ref_v, 0.1)
 
     return recordings
 
 
-def run_RmpRiTau_step(
-        stim_start,
-        stim_end,
-        current_amplitude,
-        plot_traces=None):
-    """Run """
+def run_RmpRiTau_step(stim_start, stim_end, current_amplitude, plot_traces=None):
+    """Run"""
 
     cell = create_cell()
     stimuli = create_stimuli(cell, stim_start, stim_end, current_amplitude)  # noqa
     recordings = create_recordings(cell)
 
     # Overriding default 30s simulation,
     neuron.h.tstop = stim_end + stim_start
-    print(
-        'Setting simulation time to %.6g ms for the step current' %
-        neuron.h.tstop)
+    print("Setting simulation time to %.6g ms for the step current" % neuron.h.tstop)
 
-    print('Setting initial voltage to -70 mV')
+    print("Setting initial voltage to -70 mV")
     neuron.h.v_init = -70
 
     neuron.h.stdinit()
     neuron.h.dt = 1000
     neuron.h.t = -1e9
     for _ in range(10):
         neuron.h.fadvance()
 
     neuron.h.t = 0
     neuron.h.dt = 0.025
     neuron.h.frecord_init()
 
     neuron.h.continuerun(3000)
 
-    time = numpy.array(recordings['time'])
-    soma_voltage = numpy.array(recordings['soma(0.5)'])
+    time = numpy.array(recordings["time"])
+    soma_voltage = numpy.array(recordings["soma(0.5)"])
 
-    recordings_dir = 'python_recordings'
+    recordings_dir = "python_recordings"
 
-    soma_voltage_filename = os.path.join(
-        recordings_dir,
-        'soma_voltage_RmpRiTau_step.dat')
+    soma_voltage_filename = os.path.join(recordings_dir, "soma_voltage_RmpRiTau_step.dat")
     numpy.savetxt(soma_voltage_filename, zip(time, soma_voltage))
 
-    print('Soma voltage for RmpRiTau trace saved to: %s'
-          % (soma_voltage_filename))
+    print("Soma voltage for RmpRiTau trace saved to: %s" % (soma_voltage_filename))
 
     if plot_traces:
         import pylab
-        pylab.figure(facecolor='white')
-        pylab.plot(recordings['time'], recordings['soma(0.5)'])
-        pylab.xlabel('time (ms)')
-        pylab.ylabel('Vm (mV)')
-        pylab.gcf().canvas.set_window_title('RmpRiTau trace')
+
+        pylab.figure(facecolor="white")
+        pylab.plot(recordings["time"], recordings["soma(0.5)"])
+        pylab.xlabel("time (ms)")
+        pylab.ylabel("Vm (mV)")
+        pylab.gcf().canvas.set_window_title("RmpRiTau trace")
 
     return time, soma_voltage, stim_start, stim_end
 
 
 def init_simulation():
     """Initialise simulation environment"""
 
     neuron.h.load_file("stdrun.hoc")
     neuron.h.load_file("import3d.hoc")
 
-    print('Loading constants')
-    neuron.h.load_file('constants.hoc')
+    print("Loading constants")
+    neuron.h.load_file("constants.hoc")
 
 
-def analyse_RmpRiTau_trace(
-        time,
-        soma_voltage,
-        stim_start,
-        stim_end,
-        current_amplitude):
+def analyse_RmpRiTau_trace(time, soma_voltage, stim_start, stim_end, current_amplitude):
     """Analyse the output of the RmpRiTau protocol"""
 
     # Import the eFeature Extraction Library
     import efel
 
     # Prepare the trace data
     trace = {}
-    trace['T'] = time
-    trace['V'] = soma_voltage
-    trace['stim_start'] = [stim_start]
-    trace['stim_end'] = [stim_end]
+    trace["T"] = time
+    trace["V"] = soma_voltage
+    trace["stim_start"] = [stim_start]
+    trace["stim_end"] = [stim_end]
 
     # Calculate the necessary eFeatures
     efel_results = efel.getFeatureValues(
-        [trace],
-        ['voltage_base', 'steady_state_voltage_stimend',
-         'decay_time_constant_after_stim'])
-
-    voltage_base = efel_results[0]['voltage_base'][0]
-    ss_voltage = efel_results[0]['steady_state_voltage_stimend'][0]
-    dct = efel_results[0]['decay_time_constant_after_stim'][0]
+        [trace], ["voltage_base", "steady_state_voltage_stimend", "decay_time_constant_after_stim"]
+    )
+
+    voltage_base = efel_results[0]["voltage_base"][0]
+    ss_voltage = efel_results[0]["steady_state_voltage_stimend"][0]
+    dct = efel_results[0]["decay_time_constant_after_stim"][0]
 
     # Calculate input resistance
     input_resistance = float(ss_voltage - voltage_base) / current_amplitude
 
     rmpritau_dict = {}
 
-    rmpritau_dict['Rmp'] = '%.6g' % voltage_base
-    rmpritau_dict['Rmp_Units'] = 'mV'
-    rmpritau_dict['Rin'] = '%.6g' % input_resistance
-    rmpritau_dict['Rin_Units'] = 'MOhm'
-    rmpritau_dict['Tau'] = '%.6g' % dct
-    rmpritau_dict['Tau_Units'] = 'ms'
-
-    print('Resting membrane potential is %s %s' %
-          (rmpritau_dict['Rmp'], rmpritau_dict['Rmp_Units']))
-    print('Input resistance is %s %s' %
-          (rmpritau_dict['Rin'], rmpritau_dict['Rin_Units']))
-    print('Time constant is %s %s' %
-          (rmpritau_dict['Tau'], rmpritau_dict['Tau_Units']))
+    rmpritau_dict["Rmp"] = "%.6g" % voltage_base
+    rmpritau_dict["Rmp_Units"] = "mV"
+    rmpritau_dict["Rin"] = "%.6g" % input_resistance
+    rmpritau_dict["Rin_Units"] = "MOhm"
+    rmpritau_dict["Tau"] = "%.6g" % dct
+    rmpritau_dict["Tau_Units"] = "ms"
+
+    print("Resting membrane potential is %s %s" % (rmpritau_dict["Rmp"], rmpritau_dict["Rmp_Units"]))
+    print("Input resistance is %s %s" % (rmpritau_dict["Rin"], rmpritau_dict["Rin_Units"]))
+    print("Time constant is %s %s" % (rmpritau_dict["Tau"], rmpritau_dict["Tau_Units"]))
 
     import json
 
-    with open('rmp_ri_tau.json', 'w') as rmpritau_json_file:
-        json.dump(rmpritau_dict, rmpritau_json_file,
-                        sort_keys=True,
-                        indent=4,
-                        separators=(',', ': '))
+    with open("rmp_ri_tau.json", "w") as rmpritau_json_file:
+        json.dump(rmpritau_dict, rmpritau_json_file, sort_keys=True, indent=4, separators=(",", ": "))
 
 
 def main(plot_traces=False):
     """Main"""
 
     # Import matplotlib to plot the traces
     if plot_traces:
         import matplotlib
-        matplotlib.rcParams['path.simplify'] = False
+
+        matplotlib.rcParams["path.simplify"] = False
 
     init_simulation()
 
     current_amplitude = -0.01
     stim_start = 1000
     stim_end = 2000
 
     time, soma_voltage, stim_start, stim_end = run_RmpRiTau_step(
-        stim_start, stim_end, current_amplitude, plot_traces=plot_traces)
+        stim_start, stim_end, current_amplitude, plot_traces=plot_traces
+    )
 
-    analyse_RmpRiTau_trace(
-        time,
-        soma_voltage,
-        stim_start,
-        stim_end,
-        current_amplitude)
+    analyse_RmpRiTau_trace(time, soma_voltage, stim_start, stim_end, current_amplitude)
 
     if plot_traces:
         import pylab
+
         pylab.show()
 
-if __name__ == '__main__':
+
+if __name__ == "__main__":
     if len(sys.argv) == 1:
         main(plot_traces=True)
-    elif len(sys.argv) == 2 and sys.argv[1] == '--no-plots':
+    elif len(sys.argv) == 2 and sys.argv[1] == "--no-plots":
         main(plot_traces=False)
     else:
-        raise Exception(
-            "Script only accepts one argument: --no-plots, not %s" %
-            str(sys.argv))
+        raise Exception("Script only accepts one argument: --no-plots, not %s" % str(sys.argv))
```

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/synapses/mtype_map.tsv` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/synapses/mtype_map.tsv`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/synapses/synapses.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/synapses/synapses.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/synapses/synapses.tsv` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/synapses/synapses.tsv`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/synapses/synconf.txt` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/synapses/synconf.txt`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BP_bAC217_1/template.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/template.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/LICENSE` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/LICENSE`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/README` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/README`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/biophysics.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/biophysics.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/constants.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/constants.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/creategui.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/creategui.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/createsimulation.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/createsimulation.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/init.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/init.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/Ca.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/Ca.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/CaDynamics_E2.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/CaDynamics_E2.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/Ca_LVAst.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/Ca_LVAst.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/Ih.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/Ih.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/Im.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/Im.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/K_Pst.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/K_Pst.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/K_Tst.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/K_Tst.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/NaTa_t.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/NaTa_t.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/NaTs2_t.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/NaTs2_t.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/Nap_Et2.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/Nap_Et2.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/ProbAMPANMDA_EMS.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/ProbAMPANMDA_EMS.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/ProbGABAAB_EMS.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/ProbGABAAB_EMS.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/SK_E2.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/SK_E2.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/SKv3_1.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mechanisms/SKv3_1.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/morphology/C160998B-I_-_Scale_x1.000_y1.050_z1.000_-_Clone_5.asc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/morphology/C160998B-I_-_Scale_x1.000_y1.050_z1.000_-_Clone_5.asc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/morphology.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/morphology.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mosinit.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/mosinit.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/ringplot.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/ringplot.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/run.py` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/run.py`

 * *Files 6% similar despite different names*

```diff
@@ -32,158 +32,155 @@
  * @author Werner Van Geit @ BBP
  * @date 2015
 """
 
 # pylint: disable=C0325, W0212, F0401, W0612, F0401
 
 import os
+import sys
+
 import neuron
 import numpy
-import sys
 
 
 def create_cell(add_synapses=True):
     """Create the cell model"""
     # Load morphology
     neuron.h.load_file("morphology.hoc")
     # Load biophysics
     neuron.h.load_file("biophysics.hoc")
     # Load main cell template
     neuron.h.load_file("template.hoc")
 
     # Instantiate the cell from the template
 
-    print("Loading cell bAC217_L5_BTC_160272643a")
-    cell = neuron.h.bAC217_L5_BTC_160272643a(1 if add_synapses else 0)
+    print("Loading cell cACint209_L5_ChC_e98f63217d")
+    cell = neuron.h.cACint209_L5_ChC_e98f63217d(1 if add_synapses else 0)
     return cell
 
 
 def create_stimuli(cell, step_number):
     """Create the stimuli"""
 
-    print('Attaching stimulus electrodes')
+    print("Attaching stimulus electrodes")
 
     stimuli = []
     step_amp = [0] * 3
 
-    with open('current_amps.dat', 'r') as current_amps_file:
-        first_line = current_amps_file.read().split('\n')[0].strip()
-        hyp_amp, step_amp[0], step_amp[1], step_amp[2] = first_line.split(' ')
+    with open("current_amps.dat", "r") as current_amps_file:
+        first_line = current_amps_file.read().split("\n")[0].strip()
+        hyp_amp, step_amp[0], step_amp[1], step_amp[2] = first_line.split(" ")
 
     iclamp = neuron.h.IClamp(0.5, sec=cell.soma[0])
     iclamp.delay = 700
     iclamp.dur = 2000
     iclamp.amp = float(step_amp[step_number - 1])
-    print('Setting up step current clamp: '
-          'amp=%f nA, delay=%f ms, duration=%f ms' %
-          (iclamp.amp, iclamp.delay, iclamp.dur))
+    print(
+        "Setting up step current clamp: "
+        "amp=%f nA, delay=%f ms, duration=%f ms" % (iclamp.amp, iclamp.delay, iclamp.dur)
+    )
 
     stimuli.append(iclamp)
 
     hyp_iclamp = neuron.h.IClamp(0.5, sec=cell.soma[0])
     hyp_iclamp.delay = 0
     hyp_iclamp.dur = 3000
     hyp_iclamp.amp = float(hyp_amp)
-    print('Setting up hypamp current clamp: '
-          'amp=%f nA, delay=%f ms, duration=%f ms' %
-          (hyp_iclamp.amp, hyp_iclamp.delay, hyp_iclamp.dur))
+    print(
+        "Setting up hypamp current clamp: "
+        "amp=%f nA, delay=%f ms, duration=%f ms" % (hyp_iclamp.amp, hyp_iclamp.delay, hyp_iclamp.dur)
+    )
 
     stimuli.append(hyp_iclamp)
 
     return stimuli
 
 
 def create_recordings(cell):
     """Create the recordings"""
-    print('Attaching recording electrodes')
+    print("Attaching recording electrodes")
 
     recordings = {}
 
-    recordings['time'] = neuron.h.Vector()
-    recordings['soma(0.5)'] = neuron.h.Vector()
+    recordings["time"] = neuron.h.Vector()
+    recordings["soma(0.5)"] = neuron.h.Vector()
 
-    recordings['time'].record(neuron.h._ref_t, 0.1)
-    recordings['soma(0.5)'].record(cell.soma[0](0.5)._ref_v, 0.1)
+    recordings["time"].record(neuron.h._ref_t, 0.1)
+    recordings["soma(0.5)"].record(cell.soma[0](0.5)._ref_v, 0.1)
 
     return recordings
 
 
 def run_step(step_number, plot_traces=None):
     """Run step current simulation with index step_number"""
 
     cell = create_cell(add_synapses=False)
     stimuli = create_stimuli(cell, step_number)
     recordings = create_recordings(cell)
 
     # Overriding default 30s simulation,
-    print('Setting simulation time to 3s for the step currents')
+    print("Setting simulation time to 3s for the step currents")
     neuron.h.tstop = 3000
 
-    print('Disabling variable timestep integration')
+    print("Disabling variable timestep integration")
     neuron.h.cvode_active(0)
 
-    print('Running for %f ms' % neuron.h.tstop)
+    print("Running for %f ms" % neuron.h.tstop)
     neuron.h.run()
 
-    time = numpy.array(recordings['time'])
-    soma_voltage = numpy.array(recordings['soma(0.5)'])
+    time = numpy.array(recordings["time"])
+    soma_voltage = numpy.array(recordings["soma(0.5)"])
 
-    recordings_dir = 'python_recordings'
+    recordings_dir = "python_recordings"
 
-    soma_voltage_filename = os.path.join(
-        recordings_dir,
-        'soma_voltage_step%d.dat' % step_number)
-    numpy.savetxt(
-            soma_voltage_filename,
-            numpy.transpose(
-               numpy.vstack((
-                    time,
-                    soma_voltage))))
+    soma_voltage_filename = os.path.join(recordings_dir, "soma_voltage_step%d.dat" % step_number)
+    numpy.savetxt(soma_voltage_filename, numpy.transpose(numpy.vstack((time, soma_voltage))))
 
-    print('Soma voltage for step %d saved to: %s'
-          % (step_number, soma_voltage_filename))
+    print("Soma voltage for step %d saved to: %s" % (step_number, soma_voltage_filename))
 
     if plot_traces:
         import pylab
+
         pylab.figure()
-        pylab.plot(recordings['time'], recordings['soma(0.5)'])
-        pylab.xlabel('time (ms)')
-        pylab.ylabel('Vm (mV)')
-        pylab.gcf().canvas.set_window_title('Step %d' % step_number)
+        pylab.plot(recordings["time"], recordings["soma(0.5)"])
+        pylab.xlabel("time (ms)")
+        pylab.ylabel("Vm (mV)")
+        pylab.gcf().canvas.set_window_title("Step %d" % step_number)
 
 
 def init_simulation():
     """Initialise simulation environment"""
 
     neuron.h.load_file("stdrun.hoc")
     neuron.h.load_file("import3d.hoc")
 
-    print('Loading constants')
-    neuron.h.load_file('constants.hoc')
+    print("Loading constants")
+    neuron.h.load_file("constants.hoc")
 
 
 def main(plot_traces=True):
     """Main"""
 
     # Import matplotlib to plot the traces
     if plot_traces:
         import matplotlib
-        matplotlib.rcParams['path.simplify'] = False
+
+        matplotlib.rcParams["path.simplify"] = False
 
     init_simulation()
 
     for step_number in range(1, 4):
         run_step(step_number, plot_traces=plot_traces)
 
     if plot_traces:
         import pylab
+
         pylab.show()
 
-if __name__ == '__main__':
+
+if __name__ == "__main__":
     if len(sys.argv) == 1:
         main(plot_traces=True)
-    elif len(sys.argv) == 2 and sys.argv[1] == '--no-plots':
+    elif len(sys.argv) == 2 and sys.argv[1] == "--no-plots":
         main(plot_traces=False)
     else:
-        raise Exception(
-            "Script only accepts one argument: --no-plots, not %s" %
-            str(sys.argv))
+        raise Exception("Script only accepts one argument: --no-plots, not %s" % str(sys.argv))
```

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/run_RmpRiTau.py` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/run_RmpRiTau.py`

 * *Files 10% similar despite different names*

```diff
@@ -32,222 +32,201 @@
  * @author Werner Van Geit @ BBP
  * @date 2015
 """
 
 # pylint: disable=C0325, W0212, F0401, W0612, F0401
 
 import os
+import sys
+
 import neuron
 import numpy
-import sys
 
 
 def create_cell():
     """Create the cell model"""
     # Load morphology
     neuron.h.load_file("morphology.hoc")
     # Load biophysics
     neuron.h.load_file("biophysics.hoc")
     # Load main cell template
     neuron.h.load_file("template.hoc")
 
     # Instantiate the cell from the template
 
-    print("Loading cell bAC217_L5_BTC_160272643a")
-    cell = neuron.h.bAC217_L5_BTC_160272643a(0)
+    print("Loading cell bAC217_L5_DBC_4765d943f4")
+    cell = neuron.h.bAC217_L5_DBC_4765d943f4(0)
     return cell
 
 
 def create_stimuli(cell, stim_start, stim_end, current_amplitude):
     """Create the stimuli"""
 
-    print('Attaching stimulus electrodes')
+    print("Attaching stimulus electrodes")
 
     stimuli = []
 
     iclamp = neuron.h.IClamp(0.5, sec=cell.soma[0])
     iclamp.delay = stim_start
     iclamp.dur = stim_end - stim_start
     iclamp.amp = current_amplitude
-    print('Setting up step current clamp: '
-          'amp=%f nA, delay=%f ms, duration=%f ms' %
-          (iclamp.amp, iclamp.delay, iclamp.dur))
+    print(
+        "Setting up step current clamp: "
+        "amp=%f nA, delay=%f ms, duration=%f ms" % (iclamp.amp, iclamp.delay, iclamp.dur)
+    )
 
     stimuli.append(iclamp)
 
     return stimuli
 
 
 def create_recordings(cell):
     """Create the recordings"""
-    print('Attaching recording electrodes')
+    print("Attaching recording electrodes")
 
     recordings = {}
 
-    recordings['time'] = neuron.h.Vector()
-    recordings['soma(0.5)'] = neuron.h.Vector()
+    recordings["time"] = neuron.h.Vector()
+    recordings["soma(0.5)"] = neuron.h.Vector()
 
-    recordings['time'].record(neuron.h._ref_t, 0.1)
-    recordings['soma(0.5)'].record(cell.soma[0](0.5)._ref_v, 0.1)
+    recordings["time"].record(neuron.h._ref_t, 0.1)
+    recordings["soma(0.5)"].record(cell.soma[0](0.5)._ref_v, 0.1)
 
     return recordings
 
 
-def run_RmpRiTau_step(
-        stim_start,
-        stim_end,
-        current_amplitude,
-        plot_traces=None):
-    """Run """
+def run_RmpRiTau_step(stim_start, stim_end, current_amplitude, plot_traces=None):
+    """Run"""
 
     cell = create_cell()
     stimuli = create_stimuli(cell, stim_start, stim_end, current_amplitude)  # noqa
     recordings = create_recordings(cell)
 
     # Overriding default 30s simulation,
     neuron.h.tstop = stim_end + stim_start
-    print(
-        'Setting simulation time to %.6g ms for the step current' %
-        neuron.h.tstop)
+    print("Setting simulation time to %.6g ms for the step current" % neuron.h.tstop)
 
-    print('Setting initial voltage to -70 mV')
+    print("Setting initial voltage to -70 mV")
     neuron.h.v_init = -70
 
     neuron.h.stdinit()
     neuron.h.dt = 1000
     neuron.h.t = -1e9
     for _ in range(10):
         neuron.h.fadvance()
 
     neuron.h.t = 0
     neuron.h.dt = 0.025
     neuron.h.frecord_init()
 
     neuron.h.continuerun(3000)
 
-    time = numpy.array(recordings['time'])
-    soma_voltage = numpy.array(recordings['soma(0.5)'])
+    time = numpy.array(recordings["time"])
+    soma_voltage = numpy.array(recordings["soma(0.5)"])
 
-    recordings_dir = 'python_recordings'
+    recordings_dir = "python_recordings"
 
-    soma_voltage_filename = os.path.join(
-        recordings_dir,
-        'soma_voltage_RmpRiTau_step.dat')
+    soma_voltage_filename = os.path.join(recordings_dir, "soma_voltage_RmpRiTau_step.dat")
     numpy.savetxt(soma_voltage_filename, zip(time, soma_voltage))
 
-    print('Soma voltage for RmpRiTau trace saved to: %s'
-          % (soma_voltage_filename))
+    print("Soma voltage for RmpRiTau trace saved to: %s" % (soma_voltage_filename))
 
     if plot_traces:
         import pylab
-        pylab.figure(facecolor='white')
-        pylab.plot(recordings['time'], recordings['soma(0.5)'])
-        pylab.xlabel('time (ms)')
-        pylab.ylabel('Vm (mV)')
-        pylab.gcf().canvas.set_window_title('RmpRiTau trace')
+
+        pylab.figure(facecolor="white")
+        pylab.plot(recordings["time"], recordings["soma(0.5)"])
+        pylab.xlabel("time (ms)")
+        pylab.ylabel("Vm (mV)")
+        pylab.gcf().canvas.set_window_title("RmpRiTau trace")
 
     return time, soma_voltage, stim_start, stim_end
 
 
 def init_simulation():
     """Initialise simulation environment"""
 
     neuron.h.load_file("stdrun.hoc")
     neuron.h.load_file("import3d.hoc")
 
-    print('Loading constants')
-    neuron.h.load_file('constants.hoc')
+    print("Loading constants")
+    neuron.h.load_file("constants.hoc")
 
 
-def analyse_RmpRiTau_trace(
-        time,
-        soma_voltage,
-        stim_start,
-        stim_end,
-        current_amplitude):
+def analyse_RmpRiTau_trace(time, soma_voltage, stim_start, stim_end, current_amplitude):
     """Analyse the output of the RmpRiTau protocol"""
 
     # Import the eFeature Extraction Library
     import efel
 
     # Prepare the trace data
     trace = {}
-    trace['T'] = time
-    trace['V'] = soma_voltage
-    trace['stim_start'] = [stim_start]
-    trace['stim_end'] = [stim_end]
+    trace["T"] = time
+    trace["V"] = soma_voltage
+    trace["stim_start"] = [stim_start]
+    trace["stim_end"] = [stim_end]
 
     # Calculate the necessary eFeatures
     efel_results = efel.getFeatureValues(
-        [trace],
-        ['voltage_base', 'steady_state_voltage_stimend',
-         'decay_time_constant_after_stim'])
-
-    voltage_base = efel_results[0]['voltage_base'][0]
-    ss_voltage = efel_results[0]['steady_state_voltage_stimend'][0]
-    dct = efel_results[0]['decay_time_constant_after_stim'][0]
+        [trace], ["voltage_base", "steady_state_voltage_stimend", "decay_time_constant_after_stim"]
+    )
+
+    voltage_base = efel_results[0]["voltage_base"][0]
+    ss_voltage = efel_results[0]["steady_state_voltage_stimend"][0]
+    dct = efel_results[0]["decay_time_constant_after_stim"][0]
 
     # Calculate input resistance
     input_resistance = float(ss_voltage - voltage_base) / current_amplitude
 
     rmpritau_dict = {}
 
-    rmpritau_dict['Rmp'] = '%.6g' % voltage_base
-    rmpritau_dict['Rmp_Units'] = 'mV'
-    rmpritau_dict['Rin'] = '%.6g' % input_resistance
-    rmpritau_dict['Rin_Units'] = 'MOhm'
-    rmpritau_dict['Tau'] = '%.6g' % dct
-    rmpritau_dict['Tau_Units'] = 'ms'
-
-    print('Resting membrane potential is %s %s' %
-          (rmpritau_dict['Rmp'], rmpritau_dict['Rmp_Units']))
-    print('Input resistance is %s %s' %
-          (rmpritau_dict['Rin'], rmpritau_dict['Rin_Units']))
-    print('Time constant is %s %s' %
-          (rmpritau_dict['Tau'], rmpritau_dict['Tau_Units']))
+    rmpritau_dict["Rmp"] = "%.6g" % voltage_base
+    rmpritau_dict["Rmp_Units"] = "mV"
+    rmpritau_dict["Rin"] = "%.6g" % input_resistance
+    rmpritau_dict["Rin_Units"] = "MOhm"
+    rmpritau_dict["Tau"] = "%.6g" % dct
+    rmpritau_dict["Tau_Units"] = "ms"
+
+    print("Resting membrane potential is %s %s" % (rmpritau_dict["Rmp"], rmpritau_dict["Rmp_Units"]))
+    print("Input resistance is %s %s" % (rmpritau_dict["Rin"], rmpritau_dict["Rin_Units"]))
+    print("Time constant is %s %s" % (rmpritau_dict["Tau"], rmpritau_dict["Tau_Units"]))
 
     import json
 
-    with open('rmp_ri_tau.json', 'w') as rmpritau_json_file:
-        json.dump(rmpritau_dict, rmpritau_json_file,
-                        sort_keys=True,
-                        indent=4,
-                        separators=(',', ': '))
+    with open("rmp_ri_tau.json", "w") as rmpritau_json_file:
+        json.dump(rmpritau_dict, rmpritau_json_file, sort_keys=True, indent=4, separators=(",", ": "))
 
 
 def main(plot_traces=False):
     """Main"""
 
     # Import matplotlib to plot the traces
     if plot_traces:
         import matplotlib
-        matplotlib.rcParams['path.simplify'] = False
+
+        matplotlib.rcParams["path.simplify"] = False
 
     init_simulation()
 
     current_amplitude = -0.01
     stim_start = 1000
     stim_end = 2000
 
     time, soma_voltage, stim_start, stim_end = run_RmpRiTau_step(
-        stim_start, stim_end, current_amplitude, plot_traces=plot_traces)
+        stim_start, stim_end, current_amplitude, plot_traces=plot_traces
+    )
 
-    analyse_RmpRiTau_trace(
-        time,
-        soma_voltage,
-        stim_start,
-        stim_end,
-        current_amplitude)
+    analyse_RmpRiTau_trace(time, soma_voltage, stim_start, stim_end, current_amplitude)
 
     if plot_traces:
         import pylab
+
         pylab.show()
 
-if __name__ == '__main__':
+
+if __name__ == "__main__":
     if len(sys.argv) == 1:
         main(plot_traces=True)
-    elif len(sys.argv) == 2 and sys.argv[1] == '--no-plots':
+    elif len(sys.argv) == 2 and sys.argv[1] == "--no-plots":
         main(plot_traces=False)
     else:
-        raise Exception(
-            "Script only accepts one argument: --no-plots, not %s" %
-            str(sys.argv))
+        raise Exception("Script only accepts one argument: --no-plots, not %s" % str(sys.argv))
```

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/synapses/mtype_map.tsv` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/synapses/mtype_map.tsv`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/synapses/synapses.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/synapses/synapses.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/synapses/synapses.tsv` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/synapses/synapses.tsv`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/synapses/synconf.txt` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/synapses/synconf.txt`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_BTC_bAC217_1/template.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/template.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/LICENSE` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/LICENSE`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/README` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/README`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/biophysics.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/biophysics.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/constants.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/constants.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/creategui.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/creategui.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/createsimulation.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/createsimulation.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/init.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/init.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/Ca.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/Ca.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/CaDynamics_E2.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/CaDynamics_E2.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/Ca_LVAst.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/Ca_LVAst.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/Ih.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/Ih.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/Im.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/Im.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/K_Pst.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/K_Pst.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/K_Tst.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/K_Tst.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/NaTa_t.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/NaTa_t.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/NaTs2_t.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/NaTs2_t.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/Nap_Et2.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/Nap_Et2.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/ProbAMPANMDA_EMS.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/ProbAMPANMDA_EMS.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/ProbGABAAB_EMS.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/ProbGABAAB_EMS.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/SK_E2.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/SK_E2.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/SKv3_1.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mechanisms/SKv3_1.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/morphology/C091000D-I3_-_Scale_x1.000_y1.025_z1.000_-_Clone_6.asc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/morphology/C091000D-I3_-_Scale_x1.000_y1.025_z1.000_-_Clone_6.asc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/morphology.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/morphology.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mosinit.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/mosinit.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/ringplot.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/ringplot.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/run.py` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/run.py`

 * *Files 8% similar despite different names*

```diff
@@ -32,158 +32,155 @@
  * @author Werner Van Geit @ BBP
  * @date 2015
 """
 
 # pylint: disable=C0325, W0212, F0401, W0612, F0401
 
 import os
+import sys
+
 import neuron
 import numpy
-import sys
 
 
 def create_cell(add_synapses=True):
     """Create the cell model"""
     # Load morphology
     neuron.h.load_file("morphology.hoc")
     # Load biophysics
     neuron.h.load_file("biophysics.hoc")
     # Load main cell template
     neuron.h.load_file("template.hoc")
 
     # Instantiate the cell from the template
 
-    print("Loading cell cACint209_L5_ChC_e98f63217d")
-    cell = neuron.h.cACint209_L5_ChC_e98f63217d(1 if add_synapses else 0)
+    print("Loading cell cADpyr232_L5_TTPC2_8052133265")
+    cell = neuron.h.cADpyr232_L5_TTPC2_8052133265(1 if add_synapses else 0)
     return cell
 
 
 def create_stimuli(cell, step_number):
     """Create the stimuli"""
 
-    print('Attaching stimulus electrodes')
+    print("Attaching stimulus electrodes")
 
     stimuli = []
     step_amp = [0] * 3
 
-    with open('current_amps.dat', 'r') as current_amps_file:
-        first_line = current_amps_file.read().split('\n')[0].strip()
-        hyp_amp, step_amp[0], step_amp[1], step_amp[2] = first_line.split(' ')
+    with open("current_amps.dat", "r") as current_amps_file:
+        first_line = current_amps_file.read().split("\n")[0].strip()
+        hyp_amp, step_amp[0], step_amp[1], step_amp[2] = first_line.split(" ")
 
     iclamp = neuron.h.IClamp(0.5, sec=cell.soma[0])
     iclamp.delay = 700
     iclamp.dur = 2000
     iclamp.amp = float(step_amp[step_number - 1])
-    print('Setting up step current clamp: '
-          'amp=%f nA, delay=%f ms, duration=%f ms' %
-          (iclamp.amp, iclamp.delay, iclamp.dur))
+    print(
+        "Setting up step current clamp: "
+        "amp=%f nA, delay=%f ms, duration=%f ms" % (iclamp.amp, iclamp.delay, iclamp.dur)
+    )
 
     stimuli.append(iclamp)
 
     hyp_iclamp = neuron.h.IClamp(0.5, sec=cell.soma[0])
     hyp_iclamp.delay = 0
     hyp_iclamp.dur = 3000
     hyp_iclamp.amp = float(hyp_amp)
-    print('Setting up hypamp current clamp: '
-          'amp=%f nA, delay=%f ms, duration=%f ms' %
-          (hyp_iclamp.amp, hyp_iclamp.delay, hyp_iclamp.dur))
+    print(
+        "Setting up hypamp current clamp: "
+        "amp=%f nA, delay=%f ms, duration=%f ms" % (hyp_iclamp.amp, hyp_iclamp.delay, hyp_iclamp.dur)
+    )
 
     stimuli.append(hyp_iclamp)
 
     return stimuli
 
 
 def create_recordings(cell):
     """Create the recordings"""
-    print('Attaching recording electrodes')
+    print("Attaching recording electrodes")
 
     recordings = {}
 
-    recordings['time'] = neuron.h.Vector()
-    recordings['soma(0.5)'] = neuron.h.Vector()
+    recordings["time"] = neuron.h.Vector()
+    recordings["soma(0.5)"] = neuron.h.Vector()
 
-    recordings['time'].record(neuron.h._ref_t, 0.1)
-    recordings['soma(0.5)'].record(cell.soma[0](0.5)._ref_v, 0.1)
+    recordings["time"].record(neuron.h._ref_t, 0.1)
+    recordings["soma(0.5)"].record(cell.soma[0](0.5)._ref_v, 0.1)
 
     return recordings
 
 
 def run_step(step_number, plot_traces=None):
     """Run step current simulation with index step_number"""
 
     cell = create_cell(add_synapses=False)
     stimuli = create_stimuli(cell, step_number)
     recordings = create_recordings(cell)
 
     # Overriding default 30s simulation,
-    print('Setting simulation time to 3s for the step currents')
+    print("Setting simulation time to 3s for the step currents")
     neuron.h.tstop = 3000
 
-    print('Disabling variable timestep integration')
+    print("Disabling variable timestep integration")
     neuron.h.cvode_active(0)
 
-    print('Running for %f ms' % neuron.h.tstop)
+    print("Running for %f ms" % neuron.h.tstop)
     neuron.h.run()
 
-    time = numpy.array(recordings['time'])
-    soma_voltage = numpy.array(recordings['soma(0.5)'])
+    time = numpy.array(recordings["time"])
+    soma_voltage = numpy.array(recordings["soma(0.5)"])
 
-    recordings_dir = 'python_recordings'
+    recordings_dir = "python_recordings"
 
-    soma_voltage_filename = os.path.join(
-        recordings_dir,
-        'soma_voltage_step%d.dat' % step_number)
-    numpy.savetxt(
-            soma_voltage_filename,
-            numpy.transpose(
-               numpy.vstack((
-                    time,
-                    soma_voltage))))
+    soma_voltage_filename = os.path.join(recordings_dir, "soma_voltage_step%d.dat" % step_number)
+    numpy.savetxt(soma_voltage_filename, numpy.transpose(numpy.vstack((time, soma_voltage))))
 
-    print('Soma voltage for step %d saved to: %s'
-          % (step_number, soma_voltage_filename))
+    print("Soma voltage for step %d saved to: %s" % (step_number, soma_voltage_filename))
 
     if plot_traces:
         import pylab
+
         pylab.figure()
-        pylab.plot(recordings['time'], recordings['soma(0.5)'])
-        pylab.xlabel('time (ms)')
-        pylab.ylabel('Vm (mV)')
-        pylab.gcf().canvas.set_window_title('Step %d' % step_number)
+        pylab.plot(recordings["time"], recordings["soma(0.5)"])
+        pylab.xlabel("time (ms)")
+        pylab.ylabel("Vm (mV)")
+        pylab.gcf().canvas.set_window_title("Step %d" % step_number)
 
 
 def init_simulation():
     """Initialise simulation environment"""
 
     neuron.h.load_file("stdrun.hoc")
     neuron.h.load_file("import3d.hoc")
 
-    print('Loading constants')
-    neuron.h.load_file('constants.hoc')
+    print("Loading constants")
+    neuron.h.load_file("constants.hoc")
 
 
 def main(plot_traces=True):
     """Main"""
 
     # Import matplotlib to plot the traces
     if plot_traces:
         import matplotlib
-        matplotlib.rcParams['path.simplify'] = False
+
+        matplotlib.rcParams["path.simplify"] = False
 
     init_simulation()
 
     for step_number in range(1, 4):
         run_step(step_number, plot_traces=plot_traces)
 
     if plot_traces:
         import pylab
+
         pylab.show()
 
-if __name__ == '__main__':
+
+if __name__ == "__main__":
     if len(sys.argv) == 1:
         main(plot_traces=True)
-    elif len(sys.argv) == 2 and sys.argv[1] == '--no-plots':
+    elif len(sys.argv) == 2 and sys.argv[1] == "--no-plots":
         main(plot_traces=False)
     else:
-        raise Exception(
-            "Script only accepts one argument: --no-plots, not %s" %
-            str(sys.argv))
+        raise Exception("Script only accepts one argument: --no-plots, not %s" % str(sys.argv))
```

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/run_RmpRiTau.py` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/run_RmpRiTau.py`

 * *Files 10% similar despite different names*

```diff
@@ -32,222 +32,201 @@
  * @author Werner Van Geit @ BBP
  * @date 2015
 """
 
 # pylint: disable=C0325, W0212, F0401, W0612, F0401
 
 import os
+import sys
+
 import neuron
 import numpy
-import sys
 
 
 def create_cell():
     """Create the cell model"""
     # Load morphology
     neuron.h.load_file("morphology.hoc")
     # Load biophysics
     neuron.h.load_file("biophysics.hoc")
     # Load main cell template
     neuron.h.load_file("template.hoc")
 
     # Instantiate the cell from the template
 
-    print("Loading cell cACint209_L5_ChC_e98f63217d")
-    cell = neuron.h.cACint209_L5_ChC_e98f63217d(0)
+    print("Loading cell cADpyr232_L5_STPC_d16b0be14e")
+    cell = neuron.h.cADpyr232_L5_STPC_d16b0be14e(0)
     return cell
 
 
 def create_stimuli(cell, stim_start, stim_end, current_amplitude):
     """Create the stimuli"""
 
-    print('Attaching stimulus electrodes')
+    print("Attaching stimulus electrodes")
 
     stimuli = []
 
     iclamp = neuron.h.IClamp(0.5, sec=cell.soma[0])
     iclamp.delay = stim_start
     iclamp.dur = stim_end - stim_start
     iclamp.amp = current_amplitude
-    print('Setting up step current clamp: '
-          'amp=%f nA, delay=%f ms, duration=%f ms' %
-          (iclamp.amp, iclamp.delay, iclamp.dur))
+    print(
+        "Setting up step current clamp: "
+        "amp=%f nA, delay=%f ms, duration=%f ms" % (iclamp.amp, iclamp.delay, iclamp.dur)
+    )
 
     stimuli.append(iclamp)
 
     return stimuli
 
 
 def create_recordings(cell):
     """Create the recordings"""
-    print('Attaching recording electrodes')
+    print("Attaching recording electrodes")
 
     recordings = {}
 
-    recordings['time'] = neuron.h.Vector()
-    recordings['soma(0.5)'] = neuron.h.Vector()
+    recordings["time"] = neuron.h.Vector()
+    recordings["soma(0.5)"] = neuron.h.Vector()
 
-    recordings['time'].record(neuron.h._ref_t, 0.1)
-    recordings['soma(0.5)'].record(cell.soma[0](0.5)._ref_v, 0.1)
+    recordings["time"].record(neuron.h._ref_t, 0.1)
+    recordings["soma(0.5)"].record(cell.soma[0](0.5)._ref_v, 0.1)
 
     return recordings
 
 
-def run_RmpRiTau_step(
-        stim_start,
-        stim_end,
-        current_amplitude,
-        plot_traces=None):
-    """Run """
+def run_RmpRiTau_step(stim_start, stim_end, current_amplitude, plot_traces=None):
+    """Run"""
 
     cell = create_cell()
     stimuli = create_stimuli(cell, stim_start, stim_end, current_amplitude)  # noqa
     recordings = create_recordings(cell)
 
     # Overriding default 30s simulation,
     neuron.h.tstop = stim_end + stim_start
-    print(
-        'Setting simulation time to %.6g ms for the step current' %
-        neuron.h.tstop)
+    print("Setting simulation time to %.6g ms for the step current" % neuron.h.tstop)
 
-    print('Setting initial voltage to -70 mV')
+    print("Setting initial voltage to -70 mV")
     neuron.h.v_init = -70
 
     neuron.h.stdinit()
     neuron.h.dt = 1000
     neuron.h.t = -1e9
     for _ in range(10):
         neuron.h.fadvance()
 
     neuron.h.t = 0
     neuron.h.dt = 0.025
     neuron.h.frecord_init()
 
     neuron.h.continuerun(3000)
 
-    time = numpy.array(recordings['time'])
-    soma_voltage = numpy.array(recordings['soma(0.5)'])
+    time = numpy.array(recordings["time"])
+    soma_voltage = numpy.array(recordings["soma(0.5)"])
 
-    recordings_dir = 'python_recordings'
+    recordings_dir = "python_recordings"
 
-    soma_voltage_filename = os.path.join(
-        recordings_dir,
-        'soma_voltage_RmpRiTau_step.dat')
+    soma_voltage_filename = os.path.join(recordings_dir, "soma_voltage_RmpRiTau_step.dat")
     numpy.savetxt(soma_voltage_filename, zip(time, soma_voltage))
 
-    print('Soma voltage for RmpRiTau trace saved to: %s'
-          % (soma_voltage_filename))
+    print("Soma voltage for RmpRiTau trace saved to: %s" % (soma_voltage_filename))
 
     if plot_traces:
         import pylab
-        pylab.figure(facecolor='white')
-        pylab.plot(recordings['time'], recordings['soma(0.5)'])
-        pylab.xlabel('time (ms)')
-        pylab.ylabel('Vm (mV)')
-        pylab.gcf().canvas.set_window_title('RmpRiTau trace')
+
+        pylab.figure(facecolor="white")
+        pylab.plot(recordings["time"], recordings["soma(0.5)"])
+        pylab.xlabel("time (ms)")
+        pylab.ylabel("Vm (mV)")
+        pylab.gcf().canvas.set_window_title("RmpRiTau trace")
 
     return time, soma_voltage, stim_start, stim_end
 
 
 def init_simulation():
     """Initialise simulation environment"""
 
     neuron.h.load_file("stdrun.hoc")
     neuron.h.load_file("import3d.hoc")
 
-    print('Loading constants')
-    neuron.h.load_file('constants.hoc')
+    print("Loading constants")
+    neuron.h.load_file("constants.hoc")
 
 
-def analyse_RmpRiTau_trace(
-        time,
-        soma_voltage,
-        stim_start,
-        stim_end,
-        current_amplitude):
+def analyse_RmpRiTau_trace(time, soma_voltage, stim_start, stim_end, current_amplitude):
     """Analyse the output of the RmpRiTau protocol"""
 
     # Import the eFeature Extraction Library
     import efel
 
     # Prepare the trace data
     trace = {}
-    trace['T'] = time
-    trace['V'] = soma_voltage
-    trace['stim_start'] = [stim_start]
-    trace['stim_end'] = [stim_end]
+    trace["T"] = time
+    trace["V"] = soma_voltage
+    trace["stim_start"] = [stim_start]
+    trace["stim_end"] = [stim_end]
 
     # Calculate the necessary eFeatures
     efel_results = efel.getFeatureValues(
-        [trace],
-        ['voltage_base', 'steady_state_voltage_stimend',
-         'decay_time_constant_after_stim'])
-
-    voltage_base = efel_results[0]['voltage_base'][0]
-    ss_voltage = efel_results[0]['steady_state_voltage_stimend'][0]
-    dct = efel_results[0]['decay_time_constant_after_stim'][0]
+        [trace], ["voltage_base", "steady_state_voltage_stimend", "decay_time_constant_after_stim"]
+    )
+
+    voltage_base = efel_results[0]["voltage_base"][0]
+    ss_voltage = efel_results[0]["steady_state_voltage_stimend"][0]
+    dct = efel_results[0]["decay_time_constant_after_stim"][0]
 
     # Calculate input resistance
     input_resistance = float(ss_voltage - voltage_base) / current_amplitude
 
     rmpritau_dict = {}
 
-    rmpritau_dict['Rmp'] = '%.6g' % voltage_base
-    rmpritau_dict['Rmp_Units'] = 'mV'
-    rmpritau_dict['Rin'] = '%.6g' % input_resistance
-    rmpritau_dict['Rin_Units'] = 'MOhm'
-    rmpritau_dict['Tau'] = '%.6g' % dct
-    rmpritau_dict['Tau_Units'] = 'ms'
-
-    print('Resting membrane potential is %s %s' %
-          (rmpritau_dict['Rmp'], rmpritau_dict['Rmp_Units']))
-    print('Input resistance is %s %s' %
-          (rmpritau_dict['Rin'], rmpritau_dict['Rin_Units']))
-    print('Time constant is %s %s' %
-          (rmpritau_dict['Tau'], rmpritau_dict['Tau_Units']))
+    rmpritau_dict["Rmp"] = "%.6g" % voltage_base
+    rmpritau_dict["Rmp_Units"] = "mV"
+    rmpritau_dict["Rin"] = "%.6g" % input_resistance
+    rmpritau_dict["Rin_Units"] = "MOhm"
+    rmpritau_dict["Tau"] = "%.6g" % dct
+    rmpritau_dict["Tau_Units"] = "ms"
+
+    print("Resting membrane potential is %s %s" % (rmpritau_dict["Rmp"], rmpritau_dict["Rmp_Units"]))
+    print("Input resistance is %s %s" % (rmpritau_dict["Rin"], rmpritau_dict["Rin_Units"]))
+    print("Time constant is %s %s" % (rmpritau_dict["Tau"], rmpritau_dict["Tau_Units"]))
 
     import json
 
-    with open('rmp_ri_tau.json', 'w') as rmpritau_json_file:
-        json.dump(rmpritau_dict, rmpritau_json_file,
-                        sort_keys=True,
-                        indent=4,
-                        separators=(',', ': '))
+    with open("rmp_ri_tau.json", "w") as rmpritau_json_file:
+        json.dump(rmpritau_dict, rmpritau_json_file, sort_keys=True, indent=4, separators=(",", ": "))
 
 
 def main(plot_traces=False):
     """Main"""
 
     # Import matplotlib to plot the traces
     if plot_traces:
         import matplotlib
-        matplotlib.rcParams['path.simplify'] = False
+
+        matplotlib.rcParams["path.simplify"] = False
 
     init_simulation()
 
     current_amplitude = -0.01
     stim_start = 1000
     stim_end = 2000
 
     time, soma_voltage, stim_start, stim_end = run_RmpRiTau_step(
-        stim_start, stim_end, current_amplitude, plot_traces=plot_traces)
+        stim_start, stim_end, current_amplitude, plot_traces=plot_traces
+    )
 
-    analyse_RmpRiTau_trace(
-        time,
-        soma_voltage,
-        stim_start,
-        stim_end,
-        current_amplitude)
+    analyse_RmpRiTau_trace(time, soma_voltage, stim_start, stim_end, current_amplitude)
 
     if plot_traces:
         import pylab
+
         pylab.show()
 
-if __name__ == '__main__':
+
+if __name__ == "__main__":
     if len(sys.argv) == 1:
         main(plot_traces=True)
-    elif len(sys.argv) == 2 and sys.argv[1] == '--no-plots':
+    elif len(sys.argv) == 2 and sys.argv[1] == "--no-plots":
         main(plot_traces=False)
     else:
-        raise Exception(
-            "Script only accepts one argument: --no-plots, not %s" %
-            str(sys.argv))
+        raise Exception("Script only accepts one argument: --no-plots, not %s" % str(sys.argv))
```

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/synapses/mtype_map.tsv` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/synapses/mtype_map.tsv`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/synapses/synapses.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/synapses/synapses.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/synapses/synapses.tsv` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/synapses/synapses.tsv`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/synapses/synconf.txt` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/synapses/synconf.txt`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_ChC_cACint209_1/template.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/template.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/LICENSE` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/LICENSE`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/README` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/README`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/biophysics.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/biophysics.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/constants.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/constants.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/creategui.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/creategui.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/createsimulation.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/createsimulation.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/init.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/init.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/Ca.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/Ca.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/CaDynamics_E2.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/CaDynamics_E2.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/Ca_LVAst.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/Ca_LVAst.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/Ih.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/Ih.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/Im.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/Im.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/K_Pst.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/K_Pst.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/K_Tst.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/K_Tst.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/NaTa_t.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/NaTa_t.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/NaTs2_t.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/NaTs2_t.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/Nap_Et2.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/Nap_Et2.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/ProbAMPANMDA_EMS.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/ProbAMPANMDA_EMS.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/ProbGABAAB_EMS.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/ProbGABAAB_EMS.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/SK_E2.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/SK_E2.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/SKv3_1.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mechanisms/SKv3_1.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/morphology/rp100428-12_idC_-_Scale_x1.000_y1.025_z1.000_-_Clone_1.asc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/morphology/rp100428-12_idC_-_Scale_x1.000_y1.025_z1.000_-_Clone_1.asc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/morphology.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/morphology.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mosinit.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/mosinit.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/ringplot.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/ringplot.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/run.py` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/run.py`

 * *Files 7% similar despite different names*

```diff
@@ -32,17 +32,18 @@
  * @author Werner Van Geit @ BBP
  * @date 2015
 """
 
 # pylint: disable=C0325, W0212, F0401, W0612, F0401
 
 import os
+import sys
+
 import neuron
 import numpy
-import sys
 
 
 def create_cell(add_synapses=True):
     """Create the cell model"""
     # Load morphology
     neuron.h.load_file("morphology.hoc")
     # Load biophysics
@@ -56,134 +57,130 @@
     cell = neuron.h.bAC217_L5_DBC_4765d943f4(1 if add_synapses else 0)
     return cell
 
 
 def create_stimuli(cell, step_number):
     """Create the stimuli"""
 
-    print('Attaching stimulus electrodes')
+    print("Attaching stimulus electrodes")
 
     stimuli = []
     step_amp = [0] * 3
 
-    with open('current_amps.dat', 'r') as current_amps_file:
-        first_line = current_amps_file.read().split('\n')[0].strip()
-        hyp_amp, step_amp[0], step_amp[1], step_amp[2] = first_line.split(' ')
+    with open("current_amps.dat", "r") as current_amps_file:
+        first_line = current_amps_file.read().split("\n")[0].strip()
+        hyp_amp, step_amp[0], step_amp[1], step_amp[2] = first_line.split(" ")
 
     iclamp = neuron.h.IClamp(0.5, sec=cell.soma[0])
     iclamp.delay = 700
     iclamp.dur = 2000
     iclamp.amp = float(step_amp[step_number - 1])
-    print('Setting up step current clamp: '
-          'amp=%f nA, delay=%f ms, duration=%f ms' %
-          (iclamp.amp, iclamp.delay, iclamp.dur))
+    print(
+        "Setting up step current clamp: "
+        "amp=%f nA, delay=%f ms, duration=%f ms" % (iclamp.amp, iclamp.delay, iclamp.dur)
+    )
 
     stimuli.append(iclamp)
 
     hyp_iclamp = neuron.h.IClamp(0.5, sec=cell.soma[0])
     hyp_iclamp.delay = 0
     hyp_iclamp.dur = 3000
     hyp_iclamp.amp = float(hyp_amp)
-    print('Setting up hypamp current clamp: '
-          'amp=%f nA, delay=%f ms, duration=%f ms' %
-          (hyp_iclamp.amp, hyp_iclamp.delay, hyp_iclamp.dur))
+    print(
+        "Setting up hypamp current clamp: "
+        "amp=%f nA, delay=%f ms, duration=%f ms" % (hyp_iclamp.amp, hyp_iclamp.delay, hyp_iclamp.dur)
+    )
 
     stimuli.append(hyp_iclamp)
 
     return stimuli
 
 
 def create_recordings(cell):
     """Create the recordings"""
-    print('Attaching recording electrodes')
+    print("Attaching recording electrodes")
 
     recordings = {}
 
-    recordings['time'] = neuron.h.Vector()
-    recordings['soma(0.5)'] = neuron.h.Vector()
+    recordings["time"] = neuron.h.Vector()
+    recordings["soma(0.5)"] = neuron.h.Vector()
 
-    recordings['time'].record(neuron.h._ref_t, 0.1)
-    recordings['soma(0.5)'].record(cell.soma[0](0.5)._ref_v, 0.1)
+    recordings["time"].record(neuron.h._ref_t, 0.1)
+    recordings["soma(0.5)"].record(cell.soma[0](0.5)._ref_v, 0.1)
 
     return recordings
 
 
 def run_step(step_number, plot_traces=None):
     """Run step current simulation with index step_number"""
 
     cell = create_cell(add_synapses=False)
     stimuli = create_stimuli(cell, step_number)
     recordings = create_recordings(cell)
 
     # Overriding default 30s simulation,
-    print('Setting simulation time to 3s for the step currents')
+    print("Setting simulation time to 3s for the step currents")
     neuron.h.tstop = 3000
 
-    print('Disabling variable timestep integration')
+    print("Disabling variable timestep integration")
     neuron.h.cvode_active(0)
 
-    print('Running for %f ms' % neuron.h.tstop)
+    print("Running for %f ms" % neuron.h.tstop)
     neuron.h.run()
 
-    time = numpy.array(recordings['time'])
-    soma_voltage = numpy.array(recordings['soma(0.5)'])
+    time = numpy.array(recordings["time"])
+    soma_voltage = numpy.array(recordings["soma(0.5)"])
 
-    recordings_dir = 'python_recordings'
+    recordings_dir = "python_recordings"
 
-    soma_voltage_filename = os.path.join(
-        recordings_dir,
-        'soma_voltage_step%d.dat' % step_number)
-    numpy.savetxt(
-            soma_voltage_filename,
-            numpy.transpose(
-               numpy.vstack((
-                    time,
-                    soma_voltage))))
+    soma_voltage_filename = os.path.join(recordings_dir, "soma_voltage_step%d.dat" % step_number)
+    numpy.savetxt(soma_voltage_filename, numpy.transpose(numpy.vstack((time, soma_voltage))))
 
-    print('Soma voltage for step %d saved to: %s'
-          % (step_number, soma_voltage_filename))
+    print("Soma voltage for step %d saved to: %s" % (step_number, soma_voltage_filename))
 
     if plot_traces:
         import pylab
+
         pylab.figure()
-        pylab.plot(recordings['time'], recordings['soma(0.5)'])
-        pylab.xlabel('time (ms)')
-        pylab.ylabel('Vm (mV)')
-        pylab.gcf().canvas.set_window_title('Step %d' % step_number)
+        pylab.plot(recordings["time"], recordings["soma(0.5)"])
+        pylab.xlabel("time (ms)")
+        pylab.ylabel("Vm (mV)")
+        pylab.gcf().canvas.set_window_title("Step %d" % step_number)
 
 
 def init_simulation():
     """Initialise simulation environment"""
 
     neuron.h.load_file("stdrun.hoc")
     neuron.h.load_file("import3d.hoc")
 
-    print('Loading constants')
-    neuron.h.load_file('constants.hoc')
+    print("Loading constants")
+    neuron.h.load_file("constants.hoc")
 
 
 def main(plot_traces=True):
     """Main"""
 
     # Import matplotlib to plot the traces
     if plot_traces:
         import matplotlib
-        matplotlib.rcParams['path.simplify'] = False
+
+        matplotlib.rcParams["path.simplify"] = False
 
     init_simulation()
 
     for step_number in range(1, 4):
         run_step(step_number, plot_traces=plot_traces)
 
     if plot_traces:
         import pylab
+
         pylab.show()
 
-if __name__ == '__main__':
+
+if __name__ == "__main__":
     if len(sys.argv) == 1:
         main(plot_traces=True)
-    elif len(sys.argv) == 2 and sys.argv[1] == '--no-plots':
+    elif len(sys.argv) == 2 and sys.argv[1] == "--no-plots":
         main(plot_traces=False)
     else:
-        raise Exception(
-            "Script only accepts one argument: --no-plots, not %s" %
-            str(sys.argv))
+        raise Exception("Script only accepts one argument: --no-plots, not %s" % str(sys.argv))
```

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/run_RmpRiTau.py` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/run_RmpRiTau.py`

 * *Files 9% similar despite different names*

```diff
@@ -32,222 +32,201 @@
  * @author Werner Van Geit @ BBP
  * @date 2015
 """
 
 # pylint: disable=C0325, W0212, F0401, W0612, F0401
 
 import os
+import sys
+
 import neuron
 import numpy
-import sys
 
 
 def create_cell():
     """Create the cell model"""
     # Load morphology
     neuron.h.load_file("morphology.hoc")
     # Load biophysics
     neuron.h.load_file("biophysics.hoc")
     # Load main cell template
     neuron.h.load_file("template.hoc")
 
     # Instantiate the cell from the template
 
-    print("Loading cell bAC217_L5_DBC_4765d943f4")
-    cell = neuron.h.bAC217_L5_DBC_4765d943f4(0)
+    print("Loading cell bAC217_L5_NBC_2db880c523")
+    cell = neuron.h.bAC217_L5_NBC_2db880c523(0)
     return cell
 
 
 def create_stimuli(cell, stim_start, stim_end, current_amplitude):
     """Create the stimuli"""
 
-    print('Attaching stimulus electrodes')
+    print("Attaching stimulus electrodes")
 
     stimuli = []
 
     iclamp = neuron.h.IClamp(0.5, sec=cell.soma[0])
     iclamp.delay = stim_start
     iclamp.dur = stim_end - stim_start
     iclamp.amp = current_amplitude
-    print('Setting up step current clamp: '
-          'amp=%f nA, delay=%f ms, duration=%f ms' %
-          (iclamp.amp, iclamp.delay, iclamp.dur))
+    print(
+        "Setting up step current clamp: "
+        "amp=%f nA, delay=%f ms, duration=%f ms" % (iclamp.amp, iclamp.delay, iclamp.dur)
+    )
 
     stimuli.append(iclamp)
 
     return stimuli
 
 
 def create_recordings(cell):
     """Create the recordings"""
-    print('Attaching recording electrodes')
+    print("Attaching recording electrodes")
 
     recordings = {}
 
-    recordings['time'] = neuron.h.Vector()
-    recordings['soma(0.5)'] = neuron.h.Vector()
+    recordings["time"] = neuron.h.Vector()
+    recordings["soma(0.5)"] = neuron.h.Vector()
 
-    recordings['time'].record(neuron.h._ref_t, 0.1)
-    recordings['soma(0.5)'].record(cell.soma[0](0.5)._ref_v, 0.1)
+    recordings["time"].record(neuron.h._ref_t, 0.1)
+    recordings["soma(0.5)"].record(cell.soma[0](0.5)._ref_v, 0.1)
 
     return recordings
 
 
-def run_RmpRiTau_step(
-        stim_start,
-        stim_end,
-        current_amplitude,
-        plot_traces=None):
-    """Run """
+def run_RmpRiTau_step(stim_start, stim_end, current_amplitude, plot_traces=None):
+    """Run"""
 
     cell = create_cell()
     stimuli = create_stimuli(cell, stim_start, stim_end, current_amplitude)  # noqa
     recordings = create_recordings(cell)
 
     # Overriding default 30s simulation,
     neuron.h.tstop = stim_end + stim_start
-    print(
-        'Setting simulation time to %.6g ms for the step current' %
-        neuron.h.tstop)
+    print("Setting simulation time to %.6g ms for the step current" % neuron.h.tstop)
 
-    print('Setting initial voltage to -70 mV')
+    print("Setting initial voltage to -70 mV")
     neuron.h.v_init = -70
 
     neuron.h.stdinit()
     neuron.h.dt = 1000
     neuron.h.t = -1e9
     for _ in range(10):
         neuron.h.fadvance()
 
     neuron.h.t = 0
     neuron.h.dt = 0.025
     neuron.h.frecord_init()
 
     neuron.h.continuerun(3000)
 
-    time = numpy.array(recordings['time'])
-    soma_voltage = numpy.array(recordings['soma(0.5)'])
+    time = numpy.array(recordings["time"])
+    soma_voltage = numpy.array(recordings["soma(0.5)"])
 
-    recordings_dir = 'python_recordings'
+    recordings_dir = "python_recordings"
 
-    soma_voltage_filename = os.path.join(
-        recordings_dir,
-        'soma_voltage_RmpRiTau_step.dat')
+    soma_voltage_filename = os.path.join(recordings_dir, "soma_voltage_RmpRiTau_step.dat")
     numpy.savetxt(soma_voltage_filename, zip(time, soma_voltage))
 
-    print('Soma voltage for RmpRiTau trace saved to: %s'
-          % (soma_voltage_filename))
+    print("Soma voltage for RmpRiTau trace saved to: %s" % (soma_voltage_filename))
 
     if plot_traces:
         import pylab
-        pylab.figure(facecolor='white')
-        pylab.plot(recordings['time'], recordings['soma(0.5)'])
-        pylab.xlabel('time (ms)')
-        pylab.ylabel('Vm (mV)')
-        pylab.gcf().canvas.set_window_title('RmpRiTau trace')
+
+        pylab.figure(facecolor="white")
+        pylab.plot(recordings["time"], recordings["soma(0.5)"])
+        pylab.xlabel("time (ms)")
+        pylab.ylabel("Vm (mV)")
+        pylab.gcf().canvas.set_window_title("RmpRiTau trace")
 
     return time, soma_voltage, stim_start, stim_end
 
 
 def init_simulation():
     """Initialise simulation environment"""
 
     neuron.h.load_file("stdrun.hoc")
     neuron.h.load_file("import3d.hoc")
 
-    print('Loading constants')
-    neuron.h.load_file('constants.hoc')
+    print("Loading constants")
+    neuron.h.load_file("constants.hoc")
 
 
-def analyse_RmpRiTau_trace(
-        time,
-        soma_voltage,
-        stim_start,
-        stim_end,
-        current_amplitude):
+def analyse_RmpRiTau_trace(time, soma_voltage, stim_start, stim_end, current_amplitude):
     """Analyse the output of the RmpRiTau protocol"""
 
     # Import the eFeature Extraction Library
     import efel
 
     # Prepare the trace data
     trace = {}
-    trace['T'] = time
-    trace['V'] = soma_voltage
-    trace['stim_start'] = [stim_start]
-    trace['stim_end'] = [stim_end]
+    trace["T"] = time
+    trace["V"] = soma_voltage
+    trace["stim_start"] = [stim_start]
+    trace["stim_end"] = [stim_end]
 
     # Calculate the necessary eFeatures
     efel_results = efel.getFeatureValues(
-        [trace],
-        ['voltage_base', 'steady_state_voltage_stimend',
-         'decay_time_constant_after_stim'])
-
-    voltage_base = efel_results[0]['voltage_base'][0]
-    ss_voltage = efel_results[0]['steady_state_voltage_stimend'][0]
-    dct = efel_results[0]['decay_time_constant_after_stim'][0]
+        [trace], ["voltage_base", "steady_state_voltage_stimend", "decay_time_constant_after_stim"]
+    )
+
+    voltage_base = efel_results[0]["voltage_base"][0]
+    ss_voltage = efel_results[0]["steady_state_voltage_stimend"][0]
+    dct = efel_results[0]["decay_time_constant_after_stim"][0]
 
     # Calculate input resistance
     input_resistance = float(ss_voltage - voltage_base) / current_amplitude
 
     rmpritau_dict = {}
 
-    rmpritau_dict['Rmp'] = '%.6g' % voltage_base
-    rmpritau_dict['Rmp_Units'] = 'mV'
-    rmpritau_dict['Rin'] = '%.6g' % input_resistance
-    rmpritau_dict['Rin_Units'] = 'MOhm'
-    rmpritau_dict['Tau'] = '%.6g' % dct
-    rmpritau_dict['Tau_Units'] = 'ms'
-
-    print('Resting membrane potential is %s %s' %
-          (rmpritau_dict['Rmp'], rmpritau_dict['Rmp_Units']))
-    print('Input resistance is %s %s' %
-          (rmpritau_dict['Rin'], rmpritau_dict['Rin_Units']))
-    print('Time constant is %s %s' %
-          (rmpritau_dict['Tau'], rmpritau_dict['Tau_Units']))
+    rmpritau_dict["Rmp"] = "%.6g" % voltage_base
+    rmpritau_dict["Rmp_Units"] = "mV"
+    rmpritau_dict["Rin"] = "%.6g" % input_resistance
+    rmpritau_dict["Rin_Units"] = "MOhm"
+    rmpritau_dict["Tau"] = "%.6g" % dct
+    rmpritau_dict["Tau_Units"] = "ms"
+
+    print("Resting membrane potential is %s %s" % (rmpritau_dict["Rmp"], rmpritau_dict["Rmp_Units"]))
+    print("Input resistance is %s %s" % (rmpritau_dict["Rin"], rmpritau_dict["Rin_Units"]))
+    print("Time constant is %s %s" % (rmpritau_dict["Tau"], rmpritau_dict["Tau_Units"]))
 
     import json
 
-    with open('rmp_ri_tau.json', 'w') as rmpritau_json_file:
-        json.dump(rmpritau_dict, rmpritau_json_file,
-                        sort_keys=True,
-                        indent=4,
-                        separators=(',', ': '))
+    with open("rmp_ri_tau.json", "w") as rmpritau_json_file:
+        json.dump(rmpritau_dict, rmpritau_json_file, sort_keys=True, indent=4, separators=(",", ": "))
 
 
 def main(plot_traces=False):
     """Main"""
 
     # Import matplotlib to plot the traces
     if plot_traces:
         import matplotlib
-        matplotlib.rcParams['path.simplify'] = False
+
+        matplotlib.rcParams["path.simplify"] = False
 
     init_simulation()
 
     current_amplitude = -0.01
     stim_start = 1000
     stim_end = 2000
 
     time, soma_voltage, stim_start, stim_end = run_RmpRiTau_step(
-        stim_start, stim_end, current_amplitude, plot_traces=plot_traces)
+        stim_start, stim_end, current_amplitude, plot_traces=plot_traces
+    )
 
-    analyse_RmpRiTau_trace(
-        time,
-        soma_voltage,
-        stim_start,
-        stim_end,
-        current_amplitude)
+    analyse_RmpRiTau_trace(time, soma_voltage, stim_start, stim_end, current_amplitude)
 
     if plot_traces:
         import pylab
+
         pylab.show()
 
-if __name__ == '__main__':
+
+if __name__ == "__main__":
     if len(sys.argv) == 1:
         main(plot_traces=True)
-    elif len(sys.argv) == 2 and sys.argv[1] == '--no-plots':
+    elif len(sys.argv) == 2 and sys.argv[1] == "--no-plots":
         main(plot_traces=False)
     else:
-        raise Exception(
-            "Script only accepts one argument: --no-plots, not %s" %
-            str(sys.argv))
+        raise Exception("Script only accepts one argument: --no-plots, not %s" % str(sys.argv))
```

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/synapses/mtype_map.tsv` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/synapses/mtype_map.tsv`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/synapses/synapses.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/synapses/synapses.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/synapses/synapses.tsv` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/synapses/synapses.tsv`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/synapses/synconf.txt` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/synapses/synconf.txt`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_DBC_bAC217_1/template.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_DBC_bAC217_1/template.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/LICENSE` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/LICENSE`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/README` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/README`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/biophysics.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/biophysics.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/constants.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/constants.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/creategui.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/creategui.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/createsimulation.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/createsimulation.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/init.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/init.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/Ca.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/Ca.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/CaDynamics_E2.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/CaDynamics_E2.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/Ca_LVAst.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/Ca_LVAst.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/Ih.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/Ih.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/Im.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/Im.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/K_Pst.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/K_Pst.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/K_Tst.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/K_Tst.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/NaTa_t.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/NaTa_t.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/NaTs2_t.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/NaTs2_t.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/Nap_Et2.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/Nap_Et2.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/ProbAMPANMDA_EMS.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/ProbAMPANMDA_EMS.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/ProbGABAAB_EMS.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/ProbGABAAB_EMS.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/SK_E2.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/SK_E2.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/SKv3_1.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mechanisms/SKv3_1.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/morphology/og061123b1-3_idB_-_Scale_x1.000_y0.975_z1.000_-_Clone_4.asc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/morphology/og061123b1-3_idB_-_Scale_x1.000_y0.975_z1.000_-_Clone_4.asc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/morphology.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/morphology.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mosinit.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/mosinit.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/ringplot.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/ringplot.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/run.py` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/run.py`

 * *Files 7% similar despite different names*

```diff
@@ -32,158 +32,155 @@
  * @author Werner Van Geit @ BBP
  * @date 2015
 """
 
 # pylint: disable=C0325, W0212, F0401, W0612, F0401
 
 import os
+import sys
+
 import neuron
 import numpy
-import sys
 
 
 def create_cell(add_synapses=True):
     """Create the cell model"""
     # Load morphology
     neuron.h.load_file("morphology.hoc")
     # Load biophysics
     neuron.h.load_file("biophysics.hoc")
     # Load main cell template
     neuron.h.load_file("template.hoc")
 
     # Instantiate the cell from the template
 
-    print("Loading cell bAC217_L5_LBC_c2cff91741")
-    cell = neuron.h.bAC217_L5_LBC_c2cff91741(1 if add_synapses else 0)
+    print("Loading cell bNAC219_L5_NGC_6186b7e85e")
+    cell = neuron.h.bNAC219_L5_NGC_6186b7e85e(1 if add_synapses else 0)
     return cell
 
 
 def create_stimuli(cell, step_number):
     """Create the stimuli"""
 
-    print('Attaching stimulus electrodes')
+    print("Attaching stimulus electrodes")
 
     stimuli = []
     step_amp = [0] * 3
 
-    with open('current_amps.dat', 'r') as current_amps_file:
-        first_line = current_amps_file.read().split('\n')[0].strip()
-        hyp_amp, step_amp[0], step_amp[1], step_amp[2] = first_line.split(' ')
+    with open("current_amps.dat", "r") as current_amps_file:
+        first_line = current_amps_file.read().split("\n")[0].strip()
+        hyp_amp, step_amp[0], step_amp[1], step_amp[2] = first_line.split(" ")
 
     iclamp = neuron.h.IClamp(0.5, sec=cell.soma[0])
     iclamp.delay = 700
     iclamp.dur = 2000
     iclamp.amp = float(step_amp[step_number - 1])
-    print('Setting up step current clamp: '
-          'amp=%f nA, delay=%f ms, duration=%f ms' %
-          (iclamp.amp, iclamp.delay, iclamp.dur))
+    print(
+        "Setting up step current clamp: "
+        "amp=%f nA, delay=%f ms, duration=%f ms" % (iclamp.amp, iclamp.delay, iclamp.dur)
+    )
 
     stimuli.append(iclamp)
 
     hyp_iclamp = neuron.h.IClamp(0.5, sec=cell.soma[0])
     hyp_iclamp.delay = 0
     hyp_iclamp.dur = 3000
     hyp_iclamp.amp = float(hyp_amp)
-    print('Setting up hypamp current clamp: '
-          'amp=%f nA, delay=%f ms, duration=%f ms' %
-          (hyp_iclamp.amp, hyp_iclamp.delay, hyp_iclamp.dur))
+    print(
+        "Setting up hypamp current clamp: "
+        "amp=%f nA, delay=%f ms, duration=%f ms" % (hyp_iclamp.amp, hyp_iclamp.delay, hyp_iclamp.dur)
+    )
 
     stimuli.append(hyp_iclamp)
 
     return stimuli
 
 
 def create_recordings(cell):
     """Create the recordings"""
-    print('Attaching recording electrodes')
+    print("Attaching recording electrodes")
 
     recordings = {}
 
-    recordings['time'] = neuron.h.Vector()
-    recordings['soma(0.5)'] = neuron.h.Vector()
+    recordings["time"] = neuron.h.Vector()
+    recordings["soma(0.5)"] = neuron.h.Vector()
 
-    recordings['time'].record(neuron.h._ref_t, 0.1)
-    recordings['soma(0.5)'].record(cell.soma[0](0.5)._ref_v, 0.1)
+    recordings["time"].record(neuron.h._ref_t, 0.1)
+    recordings["soma(0.5)"].record(cell.soma[0](0.5)._ref_v, 0.1)
 
     return recordings
 
 
 def run_step(step_number, plot_traces=None):
     """Run step current simulation with index step_number"""
 
     cell = create_cell(add_synapses=False)
     stimuli = create_stimuli(cell, step_number)
     recordings = create_recordings(cell)
 
     # Overriding default 30s simulation,
-    print('Setting simulation time to 3s for the step currents')
+    print("Setting simulation time to 3s for the step currents")
     neuron.h.tstop = 3000
 
-    print('Disabling variable timestep integration')
+    print("Disabling variable timestep integration")
     neuron.h.cvode_active(0)
 
-    print('Running for %f ms' % neuron.h.tstop)
+    print("Running for %f ms" % neuron.h.tstop)
     neuron.h.run()
 
-    time = numpy.array(recordings['time'])
-    soma_voltage = numpy.array(recordings['soma(0.5)'])
+    time = numpy.array(recordings["time"])
+    soma_voltage = numpy.array(recordings["soma(0.5)"])
 
-    recordings_dir = 'python_recordings'
+    recordings_dir = "python_recordings"
 
-    soma_voltage_filename = os.path.join(
-        recordings_dir,
-        'soma_voltage_step%d.dat' % step_number)
-    numpy.savetxt(
-            soma_voltage_filename,
-            numpy.transpose(
-               numpy.vstack((
-                    time,
-                    soma_voltage))))
+    soma_voltage_filename = os.path.join(recordings_dir, "soma_voltage_step%d.dat" % step_number)
+    numpy.savetxt(soma_voltage_filename, numpy.transpose(numpy.vstack((time, soma_voltage))))
 
-    print('Soma voltage for step %d saved to: %s'
-          % (step_number, soma_voltage_filename))
+    print("Soma voltage for step %d saved to: %s" % (step_number, soma_voltage_filename))
 
     if plot_traces:
         import pylab
+
         pylab.figure()
-        pylab.plot(recordings['time'], recordings['soma(0.5)'])
-        pylab.xlabel('time (ms)')
-        pylab.ylabel('Vm (mV)')
-        pylab.gcf().canvas.set_window_title('Step %d' % step_number)
+        pylab.plot(recordings["time"], recordings["soma(0.5)"])
+        pylab.xlabel("time (ms)")
+        pylab.ylabel("Vm (mV)")
+        pylab.gcf().canvas.set_window_title("Step %d" % step_number)
 
 
 def init_simulation():
     """Initialise simulation environment"""
 
     neuron.h.load_file("stdrun.hoc")
     neuron.h.load_file("import3d.hoc")
 
-    print('Loading constants')
-    neuron.h.load_file('constants.hoc')
+    print("Loading constants")
+    neuron.h.load_file("constants.hoc")
 
 
 def main(plot_traces=True):
     """Main"""
 
     # Import matplotlib to plot the traces
     if plot_traces:
         import matplotlib
-        matplotlib.rcParams['path.simplify'] = False
+
+        matplotlib.rcParams["path.simplify"] = False
 
     init_simulation()
 
     for step_number in range(1, 4):
         run_step(step_number, plot_traces=plot_traces)
 
     if plot_traces:
         import pylab
+
         pylab.show()
 
-if __name__ == '__main__':
+
+if __name__ == "__main__":
     if len(sys.argv) == 1:
         main(plot_traces=True)
-    elif len(sys.argv) == 2 and sys.argv[1] == '--no-plots':
+    elif len(sys.argv) == 2 and sys.argv[1] == "--no-plots":
         main(plot_traces=False)
     else:
-        raise Exception(
-            "Script only accepts one argument: --no-plots, not %s" %
-            str(sys.argv))
+        raise Exception("Script only accepts one argument: --no-plots, not %s" % str(sys.argv))
```

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/run_RmpRiTau.py` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/run_RmpRiTau.py`

 * *Files 9% similar despite different names*

```diff
@@ -32,222 +32,201 @@
  * @author Werner Van Geit @ BBP
  * @date 2015
 """
 
 # pylint: disable=C0325, W0212, F0401, W0612, F0401
 
 import os
+import sys
+
 import neuron
 import numpy
-import sys
 
 
 def create_cell():
     """Create the cell model"""
     # Load morphology
     neuron.h.load_file("morphology.hoc")
     # Load biophysics
     neuron.h.load_file("biophysics.hoc")
     # Load main cell template
     neuron.h.load_file("template.hoc")
 
     # Instantiate the cell from the template
 
-    print("Loading cell bAC217_L5_LBC_c2cff91741")
-    cell = neuron.h.bAC217_L5_LBC_c2cff91741(0)
+    print("Loading cell bAC217_L5_BTC_160272643a")
+    cell = neuron.h.bAC217_L5_BTC_160272643a(0)
     return cell
 
 
 def create_stimuli(cell, stim_start, stim_end, current_amplitude):
     """Create the stimuli"""
 
-    print('Attaching stimulus electrodes')
+    print("Attaching stimulus electrodes")
 
     stimuli = []
 
     iclamp = neuron.h.IClamp(0.5, sec=cell.soma[0])
     iclamp.delay = stim_start
     iclamp.dur = stim_end - stim_start
     iclamp.amp = current_amplitude
-    print('Setting up step current clamp: '
-          'amp=%f nA, delay=%f ms, duration=%f ms' %
-          (iclamp.amp, iclamp.delay, iclamp.dur))
+    print(
+        "Setting up step current clamp: "
+        "amp=%f nA, delay=%f ms, duration=%f ms" % (iclamp.amp, iclamp.delay, iclamp.dur)
+    )
 
     stimuli.append(iclamp)
 
     return stimuli
 
 
 def create_recordings(cell):
     """Create the recordings"""
-    print('Attaching recording electrodes')
+    print("Attaching recording electrodes")
 
     recordings = {}
 
-    recordings['time'] = neuron.h.Vector()
-    recordings['soma(0.5)'] = neuron.h.Vector()
+    recordings["time"] = neuron.h.Vector()
+    recordings["soma(0.5)"] = neuron.h.Vector()
 
-    recordings['time'].record(neuron.h._ref_t, 0.1)
-    recordings['soma(0.5)'].record(cell.soma[0](0.5)._ref_v, 0.1)
+    recordings["time"].record(neuron.h._ref_t, 0.1)
+    recordings["soma(0.5)"].record(cell.soma[0](0.5)._ref_v, 0.1)
 
     return recordings
 
 
-def run_RmpRiTau_step(
-        stim_start,
-        stim_end,
-        current_amplitude,
-        plot_traces=None):
-    """Run """
+def run_RmpRiTau_step(stim_start, stim_end, current_amplitude, plot_traces=None):
+    """Run"""
 
     cell = create_cell()
     stimuli = create_stimuli(cell, stim_start, stim_end, current_amplitude)  # noqa
     recordings = create_recordings(cell)
 
     # Overriding default 30s simulation,
     neuron.h.tstop = stim_end + stim_start
-    print(
-        'Setting simulation time to %.6g ms for the step current' %
-        neuron.h.tstop)
+    print("Setting simulation time to %.6g ms for the step current" % neuron.h.tstop)
 
-    print('Setting initial voltage to -70 mV')
+    print("Setting initial voltage to -70 mV")
     neuron.h.v_init = -70
 
     neuron.h.stdinit()
     neuron.h.dt = 1000
     neuron.h.t = -1e9
     for _ in range(10):
         neuron.h.fadvance()
 
     neuron.h.t = 0
     neuron.h.dt = 0.025
     neuron.h.frecord_init()
 
     neuron.h.continuerun(3000)
 
-    time = numpy.array(recordings['time'])
-    soma_voltage = numpy.array(recordings['soma(0.5)'])
+    time = numpy.array(recordings["time"])
+    soma_voltage = numpy.array(recordings["soma(0.5)"])
 
-    recordings_dir = 'python_recordings'
+    recordings_dir = "python_recordings"
 
-    soma_voltage_filename = os.path.join(
-        recordings_dir,
-        'soma_voltage_RmpRiTau_step.dat')
+    soma_voltage_filename = os.path.join(recordings_dir, "soma_voltage_RmpRiTau_step.dat")
     numpy.savetxt(soma_voltage_filename, zip(time, soma_voltage))
 
-    print('Soma voltage for RmpRiTau trace saved to: %s'
-          % (soma_voltage_filename))
+    print("Soma voltage for RmpRiTau trace saved to: %s" % (soma_voltage_filename))
 
     if plot_traces:
         import pylab
-        pylab.figure(facecolor='white')
-        pylab.plot(recordings['time'], recordings['soma(0.5)'])
-        pylab.xlabel('time (ms)')
-        pylab.ylabel('Vm (mV)')
-        pylab.gcf().canvas.set_window_title('RmpRiTau trace')
+
+        pylab.figure(facecolor="white")
+        pylab.plot(recordings["time"], recordings["soma(0.5)"])
+        pylab.xlabel("time (ms)")
+        pylab.ylabel("Vm (mV)")
+        pylab.gcf().canvas.set_window_title("RmpRiTau trace")
 
     return time, soma_voltage, stim_start, stim_end
 
 
 def init_simulation():
     """Initialise simulation environment"""
 
     neuron.h.load_file("stdrun.hoc")
     neuron.h.load_file("import3d.hoc")
 
-    print('Loading constants')
-    neuron.h.load_file('constants.hoc')
+    print("Loading constants")
+    neuron.h.load_file("constants.hoc")
 
 
-def analyse_RmpRiTau_trace(
-        time,
-        soma_voltage,
-        stim_start,
-        stim_end,
-        current_amplitude):
+def analyse_RmpRiTau_trace(time, soma_voltage, stim_start, stim_end, current_amplitude):
     """Analyse the output of the RmpRiTau protocol"""
 
     # Import the eFeature Extraction Library
     import efel
 
     # Prepare the trace data
     trace = {}
-    trace['T'] = time
-    trace['V'] = soma_voltage
-    trace['stim_start'] = [stim_start]
-    trace['stim_end'] = [stim_end]
+    trace["T"] = time
+    trace["V"] = soma_voltage
+    trace["stim_start"] = [stim_start]
+    trace["stim_end"] = [stim_end]
 
     # Calculate the necessary eFeatures
     efel_results = efel.getFeatureValues(
-        [trace],
-        ['voltage_base', 'steady_state_voltage_stimend',
-         'decay_time_constant_after_stim'])
-
-    voltage_base = efel_results[0]['voltage_base'][0]
-    ss_voltage = efel_results[0]['steady_state_voltage_stimend'][0]
-    dct = efel_results[0]['decay_time_constant_after_stim'][0]
+        [trace], ["voltage_base", "steady_state_voltage_stimend", "decay_time_constant_after_stim"]
+    )
+
+    voltage_base = efel_results[0]["voltage_base"][0]
+    ss_voltage = efel_results[0]["steady_state_voltage_stimend"][0]
+    dct = efel_results[0]["decay_time_constant_after_stim"][0]
 
     # Calculate input resistance
     input_resistance = float(ss_voltage - voltage_base) / current_amplitude
 
     rmpritau_dict = {}
 
-    rmpritau_dict['Rmp'] = '%.6g' % voltage_base
-    rmpritau_dict['Rmp_Units'] = 'mV'
-    rmpritau_dict['Rin'] = '%.6g' % input_resistance
-    rmpritau_dict['Rin_Units'] = 'MOhm'
-    rmpritau_dict['Tau'] = '%.6g' % dct
-    rmpritau_dict['Tau_Units'] = 'ms'
-
-    print('Resting membrane potential is %s %s' %
-          (rmpritau_dict['Rmp'], rmpritau_dict['Rmp_Units']))
-    print('Input resistance is %s %s' %
-          (rmpritau_dict['Rin'], rmpritau_dict['Rin_Units']))
-    print('Time constant is %s %s' %
-          (rmpritau_dict['Tau'], rmpritau_dict['Tau_Units']))
+    rmpritau_dict["Rmp"] = "%.6g" % voltage_base
+    rmpritau_dict["Rmp_Units"] = "mV"
+    rmpritau_dict["Rin"] = "%.6g" % input_resistance
+    rmpritau_dict["Rin_Units"] = "MOhm"
+    rmpritau_dict["Tau"] = "%.6g" % dct
+    rmpritau_dict["Tau_Units"] = "ms"
+
+    print("Resting membrane potential is %s %s" % (rmpritau_dict["Rmp"], rmpritau_dict["Rmp_Units"]))
+    print("Input resistance is %s %s" % (rmpritau_dict["Rin"], rmpritau_dict["Rin_Units"]))
+    print("Time constant is %s %s" % (rmpritau_dict["Tau"], rmpritau_dict["Tau_Units"]))
 
     import json
 
-    with open('rmp_ri_tau.json', 'w') as rmpritau_json_file:
-        json.dump(rmpritau_dict, rmpritau_json_file,
-                        sort_keys=True,
-                        indent=4,
-                        separators=(',', ': '))
+    with open("rmp_ri_tau.json", "w") as rmpritau_json_file:
+        json.dump(rmpritau_dict, rmpritau_json_file, sort_keys=True, indent=4, separators=(",", ": "))
 
 
 def main(plot_traces=False):
     """Main"""
 
     # Import matplotlib to plot the traces
     if plot_traces:
         import matplotlib
-        matplotlib.rcParams['path.simplify'] = False
+
+        matplotlib.rcParams["path.simplify"] = False
 
     init_simulation()
 
     current_amplitude = -0.01
     stim_start = 1000
     stim_end = 2000
 
     time, soma_voltage, stim_start, stim_end = run_RmpRiTau_step(
-        stim_start, stim_end, current_amplitude, plot_traces=plot_traces)
+        stim_start, stim_end, current_amplitude, plot_traces=plot_traces
+    )
 
-    analyse_RmpRiTau_trace(
-        time,
-        soma_voltage,
-        stim_start,
-        stim_end,
-        current_amplitude)
+    analyse_RmpRiTau_trace(time, soma_voltage, stim_start, stim_end, current_amplitude)
 
     if plot_traces:
         import pylab
+
         pylab.show()
 
-if __name__ == '__main__':
+
+if __name__ == "__main__":
     if len(sys.argv) == 1:
         main(plot_traces=True)
-    elif len(sys.argv) == 2 and sys.argv[1] == '--no-plots':
+    elif len(sys.argv) == 2 and sys.argv[1] == "--no-plots":
         main(plot_traces=False)
     else:
-        raise Exception(
-            "Script only accepts one argument: --no-plots, not %s" %
-            str(sys.argv))
+        raise Exception("Script only accepts one argument: --no-plots, not %s" % str(sys.argv))
```

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/synapses/mtype_map.tsv` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/synapses/mtype_map.tsv`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/synapses/synapses.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/synapses/synapses.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/synapses/synapses.tsv` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/synapses/synapses.tsv`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/synapses/synconf.txt` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/synapses/synconf.txt`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_LBC_bAC217_1/template.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/template.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/LICENSE` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/LICENSE`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/README` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/README`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/biophysics.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/biophysics.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/constants.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/constants.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/creategui.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/creategui.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/createsimulation.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/createsimulation.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/init.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/init.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/Ca.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/Ca.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/CaDynamics_E2.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/CaDynamics_E2.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/Ca_LVAst.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/Ca_LVAst.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/Ih.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/Ih.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/Im.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/Im.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/K_Pst.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/K_Pst.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/K_Tst.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/K_Tst.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/NaTa_t.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/NaTa_t.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/NaTs2_t.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/NaTs2_t.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/Nap_Et2.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/Nap_Et2.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/ProbAMPANMDA_EMS.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/ProbAMPANMDA_EMS.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/ProbGABAAB_EMS.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/ProbGABAAB_EMS.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/SK_E2.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/SK_E2.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/SKv3_1.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/mechanisms/SKv3_1.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/morphology/C040601.asc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/morphology/C040601.asc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/morphology.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/morphology.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/mosinit.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/mosinit.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/ringplot.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/ringplot.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/run.py` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BP_bAC217_1/run.py`

 * *Files 6% similar despite different names*

```diff
@@ -32,158 +32,155 @@
  * @author Werner Van Geit @ BBP
  * @date 2015
 """
 
 # pylint: disable=C0325, W0212, F0401, W0612, F0401
 
 import os
+import sys
+
 import neuron
 import numpy
-import sys
 
 
 def create_cell(add_synapses=True):
     """Create the cell model"""
     # Load morphology
     neuron.h.load_file("morphology.hoc")
     # Load biophysics
     neuron.h.load_file("biophysics.hoc")
     # Load main cell template
     neuron.h.load_file("template.hoc")
 
     # Instantiate the cell from the template
 
-    print("Loading cell bAC217_L5_MC_cc2a170ef6")
-    cell = neuron.h.bAC217_L5_MC_cc2a170ef6(1 if add_synapses else 0)
+    print("Loading cell bAC217_L5_BP_d0cc8d7615")
+    cell = neuron.h.bAC217_L5_BP_d0cc8d7615(1 if add_synapses else 0)
     return cell
 
 
 def create_stimuli(cell, step_number):
     """Create the stimuli"""
 
-    print('Attaching stimulus electrodes')
+    print("Attaching stimulus electrodes")
 
     stimuli = []
     step_amp = [0] * 3
 
-    with open('current_amps.dat', 'r') as current_amps_file:
-        first_line = current_amps_file.read().split('\n')[0].strip()
-        hyp_amp, step_amp[0], step_amp[1], step_amp[2] = first_line.split(' ')
+    with open("current_amps.dat", "r") as current_amps_file:
+        first_line = current_amps_file.read().split("\n")[0].strip()
+        hyp_amp, step_amp[0], step_amp[1], step_amp[2] = first_line.split(" ")
 
     iclamp = neuron.h.IClamp(0.5, sec=cell.soma[0])
     iclamp.delay = 700
     iclamp.dur = 2000
     iclamp.amp = float(step_amp[step_number - 1])
-    print('Setting up step current clamp: '
-          'amp=%f nA, delay=%f ms, duration=%f ms' %
-          (iclamp.amp, iclamp.delay, iclamp.dur))
+    print(
+        "Setting up step current clamp: "
+        "amp=%f nA, delay=%f ms, duration=%f ms" % (iclamp.amp, iclamp.delay, iclamp.dur)
+    )
 
     stimuli.append(iclamp)
 
     hyp_iclamp = neuron.h.IClamp(0.5, sec=cell.soma[0])
     hyp_iclamp.delay = 0
     hyp_iclamp.dur = 3000
     hyp_iclamp.amp = float(hyp_amp)
-    print('Setting up hypamp current clamp: '
-          'amp=%f nA, delay=%f ms, duration=%f ms' %
-          (hyp_iclamp.amp, hyp_iclamp.delay, hyp_iclamp.dur))
+    print(
+        "Setting up hypamp current clamp: "
+        "amp=%f nA, delay=%f ms, duration=%f ms" % (hyp_iclamp.amp, hyp_iclamp.delay, hyp_iclamp.dur)
+    )
 
     stimuli.append(hyp_iclamp)
 
     return stimuli
 
 
 def create_recordings(cell):
     """Create the recordings"""
-    print('Attaching recording electrodes')
+    print("Attaching recording electrodes")
 
     recordings = {}
 
-    recordings['time'] = neuron.h.Vector()
-    recordings['soma(0.5)'] = neuron.h.Vector()
+    recordings["time"] = neuron.h.Vector()
+    recordings["soma(0.5)"] = neuron.h.Vector()
 
-    recordings['time'].record(neuron.h._ref_t, 0.1)
-    recordings['soma(0.5)'].record(cell.soma[0](0.5)._ref_v, 0.1)
+    recordings["time"].record(neuron.h._ref_t, 0.1)
+    recordings["soma(0.5)"].record(cell.soma[0](0.5)._ref_v, 0.1)
 
     return recordings
 
 
 def run_step(step_number, plot_traces=None):
     """Run step current simulation with index step_number"""
 
     cell = create_cell(add_synapses=False)
     stimuli = create_stimuli(cell, step_number)
     recordings = create_recordings(cell)
 
     # Overriding default 30s simulation,
-    print('Setting simulation time to 3s for the step currents')
+    print("Setting simulation time to 3s for the step currents")
     neuron.h.tstop = 3000
 
-    print('Disabling variable timestep integration')
+    print("Disabling variable timestep integration")
     neuron.h.cvode_active(0)
 
-    print('Running for %f ms' % neuron.h.tstop)
+    print("Running for %f ms" % neuron.h.tstop)
     neuron.h.run()
 
-    time = numpy.array(recordings['time'])
-    soma_voltage = numpy.array(recordings['soma(0.5)'])
+    time = numpy.array(recordings["time"])
+    soma_voltage = numpy.array(recordings["soma(0.5)"])
 
-    recordings_dir = 'python_recordings'
+    recordings_dir = "python_recordings"
 
-    soma_voltage_filename = os.path.join(
-        recordings_dir,
-        'soma_voltage_step%d.dat' % step_number)
-    numpy.savetxt(
-            soma_voltage_filename,
-            numpy.transpose(
-               numpy.vstack((
-                    time,
-                    soma_voltage))))
+    soma_voltage_filename = os.path.join(recordings_dir, "soma_voltage_step%d.dat" % step_number)
+    numpy.savetxt(soma_voltage_filename, numpy.transpose(numpy.vstack((time, soma_voltage))))
 
-    print('Soma voltage for step %d saved to: %s'
-          % (step_number, soma_voltage_filename))
+    print("Soma voltage for step %d saved to: %s" % (step_number, soma_voltage_filename))
 
     if plot_traces:
         import pylab
+
         pylab.figure()
-        pylab.plot(recordings['time'], recordings['soma(0.5)'])
-        pylab.xlabel('time (ms)')
-        pylab.ylabel('Vm (mV)')
-        pylab.gcf().canvas.set_window_title('Step %d' % step_number)
+        pylab.plot(recordings["time"], recordings["soma(0.5)"])
+        pylab.xlabel("time (ms)")
+        pylab.ylabel("Vm (mV)")
+        pylab.gcf().canvas.set_window_title("Step %d" % step_number)
 
 
 def init_simulation():
     """Initialise simulation environment"""
 
     neuron.h.load_file("stdrun.hoc")
     neuron.h.load_file("import3d.hoc")
 
-    print('Loading constants')
-    neuron.h.load_file('constants.hoc')
+    print("Loading constants")
+    neuron.h.load_file("constants.hoc")
 
 
 def main(plot_traces=True):
     """Main"""
 
     # Import matplotlib to plot the traces
     if plot_traces:
         import matplotlib
-        matplotlib.rcParams['path.simplify'] = False
+
+        matplotlib.rcParams["path.simplify"] = False
 
     init_simulation()
 
     for step_number in range(1, 4):
         run_step(step_number, plot_traces=plot_traces)
 
     if plot_traces:
         import pylab
+
         pylab.show()
 
-if __name__ == '__main__':
+
+if __name__ == "__main__":
     if len(sys.argv) == 1:
         main(plot_traces=True)
-    elif len(sys.argv) == 2 and sys.argv[1] == '--no-plots':
+    elif len(sys.argv) == 2 and sys.argv[1] == "--no-plots":
         main(plot_traces=False)
     else:
-        raise Exception(
-            "Script only accepts one argument: --no-plots, not %s" %
-            str(sys.argv))
+        raise Exception("Script only accepts one argument: --no-plots, not %s" % str(sys.argv))
```

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/run_RmpRiTau.py` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/run_RmpRiTau.py`

 * *Files 10% similar despite different names*

```diff
@@ -32,222 +32,201 @@
  * @author Werner Van Geit @ BBP
  * @date 2015
 """
 
 # pylint: disable=C0325, W0212, F0401, W0612, F0401
 
 import os
+import sys
+
 import neuron
 import numpy
-import sys
 
 
 def create_cell():
     """Create the cell model"""
     # Load morphology
     neuron.h.load_file("morphology.hoc")
     # Load biophysics
     neuron.h.load_file("biophysics.hoc")
     # Load main cell template
     neuron.h.load_file("template.hoc")
 
     # Instantiate the cell from the template
 
-    print("Loading cell bAC217_L5_MC_cc2a170ef6")
-    cell = neuron.h.bAC217_L5_MC_cc2a170ef6(0)
+    print("Loading cell cADpyr232_L5_TTPC2_8052133265")
+    cell = neuron.h.cADpyr232_L5_TTPC2_8052133265(0)
     return cell
 
 
 def create_stimuli(cell, stim_start, stim_end, current_amplitude):
     """Create the stimuli"""
 
-    print('Attaching stimulus electrodes')
+    print("Attaching stimulus electrodes")
 
     stimuli = []
 
     iclamp = neuron.h.IClamp(0.5, sec=cell.soma[0])
     iclamp.delay = stim_start
     iclamp.dur = stim_end - stim_start
     iclamp.amp = current_amplitude
-    print('Setting up step current clamp: '
-          'amp=%f nA, delay=%f ms, duration=%f ms' %
-          (iclamp.amp, iclamp.delay, iclamp.dur))
+    print(
+        "Setting up step current clamp: "
+        "amp=%f nA, delay=%f ms, duration=%f ms" % (iclamp.amp, iclamp.delay, iclamp.dur)
+    )
 
     stimuli.append(iclamp)
 
     return stimuli
 
 
 def create_recordings(cell):
     """Create the recordings"""
-    print('Attaching recording electrodes')
+    print("Attaching recording electrodes")
 
     recordings = {}
 
-    recordings['time'] = neuron.h.Vector()
-    recordings['soma(0.5)'] = neuron.h.Vector()
+    recordings["time"] = neuron.h.Vector()
+    recordings["soma(0.5)"] = neuron.h.Vector()
 
-    recordings['time'].record(neuron.h._ref_t, 0.1)
-    recordings['soma(0.5)'].record(cell.soma[0](0.5)._ref_v, 0.1)
+    recordings["time"].record(neuron.h._ref_t, 0.1)
+    recordings["soma(0.5)"].record(cell.soma[0](0.5)._ref_v, 0.1)
 
     return recordings
 
 
-def run_RmpRiTau_step(
-        stim_start,
-        stim_end,
-        current_amplitude,
-        plot_traces=None):
-    """Run """
+def run_RmpRiTau_step(stim_start, stim_end, current_amplitude, plot_traces=None):
+    """Run"""
 
     cell = create_cell()
     stimuli = create_stimuli(cell, stim_start, stim_end, current_amplitude)  # noqa
     recordings = create_recordings(cell)
 
     # Overriding default 30s simulation,
     neuron.h.tstop = stim_end + stim_start
-    print(
-        'Setting simulation time to %.6g ms for the step current' %
-        neuron.h.tstop)
+    print("Setting simulation time to %.6g ms for the step current" % neuron.h.tstop)
 
-    print('Setting initial voltage to -70 mV')
+    print("Setting initial voltage to -70 mV")
     neuron.h.v_init = -70
 
     neuron.h.stdinit()
     neuron.h.dt = 1000
     neuron.h.t = -1e9
     for _ in range(10):
         neuron.h.fadvance()
 
     neuron.h.t = 0
     neuron.h.dt = 0.025
     neuron.h.frecord_init()
 
     neuron.h.continuerun(3000)
 
-    time = numpy.array(recordings['time'])
-    soma_voltage = numpy.array(recordings['soma(0.5)'])
+    time = numpy.array(recordings["time"])
+    soma_voltage = numpy.array(recordings["soma(0.5)"])
 
-    recordings_dir = 'python_recordings'
+    recordings_dir = "python_recordings"
 
-    soma_voltage_filename = os.path.join(
-        recordings_dir,
-        'soma_voltage_RmpRiTau_step.dat')
+    soma_voltage_filename = os.path.join(recordings_dir, "soma_voltage_RmpRiTau_step.dat")
     numpy.savetxt(soma_voltage_filename, zip(time, soma_voltage))
 
-    print('Soma voltage for RmpRiTau trace saved to: %s'
-          % (soma_voltage_filename))
+    print("Soma voltage for RmpRiTau trace saved to: %s" % (soma_voltage_filename))
 
     if plot_traces:
         import pylab
-        pylab.figure(facecolor='white')
-        pylab.plot(recordings['time'], recordings['soma(0.5)'])
-        pylab.xlabel('time (ms)')
-        pylab.ylabel('Vm (mV)')
-        pylab.gcf().canvas.set_window_title('RmpRiTau trace')
+
+        pylab.figure(facecolor="white")
+        pylab.plot(recordings["time"], recordings["soma(0.5)"])
+        pylab.xlabel("time (ms)")
+        pylab.ylabel("Vm (mV)")
+        pylab.gcf().canvas.set_window_title("RmpRiTau trace")
 
     return time, soma_voltage, stim_start, stim_end
 
 
 def init_simulation():
     """Initialise simulation environment"""
 
     neuron.h.load_file("stdrun.hoc")
     neuron.h.load_file("import3d.hoc")
 
-    print('Loading constants')
-    neuron.h.load_file('constants.hoc')
+    print("Loading constants")
+    neuron.h.load_file("constants.hoc")
 
 
-def analyse_RmpRiTau_trace(
-        time,
-        soma_voltage,
-        stim_start,
-        stim_end,
-        current_amplitude):
+def analyse_RmpRiTau_trace(time, soma_voltage, stim_start, stim_end, current_amplitude):
     """Analyse the output of the RmpRiTau protocol"""
 
     # Import the eFeature Extraction Library
     import efel
 
     # Prepare the trace data
     trace = {}
-    trace['T'] = time
-    trace['V'] = soma_voltage
-    trace['stim_start'] = [stim_start]
-    trace['stim_end'] = [stim_end]
+    trace["T"] = time
+    trace["V"] = soma_voltage
+    trace["stim_start"] = [stim_start]
+    trace["stim_end"] = [stim_end]
 
     # Calculate the necessary eFeatures
     efel_results = efel.getFeatureValues(
-        [trace],
-        ['voltage_base', 'steady_state_voltage_stimend',
-         'decay_time_constant_after_stim'])
-
-    voltage_base = efel_results[0]['voltage_base'][0]
-    ss_voltage = efel_results[0]['steady_state_voltage_stimend'][0]
-    dct = efel_results[0]['decay_time_constant_after_stim'][0]
+        [trace], ["voltage_base", "steady_state_voltage_stimend", "decay_time_constant_after_stim"]
+    )
+
+    voltage_base = efel_results[0]["voltage_base"][0]
+    ss_voltage = efel_results[0]["steady_state_voltage_stimend"][0]
+    dct = efel_results[0]["decay_time_constant_after_stim"][0]
 
     # Calculate input resistance
     input_resistance = float(ss_voltage - voltage_base) / current_amplitude
 
     rmpritau_dict = {}
 
-    rmpritau_dict['Rmp'] = '%.6g' % voltage_base
-    rmpritau_dict['Rmp_Units'] = 'mV'
-    rmpritau_dict['Rin'] = '%.6g' % input_resistance
-    rmpritau_dict['Rin_Units'] = 'MOhm'
-    rmpritau_dict['Tau'] = '%.6g' % dct
-    rmpritau_dict['Tau_Units'] = 'ms'
-
-    print('Resting membrane potential is %s %s' %
-          (rmpritau_dict['Rmp'], rmpritau_dict['Rmp_Units']))
-    print('Input resistance is %s %s' %
-          (rmpritau_dict['Rin'], rmpritau_dict['Rin_Units']))
-    print('Time constant is %s %s' %
-          (rmpritau_dict['Tau'], rmpritau_dict['Tau_Units']))
+    rmpritau_dict["Rmp"] = "%.6g" % voltage_base
+    rmpritau_dict["Rmp_Units"] = "mV"
+    rmpritau_dict["Rin"] = "%.6g" % input_resistance
+    rmpritau_dict["Rin_Units"] = "MOhm"
+    rmpritau_dict["Tau"] = "%.6g" % dct
+    rmpritau_dict["Tau_Units"] = "ms"
+
+    print("Resting membrane potential is %s %s" % (rmpritau_dict["Rmp"], rmpritau_dict["Rmp_Units"]))
+    print("Input resistance is %s %s" % (rmpritau_dict["Rin"], rmpritau_dict["Rin_Units"]))
+    print("Time constant is %s %s" % (rmpritau_dict["Tau"], rmpritau_dict["Tau_Units"]))
 
     import json
 
-    with open('rmp_ri_tau.json', 'w') as rmpritau_json_file:
-        json.dump(rmpritau_dict, rmpritau_json_file,
-                        sort_keys=True,
-                        indent=4,
-                        separators=(',', ': '))
+    with open("rmp_ri_tau.json", "w") as rmpritau_json_file:
+        json.dump(rmpritau_dict, rmpritau_json_file, sort_keys=True, indent=4, separators=(",", ": "))
 
 
 def main(plot_traces=False):
     """Main"""
 
     # Import matplotlib to plot the traces
     if plot_traces:
         import matplotlib
-        matplotlib.rcParams['path.simplify'] = False
+
+        matplotlib.rcParams["path.simplify"] = False
 
     init_simulation()
 
     current_amplitude = -0.01
     stim_start = 1000
     stim_end = 2000
 
     time, soma_voltage, stim_start, stim_end = run_RmpRiTau_step(
-        stim_start, stim_end, current_amplitude, plot_traces=plot_traces)
+        stim_start, stim_end, current_amplitude, plot_traces=plot_traces
+    )
 
-    analyse_RmpRiTau_trace(
-        time,
-        soma_voltage,
-        stim_start,
-        stim_end,
-        current_amplitude)
+    analyse_RmpRiTau_trace(time, soma_voltage, stim_start, stim_end, current_amplitude)
 
     if plot_traces:
         import pylab
+
         pylab.show()
 
-if __name__ == '__main__':
+
+if __name__ == "__main__":
     if len(sys.argv) == 1:
         main(plot_traces=True)
-    elif len(sys.argv) == 2 and sys.argv[1] == '--no-plots':
+    elif len(sys.argv) == 2 and sys.argv[1] == "--no-plots":
         main(plot_traces=False)
     else:
-        raise Exception(
-            "Script only accepts one argument: --no-plots, not %s" %
-            str(sys.argv))
+        raise Exception("Script only accepts one argument: --no-plots, not %s" % str(sys.argv))
```

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/synapses/mtype_map.tsv` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/synapses/mtype_map.tsv`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/synapses/synapses.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/synapses/synapses.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/synapses/synapses.tsv` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/synapses/synapses.tsv`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/synapses/synconf.txt` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/synapses/synconf.txt`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_MC_bAC217_1/template.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/template.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/LICENSE` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/LICENSE`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/README` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/README`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/biophysics.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/biophysics.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/constants.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/constants.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/creategui.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/creategui.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/createsimulation.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/createsimulation.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/init.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/init.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/Ca.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/Ca.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/CaDynamics_E2.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/CaDynamics_E2.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/Ca_LVAst.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/Ca_LVAst.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/Ih.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/Ih.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/Im.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/Im.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/K_Pst.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/K_Pst.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/K_Tst.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/K_Tst.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/NaTa_t.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/NaTa_t.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/NaTs2_t.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/NaTs2_t.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/Nap_Et2.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/Nap_Et2.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/ProbAMPANMDA_EMS.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/ProbAMPANMDA_EMS.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/ProbGABAAB_EMS.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/ProbGABAAB_EMS.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/SK_E2.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/SK_E2.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/SKv3_1.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mechanisms/SKv3_1.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/morphology/C080301B1_-_Scale_x1.000_y1.050_z1.000_-_Clone_2.asc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/morphology/C080301B1_-_Scale_x1.000_y1.050_z1.000_-_Clone_2.asc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/morphology.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/morphology.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mosinit.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/mosinit.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/ringplot.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/ringplot.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/run.py` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_BTC_bAC217_1/run.py`

 * *Files 7% similar despite different names*

```diff
@@ -32,158 +32,155 @@
  * @author Werner Van Geit @ BBP
  * @date 2015
 """
 
 # pylint: disable=C0325, W0212, F0401, W0612, F0401
 
 import os
+import sys
+
 import neuron
 import numpy
-import sys
 
 
 def create_cell(add_synapses=True):
     """Create the cell model"""
     # Load morphology
     neuron.h.load_file("morphology.hoc")
     # Load biophysics
     neuron.h.load_file("biophysics.hoc")
     # Load main cell template
     neuron.h.load_file("template.hoc")
 
     # Instantiate the cell from the template
 
-    print("Loading cell bAC217_L5_NBC_2db880c523")
-    cell = neuron.h.bAC217_L5_NBC_2db880c523(1 if add_synapses else 0)
+    print("Loading cell bAC217_L5_BTC_160272643a")
+    cell = neuron.h.bAC217_L5_BTC_160272643a(1 if add_synapses else 0)
     return cell
 
 
 def create_stimuli(cell, step_number):
     """Create the stimuli"""
 
-    print('Attaching stimulus electrodes')
+    print("Attaching stimulus electrodes")
 
     stimuli = []
     step_amp = [0] * 3
 
-    with open('current_amps.dat', 'r') as current_amps_file:
-        first_line = current_amps_file.read().split('\n')[0].strip()
-        hyp_amp, step_amp[0], step_amp[1], step_amp[2] = first_line.split(' ')
+    with open("current_amps.dat", "r") as current_amps_file:
+        first_line = current_amps_file.read().split("\n")[0].strip()
+        hyp_amp, step_amp[0], step_amp[1], step_amp[2] = first_line.split(" ")
 
     iclamp = neuron.h.IClamp(0.5, sec=cell.soma[0])
     iclamp.delay = 700
     iclamp.dur = 2000
     iclamp.amp = float(step_amp[step_number - 1])
-    print('Setting up step current clamp: '
-          'amp=%f nA, delay=%f ms, duration=%f ms' %
-          (iclamp.amp, iclamp.delay, iclamp.dur))
+    print(
+        "Setting up step current clamp: "
+        "amp=%f nA, delay=%f ms, duration=%f ms" % (iclamp.amp, iclamp.delay, iclamp.dur)
+    )
 
     stimuli.append(iclamp)
 
     hyp_iclamp = neuron.h.IClamp(0.5, sec=cell.soma[0])
     hyp_iclamp.delay = 0
     hyp_iclamp.dur = 3000
     hyp_iclamp.amp = float(hyp_amp)
-    print('Setting up hypamp current clamp: '
-          'amp=%f nA, delay=%f ms, duration=%f ms' %
-          (hyp_iclamp.amp, hyp_iclamp.delay, hyp_iclamp.dur))
+    print(
+        "Setting up hypamp current clamp: "
+        "amp=%f nA, delay=%f ms, duration=%f ms" % (hyp_iclamp.amp, hyp_iclamp.delay, hyp_iclamp.dur)
+    )
 
     stimuli.append(hyp_iclamp)
 
     return stimuli
 
 
 def create_recordings(cell):
     """Create the recordings"""
-    print('Attaching recording electrodes')
+    print("Attaching recording electrodes")
 
     recordings = {}
 
-    recordings['time'] = neuron.h.Vector()
-    recordings['soma(0.5)'] = neuron.h.Vector()
+    recordings["time"] = neuron.h.Vector()
+    recordings["soma(0.5)"] = neuron.h.Vector()
 
-    recordings['time'].record(neuron.h._ref_t, 0.1)
-    recordings['soma(0.5)'].record(cell.soma[0](0.5)._ref_v, 0.1)
+    recordings["time"].record(neuron.h._ref_t, 0.1)
+    recordings["soma(0.5)"].record(cell.soma[0](0.5)._ref_v, 0.1)
 
     return recordings
 
 
 def run_step(step_number, plot_traces=None):
     """Run step current simulation with index step_number"""
 
     cell = create_cell(add_synapses=False)
     stimuli = create_stimuli(cell, step_number)
     recordings = create_recordings(cell)
 
     # Overriding default 30s simulation,
-    print('Setting simulation time to 3s for the step currents')
+    print("Setting simulation time to 3s for the step currents")
     neuron.h.tstop = 3000
 
-    print('Disabling variable timestep integration')
+    print("Disabling variable timestep integration")
     neuron.h.cvode_active(0)
 
-    print('Running for %f ms' % neuron.h.tstop)
+    print("Running for %f ms" % neuron.h.tstop)
     neuron.h.run()
 
-    time = numpy.array(recordings['time'])
-    soma_voltage = numpy.array(recordings['soma(0.5)'])
+    time = numpy.array(recordings["time"])
+    soma_voltage = numpy.array(recordings["soma(0.5)"])
 
-    recordings_dir = 'python_recordings'
+    recordings_dir = "python_recordings"
 
-    soma_voltage_filename = os.path.join(
-        recordings_dir,
-        'soma_voltage_step%d.dat' % step_number)
-    numpy.savetxt(
-            soma_voltage_filename,
-            numpy.transpose(
-               numpy.vstack((
-                    time,
-                    soma_voltage))))
+    soma_voltage_filename = os.path.join(recordings_dir, "soma_voltage_step%d.dat" % step_number)
+    numpy.savetxt(soma_voltage_filename, numpy.transpose(numpy.vstack((time, soma_voltage))))
 
-    print('Soma voltage for step %d saved to: %s'
-          % (step_number, soma_voltage_filename))
+    print("Soma voltage for step %d saved to: %s" % (step_number, soma_voltage_filename))
 
     if plot_traces:
         import pylab
+
         pylab.figure()
-        pylab.plot(recordings['time'], recordings['soma(0.5)'])
-        pylab.xlabel('time (ms)')
-        pylab.ylabel('Vm (mV)')
-        pylab.gcf().canvas.set_window_title('Step %d' % step_number)
+        pylab.plot(recordings["time"], recordings["soma(0.5)"])
+        pylab.xlabel("time (ms)")
+        pylab.ylabel("Vm (mV)")
+        pylab.gcf().canvas.set_window_title("Step %d" % step_number)
 
 
 def init_simulation():
     """Initialise simulation environment"""
 
     neuron.h.load_file("stdrun.hoc")
     neuron.h.load_file("import3d.hoc")
 
-    print('Loading constants')
-    neuron.h.load_file('constants.hoc')
+    print("Loading constants")
+    neuron.h.load_file("constants.hoc")
 
 
 def main(plot_traces=True):
     """Main"""
 
     # Import matplotlib to plot the traces
     if plot_traces:
         import matplotlib
-        matplotlib.rcParams['path.simplify'] = False
+
+        matplotlib.rcParams["path.simplify"] = False
 
     init_simulation()
 
     for step_number in range(1, 4):
         run_step(step_number, plot_traces=plot_traces)
 
     if plot_traces:
         import pylab
+
         pylab.show()
 
-if __name__ == '__main__':
+
+if __name__ == "__main__":
     if len(sys.argv) == 1:
         main(plot_traces=True)
-    elif len(sys.argv) == 2 and sys.argv[1] == '--no-plots':
+    elif len(sys.argv) == 2 and sys.argv[1] == "--no-plots":
         main(plot_traces=False)
     else:
-        raise Exception(
-            "Script only accepts one argument: --no-plots, not %s" %
-            str(sys.argv))
+        raise Exception("Script only accepts one argument: --no-plots, not %s" % str(sys.argv))
```

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/run_RmpRiTau.py` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_ChC_cACint209_1/run_RmpRiTau.py`

 * *Files 10% similar despite different names*

```diff
@@ -32,222 +32,201 @@
  * @author Werner Van Geit @ BBP
  * @date 2015
 """
 
 # pylint: disable=C0325, W0212, F0401, W0612, F0401
 
 import os
+import sys
+
 import neuron
 import numpy
-import sys
 
 
 def create_cell():
     """Create the cell model"""
     # Load morphology
     neuron.h.load_file("morphology.hoc")
     # Load biophysics
     neuron.h.load_file("biophysics.hoc")
     # Load main cell template
     neuron.h.load_file("template.hoc")
 
     # Instantiate the cell from the template
 
-    print("Loading cell bAC217_L5_NBC_2db880c523")
-    cell = neuron.h.bAC217_L5_NBC_2db880c523(0)
+    print("Loading cell cACint209_L5_ChC_e98f63217d")
+    cell = neuron.h.cACint209_L5_ChC_e98f63217d(0)
     return cell
 
 
 def create_stimuli(cell, stim_start, stim_end, current_amplitude):
     """Create the stimuli"""
 
-    print('Attaching stimulus electrodes')
+    print("Attaching stimulus electrodes")
 
     stimuli = []
 
     iclamp = neuron.h.IClamp(0.5, sec=cell.soma[0])
     iclamp.delay = stim_start
     iclamp.dur = stim_end - stim_start
     iclamp.amp = current_amplitude
-    print('Setting up step current clamp: '
-          'amp=%f nA, delay=%f ms, duration=%f ms' %
-          (iclamp.amp, iclamp.delay, iclamp.dur))
+    print(
+        "Setting up step current clamp: "
+        "amp=%f nA, delay=%f ms, duration=%f ms" % (iclamp.amp, iclamp.delay, iclamp.dur)
+    )
 
     stimuli.append(iclamp)
 
     return stimuli
 
 
 def create_recordings(cell):
     """Create the recordings"""
-    print('Attaching recording electrodes')
+    print("Attaching recording electrodes")
 
     recordings = {}
 
-    recordings['time'] = neuron.h.Vector()
-    recordings['soma(0.5)'] = neuron.h.Vector()
+    recordings["time"] = neuron.h.Vector()
+    recordings["soma(0.5)"] = neuron.h.Vector()
 
-    recordings['time'].record(neuron.h._ref_t, 0.1)
-    recordings['soma(0.5)'].record(cell.soma[0](0.5)._ref_v, 0.1)
+    recordings["time"].record(neuron.h._ref_t, 0.1)
+    recordings["soma(0.5)"].record(cell.soma[0](0.5)._ref_v, 0.1)
 
     return recordings
 
 
-def run_RmpRiTau_step(
-        stim_start,
-        stim_end,
-        current_amplitude,
-        plot_traces=None):
-    """Run """
+def run_RmpRiTau_step(stim_start, stim_end, current_amplitude, plot_traces=None):
+    """Run"""
 
     cell = create_cell()
     stimuli = create_stimuli(cell, stim_start, stim_end, current_amplitude)  # noqa
     recordings = create_recordings(cell)
 
     # Overriding default 30s simulation,
     neuron.h.tstop = stim_end + stim_start
-    print(
-        'Setting simulation time to %.6g ms for the step current' %
-        neuron.h.tstop)
+    print("Setting simulation time to %.6g ms for the step current" % neuron.h.tstop)
 
-    print('Setting initial voltage to -70 mV')
+    print("Setting initial voltage to -70 mV")
     neuron.h.v_init = -70
 
     neuron.h.stdinit()
     neuron.h.dt = 1000
     neuron.h.t = -1e9
     for _ in range(10):
         neuron.h.fadvance()
 
     neuron.h.t = 0
     neuron.h.dt = 0.025
     neuron.h.frecord_init()
 
     neuron.h.continuerun(3000)
 
-    time = numpy.array(recordings['time'])
-    soma_voltage = numpy.array(recordings['soma(0.5)'])
+    time = numpy.array(recordings["time"])
+    soma_voltage = numpy.array(recordings["soma(0.5)"])
 
-    recordings_dir = 'python_recordings'
+    recordings_dir = "python_recordings"
 
-    soma_voltage_filename = os.path.join(
-        recordings_dir,
-        'soma_voltage_RmpRiTau_step.dat')
+    soma_voltage_filename = os.path.join(recordings_dir, "soma_voltage_RmpRiTau_step.dat")
     numpy.savetxt(soma_voltage_filename, zip(time, soma_voltage))
 
-    print('Soma voltage for RmpRiTau trace saved to: %s'
-          % (soma_voltage_filename))
+    print("Soma voltage for RmpRiTau trace saved to: %s" % (soma_voltage_filename))
 
     if plot_traces:
         import pylab
-        pylab.figure(facecolor='white')
-        pylab.plot(recordings['time'], recordings['soma(0.5)'])
-        pylab.xlabel('time (ms)')
-        pylab.ylabel('Vm (mV)')
-        pylab.gcf().canvas.set_window_title('RmpRiTau trace')
+
+        pylab.figure(facecolor="white")
+        pylab.plot(recordings["time"], recordings["soma(0.5)"])
+        pylab.xlabel("time (ms)")
+        pylab.ylabel("Vm (mV)")
+        pylab.gcf().canvas.set_window_title("RmpRiTau trace")
 
     return time, soma_voltage, stim_start, stim_end
 
 
 def init_simulation():
     """Initialise simulation environment"""
 
     neuron.h.load_file("stdrun.hoc")
     neuron.h.load_file("import3d.hoc")
 
-    print('Loading constants')
-    neuron.h.load_file('constants.hoc')
+    print("Loading constants")
+    neuron.h.load_file("constants.hoc")
 
 
-def analyse_RmpRiTau_trace(
-        time,
-        soma_voltage,
-        stim_start,
-        stim_end,
-        current_amplitude):
+def analyse_RmpRiTau_trace(time, soma_voltage, stim_start, stim_end, current_amplitude):
     """Analyse the output of the RmpRiTau protocol"""
 
     # Import the eFeature Extraction Library
     import efel
 
     # Prepare the trace data
     trace = {}
-    trace['T'] = time
-    trace['V'] = soma_voltage
-    trace['stim_start'] = [stim_start]
-    trace['stim_end'] = [stim_end]
+    trace["T"] = time
+    trace["V"] = soma_voltage
+    trace["stim_start"] = [stim_start]
+    trace["stim_end"] = [stim_end]
 
     # Calculate the necessary eFeatures
     efel_results = efel.getFeatureValues(
-        [trace],
-        ['voltage_base', 'steady_state_voltage_stimend',
-         'decay_time_constant_after_stim'])
-
-    voltage_base = efel_results[0]['voltage_base'][0]
-    ss_voltage = efel_results[0]['steady_state_voltage_stimend'][0]
-    dct = efel_results[0]['decay_time_constant_after_stim'][0]
+        [trace], ["voltage_base", "steady_state_voltage_stimend", "decay_time_constant_after_stim"]
+    )
+
+    voltage_base = efel_results[0]["voltage_base"][0]
+    ss_voltage = efel_results[0]["steady_state_voltage_stimend"][0]
+    dct = efel_results[0]["decay_time_constant_after_stim"][0]
 
     # Calculate input resistance
     input_resistance = float(ss_voltage - voltage_base) / current_amplitude
 
     rmpritau_dict = {}
 
-    rmpritau_dict['Rmp'] = '%.6g' % voltage_base
-    rmpritau_dict['Rmp_Units'] = 'mV'
-    rmpritau_dict['Rin'] = '%.6g' % input_resistance
-    rmpritau_dict['Rin_Units'] = 'MOhm'
-    rmpritau_dict['Tau'] = '%.6g' % dct
-    rmpritau_dict['Tau_Units'] = 'ms'
-
-    print('Resting membrane potential is %s %s' %
-          (rmpritau_dict['Rmp'], rmpritau_dict['Rmp_Units']))
-    print('Input resistance is %s %s' %
-          (rmpritau_dict['Rin'], rmpritau_dict['Rin_Units']))
-    print('Time constant is %s %s' %
-          (rmpritau_dict['Tau'], rmpritau_dict['Tau_Units']))
+    rmpritau_dict["Rmp"] = "%.6g" % voltage_base
+    rmpritau_dict["Rmp_Units"] = "mV"
+    rmpritau_dict["Rin"] = "%.6g" % input_resistance
+    rmpritau_dict["Rin_Units"] = "MOhm"
+    rmpritau_dict["Tau"] = "%.6g" % dct
+    rmpritau_dict["Tau_Units"] = "ms"
+
+    print("Resting membrane potential is %s %s" % (rmpritau_dict["Rmp"], rmpritau_dict["Rmp_Units"]))
+    print("Input resistance is %s %s" % (rmpritau_dict["Rin"], rmpritau_dict["Rin_Units"]))
+    print("Time constant is %s %s" % (rmpritau_dict["Tau"], rmpritau_dict["Tau_Units"]))
 
     import json
 
-    with open('rmp_ri_tau.json', 'w') as rmpritau_json_file:
-        json.dump(rmpritau_dict, rmpritau_json_file,
-                        sort_keys=True,
-                        indent=4,
-                        separators=(',', ': '))
+    with open("rmp_ri_tau.json", "w") as rmpritau_json_file:
+        json.dump(rmpritau_dict, rmpritau_json_file, sort_keys=True, indent=4, separators=(",", ": "))
 
 
 def main(plot_traces=False):
     """Main"""
 
     # Import matplotlib to plot the traces
     if plot_traces:
         import matplotlib
-        matplotlib.rcParams['path.simplify'] = False
+
+        matplotlib.rcParams["path.simplify"] = False
 
     init_simulation()
 
     current_amplitude = -0.01
     stim_start = 1000
     stim_end = 2000
 
     time, soma_voltage, stim_start, stim_end = run_RmpRiTau_step(
-        stim_start, stim_end, current_amplitude, plot_traces=plot_traces)
+        stim_start, stim_end, current_amplitude, plot_traces=plot_traces
+    )
 
-    analyse_RmpRiTau_trace(
-        time,
-        soma_voltage,
-        stim_start,
-        stim_end,
-        current_amplitude)
+    analyse_RmpRiTau_trace(time, soma_voltage, stim_start, stim_end, current_amplitude)
 
     if plot_traces:
         import pylab
+
         pylab.show()
 
-if __name__ == '__main__':
+
+if __name__ == "__main__":
     if len(sys.argv) == 1:
         main(plot_traces=True)
-    elif len(sys.argv) == 2 and sys.argv[1] == '--no-plots':
+    elif len(sys.argv) == 2 and sys.argv[1] == "--no-plots":
         main(plot_traces=False)
     else:
-        raise Exception(
-            "Script only accepts one argument: --no-plots, not %s" %
-            str(sys.argv))
+        raise Exception("Script only accepts one argument: --no-plots, not %s" % str(sys.argv))
```

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/synapses/mtype_map.tsv` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/synapses/mtype_map.tsv`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/synapses/synapses.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/synapses/synapses.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/synapses/synapses.tsv` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/synapses/synapses.tsv`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/synapses/synconf.txt` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/synapses/synconf.txt`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NBC_bAC217_1/template.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/template.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/LICENSE` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/LICENSE`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/README` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/README`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/biophysics.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/biophysics.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/constants.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/constants.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/creategui.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/creategui.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/createsimulation.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/createsimulation.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/init.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/init.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/Ca.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/Ca.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/CaDynamics_E2.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/CaDynamics_E2.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/Ca_LVAst.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/Ca_LVAst.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/Ih.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/Ih.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/Im.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/Im.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/K_Pst.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/K_Pst.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/K_Tst.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/K_Tst.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/NaTa_t.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/NaTa_t.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/NaTs2_t.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/NaTs2_t.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/Nap_Et2.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/Nap_Et2.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/ProbAMPANMDA_EMS.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/ProbAMPANMDA_EMS.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/ProbGABAAB_EMS.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/ProbGABAAB_EMS.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/SK_E2.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/SK_E2.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/SKv3_1.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mechanisms/SKv3_1.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/morphology/rp110125_L5-2_idA_-_Scale_x1.000_y0.950_z1.000_-_Clone_42.asc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/morphology/rp110125_L5-2_idA_-_Scale_x1.000_y0.950_z1.000_-_Clone_42.asc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/morphology.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/morphology.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mosinit.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/mosinit.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/ringplot.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/ringplot.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/run.py` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/run.py`

 * *Files 8% similar despite different names*

```diff
@@ -32,158 +32,155 @@
  * @author Werner Van Geit @ BBP
  * @date 2015
 """
 
 # pylint: disable=C0325, W0212, F0401, W0612, F0401
 
 import os
+import sys
+
 import neuron
 import numpy
-import sys
 
 
 def create_cell(add_synapses=True):
     """Create the cell model"""
     # Load morphology
     neuron.h.load_file("morphology.hoc")
     # Load biophysics
     neuron.h.load_file("biophysics.hoc")
     # Load main cell template
     neuron.h.load_file("template.hoc")
 
     # Instantiate the cell from the template
 
-    print("Loading cell bNAC219_L5_NGC_6186b7e85e")
-    cell = neuron.h.bNAC219_L5_NGC_6186b7e85e(1 if add_synapses else 0)
+    print("Loading cell cADpyr232_L5_UTPC_5e3840b51e")
+    cell = neuron.h.cADpyr232_L5_UTPC_5e3840b51e(1 if add_synapses else 0)
     return cell
 
 
 def create_stimuli(cell, step_number):
     """Create the stimuli"""
 
-    print('Attaching stimulus electrodes')
+    print("Attaching stimulus electrodes")
 
     stimuli = []
     step_amp = [0] * 3
 
-    with open('current_amps.dat', 'r') as current_amps_file:
-        first_line = current_amps_file.read().split('\n')[0].strip()
-        hyp_amp, step_amp[0], step_amp[1], step_amp[2] = first_line.split(' ')
+    with open("current_amps.dat", "r") as current_amps_file:
+        first_line = current_amps_file.read().split("\n")[0].strip()
+        hyp_amp, step_amp[0], step_amp[1], step_amp[2] = first_line.split(" ")
 
     iclamp = neuron.h.IClamp(0.5, sec=cell.soma[0])
     iclamp.delay = 700
     iclamp.dur = 2000
     iclamp.amp = float(step_amp[step_number - 1])
-    print('Setting up step current clamp: '
-          'amp=%f nA, delay=%f ms, duration=%f ms' %
-          (iclamp.amp, iclamp.delay, iclamp.dur))
+    print(
+        "Setting up step current clamp: "
+        "amp=%f nA, delay=%f ms, duration=%f ms" % (iclamp.amp, iclamp.delay, iclamp.dur)
+    )
 
     stimuli.append(iclamp)
 
     hyp_iclamp = neuron.h.IClamp(0.5, sec=cell.soma[0])
     hyp_iclamp.delay = 0
     hyp_iclamp.dur = 3000
     hyp_iclamp.amp = float(hyp_amp)
-    print('Setting up hypamp current clamp: '
-          'amp=%f nA, delay=%f ms, duration=%f ms' %
-          (hyp_iclamp.amp, hyp_iclamp.delay, hyp_iclamp.dur))
+    print(
+        "Setting up hypamp current clamp: "
+        "amp=%f nA, delay=%f ms, duration=%f ms" % (hyp_iclamp.amp, hyp_iclamp.delay, hyp_iclamp.dur)
+    )
 
     stimuli.append(hyp_iclamp)
 
     return stimuli
 
 
 def create_recordings(cell):
     """Create the recordings"""
-    print('Attaching recording electrodes')
+    print("Attaching recording electrodes")
 
     recordings = {}
 
-    recordings['time'] = neuron.h.Vector()
-    recordings['soma(0.5)'] = neuron.h.Vector()
+    recordings["time"] = neuron.h.Vector()
+    recordings["soma(0.5)"] = neuron.h.Vector()
 
-    recordings['time'].record(neuron.h._ref_t, 0.1)
-    recordings['soma(0.5)'].record(cell.soma[0](0.5)._ref_v, 0.1)
+    recordings["time"].record(neuron.h._ref_t, 0.1)
+    recordings["soma(0.5)"].record(cell.soma[0](0.5)._ref_v, 0.1)
 
     return recordings
 
 
 def run_step(step_number, plot_traces=None):
     """Run step current simulation with index step_number"""
 
     cell = create_cell(add_synapses=False)
     stimuli = create_stimuli(cell, step_number)
     recordings = create_recordings(cell)
 
     # Overriding default 30s simulation,
-    print('Setting simulation time to 3s for the step currents')
+    print("Setting simulation time to 3s for the step currents")
     neuron.h.tstop = 3000
 
-    print('Disabling variable timestep integration')
+    print("Disabling variable timestep integration")
     neuron.h.cvode_active(0)
 
-    print('Running for %f ms' % neuron.h.tstop)
+    print("Running for %f ms" % neuron.h.tstop)
     neuron.h.run()
 
-    time = numpy.array(recordings['time'])
-    soma_voltage = numpy.array(recordings['soma(0.5)'])
+    time = numpy.array(recordings["time"])
+    soma_voltage = numpy.array(recordings["soma(0.5)"])
 
-    recordings_dir = 'python_recordings'
+    recordings_dir = "python_recordings"
 
-    soma_voltage_filename = os.path.join(
-        recordings_dir,
-        'soma_voltage_step%d.dat' % step_number)
-    numpy.savetxt(
-            soma_voltage_filename,
-            numpy.transpose(
-               numpy.vstack((
-                    time,
-                    soma_voltage))))
+    soma_voltage_filename = os.path.join(recordings_dir, "soma_voltage_step%d.dat" % step_number)
+    numpy.savetxt(soma_voltage_filename, numpy.transpose(numpy.vstack((time, soma_voltage))))
 
-    print('Soma voltage for step %d saved to: %s'
-          % (step_number, soma_voltage_filename))
+    print("Soma voltage for step %d saved to: %s" % (step_number, soma_voltage_filename))
 
     if plot_traces:
         import pylab
+
         pylab.figure()
-        pylab.plot(recordings['time'], recordings['soma(0.5)'])
-        pylab.xlabel('time (ms)')
-        pylab.ylabel('Vm (mV)')
-        pylab.gcf().canvas.set_window_title('Step %d' % step_number)
+        pylab.plot(recordings["time"], recordings["soma(0.5)"])
+        pylab.xlabel("time (ms)")
+        pylab.ylabel("Vm (mV)")
+        pylab.gcf().canvas.set_window_title("Step %d" % step_number)
 
 
 def init_simulation():
     """Initialise simulation environment"""
 
     neuron.h.load_file("stdrun.hoc")
     neuron.h.load_file("import3d.hoc")
 
-    print('Loading constants')
-    neuron.h.load_file('constants.hoc')
+    print("Loading constants")
+    neuron.h.load_file("constants.hoc")
 
 
 def main(plot_traces=True):
     """Main"""
 
     # Import matplotlib to plot the traces
     if plot_traces:
         import matplotlib
-        matplotlib.rcParams['path.simplify'] = False
+
+        matplotlib.rcParams["path.simplify"] = False
 
     init_simulation()
 
     for step_number in range(1, 4):
         run_step(step_number, plot_traces=plot_traces)
 
     if plot_traces:
         import pylab
+
         pylab.show()
 
-if __name__ == '__main__':
+
+if __name__ == "__main__":
     if len(sys.argv) == 1:
         main(plot_traces=True)
-    elif len(sys.argv) == 2 and sys.argv[1] == '--no-plots':
+    elif len(sys.argv) == 2 and sys.argv[1] == "--no-plots":
         main(plot_traces=False)
     else:
-        raise Exception(
-            "Script only accepts one argument: --no-plots, not %s" %
-            str(sys.argv))
+        raise Exception("Script only accepts one argument: --no-plots, not %s" % str(sys.argv))
```

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/run_RmpRiTau.py` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/run_RmpRiTau.py`

 * *Files 9% similar despite different names*

```diff
@@ -32,222 +32,201 @@
  * @author Werner Van Geit @ BBP
  * @date 2015
 """
 
 # pylint: disable=C0325, W0212, F0401, W0612, F0401
 
 import os
+import sys
+
 import neuron
 import numpy
-import sys
 
 
 def create_cell():
     """Create the cell model"""
     # Load morphology
     neuron.h.load_file("morphology.hoc")
     # Load biophysics
     neuron.h.load_file("biophysics.hoc")
     # Load main cell template
     neuron.h.load_file("template.hoc")
 
     # Instantiate the cell from the template
 
-    print("Loading cell bNAC219_L5_NGC_6186b7e85e")
-    cell = neuron.h.bNAC219_L5_NGC_6186b7e85e(0)
+    print("Loading cell bNAC219_L5_SBC_77ab259b7f")
+    cell = neuron.h.bNAC219_L5_SBC_77ab259b7f(0)
     return cell
 
 
 def create_stimuli(cell, stim_start, stim_end, current_amplitude):
     """Create the stimuli"""
 
-    print('Attaching stimulus electrodes')
+    print("Attaching stimulus electrodes")
 
     stimuli = []
 
     iclamp = neuron.h.IClamp(0.5, sec=cell.soma[0])
     iclamp.delay = stim_start
     iclamp.dur = stim_end - stim_start
     iclamp.amp = current_amplitude
-    print('Setting up step current clamp: '
-          'amp=%f nA, delay=%f ms, duration=%f ms' %
-          (iclamp.amp, iclamp.delay, iclamp.dur))
+    print(
+        "Setting up step current clamp: "
+        "amp=%f nA, delay=%f ms, duration=%f ms" % (iclamp.amp, iclamp.delay, iclamp.dur)
+    )
 
     stimuli.append(iclamp)
 
     return stimuli
 
 
 def create_recordings(cell):
     """Create the recordings"""
-    print('Attaching recording electrodes')
+    print("Attaching recording electrodes")
 
     recordings = {}
 
-    recordings['time'] = neuron.h.Vector()
-    recordings['soma(0.5)'] = neuron.h.Vector()
+    recordings["time"] = neuron.h.Vector()
+    recordings["soma(0.5)"] = neuron.h.Vector()
 
-    recordings['time'].record(neuron.h._ref_t, 0.1)
-    recordings['soma(0.5)'].record(cell.soma[0](0.5)._ref_v, 0.1)
+    recordings["time"].record(neuron.h._ref_t, 0.1)
+    recordings["soma(0.5)"].record(cell.soma[0](0.5)._ref_v, 0.1)
 
     return recordings
 
 
-def run_RmpRiTau_step(
-        stim_start,
-        stim_end,
-        current_amplitude,
-        plot_traces=None):
-    """Run """
+def run_RmpRiTau_step(stim_start, stim_end, current_amplitude, plot_traces=None):
+    """Run"""
 
     cell = create_cell()
     stimuli = create_stimuli(cell, stim_start, stim_end, current_amplitude)  # noqa
     recordings = create_recordings(cell)
 
     # Overriding default 30s simulation,
     neuron.h.tstop = stim_end + stim_start
-    print(
-        'Setting simulation time to %.6g ms for the step current' %
-        neuron.h.tstop)
+    print("Setting simulation time to %.6g ms for the step current" % neuron.h.tstop)
 
-    print('Setting initial voltage to -70 mV')
+    print("Setting initial voltage to -70 mV")
     neuron.h.v_init = -70
 
     neuron.h.stdinit()
     neuron.h.dt = 1000
     neuron.h.t = -1e9
     for _ in range(10):
         neuron.h.fadvance()
 
     neuron.h.t = 0
     neuron.h.dt = 0.025
     neuron.h.frecord_init()
 
     neuron.h.continuerun(3000)
 
-    time = numpy.array(recordings['time'])
-    soma_voltage = numpy.array(recordings['soma(0.5)'])
+    time = numpy.array(recordings["time"])
+    soma_voltage = numpy.array(recordings["soma(0.5)"])
 
-    recordings_dir = 'python_recordings'
+    recordings_dir = "python_recordings"
 
-    soma_voltage_filename = os.path.join(
-        recordings_dir,
-        'soma_voltage_RmpRiTau_step.dat')
+    soma_voltage_filename = os.path.join(recordings_dir, "soma_voltage_RmpRiTau_step.dat")
     numpy.savetxt(soma_voltage_filename, zip(time, soma_voltage))
 
-    print('Soma voltage for RmpRiTau trace saved to: %s'
-          % (soma_voltage_filename))
+    print("Soma voltage for RmpRiTau trace saved to: %s" % (soma_voltage_filename))
 
     if plot_traces:
         import pylab
-        pylab.figure(facecolor='white')
-        pylab.plot(recordings['time'], recordings['soma(0.5)'])
-        pylab.xlabel('time (ms)')
-        pylab.ylabel('Vm (mV)')
-        pylab.gcf().canvas.set_window_title('RmpRiTau trace')
+
+        pylab.figure(facecolor="white")
+        pylab.plot(recordings["time"], recordings["soma(0.5)"])
+        pylab.xlabel("time (ms)")
+        pylab.ylabel("Vm (mV)")
+        pylab.gcf().canvas.set_window_title("RmpRiTau trace")
 
     return time, soma_voltage, stim_start, stim_end
 
 
 def init_simulation():
     """Initialise simulation environment"""
 
     neuron.h.load_file("stdrun.hoc")
     neuron.h.load_file("import3d.hoc")
 
-    print('Loading constants')
-    neuron.h.load_file('constants.hoc')
+    print("Loading constants")
+    neuron.h.load_file("constants.hoc")
 
 
-def analyse_RmpRiTau_trace(
-        time,
-        soma_voltage,
-        stim_start,
-        stim_end,
-        current_amplitude):
+def analyse_RmpRiTau_trace(time, soma_voltage, stim_start, stim_end, current_amplitude):
     """Analyse the output of the RmpRiTau protocol"""
 
     # Import the eFeature Extraction Library
     import efel
 
     # Prepare the trace data
     trace = {}
-    trace['T'] = time
-    trace['V'] = soma_voltage
-    trace['stim_start'] = [stim_start]
-    trace['stim_end'] = [stim_end]
+    trace["T"] = time
+    trace["V"] = soma_voltage
+    trace["stim_start"] = [stim_start]
+    trace["stim_end"] = [stim_end]
 
     # Calculate the necessary eFeatures
     efel_results = efel.getFeatureValues(
-        [trace],
-        ['voltage_base', 'steady_state_voltage_stimend',
-         'decay_time_constant_after_stim'])
-
-    voltage_base = efel_results[0]['voltage_base'][0]
-    ss_voltage = efel_results[0]['steady_state_voltage_stimend'][0]
-    dct = efel_results[0]['decay_time_constant_after_stim'][0]
+        [trace], ["voltage_base", "steady_state_voltage_stimend", "decay_time_constant_after_stim"]
+    )
+
+    voltage_base = efel_results[0]["voltage_base"][0]
+    ss_voltage = efel_results[0]["steady_state_voltage_stimend"][0]
+    dct = efel_results[0]["decay_time_constant_after_stim"][0]
 
     # Calculate input resistance
     input_resistance = float(ss_voltage - voltage_base) / current_amplitude
 
     rmpritau_dict = {}
 
-    rmpritau_dict['Rmp'] = '%.6g' % voltage_base
-    rmpritau_dict['Rmp_Units'] = 'mV'
-    rmpritau_dict['Rin'] = '%.6g' % input_resistance
-    rmpritau_dict['Rin_Units'] = 'MOhm'
-    rmpritau_dict['Tau'] = '%.6g' % dct
-    rmpritau_dict['Tau_Units'] = 'ms'
-
-    print('Resting membrane potential is %s %s' %
-          (rmpritau_dict['Rmp'], rmpritau_dict['Rmp_Units']))
-    print('Input resistance is %s %s' %
-          (rmpritau_dict['Rin'], rmpritau_dict['Rin_Units']))
-    print('Time constant is %s %s' %
-          (rmpritau_dict['Tau'], rmpritau_dict['Tau_Units']))
+    rmpritau_dict["Rmp"] = "%.6g" % voltage_base
+    rmpritau_dict["Rmp_Units"] = "mV"
+    rmpritau_dict["Rin"] = "%.6g" % input_resistance
+    rmpritau_dict["Rin_Units"] = "MOhm"
+    rmpritau_dict["Tau"] = "%.6g" % dct
+    rmpritau_dict["Tau_Units"] = "ms"
+
+    print("Resting membrane potential is %s %s" % (rmpritau_dict["Rmp"], rmpritau_dict["Rmp_Units"]))
+    print("Input resistance is %s %s" % (rmpritau_dict["Rin"], rmpritau_dict["Rin_Units"]))
+    print("Time constant is %s %s" % (rmpritau_dict["Tau"], rmpritau_dict["Tau_Units"]))
 
     import json
 
-    with open('rmp_ri_tau.json', 'w') as rmpritau_json_file:
-        json.dump(rmpritau_dict, rmpritau_json_file,
-                        sort_keys=True,
-                        indent=4,
-                        separators=(',', ': '))
+    with open("rmp_ri_tau.json", "w") as rmpritau_json_file:
+        json.dump(rmpritau_dict, rmpritau_json_file, sort_keys=True, indent=4, separators=(",", ": "))
 
 
 def main(plot_traces=False):
     """Main"""
 
     # Import matplotlib to plot the traces
     if plot_traces:
         import matplotlib
-        matplotlib.rcParams['path.simplify'] = False
+
+        matplotlib.rcParams["path.simplify"] = False
 
     init_simulation()
 
     current_amplitude = -0.01
     stim_start = 1000
     stim_end = 2000
 
     time, soma_voltage, stim_start, stim_end = run_RmpRiTau_step(
-        stim_start, stim_end, current_amplitude, plot_traces=plot_traces)
+        stim_start, stim_end, current_amplitude, plot_traces=plot_traces
+    )
 
-    analyse_RmpRiTau_trace(
-        time,
-        soma_voltage,
-        stim_start,
-        stim_end,
-        current_amplitude)
+    analyse_RmpRiTau_trace(time, soma_voltage, stim_start, stim_end, current_amplitude)
 
     if plot_traces:
         import pylab
+
         pylab.show()
 
-if __name__ == '__main__':
+
+if __name__ == "__main__":
     if len(sys.argv) == 1:
         main(plot_traces=True)
-    elif len(sys.argv) == 2 and sys.argv[1] == '--no-plots':
+    elif len(sys.argv) == 2 and sys.argv[1] == "--no-plots":
         main(plot_traces=False)
     else:
-        raise Exception(
-            "Script only accepts one argument: --no-plots, not %s" %
-            str(sys.argv))
+        raise Exception("Script only accepts one argument: --no-plots, not %s" % str(sys.argv))
```

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/synapses/mtype_map.tsv` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/synapses/mtype_map.tsv`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/synapses/synapses.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/synapses/synapses.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/synapses/synapses.tsv` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/synapses/synapses.tsv`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/synapses/synconf.txt` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/synapses/synconf.txt`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/template.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/template.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/LICENSE` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/LICENSE`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/README` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/README`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/biophysics.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/biophysics.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/constants.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/constants.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/creategui.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/creategui.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/createsimulation.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/createsimulation.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/init.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/init.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/Ca.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/Ca.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/CaDynamics_E2.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/CaDynamics_E2.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/Ca_LVAst.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/Ca_LVAst.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/Ih.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/Ih.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/Im.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/Im.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/K_Pst.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/K_Pst.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/K_Tst.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/K_Tst.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/NaTa_t.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/NaTa_t.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/NaTs2_t.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/NaTs2_t.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/Nap_Et2.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/Nap_Et2.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/ProbAMPANMDA_EMS.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/ProbAMPANMDA_EMS.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/ProbGABAAB_EMS.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/ProbGABAAB_EMS.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/SK_E2.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/SK_E2.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/SKv3_1.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mechanisms/SKv3_1.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/morphology/og061106a1_idA_-_Scale_x1.000_y1.050_z1.000_-_Clone_5.asc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/morphology/og061106a1_idA_-_Scale_x1.000_y1.050_z1.000_-_Clone_5.asc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/morphology.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/morphology.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mosinit.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/mosinit.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/ringplot.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/ringplot.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/run.py` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/run.py`

 * *Files 7% similar despite different names*

```diff
@@ -32,158 +32,155 @@
  * @author Werner Van Geit @ BBP
  * @date 2015
 """
 
 # pylint: disable=C0325, W0212, F0401, W0612, F0401
 
 import os
+import sys
+
 import neuron
 import numpy
-import sys
 
 
 def create_cell(add_synapses=True):
     """Create the cell model"""
     # Load morphology
     neuron.h.load_file("morphology.hoc")
     # Load biophysics
     neuron.h.load_file("biophysics.hoc")
     # Load main cell template
     neuron.h.load_file("template.hoc")
 
     # Instantiate the cell from the template
 
-    print("Loading cell bNAC219_L5_SBC_77ab259b7f")
-    cell = neuron.h.bNAC219_L5_SBC_77ab259b7f(1 if add_synapses else 0)
+    print("Loading cell bAC217_L5_LBC_c2cff91741")
+    cell = neuron.h.bAC217_L5_LBC_c2cff91741(1 if add_synapses else 0)
     return cell
 
 
 def create_stimuli(cell, step_number):
     """Create the stimuli"""
 
-    print('Attaching stimulus electrodes')
+    print("Attaching stimulus electrodes")
 
     stimuli = []
     step_amp = [0] * 3
 
-    with open('current_amps.dat', 'r') as current_amps_file:
-        first_line = current_amps_file.read().split('\n')[0].strip()
-        hyp_amp, step_amp[0], step_amp[1], step_amp[2] = first_line.split(' ')
+    with open("current_amps.dat", "r") as current_amps_file:
+        first_line = current_amps_file.read().split("\n")[0].strip()
+        hyp_amp, step_amp[0], step_amp[1], step_amp[2] = first_line.split(" ")
 
     iclamp = neuron.h.IClamp(0.5, sec=cell.soma[0])
     iclamp.delay = 700
     iclamp.dur = 2000
     iclamp.amp = float(step_amp[step_number - 1])
-    print('Setting up step current clamp: '
-          'amp=%f nA, delay=%f ms, duration=%f ms' %
-          (iclamp.amp, iclamp.delay, iclamp.dur))
+    print(
+        "Setting up step current clamp: "
+        "amp=%f nA, delay=%f ms, duration=%f ms" % (iclamp.amp, iclamp.delay, iclamp.dur)
+    )
 
     stimuli.append(iclamp)
 
     hyp_iclamp = neuron.h.IClamp(0.5, sec=cell.soma[0])
     hyp_iclamp.delay = 0
     hyp_iclamp.dur = 3000
     hyp_iclamp.amp = float(hyp_amp)
-    print('Setting up hypamp current clamp: '
-          'amp=%f nA, delay=%f ms, duration=%f ms' %
-          (hyp_iclamp.amp, hyp_iclamp.delay, hyp_iclamp.dur))
+    print(
+        "Setting up hypamp current clamp: "
+        "amp=%f nA, delay=%f ms, duration=%f ms" % (hyp_iclamp.amp, hyp_iclamp.delay, hyp_iclamp.dur)
+    )
 
     stimuli.append(hyp_iclamp)
 
     return stimuli
 
 
 def create_recordings(cell):
     """Create the recordings"""
-    print('Attaching recording electrodes')
+    print("Attaching recording electrodes")
 
     recordings = {}
 
-    recordings['time'] = neuron.h.Vector()
-    recordings['soma(0.5)'] = neuron.h.Vector()
+    recordings["time"] = neuron.h.Vector()
+    recordings["soma(0.5)"] = neuron.h.Vector()
 
-    recordings['time'].record(neuron.h._ref_t, 0.1)
-    recordings['soma(0.5)'].record(cell.soma[0](0.5)._ref_v, 0.1)
+    recordings["time"].record(neuron.h._ref_t, 0.1)
+    recordings["soma(0.5)"].record(cell.soma[0](0.5)._ref_v, 0.1)
 
     return recordings
 
 
 def run_step(step_number, plot_traces=None):
     """Run step current simulation with index step_number"""
 
     cell = create_cell(add_synapses=False)
     stimuli = create_stimuli(cell, step_number)
     recordings = create_recordings(cell)
 
     # Overriding default 30s simulation,
-    print('Setting simulation time to 3s for the step currents')
+    print("Setting simulation time to 3s for the step currents")
     neuron.h.tstop = 3000
 
-    print('Disabling variable timestep integration')
+    print("Disabling variable timestep integration")
     neuron.h.cvode_active(0)
 
-    print('Running for %f ms' % neuron.h.tstop)
+    print("Running for %f ms" % neuron.h.tstop)
     neuron.h.run()
 
-    time = numpy.array(recordings['time'])
-    soma_voltage = numpy.array(recordings['soma(0.5)'])
+    time = numpy.array(recordings["time"])
+    soma_voltage = numpy.array(recordings["soma(0.5)"])
 
-    recordings_dir = 'python_recordings'
+    recordings_dir = "python_recordings"
 
-    soma_voltage_filename = os.path.join(
-        recordings_dir,
-        'soma_voltage_step%d.dat' % step_number)
-    numpy.savetxt(
-            soma_voltage_filename,
-            numpy.transpose(
-               numpy.vstack((
-                    time,
-                    soma_voltage))))
+    soma_voltage_filename = os.path.join(recordings_dir, "soma_voltage_step%d.dat" % step_number)
+    numpy.savetxt(soma_voltage_filename, numpy.transpose(numpy.vstack((time, soma_voltage))))
 
-    print('Soma voltage for step %d saved to: %s'
-          % (step_number, soma_voltage_filename))
+    print("Soma voltage for step %d saved to: %s" % (step_number, soma_voltage_filename))
 
     if plot_traces:
         import pylab
+
         pylab.figure()
-        pylab.plot(recordings['time'], recordings['soma(0.5)'])
-        pylab.xlabel('time (ms)')
-        pylab.ylabel('Vm (mV)')
-        pylab.gcf().canvas.set_window_title('Step %d' % step_number)
+        pylab.plot(recordings["time"], recordings["soma(0.5)"])
+        pylab.xlabel("time (ms)")
+        pylab.ylabel("Vm (mV)")
+        pylab.gcf().canvas.set_window_title("Step %d" % step_number)
 
 
 def init_simulation():
     """Initialise simulation environment"""
 
     neuron.h.load_file("stdrun.hoc")
     neuron.h.load_file("import3d.hoc")
 
-    print('Loading constants')
-    neuron.h.load_file('constants.hoc')
+    print("Loading constants")
+    neuron.h.load_file("constants.hoc")
 
 
 def main(plot_traces=True):
     """Main"""
 
     # Import matplotlib to plot the traces
     if plot_traces:
         import matplotlib
-        matplotlib.rcParams['path.simplify'] = False
+
+        matplotlib.rcParams["path.simplify"] = False
 
     init_simulation()
 
     for step_number in range(1, 4):
         run_step(step_number, plot_traces=plot_traces)
 
     if plot_traces:
         import pylab
+
         pylab.show()
 
-if __name__ == '__main__':
+
+if __name__ == "__main__":
     if len(sys.argv) == 1:
         main(plot_traces=True)
-    elif len(sys.argv) == 2 and sys.argv[1] == '--no-plots':
+    elif len(sys.argv) == 2 and sys.argv[1] == "--no-plots":
         main(plot_traces=False)
     else:
-        raise Exception(
-            "Script only accepts one argument: --no-plots, not %s" %
-            str(sys.argv))
+        raise Exception("Script only accepts one argument: --no-plots, not %s" % str(sys.argv))
```

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/run_RmpRiTau.py` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NGC_bNAC219_1/run_RmpRiTau.py`

 * *Files 10% similar despite different names*

```diff
@@ -32,222 +32,201 @@
  * @author Werner Van Geit @ BBP
  * @date 2015
 """
 
 # pylint: disable=C0325, W0212, F0401, W0612, F0401
 
 import os
+import sys
+
 import neuron
 import numpy
-import sys
 
 
 def create_cell():
     """Create the cell model"""
     # Load morphology
     neuron.h.load_file("morphology.hoc")
     # Load biophysics
     neuron.h.load_file("biophysics.hoc")
     # Load main cell template
     neuron.h.load_file("template.hoc")
 
     # Instantiate the cell from the template
 
-    print("Loading cell bNAC219_L5_SBC_77ab259b7f")
-    cell = neuron.h.bNAC219_L5_SBC_77ab259b7f(0)
+    print("Loading cell bNAC219_L5_NGC_6186b7e85e")
+    cell = neuron.h.bNAC219_L5_NGC_6186b7e85e(0)
     return cell
 
 
 def create_stimuli(cell, stim_start, stim_end, current_amplitude):
     """Create the stimuli"""
 
-    print('Attaching stimulus electrodes')
+    print("Attaching stimulus electrodes")
 
     stimuli = []
 
     iclamp = neuron.h.IClamp(0.5, sec=cell.soma[0])
     iclamp.delay = stim_start
     iclamp.dur = stim_end - stim_start
     iclamp.amp = current_amplitude
-    print('Setting up step current clamp: '
-          'amp=%f nA, delay=%f ms, duration=%f ms' %
-          (iclamp.amp, iclamp.delay, iclamp.dur))
+    print(
+        "Setting up step current clamp: "
+        "amp=%f nA, delay=%f ms, duration=%f ms" % (iclamp.amp, iclamp.delay, iclamp.dur)
+    )
 
     stimuli.append(iclamp)
 
     return stimuli
 
 
 def create_recordings(cell):
     """Create the recordings"""
-    print('Attaching recording electrodes')
+    print("Attaching recording electrodes")
 
     recordings = {}
 
-    recordings['time'] = neuron.h.Vector()
-    recordings['soma(0.5)'] = neuron.h.Vector()
+    recordings["time"] = neuron.h.Vector()
+    recordings["soma(0.5)"] = neuron.h.Vector()
 
-    recordings['time'].record(neuron.h._ref_t, 0.1)
-    recordings['soma(0.5)'].record(cell.soma[0](0.5)._ref_v, 0.1)
+    recordings["time"].record(neuron.h._ref_t, 0.1)
+    recordings["soma(0.5)"].record(cell.soma[0](0.5)._ref_v, 0.1)
 
     return recordings
 
 
-def run_RmpRiTau_step(
-        stim_start,
-        stim_end,
-        current_amplitude,
-        plot_traces=None):
-    """Run """
+def run_RmpRiTau_step(stim_start, stim_end, current_amplitude, plot_traces=None):
+    """Run"""
 
     cell = create_cell()
     stimuli = create_stimuli(cell, stim_start, stim_end, current_amplitude)  # noqa
     recordings = create_recordings(cell)
 
     # Overriding default 30s simulation,
     neuron.h.tstop = stim_end + stim_start
-    print(
-        'Setting simulation time to %.6g ms for the step current' %
-        neuron.h.tstop)
+    print("Setting simulation time to %.6g ms for the step current" % neuron.h.tstop)
 
-    print('Setting initial voltage to -70 mV')
+    print("Setting initial voltage to -70 mV")
     neuron.h.v_init = -70
 
     neuron.h.stdinit()
     neuron.h.dt = 1000
     neuron.h.t = -1e9
     for _ in range(10):
         neuron.h.fadvance()
 
     neuron.h.t = 0
     neuron.h.dt = 0.025
     neuron.h.frecord_init()
 
     neuron.h.continuerun(3000)
 
-    time = numpy.array(recordings['time'])
-    soma_voltage = numpy.array(recordings['soma(0.5)'])
+    time = numpy.array(recordings["time"])
+    soma_voltage = numpy.array(recordings["soma(0.5)"])
 
-    recordings_dir = 'python_recordings'
+    recordings_dir = "python_recordings"
 
-    soma_voltage_filename = os.path.join(
-        recordings_dir,
-        'soma_voltage_RmpRiTau_step.dat')
+    soma_voltage_filename = os.path.join(recordings_dir, "soma_voltage_RmpRiTau_step.dat")
     numpy.savetxt(soma_voltage_filename, zip(time, soma_voltage))
 
-    print('Soma voltage for RmpRiTau trace saved to: %s'
-          % (soma_voltage_filename))
+    print("Soma voltage for RmpRiTau trace saved to: %s" % (soma_voltage_filename))
 
     if plot_traces:
         import pylab
-        pylab.figure(facecolor='white')
-        pylab.plot(recordings['time'], recordings['soma(0.5)'])
-        pylab.xlabel('time (ms)')
-        pylab.ylabel('Vm (mV)')
-        pylab.gcf().canvas.set_window_title('RmpRiTau trace')
+
+        pylab.figure(facecolor="white")
+        pylab.plot(recordings["time"], recordings["soma(0.5)"])
+        pylab.xlabel("time (ms)")
+        pylab.ylabel("Vm (mV)")
+        pylab.gcf().canvas.set_window_title("RmpRiTau trace")
 
     return time, soma_voltage, stim_start, stim_end
 
 
 def init_simulation():
     """Initialise simulation environment"""
 
     neuron.h.load_file("stdrun.hoc")
     neuron.h.load_file("import3d.hoc")
 
-    print('Loading constants')
-    neuron.h.load_file('constants.hoc')
+    print("Loading constants")
+    neuron.h.load_file("constants.hoc")
 
 
-def analyse_RmpRiTau_trace(
-        time,
-        soma_voltage,
-        stim_start,
-        stim_end,
-        current_amplitude):
+def analyse_RmpRiTau_trace(time, soma_voltage, stim_start, stim_end, current_amplitude):
     """Analyse the output of the RmpRiTau protocol"""
 
     # Import the eFeature Extraction Library
     import efel
 
     # Prepare the trace data
     trace = {}
-    trace['T'] = time
-    trace['V'] = soma_voltage
-    trace['stim_start'] = [stim_start]
-    trace['stim_end'] = [stim_end]
+    trace["T"] = time
+    trace["V"] = soma_voltage
+    trace["stim_start"] = [stim_start]
+    trace["stim_end"] = [stim_end]
 
     # Calculate the necessary eFeatures
     efel_results = efel.getFeatureValues(
-        [trace],
-        ['voltage_base', 'steady_state_voltage_stimend',
-         'decay_time_constant_after_stim'])
-
-    voltage_base = efel_results[0]['voltage_base'][0]
-    ss_voltage = efel_results[0]['steady_state_voltage_stimend'][0]
-    dct = efel_results[0]['decay_time_constant_after_stim'][0]
+        [trace], ["voltage_base", "steady_state_voltage_stimend", "decay_time_constant_after_stim"]
+    )
+
+    voltage_base = efel_results[0]["voltage_base"][0]
+    ss_voltage = efel_results[0]["steady_state_voltage_stimend"][0]
+    dct = efel_results[0]["decay_time_constant_after_stim"][0]
 
     # Calculate input resistance
     input_resistance = float(ss_voltage - voltage_base) / current_amplitude
 
     rmpritau_dict = {}
 
-    rmpritau_dict['Rmp'] = '%.6g' % voltage_base
-    rmpritau_dict['Rmp_Units'] = 'mV'
-    rmpritau_dict['Rin'] = '%.6g' % input_resistance
-    rmpritau_dict['Rin_Units'] = 'MOhm'
-    rmpritau_dict['Tau'] = '%.6g' % dct
-    rmpritau_dict['Tau_Units'] = 'ms'
-
-    print('Resting membrane potential is %s %s' %
-          (rmpritau_dict['Rmp'], rmpritau_dict['Rmp_Units']))
-    print('Input resistance is %s %s' %
-          (rmpritau_dict['Rin'], rmpritau_dict['Rin_Units']))
-    print('Time constant is %s %s' %
-          (rmpritau_dict['Tau'], rmpritau_dict['Tau_Units']))
+    rmpritau_dict["Rmp"] = "%.6g" % voltage_base
+    rmpritau_dict["Rmp_Units"] = "mV"
+    rmpritau_dict["Rin"] = "%.6g" % input_resistance
+    rmpritau_dict["Rin_Units"] = "MOhm"
+    rmpritau_dict["Tau"] = "%.6g" % dct
+    rmpritau_dict["Tau_Units"] = "ms"
+
+    print("Resting membrane potential is %s %s" % (rmpritau_dict["Rmp"], rmpritau_dict["Rmp_Units"]))
+    print("Input resistance is %s %s" % (rmpritau_dict["Rin"], rmpritau_dict["Rin_Units"]))
+    print("Time constant is %s %s" % (rmpritau_dict["Tau"], rmpritau_dict["Tau_Units"]))
 
     import json
 
-    with open('rmp_ri_tau.json', 'w') as rmpritau_json_file:
-        json.dump(rmpritau_dict, rmpritau_json_file,
-                        sort_keys=True,
-                        indent=4,
-                        separators=(',', ': '))
+    with open("rmp_ri_tau.json", "w") as rmpritau_json_file:
+        json.dump(rmpritau_dict, rmpritau_json_file, sort_keys=True, indent=4, separators=(",", ": "))
 
 
 def main(plot_traces=False):
     """Main"""
 
     # Import matplotlib to plot the traces
     if plot_traces:
         import matplotlib
-        matplotlib.rcParams['path.simplify'] = False
+
+        matplotlib.rcParams["path.simplify"] = False
 
     init_simulation()
 
     current_amplitude = -0.01
     stim_start = 1000
     stim_end = 2000
 
     time, soma_voltage, stim_start, stim_end = run_RmpRiTau_step(
-        stim_start, stim_end, current_amplitude, plot_traces=plot_traces)
+        stim_start, stim_end, current_amplitude, plot_traces=plot_traces
+    )
 
-    analyse_RmpRiTau_trace(
-        time,
-        soma_voltage,
-        stim_start,
-        stim_end,
-        current_amplitude)
+    analyse_RmpRiTau_trace(time, soma_voltage, stim_start, stim_end, current_amplitude)
 
     if plot_traces:
         import pylab
+
         pylab.show()
 
-if __name__ == '__main__':
+
+if __name__ == "__main__":
     if len(sys.argv) == 1:
         main(plot_traces=True)
-    elif len(sys.argv) == 2 and sys.argv[1] == '--no-plots':
+    elif len(sys.argv) == 2 and sys.argv[1] == "--no-plots":
         main(plot_traces=False)
     else:
-        raise Exception(
-            "Script only accepts one argument: --no-plots, not %s" %
-            str(sys.argv))
+        raise Exception("Script only accepts one argument: --no-plots, not %s" % str(sys.argv))
```

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/synapses/mtype_map.tsv` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/synapses/mtype_map.tsv`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/synapses/synapses.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/synapses/synapses.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/synapses/synapses.tsv` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/synapses/synapses.tsv`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/synapses/synconf.txt` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/synapses/synconf.txt`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/template.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/template.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/LICENSE` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/LICENSE`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/README` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/README`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/biophysics.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/biophysics.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/constants.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/constants.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/creategui.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/creategui.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/createsimulation.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/createsimulation.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/init.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/init.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/CaDynamics_E2.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/CaDynamics_E2.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/Ca_HVA.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/Ca_HVA.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/Ca_LVAst.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/Ca_LVAst.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/Ih.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/Ih.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/Im.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/Im.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/K_Pst.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/K_Pst.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/K_Tst.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/K_Tst.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/NaTa_t.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/NaTa_t.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/NaTs2_t.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/NaTs2_t.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/Nap_Et2.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/Nap_Et2.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/ProbAMPANMDA_EMS.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/ProbAMPANMDA_EMS.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/ProbGABAAB_EMS.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/ProbGABAAB_EMS.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/SK_E2.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/SK_E2.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/SKv3_1.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mechanisms/SKv3_1.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/morphology/dend-C231296A-P3_axon-C231296A-P3_-_Clone_9.asc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/morphology/dend-C231296A-P3_axon-C231296A-P3_-_Clone_9.asc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/morphology.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/morphology.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mosinit.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/mosinit.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/ringplot.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/ringplot.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/run.py` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_NBC_bAC217_1/run.py`

 * *Files 7% similar despite different names*

```diff
@@ -32,158 +32,155 @@
  * @author Werner Van Geit @ BBP
  * @date 2015
 """
 
 # pylint: disable=C0325, W0212, F0401, W0612, F0401
 
 import os
+import sys
+
 import neuron
 import numpy
-import sys
 
 
 def create_cell(add_synapses=True):
     """Create the cell model"""
     # Load morphology
     neuron.h.load_file("morphology.hoc")
     # Load biophysics
     neuron.h.load_file("biophysics.hoc")
     # Load main cell template
     neuron.h.load_file("template.hoc")
 
     # Instantiate the cell from the template
 
-    print("Loading cell cADpyr232_L5_STPC_d16b0be14e")
-    cell = neuron.h.cADpyr232_L5_STPC_d16b0be14e(1 if add_synapses else 0)
+    print("Loading cell bAC217_L5_NBC_2db880c523")
+    cell = neuron.h.bAC217_L5_NBC_2db880c523(1 if add_synapses else 0)
     return cell
 
 
 def create_stimuli(cell, step_number):
     """Create the stimuli"""
 
-    print('Attaching stimulus electrodes')
+    print("Attaching stimulus electrodes")
 
     stimuli = []
     step_amp = [0] * 3
 
-    with open('current_amps.dat', 'r') as current_amps_file:
-        first_line = current_amps_file.read().split('\n')[0].strip()
-        hyp_amp, step_amp[0], step_amp[1], step_amp[2] = first_line.split(' ')
+    with open("current_amps.dat", "r") as current_amps_file:
+        first_line = current_amps_file.read().split("\n")[0].strip()
+        hyp_amp, step_amp[0], step_amp[1], step_amp[2] = first_line.split(" ")
 
     iclamp = neuron.h.IClamp(0.5, sec=cell.soma[0])
     iclamp.delay = 700
     iclamp.dur = 2000
     iclamp.amp = float(step_amp[step_number - 1])
-    print('Setting up step current clamp: '
-          'amp=%f nA, delay=%f ms, duration=%f ms' %
-          (iclamp.amp, iclamp.delay, iclamp.dur))
+    print(
+        "Setting up step current clamp: "
+        "amp=%f nA, delay=%f ms, duration=%f ms" % (iclamp.amp, iclamp.delay, iclamp.dur)
+    )
 
     stimuli.append(iclamp)
 
     hyp_iclamp = neuron.h.IClamp(0.5, sec=cell.soma[0])
     hyp_iclamp.delay = 0
     hyp_iclamp.dur = 3000
     hyp_iclamp.amp = float(hyp_amp)
-    print('Setting up hypamp current clamp: '
-          'amp=%f nA, delay=%f ms, duration=%f ms' %
-          (hyp_iclamp.amp, hyp_iclamp.delay, hyp_iclamp.dur))
+    print(
+        "Setting up hypamp current clamp: "
+        "amp=%f nA, delay=%f ms, duration=%f ms" % (hyp_iclamp.amp, hyp_iclamp.delay, hyp_iclamp.dur)
+    )
 
     stimuli.append(hyp_iclamp)
 
     return stimuli
 
 
 def create_recordings(cell):
     """Create the recordings"""
-    print('Attaching recording electrodes')
+    print("Attaching recording electrodes")
 
     recordings = {}
 
-    recordings['time'] = neuron.h.Vector()
-    recordings['soma(0.5)'] = neuron.h.Vector()
+    recordings["time"] = neuron.h.Vector()
+    recordings["soma(0.5)"] = neuron.h.Vector()
 
-    recordings['time'].record(neuron.h._ref_t, 0.1)
-    recordings['soma(0.5)'].record(cell.soma[0](0.5)._ref_v, 0.1)
+    recordings["time"].record(neuron.h._ref_t, 0.1)
+    recordings["soma(0.5)"].record(cell.soma[0](0.5)._ref_v, 0.1)
 
     return recordings
 
 
 def run_step(step_number, plot_traces=None):
     """Run step current simulation with index step_number"""
 
     cell = create_cell(add_synapses=False)
     stimuli = create_stimuli(cell, step_number)
     recordings = create_recordings(cell)
 
     # Overriding default 30s simulation,
-    print('Setting simulation time to 3s for the step currents')
+    print("Setting simulation time to 3s for the step currents")
     neuron.h.tstop = 3000
 
-    print('Disabling variable timestep integration')
+    print("Disabling variable timestep integration")
     neuron.h.cvode_active(0)
 
-    print('Running for %f ms' % neuron.h.tstop)
+    print("Running for %f ms" % neuron.h.tstop)
     neuron.h.run()
 
-    time = numpy.array(recordings['time'])
-    soma_voltage = numpy.array(recordings['soma(0.5)'])
+    time = numpy.array(recordings["time"])
+    soma_voltage = numpy.array(recordings["soma(0.5)"])
 
-    recordings_dir = 'python_recordings'
+    recordings_dir = "python_recordings"
 
-    soma_voltage_filename = os.path.join(
-        recordings_dir,
-        'soma_voltage_step%d.dat' % step_number)
-    numpy.savetxt(
-            soma_voltage_filename,
-            numpy.transpose(
-               numpy.vstack((
-                    time,
-                    soma_voltage))))
+    soma_voltage_filename = os.path.join(recordings_dir, "soma_voltage_step%d.dat" % step_number)
+    numpy.savetxt(soma_voltage_filename, numpy.transpose(numpy.vstack((time, soma_voltage))))
 
-    print('Soma voltage for step %d saved to: %s'
-          % (step_number, soma_voltage_filename))
+    print("Soma voltage for step %d saved to: %s" % (step_number, soma_voltage_filename))
 
     if plot_traces:
         import pylab
+
         pylab.figure()
-        pylab.plot(recordings['time'], recordings['soma(0.5)'])
-        pylab.xlabel('time (ms)')
-        pylab.ylabel('Vm (mV)')
-        pylab.gcf().canvas.set_window_title('Step %d' % step_number)
+        pylab.plot(recordings["time"], recordings["soma(0.5)"])
+        pylab.xlabel("time (ms)")
+        pylab.ylabel("Vm (mV)")
+        pylab.gcf().canvas.set_window_title("Step %d" % step_number)
 
 
 def init_simulation():
     """Initialise simulation environment"""
 
     neuron.h.load_file("stdrun.hoc")
     neuron.h.load_file("import3d.hoc")
 
-    print('Loading constants')
-    neuron.h.load_file('constants.hoc')
+    print("Loading constants")
+    neuron.h.load_file("constants.hoc")
 
 
 def main(plot_traces=True):
     """Main"""
 
     # Import matplotlib to plot the traces
     if plot_traces:
         import matplotlib
-        matplotlib.rcParams['path.simplify'] = False
+
+        matplotlib.rcParams["path.simplify"] = False
 
     init_simulation()
 
     for step_number in range(1, 4):
         run_step(step_number, plot_traces=plot_traces)
 
     if plot_traces:
         import pylab
+
         pylab.show()
 
-if __name__ == '__main__':
+
+if __name__ == "__main__":
     if len(sys.argv) == 1:
         main(plot_traces=True)
-    elif len(sys.argv) == 2 and sys.argv[1] == '--no-plots':
+    elif len(sys.argv) == 2 and sys.argv[1] == "--no-plots":
         main(plot_traces=False)
     else:
-        raise Exception(
-            "Script only accepts one argument: --no-plots, not %s" %
-            str(sys.argv))
+        raise Exception("Script only accepts one argument: --no-plots, not %s" % str(sys.argv))
```

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/run_RmpRiTau.py` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/run_RmpRiTau.py`

 * *Files 10% similar despite different names*

```diff
@@ -32,222 +32,201 @@
  * @author Werner Van Geit @ BBP
  * @date 2015
 """
 
 # pylint: disable=C0325, W0212, F0401, W0612, F0401
 
 import os
+import sys
+
 import neuron
 import numpy
-import sys
 
 
 def create_cell():
     """Create the cell model"""
     # Load morphology
     neuron.h.load_file("morphology.hoc")
     # Load biophysics
     neuron.h.load_file("biophysics.hoc")
     # Load main cell template
     neuron.h.load_file("template.hoc")
 
     # Instantiate the cell from the template
 
-    print("Loading cell cADpyr232_L5_STPC_d16b0be14e")
-    cell = neuron.h.cADpyr232_L5_STPC_d16b0be14e(0)
+    print("Loading cell cADpyr232_L5_UTPC_5e3840b51e")
+    cell = neuron.h.cADpyr232_L5_UTPC_5e3840b51e(0)
     return cell
 
 
 def create_stimuli(cell, stim_start, stim_end, current_amplitude):
     """Create the stimuli"""
 
-    print('Attaching stimulus electrodes')
+    print("Attaching stimulus electrodes")
 
     stimuli = []
 
     iclamp = neuron.h.IClamp(0.5, sec=cell.soma[0])
     iclamp.delay = stim_start
     iclamp.dur = stim_end - stim_start
     iclamp.amp = current_amplitude
-    print('Setting up step current clamp: '
-          'amp=%f nA, delay=%f ms, duration=%f ms' %
-          (iclamp.amp, iclamp.delay, iclamp.dur))
+    print(
+        "Setting up step current clamp: "
+        "amp=%f nA, delay=%f ms, duration=%f ms" % (iclamp.amp, iclamp.delay, iclamp.dur)
+    )
 
     stimuli.append(iclamp)
 
     return stimuli
 
 
 def create_recordings(cell):
     """Create the recordings"""
-    print('Attaching recording electrodes')
+    print("Attaching recording electrodes")
 
     recordings = {}
 
-    recordings['time'] = neuron.h.Vector()
-    recordings['soma(0.5)'] = neuron.h.Vector()
+    recordings["time"] = neuron.h.Vector()
+    recordings["soma(0.5)"] = neuron.h.Vector()
 
-    recordings['time'].record(neuron.h._ref_t, 0.1)
-    recordings['soma(0.5)'].record(cell.soma[0](0.5)._ref_v, 0.1)
+    recordings["time"].record(neuron.h._ref_t, 0.1)
+    recordings["soma(0.5)"].record(cell.soma[0](0.5)._ref_v, 0.1)
 
     return recordings
 
 
-def run_RmpRiTau_step(
-        stim_start,
-        stim_end,
-        current_amplitude,
-        plot_traces=None):
-    """Run """
+def run_RmpRiTau_step(stim_start, stim_end, current_amplitude, plot_traces=None):
+    """Run"""
 
     cell = create_cell()
     stimuli = create_stimuli(cell, stim_start, stim_end, current_amplitude)  # noqa
     recordings = create_recordings(cell)
 
     # Overriding default 30s simulation,
     neuron.h.tstop = stim_end + stim_start
-    print(
-        'Setting simulation time to %.6g ms for the step current' %
-        neuron.h.tstop)
+    print("Setting simulation time to %.6g ms for the step current" % neuron.h.tstop)
 
-    print('Setting initial voltage to -70 mV')
+    print("Setting initial voltage to -70 mV")
     neuron.h.v_init = -70
 
     neuron.h.stdinit()
     neuron.h.dt = 1000
     neuron.h.t = -1e9
     for _ in range(10):
         neuron.h.fadvance()
 
     neuron.h.t = 0
     neuron.h.dt = 0.025
     neuron.h.frecord_init()
 
     neuron.h.continuerun(3000)
 
-    time = numpy.array(recordings['time'])
-    soma_voltage = numpy.array(recordings['soma(0.5)'])
+    time = numpy.array(recordings["time"])
+    soma_voltage = numpy.array(recordings["soma(0.5)"])
 
-    recordings_dir = 'python_recordings'
+    recordings_dir = "python_recordings"
 
-    soma_voltage_filename = os.path.join(
-        recordings_dir,
-        'soma_voltage_RmpRiTau_step.dat')
+    soma_voltage_filename = os.path.join(recordings_dir, "soma_voltage_RmpRiTau_step.dat")
     numpy.savetxt(soma_voltage_filename, zip(time, soma_voltage))
 
-    print('Soma voltage for RmpRiTau trace saved to: %s'
-          % (soma_voltage_filename))
+    print("Soma voltage for RmpRiTau trace saved to: %s" % (soma_voltage_filename))
 
     if plot_traces:
         import pylab
-        pylab.figure(facecolor='white')
-        pylab.plot(recordings['time'], recordings['soma(0.5)'])
-        pylab.xlabel('time (ms)')
-        pylab.ylabel('Vm (mV)')
-        pylab.gcf().canvas.set_window_title('RmpRiTau trace')
+
+        pylab.figure(facecolor="white")
+        pylab.plot(recordings["time"], recordings["soma(0.5)"])
+        pylab.xlabel("time (ms)")
+        pylab.ylabel("Vm (mV)")
+        pylab.gcf().canvas.set_window_title("RmpRiTau trace")
 
     return time, soma_voltage, stim_start, stim_end
 
 
 def init_simulation():
     """Initialise simulation environment"""
 
     neuron.h.load_file("stdrun.hoc")
     neuron.h.load_file("import3d.hoc")
 
-    print('Loading constants')
-    neuron.h.load_file('constants.hoc')
+    print("Loading constants")
+    neuron.h.load_file("constants.hoc")
 
 
-def analyse_RmpRiTau_trace(
-        time,
-        soma_voltage,
-        stim_start,
-        stim_end,
-        current_amplitude):
+def analyse_RmpRiTau_trace(time, soma_voltage, stim_start, stim_end, current_amplitude):
     """Analyse the output of the RmpRiTau protocol"""
 
     # Import the eFeature Extraction Library
     import efel
 
     # Prepare the trace data
     trace = {}
-    trace['T'] = time
-    trace['V'] = soma_voltage
-    trace['stim_start'] = [stim_start]
-    trace['stim_end'] = [stim_end]
+    trace["T"] = time
+    trace["V"] = soma_voltage
+    trace["stim_start"] = [stim_start]
+    trace["stim_end"] = [stim_end]
 
     # Calculate the necessary eFeatures
     efel_results = efel.getFeatureValues(
-        [trace],
-        ['voltage_base', 'steady_state_voltage_stimend',
-         'decay_time_constant_after_stim'])
-
-    voltage_base = efel_results[0]['voltage_base'][0]
-    ss_voltage = efel_results[0]['steady_state_voltage_stimend'][0]
-    dct = efel_results[0]['decay_time_constant_after_stim'][0]
+        [trace], ["voltage_base", "steady_state_voltage_stimend", "decay_time_constant_after_stim"]
+    )
+
+    voltage_base = efel_results[0]["voltage_base"][0]
+    ss_voltage = efel_results[0]["steady_state_voltage_stimend"][0]
+    dct = efel_results[0]["decay_time_constant_after_stim"][0]
 
     # Calculate input resistance
     input_resistance = float(ss_voltage - voltage_base) / current_amplitude
 
     rmpritau_dict = {}
 
-    rmpritau_dict['Rmp'] = '%.6g' % voltage_base
-    rmpritau_dict['Rmp_Units'] = 'mV'
-    rmpritau_dict['Rin'] = '%.6g' % input_resistance
-    rmpritau_dict['Rin_Units'] = 'MOhm'
-    rmpritau_dict['Tau'] = '%.6g' % dct
-    rmpritau_dict['Tau_Units'] = 'ms'
-
-    print('Resting membrane potential is %s %s' %
-          (rmpritau_dict['Rmp'], rmpritau_dict['Rmp_Units']))
-    print('Input resistance is %s %s' %
-          (rmpritau_dict['Rin'], rmpritau_dict['Rin_Units']))
-    print('Time constant is %s %s' %
-          (rmpritau_dict['Tau'], rmpritau_dict['Tau_Units']))
+    rmpritau_dict["Rmp"] = "%.6g" % voltage_base
+    rmpritau_dict["Rmp_Units"] = "mV"
+    rmpritau_dict["Rin"] = "%.6g" % input_resistance
+    rmpritau_dict["Rin_Units"] = "MOhm"
+    rmpritau_dict["Tau"] = "%.6g" % dct
+    rmpritau_dict["Tau_Units"] = "ms"
+
+    print("Resting membrane potential is %s %s" % (rmpritau_dict["Rmp"], rmpritau_dict["Rmp_Units"]))
+    print("Input resistance is %s %s" % (rmpritau_dict["Rin"], rmpritau_dict["Rin_Units"]))
+    print("Time constant is %s %s" % (rmpritau_dict["Tau"], rmpritau_dict["Tau_Units"]))
 
     import json
 
-    with open('rmp_ri_tau.json', 'w') as rmpritau_json_file:
-        json.dump(rmpritau_dict, rmpritau_json_file,
-                        sort_keys=True,
-                        indent=4,
-                        separators=(',', ': '))
+    with open("rmp_ri_tau.json", "w") as rmpritau_json_file:
+        json.dump(rmpritau_dict, rmpritau_json_file, sort_keys=True, indent=4, separators=(",", ": "))
 
 
 def main(plot_traces=False):
     """Main"""
 
     # Import matplotlib to plot the traces
     if plot_traces:
         import matplotlib
-        matplotlib.rcParams['path.simplify'] = False
+
+        matplotlib.rcParams["path.simplify"] = False
 
     init_simulation()
 
     current_amplitude = -0.01
     stim_start = 1000
     stim_end = 2000
 
     time, soma_voltage, stim_start, stim_end = run_RmpRiTau_step(
-        stim_start, stim_end, current_amplitude, plot_traces=plot_traces)
+        stim_start, stim_end, current_amplitude, plot_traces=plot_traces
+    )
 
-    analyse_RmpRiTau_trace(
-        time,
-        soma_voltage,
-        stim_start,
-        stim_end,
-        current_amplitude)
+    analyse_RmpRiTau_trace(time, soma_voltage, stim_start, stim_end, current_amplitude)
 
     if plot_traces:
         import pylab
+
         pylab.show()
 
-if __name__ == '__main__':
+
+if __name__ == "__main__":
     if len(sys.argv) == 1:
         main(plot_traces=True)
-    elif len(sys.argv) == 2 and sys.argv[1] == '--no-plots':
+    elif len(sys.argv) == 2 and sys.argv[1] == "--no-plots":
         main(plot_traces=False)
     else:
-        raise Exception(
-            "Script only accepts one argument: --no-plots, not %s" %
-            str(sys.argv))
+        raise Exception("Script only accepts one argument: --no-plots, not %s" % str(sys.argv))
```

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/synapses/mtype_map.tsv` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/synapses/mtype_map.tsv`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/synapses/synapses.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/synapses/synapses.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/synapses/synapses.tsv` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/synapses/synapses.tsv`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/synapses/synconf.txt` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/synapses/synconf.txt`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/template.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/template.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/LICENSE` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/LICENSE`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/README` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/README`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/biophysics.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/biophysics.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/constants.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/constants.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/creategui.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/creategui.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/createsimulation.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/createsimulation.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/init.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/init.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/CaDynamics_E2.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/CaDynamics_E2.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/Ca_HVA.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/Ca_HVA.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/Ca_LVAst.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/Ca_LVAst.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/Ih.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/Ih.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/Im.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/Im.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/K_Pst.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/K_Pst.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/K_Tst.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/K_Tst.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/NaTa_t.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/NaTa_t.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/NaTs2_t.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/NaTs2_t.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/Nap_Et2.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/Nap_Et2.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/ProbAMPANMDA_EMS.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/ProbAMPANMDA_EMS.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/ProbGABAAB_EMS.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/ProbGABAAB_EMS.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/SK_E2.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/SK_E2.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/SKv3_1.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mechanisms/SKv3_1.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/morphology/dend-C060114A2_axon-C060114A5.asc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/morphology/dend-C060114A2_axon-C060114A5.asc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/morphology.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/morphology.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mosinit.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/mosinit.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/ringplot.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/ringplot.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/run.py` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_STPC_cADpyr232_1/run.py`

 * *Files 8% similar despite different names*

```diff
@@ -32,158 +32,155 @@
  * @author Werner Van Geit @ BBP
  * @date 2015
 """
 
 # pylint: disable=C0325, W0212, F0401, W0612, F0401
 
 import os
+import sys
+
 import neuron
 import numpy
-import sys
 
 
 def create_cell(add_synapses=True):
     """Create the cell model"""
     # Load morphology
     neuron.h.load_file("morphology.hoc")
     # Load biophysics
     neuron.h.load_file("biophysics.hoc")
     # Load main cell template
     neuron.h.load_file("template.hoc")
 
     # Instantiate the cell from the template
 
-    print("Loading cell cADpyr232_L5_TTPC1_0fb1ca4724")
-    cell = neuron.h.cADpyr232_L5_TTPC1_0fb1ca4724(1 if add_synapses else 0)
+    print("Loading cell cADpyr232_L5_STPC_d16b0be14e")
+    cell = neuron.h.cADpyr232_L5_STPC_d16b0be14e(1 if add_synapses else 0)
     return cell
 
 
 def create_stimuli(cell, step_number):
     """Create the stimuli"""
 
-    print('Attaching stimulus electrodes')
+    print("Attaching stimulus electrodes")
 
     stimuli = []
     step_amp = [0] * 3
 
-    with open('current_amps.dat', 'r') as current_amps_file:
-        first_line = current_amps_file.read().split('\n')[0].strip()
-        hyp_amp, step_amp[0], step_amp[1], step_amp[2] = first_line.split(' ')
+    with open("current_amps.dat", "r") as current_amps_file:
+        first_line = current_amps_file.read().split("\n")[0].strip()
+        hyp_amp, step_amp[0], step_amp[1], step_amp[2] = first_line.split(" ")
 
     iclamp = neuron.h.IClamp(0.5, sec=cell.soma[0])
     iclamp.delay = 700
     iclamp.dur = 2000
     iclamp.amp = float(step_amp[step_number - 1])
-    print('Setting up step current clamp: '
-          'amp=%f nA, delay=%f ms, duration=%f ms' %
-          (iclamp.amp, iclamp.delay, iclamp.dur))
+    print(
+        "Setting up step current clamp: "
+        "amp=%f nA, delay=%f ms, duration=%f ms" % (iclamp.amp, iclamp.delay, iclamp.dur)
+    )
 
     stimuli.append(iclamp)
 
     hyp_iclamp = neuron.h.IClamp(0.5, sec=cell.soma[0])
     hyp_iclamp.delay = 0
     hyp_iclamp.dur = 3000
     hyp_iclamp.amp = float(hyp_amp)
-    print('Setting up hypamp current clamp: '
-          'amp=%f nA, delay=%f ms, duration=%f ms' %
-          (hyp_iclamp.amp, hyp_iclamp.delay, hyp_iclamp.dur))
+    print(
+        "Setting up hypamp current clamp: "
+        "amp=%f nA, delay=%f ms, duration=%f ms" % (hyp_iclamp.amp, hyp_iclamp.delay, hyp_iclamp.dur)
+    )
 
     stimuli.append(hyp_iclamp)
 
     return stimuli
 
 
 def create_recordings(cell):
     """Create the recordings"""
-    print('Attaching recording electrodes')
+    print("Attaching recording electrodes")
 
     recordings = {}
 
-    recordings['time'] = neuron.h.Vector()
-    recordings['soma(0.5)'] = neuron.h.Vector()
+    recordings["time"] = neuron.h.Vector()
+    recordings["soma(0.5)"] = neuron.h.Vector()
 
-    recordings['time'].record(neuron.h._ref_t, 0.1)
-    recordings['soma(0.5)'].record(cell.soma[0](0.5)._ref_v, 0.1)
+    recordings["time"].record(neuron.h._ref_t, 0.1)
+    recordings["soma(0.5)"].record(cell.soma[0](0.5)._ref_v, 0.1)
 
     return recordings
 
 
 def run_step(step_number, plot_traces=None):
     """Run step current simulation with index step_number"""
 
     cell = create_cell(add_synapses=False)
     stimuli = create_stimuli(cell, step_number)
     recordings = create_recordings(cell)
 
     # Overriding default 30s simulation,
-    print('Setting simulation time to 3s for the step currents')
+    print("Setting simulation time to 3s for the step currents")
     neuron.h.tstop = 3000
 
-    print('Disabling variable timestep integration')
+    print("Disabling variable timestep integration")
     neuron.h.cvode_active(0)
 
-    print('Running for %f ms' % neuron.h.tstop)
+    print("Running for %f ms" % neuron.h.tstop)
     neuron.h.run()
 
-    time = numpy.array(recordings['time'])
-    soma_voltage = numpy.array(recordings['soma(0.5)'])
+    time = numpy.array(recordings["time"])
+    soma_voltage = numpy.array(recordings["soma(0.5)"])
 
-    recordings_dir = 'python_recordings'
+    recordings_dir = "python_recordings"
 
-    soma_voltage_filename = os.path.join(
-        recordings_dir,
-        'soma_voltage_step%d.dat' % step_number)
-    numpy.savetxt(
-            soma_voltage_filename,
-            numpy.transpose(
-               numpy.vstack((
-                    time,
-                    soma_voltage))))
+    soma_voltage_filename = os.path.join(recordings_dir, "soma_voltage_step%d.dat" % step_number)
+    numpy.savetxt(soma_voltage_filename, numpy.transpose(numpy.vstack((time, soma_voltage))))
 
-    print('Soma voltage for step %d saved to: %s'
-          % (step_number, soma_voltage_filename))
+    print("Soma voltage for step %d saved to: %s" % (step_number, soma_voltage_filename))
 
     if plot_traces:
         import pylab
+
         pylab.figure()
-        pylab.plot(recordings['time'], recordings['soma(0.5)'])
-        pylab.xlabel('time (ms)')
-        pylab.ylabel('Vm (mV)')
-        pylab.gcf().canvas.set_window_title('Step %d' % step_number)
+        pylab.plot(recordings["time"], recordings["soma(0.5)"])
+        pylab.xlabel("time (ms)")
+        pylab.ylabel("Vm (mV)")
+        pylab.gcf().canvas.set_window_title("Step %d" % step_number)
 
 
 def init_simulation():
     """Initialise simulation environment"""
 
     neuron.h.load_file("stdrun.hoc")
     neuron.h.load_file("import3d.hoc")
 
-    print('Loading constants')
-    neuron.h.load_file('constants.hoc')
+    print("Loading constants")
+    neuron.h.load_file("constants.hoc")
 
 
 def main(plot_traces=True):
     """Main"""
 
     # Import matplotlib to plot the traces
     if plot_traces:
         import matplotlib
-        matplotlib.rcParams['path.simplify'] = False
+
+        matplotlib.rcParams["path.simplify"] = False
 
     init_simulation()
 
     for step_number in range(1, 4):
         run_step(step_number, plot_traces=plot_traces)
 
     if plot_traces:
         import pylab
+
         pylab.show()
 
-if __name__ == '__main__':
+
+if __name__ == "__main__":
     if len(sys.argv) == 1:
         main(plot_traces=True)
-    elif len(sys.argv) == 2 and sys.argv[1] == '--no-plots':
+    elif len(sys.argv) == 2 and sys.argv[1] == "--no-plots":
         main(plot_traces=False)
     else:
-        raise Exception(
-            "Script only accepts one argument: --no-plots, not %s" %
-            str(sys.argv))
+        raise Exception("Script only accepts one argument: --no-plots, not %s" % str(sys.argv))
```

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/run_RmpRiTau.py` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/run_RmpRiTau.py`

 * *Files 10% similar despite different names*

```diff
@@ -32,17 +32,18 @@
  * @author Werner Van Geit @ BBP
  * @date 2015
 """
 
 # pylint: disable=C0325, W0212, F0401, W0612, F0401
 
 import os
+import sys
+
 import neuron
 import numpy
-import sys
 
 
 def create_cell():
     """Create the cell model"""
     # Load morphology
     neuron.h.load_file("morphology.hoc")
     # Load biophysics
@@ -56,198 +57,176 @@
     cell = neuron.h.cADpyr232_L5_TTPC1_0fb1ca4724(0)
     return cell
 
 
 def create_stimuli(cell, stim_start, stim_end, current_amplitude):
     """Create the stimuli"""
 
-    print('Attaching stimulus electrodes')
+    print("Attaching stimulus electrodes")
 
     stimuli = []
 
     iclamp = neuron.h.IClamp(0.5, sec=cell.soma[0])
     iclamp.delay = stim_start
     iclamp.dur = stim_end - stim_start
     iclamp.amp = current_amplitude
-    print('Setting up step current clamp: '
-          'amp=%f nA, delay=%f ms, duration=%f ms' %
-          (iclamp.amp, iclamp.delay, iclamp.dur))
+    print(
+        "Setting up step current clamp: "
+        "amp=%f nA, delay=%f ms, duration=%f ms" % (iclamp.amp, iclamp.delay, iclamp.dur)
+    )
 
     stimuli.append(iclamp)
 
     return stimuli
 
 
 def create_recordings(cell):
     """Create the recordings"""
-    print('Attaching recording electrodes')
+    print("Attaching recording electrodes")
 
     recordings = {}
 
-    recordings['time'] = neuron.h.Vector()
-    recordings['soma(0.5)'] = neuron.h.Vector()
+    recordings["time"] = neuron.h.Vector()
+    recordings["soma(0.5)"] = neuron.h.Vector()
 
-    recordings['time'].record(neuron.h._ref_t, 0.1)
-    recordings['soma(0.5)'].record(cell.soma[0](0.5)._ref_v, 0.1)
+    recordings["time"].record(neuron.h._ref_t, 0.1)
+    recordings["soma(0.5)"].record(cell.soma[0](0.5)._ref_v, 0.1)
 
     return recordings
 
 
-def run_RmpRiTau_step(
-        stim_start,
-        stim_end,
-        current_amplitude,
-        plot_traces=None):
-    """Run """
+def run_RmpRiTau_step(stim_start, stim_end, current_amplitude, plot_traces=None):
+    """Run"""
 
     cell = create_cell()
     stimuli = create_stimuli(cell, stim_start, stim_end, current_amplitude)  # noqa
     recordings = create_recordings(cell)
 
     # Overriding default 30s simulation,
     neuron.h.tstop = stim_end + stim_start
-    print(
-        'Setting simulation time to %.6g ms for the step current' %
-        neuron.h.tstop)
+    print("Setting simulation time to %.6g ms for the step current" % neuron.h.tstop)
 
-    print('Setting initial voltage to -70 mV')
+    print("Setting initial voltage to -70 mV")
     neuron.h.v_init = -70
 
     neuron.h.stdinit()
     neuron.h.dt = 1000
     neuron.h.t = -1e9
     for _ in range(10):
         neuron.h.fadvance()
 
     neuron.h.t = 0
     neuron.h.dt = 0.025
     neuron.h.frecord_init()
 
     neuron.h.continuerun(3000)
 
-    time = numpy.array(recordings['time'])
-    soma_voltage = numpy.array(recordings['soma(0.5)'])
+    time = numpy.array(recordings["time"])
+    soma_voltage = numpy.array(recordings["soma(0.5)"])
 
-    recordings_dir = 'python_recordings'
+    recordings_dir = "python_recordings"
 
-    soma_voltage_filename = os.path.join(
-        recordings_dir,
-        'soma_voltage_RmpRiTau_step.dat')
+    soma_voltage_filename = os.path.join(recordings_dir, "soma_voltage_RmpRiTau_step.dat")
     numpy.savetxt(soma_voltage_filename, zip(time, soma_voltage))
 
-    print('Soma voltage for RmpRiTau trace saved to: %s'
-          % (soma_voltage_filename))
+    print("Soma voltage for RmpRiTau trace saved to: %s" % (soma_voltage_filename))
 
     if plot_traces:
         import pylab
-        pylab.figure(facecolor='white')
-        pylab.plot(recordings['time'], recordings['soma(0.5)'])
-        pylab.xlabel('time (ms)')
-        pylab.ylabel('Vm (mV)')
-        pylab.gcf().canvas.set_window_title('RmpRiTau trace')
+
+        pylab.figure(facecolor="white")
+        pylab.plot(recordings["time"], recordings["soma(0.5)"])
+        pylab.xlabel("time (ms)")
+        pylab.ylabel("Vm (mV)")
+        pylab.gcf().canvas.set_window_title("RmpRiTau trace")
 
     return time, soma_voltage, stim_start, stim_end
 
 
 def init_simulation():
     """Initialise simulation environment"""
 
     neuron.h.load_file("stdrun.hoc")
     neuron.h.load_file("import3d.hoc")
 
-    print('Loading constants')
-    neuron.h.load_file('constants.hoc')
+    print("Loading constants")
+    neuron.h.load_file("constants.hoc")
 
 
-def analyse_RmpRiTau_trace(
-        time,
-        soma_voltage,
-        stim_start,
-        stim_end,
-        current_amplitude):
+def analyse_RmpRiTau_trace(time, soma_voltage, stim_start, stim_end, current_amplitude):
     """Analyse the output of the RmpRiTau protocol"""
 
     # Import the eFeature Extraction Library
     import efel
 
     # Prepare the trace data
     trace = {}
-    trace['T'] = time
-    trace['V'] = soma_voltage
-    trace['stim_start'] = [stim_start]
-    trace['stim_end'] = [stim_end]
+    trace["T"] = time
+    trace["V"] = soma_voltage
+    trace["stim_start"] = [stim_start]
+    trace["stim_end"] = [stim_end]
 
     # Calculate the necessary eFeatures
     efel_results = efel.getFeatureValues(
-        [trace],
-        ['voltage_base', 'steady_state_voltage_stimend',
-         'decay_time_constant_after_stim'])
-
-    voltage_base = efel_results[0]['voltage_base'][0]
-    ss_voltage = efel_results[0]['steady_state_voltage_stimend'][0]
-    dct = efel_results[0]['decay_time_constant_after_stim'][0]
+        [trace], ["voltage_base", "steady_state_voltage_stimend", "decay_time_constant_after_stim"]
+    )
+
+    voltage_base = efel_results[0]["voltage_base"][0]
+    ss_voltage = efel_results[0]["steady_state_voltage_stimend"][0]
+    dct = efel_results[0]["decay_time_constant_after_stim"][0]
 
     # Calculate input resistance
     input_resistance = float(ss_voltage - voltage_base) / current_amplitude
 
     rmpritau_dict = {}
 
-    rmpritau_dict['Rmp'] = '%.6g' % voltage_base
-    rmpritau_dict['Rmp_Units'] = 'mV'
-    rmpritau_dict['Rin'] = '%.6g' % input_resistance
-    rmpritau_dict['Rin_Units'] = 'MOhm'
-    rmpritau_dict['Tau'] = '%.6g' % dct
-    rmpritau_dict['Tau_Units'] = 'ms'
-
-    print('Resting membrane potential is %s %s' %
-          (rmpritau_dict['Rmp'], rmpritau_dict['Rmp_Units']))
-    print('Input resistance is %s %s' %
-          (rmpritau_dict['Rin'], rmpritau_dict['Rin_Units']))
-    print('Time constant is %s %s' %
-          (rmpritau_dict['Tau'], rmpritau_dict['Tau_Units']))
+    rmpritau_dict["Rmp"] = "%.6g" % voltage_base
+    rmpritau_dict["Rmp_Units"] = "mV"
+    rmpritau_dict["Rin"] = "%.6g" % input_resistance
+    rmpritau_dict["Rin_Units"] = "MOhm"
+    rmpritau_dict["Tau"] = "%.6g" % dct
+    rmpritau_dict["Tau_Units"] = "ms"
+
+    print("Resting membrane potential is %s %s" % (rmpritau_dict["Rmp"], rmpritau_dict["Rmp_Units"]))
+    print("Input resistance is %s %s" % (rmpritau_dict["Rin"], rmpritau_dict["Rin_Units"]))
+    print("Time constant is %s %s" % (rmpritau_dict["Tau"], rmpritau_dict["Tau_Units"]))
 
     import json
 
-    with open('rmp_ri_tau.json', 'w') as rmpritau_json_file:
-        json.dump(rmpritau_dict, rmpritau_json_file,
-                        sort_keys=True,
-                        indent=4,
-                        separators=(',', ': '))
+    with open("rmp_ri_tau.json", "w") as rmpritau_json_file:
+        json.dump(rmpritau_dict, rmpritau_json_file, sort_keys=True, indent=4, separators=(",", ": "))
 
 
 def main(plot_traces=False):
     """Main"""
 
     # Import matplotlib to plot the traces
     if plot_traces:
         import matplotlib
-        matplotlib.rcParams['path.simplify'] = False
+
+        matplotlib.rcParams["path.simplify"] = False
 
     init_simulation()
 
     current_amplitude = -0.01
     stim_start = 1000
     stim_end = 2000
 
     time, soma_voltage, stim_start, stim_end = run_RmpRiTau_step(
-        stim_start, stim_end, current_amplitude, plot_traces=plot_traces)
+        stim_start, stim_end, current_amplitude, plot_traces=plot_traces
+    )
 
-    analyse_RmpRiTau_trace(
-        time,
-        soma_voltage,
-        stim_start,
-        stim_end,
-        current_amplitude)
+    analyse_RmpRiTau_trace(time, soma_voltage, stim_start, stim_end, current_amplitude)
 
     if plot_traces:
         import pylab
+
         pylab.show()
 
-if __name__ == '__main__':
+
+if __name__ == "__main__":
     if len(sys.argv) == 1:
         main(plot_traces=True)
-    elif len(sys.argv) == 2 and sys.argv[1] == '--no-plots':
+    elif len(sys.argv) == 2 and sys.argv[1] == "--no-plots":
         main(plot_traces=False)
     else:
-        raise Exception(
-            "Script only accepts one argument: --no-plots, not %s" %
-            str(sys.argv))
+        raise Exception("Script only accepts one argument: --no-plots, not %s" % str(sys.argv))
```

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/synapses/mtype_map.tsv` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/synapses/mtype_map.tsv`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/synapses/synapses.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/synapses/synapses.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/synapses/synapses.tsv` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/synapses/synapses.tsv`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/synapses/synconf.txt` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/synapses/synconf.txt`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/template.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/template.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/LICENSE` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/LICENSE`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/README` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/README`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/biophysics.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/biophysics.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/constants.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/constants.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/creategui.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/creategui.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/createsimulation.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/createsimulation.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/init.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/init.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/CaDynamics_E2.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/CaDynamics_E2.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/Ca_HVA.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/Ca_HVA.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/Ca_LVAst.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/Ca_LVAst.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/Ih.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/Ih.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/Im.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/Im.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/K_Pst.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/K_Pst.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/K_Tst.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/K_Tst.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/NaTa_t.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/NaTa_t.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/NaTs2_t.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/NaTs2_t.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/Nap_Et2.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/Nap_Et2.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/ProbAMPANMDA_EMS.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/ProbAMPANMDA_EMS.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/ProbGABAAB_EMS.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/ProbGABAAB_EMS.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/SK_E2.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/SK_E2.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/SKv3_1.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mechanisms/SKv3_1.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/morphology/dend-C060114A7_axon-C060116A3_-_Clone_2.asc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/morphology/dend-C060114A7_axon-C060116A3_-_Clone_2.asc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/morphology.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/morphology.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mosinit.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/mosinit.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/ringplot.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/ringplot.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/run.py` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_SBC_bNAC219_1/run.py`

 * *Files 11% similar despite different names*

```diff
@@ -32,158 +32,155 @@
  * @author Werner Van Geit @ BBP
  * @date 2015
 """
 
 # pylint: disable=C0325, W0212, F0401, W0612, F0401
 
 import os
+import sys
+
 import neuron
 import numpy
-import sys
 
 
 def create_cell(add_synapses=True):
     """Create the cell model"""
     # Load morphology
     neuron.h.load_file("morphology.hoc")
     # Load biophysics
     neuron.h.load_file("biophysics.hoc")
     # Load main cell template
     neuron.h.load_file("template.hoc")
 
     # Instantiate the cell from the template
 
-    print("Loading cell cADpyr232_L5_TTPC2_8052133265")
-    cell = neuron.h.cADpyr232_L5_TTPC2_8052133265(1 if add_synapses else 0)
+    print("Loading cell bNAC219_L5_SBC_77ab259b7f")
+    cell = neuron.h.bNAC219_L5_SBC_77ab259b7f(1 if add_synapses else 0)
     return cell
 
 
 def create_stimuli(cell, step_number):
     """Create the stimuli"""
 
-    print('Attaching stimulus electrodes')
+    print("Attaching stimulus electrodes")
 
     stimuli = []
     step_amp = [0] * 3
 
-    with open('current_amps.dat', 'r') as current_amps_file:
-        first_line = current_amps_file.read().split('\n')[0].strip()
-        hyp_amp, step_amp[0], step_amp[1], step_amp[2] = first_line.split(' ')
+    with open("current_amps.dat", "r") as current_amps_file:
+        first_line = current_amps_file.read().split("\n")[0].strip()
+        hyp_amp, step_amp[0], step_amp[1], step_amp[2] = first_line.split(" ")
 
     iclamp = neuron.h.IClamp(0.5, sec=cell.soma[0])
     iclamp.delay = 700
     iclamp.dur = 2000
     iclamp.amp = float(step_amp[step_number - 1])
-    print('Setting up step current clamp: '
-          'amp=%f nA, delay=%f ms, duration=%f ms' %
-          (iclamp.amp, iclamp.delay, iclamp.dur))
+    print(
+        "Setting up step current clamp: "
+        "amp=%f nA, delay=%f ms, duration=%f ms" % (iclamp.amp, iclamp.delay, iclamp.dur)
+    )
 
     stimuli.append(iclamp)
 
     hyp_iclamp = neuron.h.IClamp(0.5, sec=cell.soma[0])
     hyp_iclamp.delay = 0
     hyp_iclamp.dur = 3000
     hyp_iclamp.amp = float(hyp_amp)
-    print('Setting up hypamp current clamp: '
-          'amp=%f nA, delay=%f ms, duration=%f ms' %
-          (hyp_iclamp.amp, hyp_iclamp.delay, hyp_iclamp.dur))
+    print(
+        "Setting up hypamp current clamp: "
+        "amp=%f nA, delay=%f ms, duration=%f ms" % (hyp_iclamp.amp, hyp_iclamp.delay, hyp_iclamp.dur)
+    )
 
     stimuli.append(hyp_iclamp)
 
     return stimuli
 
 
 def create_recordings(cell):
     """Create the recordings"""
-    print('Attaching recording electrodes')
+    print("Attaching recording electrodes")
 
     recordings = {}
 
-    recordings['time'] = neuron.h.Vector()
-    recordings['soma(0.5)'] = neuron.h.Vector()
+    recordings["time"] = neuron.h.Vector()
+    recordings["soma(0.5)"] = neuron.h.Vector()
 
-    recordings['time'].record(neuron.h._ref_t, 0.1)
-    recordings['soma(0.5)'].record(cell.soma[0](0.5)._ref_v, 0.1)
+    recordings["time"].record(neuron.h._ref_t, 0.1)
+    recordings["soma(0.5)"].record(cell.soma[0](0.5)._ref_v, 0.1)
 
     return recordings
 
 
 def run_step(step_number, plot_traces=None):
     """Run step current simulation with index step_number"""
 
     cell = create_cell(add_synapses=False)
     stimuli = create_stimuli(cell, step_number)
     recordings = create_recordings(cell)
 
     # Overriding default 30s simulation,
-    print('Setting simulation time to 3s for the step currents')
+    print("Setting simulation time to 3s for the step currents")
     neuron.h.tstop = 3000
 
-    print('Disabling variable timestep integration')
+    print("Disabling variable timestep integration")
     neuron.h.cvode_active(0)
 
-    print('Running for %f ms' % neuron.h.tstop)
+    print("Running for %f ms" % neuron.h.tstop)
     neuron.h.run()
 
-    time = numpy.array(recordings['time'])
-    soma_voltage = numpy.array(recordings['soma(0.5)'])
+    time = numpy.array(recordings["time"])
+    soma_voltage = numpy.array(recordings["soma(0.5)"])
 
-    recordings_dir = 'python_recordings'
+    recordings_dir = "python_recordings"
 
-    soma_voltage_filename = os.path.join(
-        recordings_dir,
-        'soma_voltage_step%d.dat' % step_number)
-    numpy.savetxt(
-            soma_voltage_filename,
-            numpy.transpose(
-               numpy.vstack((
-                    time,
-                    soma_voltage))))
+    soma_voltage_filename = os.path.join(recordings_dir, "soma_voltage_step%d.dat" % step_number)
+    numpy.savetxt(soma_voltage_filename, numpy.transpose(numpy.vstack((time, soma_voltage))))
 
-    print('Soma voltage for step %d saved to: %s'
-          % (step_number, soma_voltage_filename))
+    print("Soma voltage for step %d saved to: %s" % (step_number, soma_voltage_filename))
 
     if plot_traces:
         import pylab
+
         pylab.figure()
-        pylab.plot(recordings['time'], recordings['soma(0.5)'])
-        pylab.xlabel('time (ms)')
-        pylab.ylabel('Vm (mV)')
-        pylab.gcf().canvas.set_window_title('Step %d' % step_number)
+        pylab.plot(recordings["time"], recordings["soma(0.5)"])
+        pylab.xlabel("time (ms)")
+        pylab.ylabel("Vm (mV)")
+        pylab.gcf().canvas.set_window_title("Step %d" % step_number)
 
 
 def init_simulation():
     """Initialise simulation environment"""
 
     neuron.h.load_file("stdrun.hoc")
     neuron.h.load_file("import3d.hoc")
 
-    print('Loading constants')
-    neuron.h.load_file('constants.hoc')
+    print("Loading constants")
+    neuron.h.load_file("constants.hoc")
 
 
 def main(plot_traces=True):
     """Main"""
 
     # Import matplotlib to plot the traces
     if plot_traces:
         import matplotlib
-        matplotlib.rcParams['path.simplify'] = False
+
+        matplotlib.rcParams["path.simplify"] = False
 
     init_simulation()
 
     for step_number in range(1, 4):
         run_step(step_number, plot_traces=plot_traces)
 
     if plot_traces:
         import pylab
+
         pylab.show()
 
-if __name__ == '__main__':
+
+if __name__ == "__main__":
     if len(sys.argv) == 1:
         main(plot_traces=True)
-    elif len(sys.argv) == 2 and sys.argv[1] == '--no-plots':
+    elif len(sys.argv) == 2 and sys.argv[1] == "--no-plots":
         main(plot_traces=False)
     else:
-        raise Exception(
-            "Script only accepts one argument: --no-plots, not %s" %
-            str(sys.argv))
+        raise Exception("Script only accepts one argument: --no-plots, not %s" % str(sys.argv))
```

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/run_RmpRiTau.py` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_MC_bAC217_1/run_RmpRiTau.py`

 * *Files 12% similar despite different names*

```diff
@@ -32,222 +32,201 @@
  * @author Werner Van Geit @ BBP
  * @date 2015
 """
 
 # pylint: disable=C0325, W0212, F0401, W0612, F0401
 
 import os
+import sys
+
 import neuron
 import numpy
-import sys
 
 
 def create_cell():
     """Create the cell model"""
     # Load morphology
     neuron.h.load_file("morphology.hoc")
     # Load biophysics
     neuron.h.load_file("biophysics.hoc")
     # Load main cell template
     neuron.h.load_file("template.hoc")
 
     # Instantiate the cell from the template
 
-    print("Loading cell cADpyr232_L5_TTPC2_8052133265")
-    cell = neuron.h.cADpyr232_L5_TTPC2_8052133265(0)
+    print("Loading cell bAC217_L5_MC_cc2a170ef6")
+    cell = neuron.h.bAC217_L5_MC_cc2a170ef6(0)
     return cell
 
 
 def create_stimuli(cell, stim_start, stim_end, current_amplitude):
     """Create the stimuli"""
 
-    print('Attaching stimulus electrodes')
+    print("Attaching stimulus electrodes")
 
     stimuli = []
 
     iclamp = neuron.h.IClamp(0.5, sec=cell.soma[0])
     iclamp.delay = stim_start
     iclamp.dur = stim_end - stim_start
     iclamp.amp = current_amplitude
-    print('Setting up step current clamp: '
-          'amp=%f nA, delay=%f ms, duration=%f ms' %
-          (iclamp.amp, iclamp.delay, iclamp.dur))
+    print(
+        "Setting up step current clamp: "
+        "amp=%f nA, delay=%f ms, duration=%f ms" % (iclamp.amp, iclamp.delay, iclamp.dur)
+    )
 
     stimuli.append(iclamp)
 
     return stimuli
 
 
 def create_recordings(cell):
     """Create the recordings"""
-    print('Attaching recording electrodes')
+    print("Attaching recording electrodes")
 
     recordings = {}
 
-    recordings['time'] = neuron.h.Vector()
-    recordings['soma(0.5)'] = neuron.h.Vector()
+    recordings["time"] = neuron.h.Vector()
+    recordings["soma(0.5)"] = neuron.h.Vector()
 
-    recordings['time'].record(neuron.h._ref_t, 0.1)
-    recordings['soma(0.5)'].record(cell.soma[0](0.5)._ref_v, 0.1)
+    recordings["time"].record(neuron.h._ref_t, 0.1)
+    recordings["soma(0.5)"].record(cell.soma[0](0.5)._ref_v, 0.1)
 
     return recordings
 
 
-def run_RmpRiTau_step(
-        stim_start,
-        stim_end,
-        current_amplitude,
-        plot_traces=None):
-    """Run """
+def run_RmpRiTau_step(stim_start, stim_end, current_amplitude, plot_traces=None):
+    """Run"""
 
     cell = create_cell()
     stimuli = create_stimuli(cell, stim_start, stim_end, current_amplitude)  # noqa
     recordings = create_recordings(cell)
 
     # Overriding default 30s simulation,
     neuron.h.tstop = stim_end + stim_start
-    print(
-        'Setting simulation time to %.6g ms for the step current' %
-        neuron.h.tstop)
+    print("Setting simulation time to %.6g ms for the step current" % neuron.h.tstop)
 
-    print('Setting initial voltage to -70 mV')
+    print("Setting initial voltage to -70 mV")
     neuron.h.v_init = -70
 
     neuron.h.stdinit()
     neuron.h.dt = 1000
     neuron.h.t = -1e9
     for _ in range(10):
         neuron.h.fadvance()
 
     neuron.h.t = 0
     neuron.h.dt = 0.025
     neuron.h.frecord_init()
 
     neuron.h.continuerun(3000)
 
-    time = numpy.array(recordings['time'])
-    soma_voltage = numpy.array(recordings['soma(0.5)'])
+    time = numpy.array(recordings["time"])
+    soma_voltage = numpy.array(recordings["soma(0.5)"])
 
-    recordings_dir = 'python_recordings'
+    recordings_dir = "python_recordings"
 
-    soma_voltage_filename = os.path.join(
-        recordings_dir,
-        'soma_voltage_RmpRiTau_step.dat')
+    soma_voltage_filename = os.path.join(recordings_dir, "soma_voltage_RmpRiTau_step.dat")
     numpy.savetxt(soma_voltage_filename, zip(time, soma_voltage))
 
-    print('Soma voltage for RmpRiTau trace saved to: %s'
-          % (soma_voltage_filename))
+    print("Soma voltage for RmpRiTau trace saved to: %s" % (soma_voltage_filename))
 
     if plot_traces:
         import pylab
-        pylab.figure(facecolor='white')
-        pylab.plot(recordings['time'], recordings['soma(0.5)'])
-        pylab.xlabel('time (ms)')
-        pylab.ylabel('Vm (mV)')
-        pylab.gcf().canvas.set_window_title('RmpRiTau trace')
+
+        pylab.figure(facecolor="white")
+        pylab.plot(recordings["time"], recordings["soma(0.5)"])
+        pylab.xlabel("time (ms)")
+        pylab.ylabel("Vm (mV)")
+        pylab.gcf().canvas.set_window_title("RmpRiTau trace")
 
     return time, soma_voltage, stim_start, stim_end
 
 
 def init_simulation():
     """Initialise simulation environment"""
 
     neuron.h.load_file("stdrun.hoc")
     neuron.h.load_file("import3d.hoc")
 
-    print('Loading constants')
-    neuron.h.load_file('constants.hoc')
+    print("Loading constants")
+    neuron.h.load_file("constants.hoc")
 
 
-def analyse_RmpRiTau_trace(
-        time,
-        soma_voltage,
-        stim_start,
-        stim_end,
-        current_amplitude):
+def analyse_RmpRiTau_trace(time, soma_voltage, stim_start, stim_end, current_amplitude):
     """Analyse the output of the RmpRiTau protocol"""
 
     # Import the eFeature Extraction Library
     import efel
 
     # Prepare the trace data
     trace = {}
-    trace['T'] = time
-    trace['V'] = soma_voltage
-    trace['stim_start'] = [stim_start]
-    trace['stim_end'] = [stim_end]
+    trace["T"] = time
+    trace["V"] = soma_voltage
+    trace["stim_start"] = [stim_start]
+    trace["stim_end"] = [stim_end]
 
     # Calculate the necessary eFeatures
     efel_results = efel.getFeatureValues(
-        [trace],
-        ['voltage_base', 'steady_state_voltage_stimend',
-         'decay_time_constant_after_stim'])
-
-    voltage_base = efel_results[0]['voltage_base'][0]
-    ss_voltage = efel_results[0]['steady_state_voltage_stimend'][0]
-    dct = efel_results[0]['decay_time_constant_after_stim'][0]
+        [trace], ["voltage_base", "steady_state_voltage_stimend", "decay_time_constant_after_stim"]
+    )
+
+    voltage_base = efel_results[0]["voltage_base"][0]
+    ss_voltage = efel_results[0]["steady_state_voltage_stimend"][0]
+    dct = efel_results[0]["decay_time_constant_after_stim"][0]
 
     # Calculate input resistance
     input_resistance = float(ss_voltage - voltage_base) / current_amplitude
 
     rmpritau_dict = {}
 
-    rmpritau_dict['Rmp'] = '%.6g' % voltage_base
-    rmpritau_dict['Rmp_Units'] = 'mV'
-    rmpritau_dict['Rin'] = '%.6g' % input_resistance
-    rmpritau_dict['Rin_Units'] = 'MOhm'
-    rmpritau_dict['Tau'] = '%.6g' % dct
-    rmpritau_dict['Tau_Units'] = 'ms'
-
-    print('Resting membrane potential is %s %s' %
-          (rmpritau_dict['Rmp'], rmpritau_dict['Rmp_Units']))
-    print('Input resistance is %s %s' %
-          (rmpritau_dict['Rin'], rmpritau_dict['Rin_Units']))
-    print('Time constant is %s %s' %
-          (rmpritau_dict['Tau'], rmpritau_dict['Tau_Units']))
+    rmpritau_dict["Rmp"] = "%.6g" % voltage_base
+    rmpritau_dict["Rmp_Units"] = "mV"
+    rmpritau_dict["Rin"] = "%.6g" % input_resistance
+    rmpritau_dict["Rin_Units"] = "MOhm"
+    rmpritau_dict["Tau"] = "%.6g" % dct
+    rmpritau_dict["Tau_Units"] = "ms"
+
+    print("Resting membrane potential is %s %s" % (rmpritau_dict["Rmp"], rmpritau_dict["Rmp_Units"]))
+    print("Input resistance is %s %s" % (rmpritau_dict["Rin"], rmpritau_dict["Rin_Units"]))
+    print("Time constant is %s %s" % (rmpritau_dict["Tau"], rmpritau_dict["Tau_Units"]))
 
     import json
 
-    with open('rmp_ri_tau.json', 'w') as rmpritau_json_file:
-        json.dump(rmpritau_dict, rmpritau_json_file,
-                        sort_keys=True,
-                        indent=4,
-                        separators=(',', ': '))
+    with open("rmp_ri_tau.json", "w") as rmpritau_json_file:
+        json.dump(rmpritau_dict, rmpritau_json_file, sort_keys=True, indent=4, separators=(",", ": "))
 
 
 def main(plot_traces=False):
     """Main"""
 
     # Import matplotlib to plot the traces
     if plot_traces:
         import matplotlib
-        matplotlib.rcParams['path.simplify'] = False
+
+        matplotlib.rcParams["path.simplify"] = False
 
     init_simulation()
 
     current_amplitude = -0.01
     stim_start = 1000
     stim_end = 2000
 
     time, soma_voltage, stim_start, stim_end = run_RmpRiTau_step(
-        stim_start, stim_end, current_amplitude, plot_traces=plot_traces)
+        stim_start, stim_end, current_amplitude, plot_traces=plot_traces
+    )
 
-    analyse_RmpRiTau_trace(
-        time,
-        soma_voltage,
-        stim_start,
-        stim_end,
-        current_amplitude)
+    analyse_RmpRiTau_trace(time, soma_voltage, stim_start, stim_end, current_amplitude)
 
     if plot_traces:
         import pylab
+
         pylab.show()
 
-if __name__ == '__main__':
+
+if __name__ == "__main__":
     if len(sys.argv) == 1:
         main(plot_traces=True)
-    elif len(sys.argv) == 2 and sys.argv[1] == '--no-plots':
+    elif len(sys.argv) == 2 and sys.argv[1] == "--no-plots":
         main(plot_traces=False)
     else:
-        raise Exception(
-            "Script only accepts one argument: --no-plots, not %s" %
-            str(sys.argv))
+        raise Exception("Script only accepts one argument: --no-plots, not %s" % str(sys.argv))
```

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/synapses/mtype_map.tsv` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/synapses/mtype_map.tsv`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/synapses/synapses.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/synapses/synapses.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/synapses/synapses.tsv` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/synapses/synapses.tsv`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/synapses/synconf.txt` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/synapses/synconf.txt`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/template.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC2_cADpyr232_1/template.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/LICENSE` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/LICENSE`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/README` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/README`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/biophysics.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/biophysics.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/constants.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/constants.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/creategui.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/creategui.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/createsimulation.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/createsimulation.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/init.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/init.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/CaDynamics_E2.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/CaDynamics_E2.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/Ca_HVA.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/Ca_HVA.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/Ca_LVAst.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/Ca_LVAst.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/Ih.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/Ih.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/Im.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/Im.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/K_Pst.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/K_Pst.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/K_Tst.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/K_Tst.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/NaTa_t.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/NaTa_t.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/NaTs2_t.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/NaTs2_t.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/Nap_Et2.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/Nap_Et2.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/ProbAMPANMDA_EMS.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/ProbAMPANMDA_EMS.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/ProbGABAAB_EMS.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/ProbGABAAB_EMS.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/SK_E2.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/SK_E2.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/SKv3_1.mod` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mechanisms/SKv3_1.mod`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/morphology/dend-Fluo15_left_axon-Fluo15_left_-_Scale_x1.000_y0.950_z1.000_-_Clone_30.asc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/morphology/dend-Fluo15_left_axon-Fluo15_left_-_Scale_x1.000_y0.950_z1.000_-_Clone_30.asc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/morphology.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/morphology.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mosinit.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/mosinit.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/ringplot.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/ringplot.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/run.py` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_TTPC1_cADpyr232_1/run.py`

 * *Files 8% similar despite different names*

```diff
@@ -32,158 +32,155 @@
  * @author Werner Van Geit @ BBP
  * @date 2015
 """
 
 # pylint: disable=C0325, W0212, F0401, W0612, F0401
 
 import os
+import sys
+
 import neuron
 import numpy
-import sys
 
 
 def create_cell(add_synapses=True):
     """Create the cell model"""
     # Load morphology
     neuron.h.load_file("morphology.hoc")
     # Load biophysics
     neuron.h.load_file("biophysics.hoc")
     # Load main cell template
     neuron.h.load_file("template.hoc")
 
     # Instantiate the cell from the template
 
-    print("Loading cell cADpyr232_L5_UTPC_5e3840b51e")
-    cell = neuron.h.cADpyr232_L5_UTPC_5e3840b51e(1 if add_synapses else 0)
+    print("Loading cell cADpyr232_L5_TTPC1_0fb1ca4724")
+    cell = neuron.h.cADpyr232_L5_TTPC1_0fb1ca4724(1 if add_synapses else 0)
     return cell
 
 
 def create_stimuli(cell, step_number):
     """Create the stimuli"""
 
-    print('Attaching stimulus electrodes')
+    print("Attaching stimulus electrodes")
 
     stimuli = []
     step_amp = [0] * 3
 
-    with open('current_amps.dat', 'r') as current_amps_file:
-        first_line = current_amps_file.read().split('\n')[0].strip()
-        hyp_amp, step_amp[0], step_amp[1], step_amp[2] = first_line.split(' ')
+    with open("current_amps.dat", "r") as current_amps_file:
+        first_line = current_amps_file.read().split("\n")[0].strip()
+        hyp_amp, step_amp[0], step_amp[1], step_amp[2] = first_line.split(" ")
 
     iclamp = neuron.h.IClamp(0.5, sec=cell.soma[0])
     iclamp.delay = 700
     iclamp.dur = 2000
     iclamp.amp = float(step_amp[step_number - 1])
-    print('Setting up step current clamp: '
-          'amp=%f nA, delay=%f ms, duration=%f ms' %
-          (iclamp.amp, iclamp.delay, iclamp.dur))
+    print(
+        "Setting up step current clamp: "
+        "amp=%f nA, delay=%f ms, duration=%f ms" % (iclamp.amp, iclamp.delay, iclamp.dur)
+    )
 
     stimuli.append(iclamp)
 
     hyp_iclamp = neuron.h.IClamp(0.5, sec=cell.soma[0])
     hyp_iclamp.delay = 0
     hyp_iclamp.dur = 3000
     hyp_iclamp.amp = float(hyp_amp)
-    print('Setting up hypamp current clamp: '
-          'amp=%f nA, delay=%f ms, duration=%f ms' %
-          (hyp_iclamp.amp, hyp_iclamp.delay, hyp_iclamp.dur))
+    print(
+        "Setting up hypamp current clamp: "
+        "amp=%f nA, delay=%f ms, duration=%f ms" % (hyp_iclamp.amp, hyp_iclamp.delay, hyp_iclamp.dur)
+    )
 
     stimuli.append(hyp_iclamp)
 
     return stimuli
 
 
 def create_recordings(cell):
     """Create the recordings"""
-    print('Attaching recording electrodes')
+    print("Attaching recording electrodes")
 
     recordings = {}
 
-    recordings['time'] = neuron.h.Vector()
-    recordings['soma(0.5)'] = neuron.h.Vector()
+    recordings["time"] = neuron.h.Vector()
+    recordings["soma(0.5)"] = neuron.h.Vector()
 
-    recordings['time'].record(neuron.h._ref_t, 0.1)
-    recordings['soma(0.5)'].record(cell.soma[0](0.5)._ref_v, 0.1)
+    recordings["time"].record(neuron.h._ref_t, 0.1)
+    recordings["soma(0.5)"].record(cell.soma[0](0.5)._ref_v, 0.1)
 
     return recordings
 
 
 def run_step(step_number, plot_traces=None):
     """Run step current simulation with index step_number"""
 
     cell = create_cell(add_synapses=False)
     stimuli = create_stimuli(cell, step_number)
     recordings = create_recordings(cell)
 
     # Overriding default 30s simulation,
-    print('Setting simulation time to 3s for the step currents')
+    print("Setting simulation time to 3s for the step currents")
     neuron.h.tstop = 3000
 
-    print('Disabling variable timestep integration')
+    print("Disabling variable timestep integration")
     neuron.h.cvode_active(0)
 
-    print('Running for %f ms' % neuron.h.tstop)
+    print("Running for %f ms" % neuron.h.tstop)
     neuron.h.run()
 
-    time = numpy.array(recordings['time'])
-    soma_voltage = numpy.array(recordings['soma(0.5)'])
+    time = numpy.array(recordings["time"])
+    soma_voltage = numpy.array(recordings["soma(0.5)"])
 
-    recordings_dir = 'python_recordings'
+    recordings_dir = "python_recordings"
 
-    soma_voltage_filename = os.path.join(
-        recordings_dir,
-        'soma_voltage_step%d.dat' % step_number)
-    numpy.savetxt(
-            soma_voltage_filename,
-            numpy.transpose(
-               numpy.vstack((
-                    time,
-                    soma_voltage))))
+    soma_voltage_filename = os.path.join(recordings_dir, "soma_voltage_step%d.dat" % step_number)
+    numpy.savetxt(soma_voltage_filename, numpy.transpose(numpy.vstack((time, soma_voltage))))
 
-    print('Soma voltage for step %d saved to: %s'
-          % (step_number, soma_voltage_filename))
+    print("Soma voltage for step %d saved to: %s" % (step_number, soma_voltage_filename))
 
     if plot_traces:
         import pylab
+
         pylab.figure()
-        pylab.plot(recordings['time'], recordings['soma(0.5)'])
-        pylab.xlabel('time (ms)')
-        pylab.ylabel('Vm (mV)')
-        pylab.gcf().canvas.set_window_title('Step %d' % step_number)
+        pylab.plot(recordings["time"], recordings["soma(0.5)"])
+        pylab.xlabel("time (ms)")
+        pylab.ylabel("Vm (mV)")
+        pylab.gcf().canvas.set_window_title("Step %d" % step_number)
 
 
 def init_simulation():
     """Initialise simulation environment"""
 
     neuron.h.load_file("stdrun.hoc")
     neuron.h.load_file("import3d.hoc")
 
-    print('Loading constants')
-    neuron.h.load_file('constants.hoc')
+    print("Loading constants")
+    neuron.h.load_file("constants.hoc")
 
 
 def main(plot_traces=True):
     """Main"""
 
     # Import matplotlib to plot the traces
     if plot_traces:
         import matplotlib
-        matplotlib.rcParams['path.simplify'] = False
+
+        matplotlib.rcParams["path.simplify"] = False
 
     init_simulation()
 
     for step_number in range(1, 4):
         run_step(step_number, plot_traces=plot_traces)
 
     if plot_traces:
         import pylab
+
         pylab.show()
 
-if __name__ == '__main__':
+
+if __name__ == "__main__":
     if len(sys.argv) == 1:
         main(plot_traces=True)
-    elif len(sys.argv) == 2 and sys.argv[1] == '--no-plots':
+    elif len(sys.argv) == 2 and sys.argv[1] == "--no-plots":
         main(plot_traces=False)
     else:
-        raise Exception(
-            "Script only accepts one argument: --no-plots, not %s" %
-            str(sys.argv))
+        raise Exception("Script only accepts one argument: --no-plots, not %s" % str(sys.argv))
```

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/run_RmpRiTau.py` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_LBC_bAC217_1/run_RmpRiTau.py`

 * *Files 16% similar despite different names*

```diff
@@ -32,222 +32,201 @@
  * @author Werner Van Geit @ BBP
  * @date 2015
 """
 
 # pylint: disable=C0325, W0212, F0401, W0612, F0401
 
 import os
+import sys
+
 import neuron
 import numpy
-import sys
 
 
 def create_cell():
     """Create the cell model"""
     # Load morphology
     neuron.h.load_file("morphology.hoc")
     # Load biophysics
     neuron.h.load_file("biophysics.hoc")
     # Load main cell template
     neuron.h.load_file("template.hoc")
 
     # Instantiate the cell from the template
 
-    print("Loading cell cADpyr232_L5_UTPC_5e3840b51e")
-    cell = neuron.h.cADpyr232_L5_UTPC_5e3840b51e(0)
+    print("Loading cell bAC217_L5_LBC_c2cff91741")
+    cell = neuron.h.bAC217_L5_LBC_c2cff91741(0)
     return cell
 
 
 def create_stimuli(cell, stim_start, stim_end, current_amplitude):
     """Create the stimuli"""
 
-    print('Attaching stimulus electrodes')
+    print("Attaching stimulus electrodes")
 
     stimuli = []
 
     iclamp = neuron.h.IClamp(0.5, sec=cell.soma[0])
     iclamp.delay = stim_start
     iclamp.dur = stim_end - stim_start
     iclamp.amp = current_amplitude
-    print('Setting up step current clamp: '
-          'amp=%f nA, delay=%f ms, duration=%f ms' %
-          (iclamp.amp, iclamp.delay, iclamp.dur))
+    print(
+        "Setting up step current clamp: "
+        "amp=%f nA, delay=%f ms, duration=%f ms" % (iclamp.amp, iclamp.delay, iclamp.dur)
+    )
 
     stimuli.append(iclamp)
 
     return stimuli
 
 
 def create_recordings(cell):
     """Create the recordings"""
-    print('Attaching recording electrodes')
+    print("Attaching recording electrodes")
 
     recordings = {}
 
-    recordings['time'] = neuron.h.Vector()
-    recordings['soma(0.5)'] = neuron.h.Vector()
+    recordings["time"] = neuron.h.Vector()
+    recordings["soma(0.5)"] = neuron.h.Vector()
 
-    recordings['time'].record(neuron.h._ref_t, 0.1)
-    recordings['soma(0.5)'].record(cell.soma[0](0.5)._ref_v, 0.1)
+    recordings["time"].record(neuron.h._ref_t, 0.1)
+    recordings["soma(0.5)"].record(cell.soma[0](0.5)._ref_v, 0.1)
 
     return recordings
 
 
-def run_RmpRiTau_step(
-        stim_start,
-        stim_end,
-        current_amplitude,
-        plot_traces=None):
-    """Run """
+def run_RmpRiTau_step(stim_start, stim_end, current_amplitude, plot_traces=None):
+    """Run"""
 
     cell = create_cell()
     stimuli = create_stimuli(cell, stim_start, stim_end, current_amplitude)  # noqa
     recordings = create_recordings(cell)
 
     # Overriding default 30s simulation,
     neuron.h.tstop = stim_end + stim_start
-    print(
-        'Setting simulation time to %.6g ms for the step current' %
-        neuron.h.tstop)
+    print("Setting simulation time to %.6g ms for the step current" % neuron.h.tstop)
 
-    print('Setting initial voltage to -70 mV')
+    print("Setting initial voltage to -70 mV")
     neuron.h.v_init = -70
 
     neuron.h.stdinit()
     neuron.h.dt = 1000
     neuron.h.t = -1e9
     for _ in range(10):
         neuron.h.fadvance()
 
     neuron.h.t = 0
     neuron.h.dt = 0.025
     neuron.h.frecord_init()
 
     neuron.h.continuerun(3000)
 
-    time = numpy.array(recordings['time'])
-    soma_voltage = numpy.array(recordings['soma(0.5)'])
+    time = numpy.array(recordings["time"])
+    soma_voltage = numpy.array(recordings["soma(0.5)"])
 
-    recordings_dir = 'python_recordings'
+    recordings_dir = "python_recordings"
 
-    soma_voltage_filename = os.path.join(
-        recordings_dir,
-        'soma_voltage_RmpRiTau_step.dat')
+    soma_voltage_filename = os.path.join(recordings_dir, "soma_voltage_RmpRiTau_step.dat")
     numpy.savetxt(soma_voltage_filename, zip(time, soma_voltage))
 
-    print('Soma voltage for RmpRiTau trace saved to: %s'
-          % (soma_voltage_filename))
+    print("Soma voltage for RmpRiTau trace saved to: %s" % (soma_voltage_filename))
 
     if plot_traces:
         import pylab
-        pylab.figure(facecolor='white')
-        pylab.plot(recordings['time'], recordings['soma(0.5)'])
-        pylab.xlabel('time (ms)')
-        pylab.ylabel('Vm (mV)')
-        pylab.gcf().canvas.set_window_title('RmpRiTau trace')
+
+        pylab.figure(facecolor="white")
+        pylab.plot(recordings["time"], recordings["soma(0.5)"])
+        pylab.xlabel("time (ms)")
+        pylab.ylabel("Vm (mV)")
+        pylab.gcf().canvas.set_window_title("RmpRiTau trace")
 
     return time, soma_voltage, stim_start, stim_end
 
 
 def init_simulation():
     """Initialise simulation environment"""
 
     neuron.h.load_file("stdrun.hoc")
     neuron.h.load_file("import3d.hoc")
 
-    print('Loading constants')
-    neuron.h.load_file('constants.hoc')
+    print("Loading constants")
+    neuron.h.load_file("constants.hoc")
 
 
-def analyse_RmpRiTau_trace(
-        time,
-        soma_voltage,
-        stim_start,
-        stim_end,
-        current_amplitude):
+def analyse_RmpRiTau_trace(time, soma_voltage, stim_start, stim_end, current_amplitude):
     """Analyse the output of the RmpRiTau protocol"""
 
     # Import the eFeature Extraction Library
     import efel
 
     # Prepare the trace data
     trace = {}
-    trace['T'] = time
-    trace['V'] = soma_voltage
-    trace['stim_start'] = [stim_start]
-    trace['stim_end'] = [stim_end]
+    trace["T"] = time
+    trace["V"] = soma_voltage
+    trace["stim_start"] = [stim_start]
+    trace["stim_end"] = [stim_end]
 
     # Calculate the necessary eFeatures
     efel_results = efel.getFeatureValues(
-        [trace],
-        ['voltage_base', 'steady_state_voltage_stimend',
-         'decay_time_constant_after_stim'])
-
-    voltage_base = efel_results[0]['voltage_base'][0]
-    ss_voltage = efel_results[0]['steady_state_voltage_stimend'][0]
-    dct = efel_results[0]['decay_time_constant_after_stim'][0]
+        [trace], ["voltage_base", "steady_state_voltage_stimend", "decay_time_constant_after_stim"]
+    )
+
+    voltage_base = efel_results[0]["voltage_base"][0]
+    ss_voltage = efel_results[0]["steady_state_voltage_stimend"][0]
+    dct = efel_results[0]["decay_time_constant_after_stim"][0]
 
     # Calculate input resistance
     input_resistance = float(ss_voltage - voltage_base) / current_amplitude
 
     rmpritau_dict = {}
 
-    rmpritau_dict['Rmp'] = '%.6g' % voltage_base
-    rmpritau_dict['Rmp_Units'] = 'mV'
-    rmpritau_dict['Rin'] = '%.6g' % input_resistance
-    rmpritau_dict['Rin_Units'] = 'MOhm'
-    rmpritau_dict['Tau'] = '%.6g' % dct
-    rmpritau_dict['Tau_Units'] = 'ms'
-
-    print('Resting membrane potential is %s %s' %
-          (rmpritau_dict['Rmp'], rmpritau_dict['Rmp_Units']))
-    print('Input resistance is %s %s' %
-          (rmpritau_dict['Rin'], rmpritau_dict['Rin_Units']))
-    print('Time constant is %s %s' %
-          (rmpritau_dict['Tau'], rmpritau_dict['Tau_Units']))
+    rmpritau_dict["Rmp"] = "%.6g" % voltage_base
+    rmpritau_dict["Rmp_Units"] = "mV"
+    rmpritau_dict["Rin"] = "%.6g" % input_resistance
+    rmpritau_dict["Rin_Units"] = "MOhm"
+    rmpritau_dict["Tau"] = "%.6g" % dct
+    rmpritau_dict["Tau_Units"] = "ms"
+
+    print("Resting membrane potential is %s %s" % (rmpritau_dict["Rmp"], rmpritau_dict["Rmp_Units"]))
+    print("Input resistance is %s %s" % (rmpritau_dict["Rin"], rmpritau_dict["Rin_Units"]))
+    print("Time constant is %s %s" % (rmpritau_dict["Tau"], rmpritau_dict["Tau_Units"]))
 
     import json
 
-    with open('rmp_ri_tau.json', 'w') as rmpritau_json_file:
-        json.dump(rmpritau_dict, rmpritau_json_file,
-                        sort_keys=True,
-                        indent=4,
-                        separators=(',', ': '))
+    with open("rmp_ri_tau.json", "w") as rmpritau_json_file:
+        json.dump(rmpritau_dict, rmpritau_json_file, sort_keys=True, indent=4, separators=(",", ": "))
 
 
 def main(plot_traces=False):
     """Main"""
 
     # Import matplotlib to plot the traces
     if plot_traces:
         import matplotlib
-        matplotlib.rcParams['path.simplify'] = False
+
+        matplotlib.rcParams["path.simplify"] = False
 
     init_simulation()
 
     current_amplitude = -0.01
     stim_start = 1000
     stim_end = 2000
 
     time, soma_voltage, stim_start, stim_end = run_RmpRiTau_step(
-        stim_start, stim_end, current_amplitude, plot_traces=plot_traces)
+        stim_start, stim_end, current_amplitude, plot_traces=plot_traces
+    )
 
-    analyse_RmpRiTau_trace(
-        time,
-        soma_voltage,
-        stim_start,
-        stim_end,
-        current_amplitude)
+    analyse_RmpRiTau_trace(time, soma_voltage, stim_start, stim_end, current_amplitude)
 
     if plot_traces:
         import pylab
+
         pylab.show()
 
-if __name__ == '__main__':
+
+if __name__ == "__main__":
     if len(sys.argv) == 1:
         main(plot_traces=True)
-    elif len(sys.argv) == 2 and sys.argv[1] == '--no-plots':
+    elif len(sys.argv) == 2 and sys.argv[1] == "--no-plots":
         main(plot_traces=False)
     else:
-        raise Exception(
-            "Script only accepts one argument: --no-plots, not %s" %
-            str(sys.argv))
+        raise Exception("Script only accepts one argument: --no-plots, not %s" % str(sys.argv))
```

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/synapses/mtype_map.tsv` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/synapses/mtype_map.tsv`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/synapses/synapses.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/synapses/synapses.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/synapses/synapses.tsv` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/synapses/synapses.tsv`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/synapses/synconf.txt` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/synapses/synconf.txt`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/template.hoc` & `MEArec-1.9.0/src/MEArec/cell_models/bbp/L5_UTPC_cADpyr232_1/template.hoc`

 * *Files identical despite different names*

### Comparing `MEArec-1.8.0/MEArec/cli.py` & `MEArec-1.9.0/src/MEArec/cli.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,603 +1,623 @@
 import os
 import pprint
 import time
-from packaging.version import parse
 from pathlib import Path
 
-import MEArec.generation_tools as gt
-import MEAutility as mu
 import click
+import MEAutility as mu
 import numpy as np
 import yaml
-from MEArec import save_template_generator, save_recording_generator, get_default_config
+from packaging.version import parse
 
-if parse(yaml.__version__) >= parse('5.0.0'):
-    use_loader = True
-else:
-    use_loader = False
+import MEArec.generation_tools as gt
+from MEArec import (get_default_config, save_recording_generator,
+                    save_template_generator)
+from MEArec.tools import safe_yaml_load
 
 
 @click.group()
 def cli():
-    """MEArec: Fast and customizable simulation of extracellular recordings on Multi-Electrode-Arrays """
+    """MEArec: Fast and customizable simulation of extracellular recordings on Multi-Electrode-Arrays"""
     pass
 
 
 @cli.command()
-@click.option('--params', '-prm', default=None,
-              help='path to default_params.yaml (otherwise default default_params are used and some of the parameters'
-                   'can be overwritten with the following options)')
-@click.option('--default', is_flag=True,
-              help='shows default values for simulation')
-@click.option('--fname', '-fn', default=None,
-              help='template filename')
-@click.option('--folder', '-fol', default=None,
-              help='templates output base folder')
-@click.option('--cellfolder', '-cf', default=None,
-              help='folder containing bbp cell models')
-@click.option('--rot', '-r', default=None,
-              help='possible rotation arguments: norot-xrot-yrot-zrot-physrot-3drot (default=physrot)')
-@click.option('--probe', '-prb', default=None,
-              help='probe name from available electrodes (default=None)')
-@click.option('--n', '-n', default=None, type=int,
-              help='number of observations per cell type (default=50)')
-@click.option('--njobs', '-nj', default=0, type=int,
-              help='number of jobs (default n_jobs=n_cpus)')
-@click.option('--dt', '-dt', default=None, type=float,
-              help='time period in ms (default=0.03125)')
-@click.option('--ncontacts', '-nc', default=None, type=int,
-              help='number of contacts per electrode (default=1)')
-@click.option('--overhang', '-ov', default=None, type=float,
-              help='extension (um) beyond MEA boundaries for neuron locations (default=30.)')
-@click.option('--xlim', '-xl', default=None, nargs=2, type=float,
-              help='limits ( low high ) for neuron locations in the x-axis (depth) (default=[10.,80.])')
-@click.option('--ylim', '-yl', default=None, nargs=2, type=float,
-              help='limits ( low high ) for neuron locations in the y-axis (default=None)')
-@click.option('--zlim', '-zl', default=None, nargs=2, type=float,
-              help='limits ( low high ) for neuron locations in the z-axis (default=None)')
-@click.option('--seed', '-s', default=None, type=int,
-              help='random seed for template generation (int)')
-@click.option('--intraonly', '-io', is_flag=True,
-              help='only run intracellular simulations')
-@click.option('--no-parallel', '-nopar', is_flag=True,
-              help='run without multiprocessing tool')
-@click.option('--recompile', '-rc', is_flag=True,
-              help='recompile models')
-@click.option('--drifting', '-dr', is_flag=True,
-              help='generate drifting templates')
-@click.option('--min-amp', '-mamp', type=float,
-              help='miniumum template amplitude')
-@click.option('--min-drift', '-mind', type=float,
-              help='miniumum drifting distance')
-@click.option('--max-drift', '-maxd', type=float,
-              help='maximum drifting distance')
-@click.option('--drift-steps', '-drst', type=int,
-              help='number of drift steps')
-@click.option('--drift-xlim', '-dxl', default=None, nargs=2, type=float,
-              help='limits ( low high ) for neuron drift locations in the x-axis (depth) (default=[10.,80.])')
-@click.option('--drift-ylim', '-dyl', default=None, nargs=2, type=float,
-              help='limits ( low high ) for neuron drift locations in the y-axis (default=None)')
-@click.option('--drift-zlim', '-dzl', default=None, nargs=2, type=float,
-              help='limits ( low high ) for neuron drift locations in the z-axis (default=None)')
-@click.option('--verbose', '-v', is_flag=True,
-              help='produce verbose output')
+@click.option(
+    "--params",
+    "-prm",
+    default=None,
+    help="path to default_params.yaml (otherwise default default_params are used and some of the parameters"
+    "can be overwritten with the following options)",
+)
+@click.option("--default", is_flag=True, help="shows default values for simulation")
+@click.option("--fname", "-fn", default=None, help="template filename")
+@click.option("--folder", "-fol", default=None, help="templates output base folder")
+@click.option("--cellfolder", "-cf", default=None, help="folder containing bbp cell models")
+@click.option(
+    "--rot",
+    "-r",
+    default=None,
+    help="possible rotation arguments: norot-xrot-yrot-zrot-physrot-3drot (default=physrot)",
+)
+@click.option("--probe", "-prb", default=None, help="probe name from available electrodes (default=None)")
+@click.option("--n", "-n", default=None, type=int, help="number of observations per cell type (default=50)")
+@click.option("--njobs", "-nj", default=0, type=int, help="number of jobs (default n_jobs=n_cpus)")
+@click.option("--dt", "-dt", default=None, type=float, help="time period in ms (default=0.03125)")
+@click.option("--ncontacts", "-nc", default=None, type=int, help="number of contacts per electrode (default=1)")
+@click.option(
+    "--overhang",
+    "-ov",
+    default=None,
+    type=float,
+    help="extension (um) beyond MEA boundaries for neuron locations (default=30.)",
+)
+@click.option(
+    "--xlim",
+    "-xl",
+    default=None,
+    nargs=2,
+    type=float,
+    help="limits ( low high ) for neuron locations in the x-axis (depth) (default=[10.,80.])",
+)
+@click.option(
+    "--ylim",
+    "-yl",
+    default=None,
+    nargs=2,
+    type=float,
+    help="limits ( low high ) for neuron locations in the y-axis (default=None)",
+)
+@click.option(
+    "--zlim",
+    "-zl",
+    default=None,
+    nargs=2,
+    type=float,
+    help="limits ( low high ) for neuron locations in the z-axis (default=None)",
+)
+@click.option("--seed", "-s", default=None, type=int, help="random seed for template generation (int)")
+@click.option("--intraonly", "-io", is_flag=True, help="only run intracellular simulations")
+@click.option("--no-parallel", "-nopar", is_flag=True, help="run without multiprocessing tool")
+@click.option("--recompile", "-rc", is_flag=True, help="recompile models")
+@click.option("--drifting", "-dr", is_flag=True, help="generate drifting templates")
+@click.option("--min-amp", "-mamp", type=float, help="miniumum template amplitude")
+@click.option("--min-drift", "-mind", type=float, help="miniumum drifting distance")
+@click.option("--max-drift", "-maxd", type=float, help="maximum drifting distance")
+@click.option("--drift-steps", "-drst", type=int, help="number of drift steps")
+@click.option(
+    "--drift-xlim",
+    "-dxl",
+    default=None,
+    nargs=2,
+    type=float,
+    help="limits ( low high ) for neuron drift locations in the x-axis (depth) (default=[10.,80.])",
+)
+@click.option(
+    "--drift-ylim",
+    "-dyl",
+    default=None,
+    nargs=2,
+    type=float,
+    help="limits ( low high ) for neuron drift locations in the y-axis (default=None)",
+)
+@click.option(
+    "--drift-zlim",
+    "-dzl",
+    default=None,
+    nargs=2,
+    type=float,
+    help="limits ( low high ) for neuron drift locations in the z-axis (default=None)",
+)
+@click.option("--verbose", "-v", is_flag=True, help="produce verbose output")
 def gen_templates(params, **kwargs):
     """Generates TEMPLATES with biophysical simulation."""
-    info, config_folder = get_default_config()
+    info, _ = get_default_config()
 
     if params is None:
-        with open(info['templates_params'], 'r') as pf:
-            if use_loader:
-                params_dict = yaml.load(pf, Loader=yaml.FullLoader)
-            else:
-                params_dict = yaml.load(pf)
-    else:
-        with open(params, 'r') as pf:
-            if use_loader:
-                params_dict = yaml.load(pf, Loader=yaml.FullLoader)
-            else:
-                params_dict = yaml.load(pf)
+        params = info["templates_params"]
+    params_dict = safe_yaml_load(params)
 
-    if kwargs['default'] is True:
+    if kwargs["default"] is True:
         pprint.pprint(params_dict)
         mu.return_mea()
         return
 
-    if kwargs['cellfolder'] is not None:
-        model_folder = kwargs['cellfolder']
+    if kwargs["cellfolder"] is not None:
+        model_folder = kwargs["cellfolder"]
     else:
-        model_folder = info['cell_models_folder']
-    params_dict['cell_models_folder'] = model_folder
+        model_folder = info["cell_models_folder"]
+    params_dict["cell_models_folder"] = model_folder
 
-    if kwargs['seed'] is not None:
-        seed = kwargs['seed']
+    if kwargs["seed"] is not None:
+        seed = kwargs["seed"]
     else:
         seed = np.random.randint(1, 10000)
-    params_dict['seed'] = seed
+    params_dict["seed"] = seed
 
-    if kwargs['folder'] is not None:
-        templates_folder = kwargs['folder']
-        params_dict['templates_folder'] = Path(kwargs['folder'])
-    else:
-        templates_folder = Path(info['templates_folder'])
-    intraonly = kwargs['intraonly']
-
-    if kwargs['rot'] is not None:
-        params_dict['rot'] = kwargs['rot']
-    if kwargs['n'] is not None:
-        params_dict['n'] = kwargs['n']
-    if kwargs['dt'] is not None:
-        params_dict['dt'] = kwargs['dt']
-    if kwargs['ncontacts'] is not None:
-        params_dict['ncontacts'] = kwargs['ncontacts']
-    if kwargs['overhang'] is not None:
-        params_dict['overhang'] = kwargs['overhang']
-    if kwargs['xlim'] is not None and len(kwargs['xlim']) == 2:
-        params_dict['xlim'] = kwargs['xlim']
-    if kwargs['ylim'] is not None and len(kwargs['ylim']) == 2:
-        params_dict['ylim'] = kwargs['ylim']
-    if kwargs['zlim'] is not None and len(kwargs['zlim']) == 2:
-        params_dict['zlim'] = kwargs['zlim']
-    if kwargs['min_amp'] is not None:
-        params_dict['min_amp'] = kwargs['min_amp']
-
-    if kwargs['drifting']:
-        params_dict['drifting'] = True
-    elif 'drifting' not in params_dict.keys():
-        params_dict['drifting'] = False
-    if kwargs['min_drift'] is not None:
-        params_dict['min_drift'] = kwargs['min_drift']
-    if kwargs['max_drift'] is not None:
-        params_dict['max_drift'] = kwargs['max_drift']
-    if kwargs['drift_steps'] is not None:
-        params_dict['drift_steps'] = kwargs['drift_steps']
-    if kwargs['drift_xlim'] is not None and len(kwargs['drift_xlim']) == 2:
-        params_dict['drift_xlim'] = kwargs['drift_xlim']
-    if kwargs['drift_ylim'] is not None and len(kwargs['drift_ylim']) == 2:
-        params_dict['drift_ylim'] = kwargs['drift_ylim']
-    if kwargs['drift_zlim'] is not None and len(kwargs['drift_zlim']) == 2:
-        params_dict['drift_zlim'] = kwargs['drift_zlim']
-
-    if kwargs['probe'] is not None:
-        if kwargs['probe'] in mu.return_mea_list():
-            params_dict['probe'] = kwargs['probe']
+    if kwargs["folder"] is not None:
+        templates_folder = kwargs["folder"]
+        params_dict["templates_folder"] = Path(kwargs["folder"])
+    else:
+        templates_folder = Path(info["templates_folder"])
+    intraonly = kwargs["intraonly"]
+
+    if kwargs["rot"] is not None:
+        params_dict["rot"] = kwargs["rot"]
+    if kwargs["n"] is not None:
+        params_dict["n"] = kwargs["n"]
+    if kwargs["dt"] is not None:
+        params_dict["dt"] = kwargs["dt"]
+    if kwargs["ncontacts"] is not None:
+        params_dict["ncontacts"] = kwargs["ncontacts"]
+    if kwargs["overhang"] is not None:
+        params_dict["overhang"] = kwargs["overhang"]
+    if kwargs["xlim"] is not None and len(kwargs["xlim"]) == 2:
+        params_dict["xlim"] = kwargs["xlim"]
+    if kwargs["ylim"] is not None and len(kwargs["ylim"]) == 2:
+        params_dict["ylim"] = kwargs["ylim"]
+    if kwargs["zlim"] is not None and len(kwargs["zlim"]) == 2:
+        params_dict["zlim"] = kwargs["zlim"]
+    if kwargs["min_amp"] is not None:
+        params_dict["min_amp"] = kwargs["min_amp"]
+
+    if kwargs["drifting"]:
+        params_dict["drifting"] = True
+    elif "drifting" not in params_dict.keys():
+        params_dict["drifting"] = False
+    if kwargs["min_drift"] is not None:
+        params_dict["min_drift"] = kwargs["min_drift"]
+    if kwargs["max_drift"] is not None:
+        params_dict["max_drift"] = kwargs["max_drift"]
+    if kwargs["drift_steps"] is not None:
+        params_dict["drift_steps"] = kwargs["drift_steps"]
+    if kwargs["drift_xlim"] is not None and len(kwargs["drift_xlim"]) == 2:
+        params_dict["drift_xlim"] = kwargs["drift_xlim"]
+    if kwargs["drift_ylim"] is not None and len(kwargs["drift_ylim"]) == 2:
+        params_dict["drift_ylim"] = kwargs["drift_ylim"]
+    if kwargs["drift_zlim"] is not None and len(kwargs["drift_zlim"]) == 2:
+        params_dict["drift_zlim"] = kwargs["drift_zlim"]
+
+    if kwargs["probe"] is not None:
+        if kwargs["probe"] in mu.return_mea_list():
+            params_dict["probe"] = kwargs["probe"]
         else:
-            print("The probe ", kwargs['probe'], " is not listead as a MEAutility probe.")
+            print("The probe ", kwargs["probe"], " is not listead as a MEAutility probe.")
             return
-    if kwargs['no_parallel']:
+    if kwargs["no_parallel"]:
         parallel = False
     else:
         parallel = True
-    njobs = kwargs['njobs']
-    
-    recompile = kwargs['recompile']
-    verbose = kwargs['verbose']
-
-    params_dict['templates_folder'] = str(templates_folder)
-
-    tempgen = gt.gen_templates(cell_models_folder=model_folder,
-                               params=params_dict,
-                               templates_tmp_folder=str(templates_folder),
-                               intraonly=intraonly,
-                               n_jobs=njobs,
-                               recompile=recompile,
-                               parallel=parallel,
-                               verbose=verbose)
+    njobs = kwargs["njobs"]
+
+    recompile = kwargs["recompile"]
+    verbose = kwargs["verbose"]
+
+    params_dict["templates_folder"] = str(templates_folder)
+
+    tempgen = gt.gen_templates(
+        cell_models_folder=model_folder,
+        params=params_dict,
+        templates_tmp_folder=str(templates_folder),
+        intraonly=intraonly,
+        n_jobs=njobs,
+        recompile=recompile,
+        parallel=parallel,
+        verbose=verbose,
+    )
 
     # Merge simulated data and cleanup
     if not intraonly:
-        rot = params_dict['rot']
-        n = params_dict['n']
-        probe = params_dict['probe']
-        if kwargs['fname'] is None:
-            if params_dict['drifting']:
+        rot = params_dict["rot"]
+        n = params_dict["n"]
+        probe = params_dict["probe"]
+        if kwargs["fname"] is None:
+            if params_dict["drifting"]:
                 fname = f'templates_{n}_{probe}_drift_{time.strftime("%d-%m-%Y_%H-%M")}.h5'
             else:
                 fname = f'templates_{n}_{probe}_{time.strftime("%d-%m-%Y_%H-%M")}.h5'
         else:
-            fname = kwargs['fname']
+            fname = kwargs["fname"]
         save_fname = str(templates_folder / rot / fname)
         save_template_generator(tempgen, save_fname, verbose=True)
 
 
 @cli.command()
-@click.option('--templates', '-t', default=None,
-              help='templates path')
-@click.option('--params', '-prm', default=None,
-              help='path to default_params.yaml (otherwise default default_params are used '
-                   'and some of the parameters can be overwritten with the following options)')
-@click.option('--default', is_flag=True,
-              help='shows default values for simulation')
-@click.option('--fname', '-fn', default=None,
-              help='recording filename')
-@click.option('--folder', '-fol', default=None,
-              help='recording output base folder')
-@click.option('--duration', '-d', default=None, type=float,
-              help='duration in s (default=10)')
-@click.option('--njobs', '-nj', default=0, type=int,
-              help='number of jobs (default n_jobs=n_cpus)')
-@click.option('--n-exc', '-ne', default=None, type=int,
-              help='number of excitatory cells (default=15)')
-@click.option('--n-inh', '-ni', default=None, type=int,
-              help='number of inhibitory cells (default=5)')
-@click.option('--f-exc', '-fe', default=None, type=float,
-              help='average firing rate of excitatory cells in Hz (default=5)')
-@click.option('--f-inh', '-fi', default=None, type=float,
-              help='average firing rate of inhibitory cells in Hz (default=15)')
-@click.option('--st-exc', '-se', default=None, type=float,
-              help='firing rate standard deviation of excitatory cells in Hz (default=1)')
-@click.option('--st-inh', '-si', default=None, type=float,
-              help='firing rate standard deviation of inhibitory cells in Hz (default=3)')
-@click.option('--min-rate', '-mr', default=None, type=float,
-              help='minimum firing rate (default=0.5)')
-@click.option('--ref-per', '-rp', default=None, type=float,
-              help='refractory period in ms (default=2)')
-@click.option('--process', '-p', default='poisson', type=click.Choice(['poisson', 'gamma']),
-              help='process for generating spike trains (default=poisson)')
-@click.option('--tstart', default=None, type=float,
-              help='start time in s (default=0)')
-@click.option('--min-dist', '-md', default=None, type=int,
-              help='minumum distance between neuron in um (default=25)')
-@click.option('--min-amp', '-mina', default=None, type=int,
-              help='minumum eap amplitude in uV (default=50)')
-@click.option('--max-amp', '-maxa', default=None, type=int,
-              help='maximum eap amplitude in uV (default=inf)')
-@click.option('--fs', default=None, type=float,
-              help='sampling frequency in kHz (default from templates sampling frequency)')
-@click.option('--sync-rate', '-sr', default=None, type=float,
-              help='added synchrony rate on spatially overlapping spikes')
-@click.option('--sync-jitt', '-sj', default=None, type=float,
-              help='jitter in ms for added spikes')
-@click.option('--noise-lev', '-nl', default=None, type=int,
-              help='noise level in uV (default=10)')
-@click.option('--modulation', '-m', default=None, type=click.Choice(['none', 'template', 'electrode']),
-              help='modulation type')
-@click.option('--chunk-duration', '-chd', default=None, type=float,
-              help='chunk duration in s (default 0)')
-@click.option('--st-seed', '-stseed', default=None, type=int,
-              help='random seed for spike trains')
-@click.option('--temp-seed', '-tseed', default=None, type=int,
-              help='random seed for template selection')
-@click.option('--conv-seed', '-cseed', default=None, type=int,
-              help='random seed for convolution')
-@click.option('--noise-seed', '-nseed', default=None, type=int,
-              help='random seed for noise')
-@click.option('--half-dist', '-hd', default=None, type=float,
-              help='when noise is distance-correlated the distance at which covariance is 0.5 (default=30)')
-@click.option('--color-noise', '-cn', is_flag=True,
-              help='if True noise is colored')
-@click.option('--color-peak', '-cp', default=None, type=float,
-              help='peak for noise in Hz (default 500 Hz)')
-@click.option('--color-q', '-cq', default=None, type=float,
-              help='quality factor for noise filter (default=1)')
-@click.option('--random-noise-floor', '-rnf', default=None, type=float,
-              help='noise floor in std of additive noide (default 1)')
-@click.option('--filter', is_flag=True,
-              help='if True filter is applied')
-@click.option('--filt-cutoff', '-fc', default=None, type=float, multiple=True,
-              help='filter cutoff frequencies.'
-                   'High-pass: -fc hp-cutoff. Band-pass: -fc hp-cutoff -fc lp-cutoff')
-@click.option('--filt-order', '-fo', default=None, type=int,
-              help='filter order (default 3)')
-@click.option('--overlap', is_flag=True,
-              help='if True it annotates overlapping spikes')
-@click.option('--overlap-thresh', '-ot', type=float,
-              help='overlap threshold for spatial overlap')
-@click.option('--extract-wf', is_flag=True,
-              help='if True it annotates overlapping spikes')
-@click.option('--bursting', is_flag=True,
-              help='if True ISI-dependent modulation is performed')
-@click.option('--shape-mod', is_flag=True,
-              help='if True shape modulation is performed')
-@click.option('--drifting', '-dr', is_flag=True,
-              help='generate drifting recordings')
-@click.option('--preferred-dir', '-prd', default=None, nargs=3, type=float,
-              help='preferred drifting direction (0 0 1 is positive z-direction)')
-@click.option('--angle-tol', '-angt', type=float,
-              help='angle tollerance for preferred direction')
-@click.option('--drift-velocity', '-drvel', type=float,
-              help='drift velocity in um/min')
-@click.option('--t-start-drift', '-tsd', type=float,
-              help='drifting start time in s')
-@click.option('--verbose', '-v', is_flag=True,
-              help='produce verbose output')
+@click.option("--templates", "-t", default=None, help="templates path")
+@click.option(
+    "--params",
+    "-prm",
+    default=None,
+    help="path to default_params.yaml (otherwise default default_params are used "
+    "and some of the parameters can be overwritten with the following options)",
+)
+@click.option("--default", is_flag=True, help="shows default values for simulation")
+@click.option("--fname", "-fn", default=None, help="recording filename")
+@click.option("--folder", "-fol", default=None, help="recording output base folder")
+@click.option("--duration", "-d", default=None, type=float, help="duration in s (default=10)")
+@click.option("--njobs", "-nj", default=0, type=int, help="number of jobs (default n_jobs=n_cpus)")
+@click.option("--n-exc", "-ne", default=None, type=int, help="number of excitatory cells (default=15)")
+@click.option("--n-inh", "-ni", default=None, type=int, help="number of inhibitory cells (default=5)")
+@click.option(
+    "--f-exc", "-fe", default=None, type=float, help="average firing rate of excitatory cells in Hz (default=5)"
+)
+@click.option(
+    "--f-inh", "-fi", default=None, type=float, help="average firing rate of inhibitory cells in Hz (default=15)"
+)
+@click.option(
+    "--st-exc",
+    "-se",
+    default=None,
+    type=float,
+    help="firing rate standard deviation of excitatory cells in Hz (default=1)",
+)
+@click.option(
+    "--st-inh",
+    "-si",
+    default=None,
+    type=float,
+    help="firing rate standard deviation of inhibitory cells in Hz (default=3)",
+)
+@click.option("--min-rate", "-mr", default=None, type=float, help="minimum firing rate (default=0.5)")
+@click.option("--ref-per", "-rp", default=None, type=float, help="refractory period in ms (default=2)")
+@click.option(
+    "--process",
+    "-p",
+    default="poisson",
+    type=click.Choice(["poisson", "gamma"]),
+    help="process for generating spike trains (default=poisson)",
+)
+@click.option("--tstart", default=None, type=float, help="start time in s (default=0)")
+@click.option("--min-dist", "-md", default=None, type=int, help="minumum distance between neuron in um (default=25)")
+@click.option("--min-amp", "-mina", default=None, type=int, help="minumum eap amplitude in uV (default=50)")
+@click.option("--max-amp", "-maxa", default=None, type=int, help="maximum eap amplitude in uV (default=inf)")
+@click.option(
+    "--fs", default=None, type=float, help="sampling frequency in kHz (default from templates sampling frequency)"
+)
+@click.option(
+    "--sync-rate", "-sr", default=None, type=float, help="added synchrony rate on spatially overlapping spikes"
+)
+@click.option("--sync-jitt", "-sj", default=None, type=float, help="jitter in ms for added spikes")
+@click.option("--noise-lev", "-nl", default=None, type=int, help="noise level in uV (default=10)")
+@click.option(
+    "--modulation", "-m", default=None, type=click.Choice(["none", "template", "electrode"]), help="modulation type"
+)
+@click.option("--chunk-duration", "-chd", default=None, type=float, help="chunk duration in s (default 0)")
+@click.option("--st-seed", "-stseed", default=None, type=int, help="random seed for spike trains")
+@click.option("--temp-seed", "-tseed", default=None, type=int, help="random seed for template selection")
+@click.option("--conv-seed", "-cseed", default=None, type=int, help="random seed for convolution")
+@click.option("--noise-seed", "-nseed", default=None, type=int, help="random seed for noise")
+@click.option(
+    "--half-dist",
+    "-hd",
+    default=None,
+    type=float,
+    help="when noise is distance-correlated the distance at which covariance is 0.5 (default=30)",
+)
+@click.option("--color-noise", "-cn", is_flag=True, help="if True noise is colored")
+@click.option("--color-peak", "-cp", default=None, type=float, help="peak for noise in Hz (default 500 Hz)")
+@click.option("--color-q", "-cq", default=None, type=float, help="quality factor for noise filter (default=1)")
+@click.option(
+    "--random-noise-floor", "-rnf", default=None, type=float, help="noise floor in std of additive noide (default 1)"
+)
+@click.option("--filter", is_flag=True, help="if True filter is applied")
+@click.option(
+    "--filt-cutoff",
+    "-fc",
+    default=None,
+    type=float,
+    multiple=True,
+    help="filter cutoff frequencies." "High-pass: -fc hp-cutoff. Band-pass: -fc hp-cutoff -fc lp-cutoff",
+)
+@click.option("--filt-order", "-fo", default=None, type=int, help="filter order (default 3)")
+@click.option("--overlap", is_flag=True, help="if True it annotates overlapping spikes")
+@click.option("--overlap-thresh", "-ot", type=float, help="overlap threshold for spatial overlap")
+@click.option("--extract-wf", is_flag=True, help="if True it annotates overlapping spikes")
+@click.option("--bursting", is_flag=True, help="if True ISI-dependent modulation is performed")
+@click.option("--shape-mod", is_flag=True, help="if True shape modulation is performed")
+@click.option("--drifting", "-dr", is_flag=True, help="generate drifting recordings")
+@click.option(
+    "--preferred-dir",
+    "-prd",
+    default=None,
+    nargs=3,
+    type=float,
+    help="preferred drifting direction (0 0 1 is positive z-direction)",
+)
+@click.option("--angle-tol", "-angt", type=float, help="angle tollerance for preferred direction")
+@click.option("--drift-velocity", "-drvel", type=float, help="drift velocity in um/min")
+@click.option("--t-start-drift", "-tsd", type=float, help="drifting start time in s")
+@click.option("--verbose", "-v", is_flag=True, help="produce verbose output")
 def gen_recordings(params, **kwargs):
     """Generates RECORDINGS from TEMPLATES."""
     # Retrieve default_params file
-    info, config_folder = get_default_config()
+    info, _ = get_default_config()
 
     if params is None:
-        with open(info['recordings_params'], 'r') as pf:
-            if use_loader:
-                params_dict = yaml.load(pf, Loader=yaml.FullLoader)
-            else:
-                params_dict = yaml.load(pf)
-    else:
-        with open(params, 'r') as pf:
-            if use_loader:
-                params_dict = yaml.load(pf, Loader=yaml.FullLoader)
-            else:
-                params_dict = yaml.load(pf)
+        params = info["recordings_params"]
+    params_dict = safe_yaml_load(params)
 
-    if kwargs['default'] is True:
+    if kwargs["default"] is True:
         pprint.pprint(params_dict)
         return
 
-    templates_folder = Path(kwargs['templates'])
+    templates_folder = Path(kwargs["templates"])
 
-    if kwargs['folder'] is not None:
-        params_dict['recordings'].update({'recordings_folder': kwargs['folder']})
+    if kwargs["folder"] is not None:
+        params_dict["recordings"].update({"recordings_folder": kwargs["folder"]})
     else:
-        params_dict['recordings'].update({'recordings_folder': info['recordings_folder']})
-    recordings_folder = params_dict['recordings']['recordings_folder']
+        params_dict["recordings"].update({"recordings_folder": info["recordings_folder"]})
+    recordings_folder = params_dict["recordings"]["recordings_folder"]
 
-    if kwargs['templates'] is None:
-        print('Provide eap templates path')
+    if kwargs["templates"] is None:
+        print("Provide eap templates path")
         return
     else:
-        if templates_folder.is_dir() or templates_folder.suffix in ['.h5', '.hdf5']:
-            params_dict['templates'].update({'templates': kwargs['templates']})
+        if templates_folder.is_dir() or templates_folder.suffix in [".h5", ".hdf5"]:
+            params_dict["templates"].update({"templates": kwargs["templates"]})
         else:
-            print(kwargs['templates'])
+            print(kwargs["templates"])
             raise AttributeError("'templates' is not a folder")
 
-    if kwargs['n_exc'] is not None:
-        params_dict['spiketrains']['n_exc'] = kwargs['n_exc']
-    if kwargs['n_inh'] is not None:
-        params_dict['spiketrains']['n_inh'] = kwargs['n_inh']
-    if kwargs['f_exc'] is not None:
-        params_dict['spiketrains']['f_exc'] = kwargs['f_exc']
-    if kwargs['f_inh'] is not None:
-        params_dict['spiketrains']['f_inh'] = kwargs['f_inh']
-    if kwargs['st_exc'] is not None:
-        params_dict['spiketrains']['st_exc'] = kwargs['st_exc']
-    if kwargs['st_inh'] is not None:
-        params_dict['spiketrains']['st_inh'] = kwargs['st_inh']
-    if kwargs['min_rate'] is not None:
-        params_dict['spiketrains']['min_rate'] = kwargs['min_rate']
-    if kwargs['ref_per'] is not None:
-        params_dict['spiketrains']['ref_per'] = kwargs['ref_per']
-    if kwargs['process'] is not None:
-        params_dict['spiketrains']['process'] = kwargs['process']
-    if kwargs['min_rate'] is not None:
-        params_dict['spiketrains']['min_rate'] = kwargs['min_rate']
-    if kwargs['duration'] is not None:
-        params_dict['spiketrains']['duration'] = kwargs['duration']
-    if kwargs['tstart'] is not None:
-        params_dict['spiketrains']['t_start'] = kwargs['t_start']
-    if kwargs['min_dist'] is not None:
-        params_dict['templates']['min_dist'] = kwargs['min_dist']
-    if kwargs['min_amp'] is not None:
-        params_dict['templates']['min_amp'] = kwargs['min_amp']
-    if kwargs['max_amp'] is not None:
-        params_dict['templates']['max_amp'] = kwargs['max_amp']
-    if kwargs['overlap_thresh'] is not None:
-        params_dict['templates']['overlap_threshold'] = kwargs['overlap_thresh']
-
-    if kwargs['noise_lev'] is not None:
-        params_dict['recordings']['noise_level'] = kwargs['noise_lev']
-    if kwargs['modulation'] is not None:
-        params_dict['recordings']['modulation'] = kwargs['modulation']
-
-    if kwargs['chunk_duration'] is not None:
-        params_dict['recordings']['chunk_duration'] = kwargs['chunk_duration']
-    if kwargs['filter']:
-        params_dict['recordings']['filter'] = True
-    else:
-        params_dict['recordings']['filter'] = False
-    if kwargs['filt_cutoff'] is not None:
-        if isinstance(kwargs['filt_cutoff'], tuple):
-            kwargs['filt_cutoff'] = list(kwargs['filt_cutoff'])
-        params_dict['recordings']['filter_cutoff'] = kwargs['filt_cutoff']
-    if kwargs['filt_order'] is not None:
-        params_dict['recordings']['filt_order'] = kwargs['filt_order']
-    if kwargs['fs'] is not None:
-        params_dict['recordings']['fs'] = kwargs['fs']
-    else:
-        params_dict['recordings']['fs'] = None
-    if kwargs['sync_rate'] is not None:
-        params_dict['recordings']['sync_rate'] = kwargs['sync_rate']
-    else:
-        params_dict['recordings']['sync_rate'] = None
-    if kwargs['sync_jitt'] is not None:
-        params_dict['recordings']['sync_jitt'] = kwargs['sync_jitt']
-    else:
-        params_dict['recordings']['sync_jitt'] = 1
-    if kwargs['noise_seed'] is not None:
-        params_dict['seeds']['noise'] = kwargs['noise_seed']
-    if kwargs['temp_seed'] is not None:
-        params_dict['seeds']['templates'] = kwargs['temp_seed']
-    if kwargs['st_seed'] is not None:
-        params_dict['seeds']['spiketrains'] = kwargs['st_seed']
-    if kwargs['conv_seed'] is not None:
-        params_dict['seeds']['convolution'] = kwargs['conv_seed']
-    if kwargs['overlap']:
-        params_dict['recordings']['overlap'] = True
-    elif 'overlap' not in params_dict['recordings'].keys():
-        params_dict['recordings']['overlap'] = False
-    if kwargs['extract_wf']:
-        params_dict['recordings']['extract_wf'] = True
-    elif 'extract_wf' not in params_dict['recordings'].keys():
-        params_dict['recordings']['extract_wf'] = False
-
-    if kwargs['half_dist'] is not None:
-        params_dict['recordings']['half_dist'] = kwargs['half_dist']
-    if kwargs['color_noise']:
-        params_dict['recordings']['noise_color'] = True
-    elif 'noise_color' not in params_dict['recordings'].keys():
-        params_dict['recordings']['noise_color'] = False
-    if kwargs['color_peak'] is not None:
-        params_dict['recordings']['color_peak'] = kwargs['color_peak']
-    if kwargs['color_q'] is not None:
-        params_dict['recordings']['color_q'] = kwargs['color_q']
-    if kwargs['random_noise_floor'] is not None:
-        params_dict['recordings']['random_noise_floor'] = kwargs['random_noise_floor']
-
-    if kwargs['bursting']:
-        params_dict['recordings']['bursting'] = True
-    elif 'bursting' not in params_dict['recordings'].keys():
-        params_dict['recordings']['bursting'] = False
-
-    if kwargs['shape_mod']:
-        params_dict['recordings']['shape_mod'] = True
-    elif 'shape_mod' not in params_dict['recordings'].keys():
-        params_dict['recordings']['shape_mod'] = False
-
-    if kwargs['drifting']:
-        params_dict['recordings']['drifting'] = True
-    elif 'drifting' not in params_dict['recordings'].keys():
-        params_dict['recordings']['drifting'] = False
-    if kwargs['preferred_dir'] is not None and len(kwargs['preferred_dir']) == 3:
-        params_dict['recordings']['preferred_dir'] = kwargs['preferred_dir']
-    if kwargs['angle_tol']:
-        params_dict['recordings']['angle_tol'] = kwargs['angle_tol']
-    if kwargs['drift_velocity']:
-        params_dict['recordings']['drift_velocity'] = kwargs['drift_velocity']
-    if kwargs['t_start_drift']:
-        params_dict['recordings']['t_start_drift'] = kwargs['t_start_drift']
-    if kwargs['verbose']:
+    if kwargs["n_exc"] is not None:
+        params_dict["spiketrains"]["n_exc"] = kwargs["n_exc"]
+    if kwargs["n_inh"] is not None:
+        params_dict["spiketrains"]["n_inh"] = kwargs["n_inh"]
+    if kwargs["f_exc"] is not None:
+        params_dict["spiketrains"]["f_exc"] = kwargs["f_exc"]
+    if kwargs["f_inh"] is not None:
+        params_dict["spiketrains"]["f_inh"] = kwargs["f_inh"]
+    if kwargs["st_exc"] is not None:
+        params_dict["spiketrains"]["st_exc"] = kwargs["st_exc"]
+    if kwargs["st_inh"] is not None:
+        params_dict["spiketrains"]["st_inh"] = kwargs["st_inh"]
+    if kwargs["min_rate"] is not None:
+        params_dict["spiketrains"]["min_rate"] = kwargs["min_rate"]
+    if kwargs["ref_per"] is not None:
+        params_dict["spiketrains"]["ref_per"] = kwargs["ref_per"]
+    if kwargs["process"] is not None:
+        params_dict["spiketrains"]["process"] = kwargs["process"]
+    if kwargs["min_rate"] is not None:
+        params_dict["spiketrains"]["min_rate"] = kwargs["min_rate"]
+    if kwargs["duration"] is not None:
+        params_dict["spiketrains"]["duration"] = kwargs["duration"]
+    if kwargs["tstart"] is not None:
+        params_dict["spiketrains"]["t_start"] = kwargs["t_start"]
+    if kwargs["min_dist"] is not None:
+        params_dict["templates"]["min_dist"] = kwargs["min_dist"]
+    if kwargs["min_amp"] is not None:
+        params_dict["templates"]["min_amp"] = kwargs["min_amp"]
+    if kwargs["max_amp"] is not None:
+        params_dict["templates"]["max_amp"] = kwargs["max_amp"]
+    if kwargs["overlap_thresh"] is not None:
+        params_dict["templates"]["overlap_threshold"] = kwargs["overlap_thresh"]
+
+    if kwargs["noise_lev"] is not None:
+        params_dict["recordings"]["noise_level"] = kwargs["noise_lev"]
+    if kwargs["modulation"] is not None:
+        params_dict["recordings"]["modulation"] = kwargs["modulation"]
+
+    if kwargs["chunk_duration"] is not None:
+        params_dict["recordings"]["chunk_duration"] = kwargs["chunk_duration"]
+    if kwargs["filter"]:
+        params_dict["recordings"]["filter"] = True
+    else:
+        params_dict["recordings"]["filter"] = False
+    if kwargs["filt_cutoff"] is not None:
+        if isinstance(kwargs["filt_cutoff"], tuple):
+            kwargs["filt_cutoff"] = list(kwargs["filt_cutoff"])
+        params_dict["recordings"]["filter_cutoff"] = kwargs["filt_cutoff"]
+    if kwargs["filt_order"] is not None:
+        params_dict["recordings"]["filt_order"] = kwargs["filt_order"]
+    if kwargs["fs"] is not None:
+        params_dict["recordings"]["fs"] = kwargs["fs"]
+    else:
+        params_dict["recordings"]["fs"] = None
+    if kwargs["sync_rate"] is not None:
+        params_dict["recordings"]["sync_rate"] = kwargs["sync_rate"]
+    else:
+        params_dict["recordings"]["sync_rate"] = None
+    if kwargs["sync_jitt"] is not None:
+        params_dict["recordings"]["sync_jitt"] = kwargs["sync_jitt"]
+    else:
+        params_dict["recordings"]["sync_jitt"] = 1
+    if kwargs["noise_seed"] is not None:
+        params_dict["seeds"]["noise"] = kwargs["noise_seed"]
+    if kwargs["temp_seed"] is not None:
+        params_dict["seeds"]["templates"] = kwargs["temp_seed"]
+    if kwargs["st_seed"] is not None:
+        params_dict["seeds"]["spiketrains"] = kwargs["st_seed"]
+    if kwargs["conv_seed"] is not None:
+        params_dict["seeds"]["convolution"] = kwargs["conv_seed"]
+    if kwargs["overlap"]:
+        params_dict["recordings"]["overlap"] = True
+    elif "overlap" not in params_dict["recordings"].keys():
+        params_dict["recordings"]["overlap"] = False
+    if kwargs["extract_wf"]:
+        params_dict["recordings"]["extract_wf"] = True
+    elif "extract_wf" not in params_dict["recordings"].keys():
+        params_dict["recordings"]["extract_wf"] = False
+
+    if kwargs["half_dist"] is not None:
+        params_dict["recordings"]["half_dist"] = kwargs["half_dist"]
+    if kwargs["color_noise"]:
+        params_dict["recordings"]["noise_color"] = True
+    elif "noise_color" not in params_dict["recordings"].keys():
+        params_dict["recordings"]["noise_color"] = False
+    if kwargs["color_peak"] is not None:
+        params_dict["recordings"]["color_peak"] = kwargs["color_peak"]
+    if kwargs["color_q"] is not None:
+        params_dict["recordings"]["color_q"] = kwargs["color_q"]
+    if kwargs["random_noise_floor"] is not None:
+        params_dict["recordings"]["random_noise_floor"] = kwargs["random_noise_floor"]
+
+    if kwargs["bursting"]:
+        params_dict["recordings"]["bursting"] = True
+    elif "bursting" not in params_dict["recordings"].keys():
+        params_dict["recordings"]["bursting"] = False
+
+    if kwargs["shape_mod"]:
+        params_dict["recordings"]["shape_mod"] = True
+    elif "shape_mod" not in params_dict["recordings"].keys():
+        params_dict["recordings"]["shape_mod"] = False
+
+    if kwargs["drifting"]:
+        params_dict["recordings"]["drifting"] = True
+    elif "drifting" not in params_dict["recordings"].keys():
+        params_dict["recordings"]["drifting"] = False
+    if kwargs["preferred_dir"] is not None and len(kwargs["preferred_dir"]) == 3:
+        params_dict["recordings"]["preferred_dir"] = kwargs["preferred_dir"]
+    if kwargs["angle_tol"]:
+        params_dict["recordings"]["angle_tol"] = kwargs["angle_tol"]
+    if kwargs["drift_velocity"]:
+        params_dict["recordings"]["drift_velocity"] = kwargs["drift_velocity"]
+    if kwargs["t_start_drift"]:
+        params_dict["recordings"]["t_start_drift"] = kwargs["t_start_drift"]
+    if kwargs["verbose"]:
         verbose = 2
     else:
-        verbose = kwargs['verbose']
-    njobs = kwargs['njobs']
+        verbose = kwargs["verbose"]
+    njobs = kwargs["njobs"]
 
-    recgen = gt.gen_recordings(templates=kwargs['templates'], params=params_dict, verbose=verbose, n_jobs=njobs)
+    recgen = gt.gen_recordings(templates=kwargs["templates"], params=params_dict, verbose=verbose, n_jobs=njobs)
     info = recgen.info
 
-    n_neurons = info['recordings']['n_neurons']
-    electrode_name = info['electrodes']['electrode_name']
-    duration = info['recordings']['duration']
-    noise_level = info['recordings']['noise_level']
-
-    if kwargs['fname'] is None:
-        if kwargs['drifting']:
-            fname = f'recordings_{n_neurons}cells_{electrode_name}_{duration}_{np.round(noise_level, 2)}uV_' \
-                    f'drift_{time.strftime("%d-%m-%Y_%H-%M")}.h5'
+    n_neurons = info["recordings"]["n_neurons"]
+    electrode_name = info["electrodes"]["electrode_name"]
+    duration = info["recordings"]["duration"]
+    noise_level = info["recordings"]["noise_level"]
+
+    if kwargs["fname"] is None:
+        if kwargs["drifting"]:
+            fname = (
+                f"recordings_{n_neurons}cells_{electrode_name}_{duration}_{np.round(noise_level, 2)}uV_"
+                f'drift_{time.strftime("%d-%m-%Y_%H-%M")}.h5'
+            )
         else:
-            fname = f'recordings_{n_neurons}cells_{electrode_name}_{duration}_{np.round(noise_level, 2)}uV_' \
-                    f'{time.strftime("%d-%m-%Y_%H-%M")}.h5'
+            fname = (
+                f"recordings_{n_neurons}cells_{electrode_name}_{duration}_{np.round(noise_level, 2)}uV_"
+                f'{time.strftime("%d-%m-%Y_%H-%M")}.h5'
+            )
     else:
-        fname = kwargs['fname']
+        fname = kwargs["fname"]
 
     if recordings_folder is not None:
         recordings_folder = Path(recordings_folder)
         if not recordings_folder.is_dir():
             os.makedirs(str(recordings_folder))
     rec_path = str(recordings_folder / fname)
     save_recording_generator(recgen, rec_path, verbose=True)
 
 
 @cli.command()
 def default_config():
     """Print default configurations."""
-    info, config = get_default_config(print_version=True)
+    info, _ = get_default_config(print_version=True)
     pprint.pprint(info)
 
 
 @cli.command()
-@click.option('--info', is_flag=True,
-              default=False,
-              help='if True probe information is printed')
+@click.option("--info", is_flag=True, default=False, help="if True probe information is printed")
 def available_probes(info):
     """Print available probes."""
     from pprint import pprint
+
     probe_list = mu.return_mea_list()
     for p in probe_list:
         probe_info = mu.return_mea_info(p)
-        if 'description' not in probe_info.keys():
-            probe_info['description'] = 'no description'
+        if "description" not in probe_info.keys():
+            probe_info["description"] = "no description"
         if info:
             print(p)
             pprint(mu.return_mea_info(p))
         else:
-            print(p, '----------', probe_info['description'])
+            print(p, "----------", probe_info["description"])
         print()
 
 
 @cli.command()
-@click.argument('cell-models-folder')
+@click.argument("cell-models-folder")
 def set_cell_models_folder(cell_models_folder):
     """Set default cell_models folder."""
     info, config = get_default_config()
     cell_models_folder = Path(cell_models_folder)
     if cell_models_folder.is_dir():
-        info['cell_models_folder'] = str(cell_models_folder.absolute())
-        with open(Path(config) / 'mearec.conf', 'w') as f:
+        info["cell_models_folder"] = str(cell_models_folder.absolute())
+        with open(Path(config) / "mearec.conf", "w") as f:
             yaml.dump(info, f)
-        print('Set default cell_models_folder to: ', cell_models_folder)
+        print("Set default cell_models_folder to: ", cell_models_folder)
     else:
-        print(cell_models_folder, ' is not a folder!')
+        print(cell_models_folder, " is not a folder!")
 
 
 @cli.command()
-@click.argument('templates-folder')
-@click.option('--create', is_flag=True, help='if True it creates the directory')
+@click.argument("templates-folder")
+@click.option("--create", is_flag=True, help="if True it creates the directory")
 def set_templates_folder(templates_folder, create):
     """Set default templates output folder."""
     info, config = get_default_config()
     templates_folder = Path(templates_folder).absolute()
     if templates_folder.is_dir():
-        info['templates_folder'] = str(templates_folder)
-        with open(Path(config) / 'mearec.conf', 'w') as f:
+        info["templates_folder"] = str(templates_folder)
+        with open(Path(config) / "mearec.conf", "w") as f:
             yaml.dump(info, f)
-        print('Set default templates_folder to: ', templates_folder)
+        print("Set default templates_folder to: ", templates_folder)
     elif create:
         os.makedirs(str(templates_folder))
-        info['templates_folder'] = str(templates_folder)
-        with open(Path(config) / 'mearec.conf', 'w') as f:
+        info["templates_folder"] = str(templates_folder)
+        with open(Path(config) / "mearec.conf", "w") as f:
             yaml.dump(info, f)
-        print('Set default templates_folder to: ', templates_folder)
+        print("Set default templates_folder to: ", templates_folder)
     else:
-        print(templates_folder, ' is not a folder!')
+        print(templates_folder, " is not a folder!")
 
 
 @cli.command()
-@click.argument('recordings-folder')
-@click.option('--create', is_flag=True, help='if True it creates the directory')
+@click.argument("recordings-folder")
+@click.option("--create", is_flag=True, help="if True it creates the directory")
 def set_recordings_folder(recordings_folder, create):
     """Set default recordings output folder."""
     info, config = get_default_config()
     recordings_folder = Path(recordings_folder).absolute()
     if recordings_folder.is_dir():
-        info['recordings_folder'] = str(recordings_folder)
-        with open(Path(config) / 'mearec.conf', 'w') as f:
+        info["recordings_folder"] = str(recordings_folder)
+        with open(Path(config) / "mearec.conf", "w") as f:
             yaml.dump(info, f)
-        print('Set default recordings_folder to: ', recordings_folder)
+        print("Set default recordings_folder to: ", recordings_folder)
     elif create:
         os.makedirs(str(recordings_folder))
-        info['recordings_folder'] = str(recordings_folder)
-        with open(Path(config) / 'mearec.conf', 'w') as f:
+        info["recordings_folder"] = str(recordings_folder)
+        with open(Path(config) / "mearec.conf", "w") as f:
             yaml.dump(info, f)
-        print('Set default recordings_folder to: ', recordings_folder)
+        print("Set default recordings_folder to: ", recordings_folder)
     else:
-        print(recordings_folder, ' is not a folder!')
+        print(recordings_folder, " is not a folder!")
 
 
 @cli.command()
-@click.argument('templates-params')
+@click.argument("templates-params")
 def set_templates_params(templates_params):
     """Set default templates parameter file."""
     info, config = get_default_config()
     templates_params = Path(templates_params).absolute()
-    if templates_params.is_file() and templates_params.suffix in ['.yaml', '.yml']:
-        info['templates_params'] = str(templates_params)
-        with open(Path(config) / 'mearec.conf', 'w') as f:
+    if templates_params.is_file() and templates_params.suffix in [".yaml", ".yml"]:
+        info["templates_params"] = str(templates_params)
+        with open(Path(config) / "mearec.conf", "w") as f:
             yaml.dump(info, f)
-        print('Set default templates_params to: ', templates_params)
+        print("Set default templates_params to: ", templates_params)
     else:
-        print(templates_params, ' is not a yaml!')
+        print(templates_params, " is not a yaml!")
 
 
 @cli.command()
-@click.argument('recordings-params')
+@click.argument("recordings-params")
 def set_recordings_params(recordings_params):
     """Set default recordings parameter file."""
     info, config = get_default_config()
     recordings_params = Path(recordings_params).absolute()
-    if recordings_params.is_file() and recordings_params.suffix in ['.yaml', '.yml']:
-        info['recording_params'] = str(recordings_params)
-        with open(Path(config) / 'mearec.conf', 'w') as f:
+    if recordings_params.is_file() and recordings_params.suffix in [".yaml", ".yml"]:
+        info["recording_params"] = str(recordings_params)
+        with open(Path(config) / "mearec.conf", "w") as f:
             yaml.dump(info, f)
-        print('Set default recordings_params to: ', recordings_params)
+        print("Set default recordings_params to: ", recordings_params)
     else:
-        print(recordings_params, ' is not a yaml!')
+        print(recordings_params, " is not a yaml!")
```

### Comparing `MEArec-1.8.0/MEArec/default_params/recordings_params.yaml` & `MEArec-1.9.0/src/MEArec/default_params/recordings_params.yaml`

 * *Files 6% similar despite different names*

```diff
@@ -85,26 +85,31 @@
   color_peak: 300 # (color) peak / curoff frequency of resonating filter
   color_q: 2 # (color) quality factor of resonating filter
   color_noise_floor: 1 # (color) additional noise floor
 
   filter: True # if True it filters the recordings
   filter_cutoff: [300, 6000] # filter cutoff frequencies in Hz
   filter_order: 3 # filter order
+  filter_mode: filtfilt # filter mode (filtfilt, lfilter)
 
   drifting: False # if True templates are drifted
   # these params are shared across multiple drift signals
   n_drifting: null # number of drifting units
   preferred_dir: [0, 0, 1]  # preferred drifting direction ([0,0,1] is positive z, direction)
   angle_tol: 15  # tolerance for direction in degrees
   # these params specify one drift signal
-  drift_mode_speed: 'slow' # drifting mode can be ['slow', 'fast']
-  drift_mode_probe: 'rigid' # ['rigid', 'non-rigid']
+  drift_mode_speed: slow # drifting mode can be ['slow', 'fast']
+  drift_mode_probe: rigid # ['rigid', 'non-rigid']
   drift_fs: 100 # sampling frequency of drift signal in Hz
-  non_rigid_gradient_mode: 'linear' # ['linear'] how the gradient on drift is applied on the prefered_dir. linear is 0->max velocity from up to bottom.
+  non_rigid_gradient_mode: linear # ['linear'] how the gradient on drift is applied on the prefered_dir. linear is 0->max velocity from up to bottom.
+  non_rigid_linear_min_factor: 0.5 # minimum factor of velocity for the neurons
+  non_rigid_linear_direction: 1 # the non rigid direction: if 1, non rigid drift is from bottom to top, if -1 is the opposite
+  non_rigid_step_depth_boundary: null # if not None, the depth in um at which the non rigid drift changes direction
+  non_rigid_step_factors: null # if not None, the factors of velocity for the non rigid drift
   slow_drift_velocity: 5  # drift velocity in um/min.
   slow_drift_amplitude: null  # Amplitude of drifts in um. If None, the maximum available value based on the drifting templates is used.
-  slow_drift_waveform: 'triangluar'  # 'triangluar' or 'sine'
+  slow_drift_waveform: triangluar  # 'triangluar' or 'sine'
   fast_drift_period: 10  # period between fast drift events
   fast_drift_max_jump: 20 # maximum 'jump' in um for fast drifts
   fast_drift_min_jump: 5 # minimum 'jump' in um for fast drifts
   t_start_drift: 0  # time in s when drifting starts
   t_end_drift: null  # time in s when drifting stops
```

### Comparing `MEArec-1.8.0/MEArec/default_params/templates_params.yaml` & `MEArec-1.9.0/src/MEArec/default_params/templates_params.yaml`

 * *Files 8% similar despite different names*

```diff
@@ -18,14 +18,15 @@
 offset: 0 # plane offset (um) for MEA
 xlim: [10,80] # limits ( low high ) for neuron locations in the x-axis (depth)
 ylim: null # limits ( low high ) for neuron locations in the y-axis
 zlim: null # limits ( low high ) for neuron locations in the z-axis
 x_distr: 'uniform' # distribution of x locsations ('uniform' | 'beta')
 beta_distr_params: [1.5, 5] # parameters for beta distribution of x locations (depth)
 min_amp: 30 # minimum amplitude for detection
+check_eap_shape: True # if True, EAPs with negative peaks smaller than positive peaks are discarded
 n: 50 # number of EAPs per cell model
 seed: null # random seed for positions and rotations
 
 drifting: False # if True, drifting templates are simulated
 max_drift: 100 # max distance from the initial and final cell position
 min_drift: 30  # min distance from the initial and final cell position
 drift_steps: 31 # number of drift steps
```

### Comparing `MEArec-1.8.0/MEArec/generation_tools.py` & `MEArec-1.9.0/src/MEArec/generation_tools.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,26 +1,33 @@
-import MEArec
-from MEArec.tools import load_templates, get_binary_cat, get_default_recordings_params
-from MEArec.generators import RecordingGenerator, SpikeTrainGenerator, TemplateGenerator
-import yaml
 import os
-from packaging.version import parse
 import time
 from pathlib import Path
-import numpy as np
-import neo
-
-if parse(yaml.__version__) >= parse('5.0.0'):
-    use_loader = True
-else:
-    use_loader = False
 
+import neo
+import numpy as np
+import yaml
+from packaging.version import parse
 
-def gen_recordings(params=None, templates=None, tempgen=None, spgen=None, verbose=True,
-                   tmp_mode='memmap', template_ids=None, tmp_folder=None, n_jobs=0, drift_dicts=None):
+from .generators import (RecordingGenerator, SpikeTrainGenerator,
+                         TemplateGenerator)
+from .tools import get_binary_cat, load_templates, safe_yaml_load
+
+
+def gen_recordings(
+    params=None,
+    templates=None,
+    tempgen=None,
+    spgen=None,
+    verbose=True,
+    tmp_mode="memmap",
+    template_ids=None,
+    tmp_folder=None,
+    n_jobs=0,
+    drift_dicts=None,
+):
     """
     Generates recordings.
 
     Parameters
     ----------
     templates : str
         Path to generated templates
@@ -46,111 +53,113 @@
     -------
     RecordingGenerator
         Generated recording generator object
     """
     t_start = time.perf_counter()
     if isinstance(params, (str, Path)):
         params = Path(params)
-        if params.is_file() and params.suffix in ['.yaml', '.yml']:
-            with open(params, 'r') as pf:
-                if use_loader:
-                    params_dict = yaml.load(pf, Loader=yaml.FullLoader)
-                else:
-                    params_dict = yaml.load(pf)
+        if params.is_file() and params.suffix in [".yaml", ".yml"]:
+            params_dict = safe_yaml_load(params)
     elif isinstance(params, dict):
         params_dict = params
     else:
-        params_dict = {} 
+        params_dict = {}
 
-    if 'spiketrains' not in params_dict:
-        params_dict['spiketrains'] = {}
-    if 'templates' not in params_dict:
-        params_dict['templates'] = {}
-    if 'recordings' not in params_dict:
-        params_dict['recordings'] = {}
-    if 'cell_types' not in params_dict:
-        params_dict['cell_types'] = {}
-    if 'seeds' not in params_dict:
-        params_dict['seeds'] = {}
+    if "spiketrains" not in params_dict:
+        params_dict["spiketrains"] = {}
+    if "templates" not in params_dict:
+        params_dict["templates"] = {}
+    if "recordings" not in params_dict:
+        params_dict["recordings"] = {}
+    if "cell_types" not in params_dict:
+        params_dict["cell_types"] = {}
+    if "seeds" not in params_dict:
+        params_dict["seeds"] = {}
 
     if tempgen is None and templates is None:
         raise AttributeError("Provide either 'templates' or 'tempgen' TemplateGenerator object")
 
     if tempgen is None:
         templates = Path(templates)
-        if templates.suffix in ['.h5', '.hdf5']:
+        if templates.suffix in [".h5", ".hdf5"]:
             tempgen = load_templates(templates, verbose=verbose)
         else:
             raise AttributeError("'templates' is not an hdf5 file")
 
-    if 'spiketrains' in params_dict['seeds']:
-        if params_dict['seeds']['spiketrains'] is None:
-            params_dict['seeds']['spiketrains'] = np.random.randint(1, 10000)
+    if "spiketrains" in params_dict["seeds"]:
+        if params_dict["seeds"]["spiketrains"] is None:
+            params_dict["seeds"]["spiketrains"] = np.random.randint(1, 10000)
     else:
-        params_dict['seeds']['spiketrains'] = np.random.randint(1, 10000)
+        params_dict["seeds"]["spiketrains"] = np.random.randint(1, 10000)
 
-    if 'templates' in params_dict['seeds']:
-        if params_dict['seeds']['templates'] is None:
-            params_dict['seeds']['templates'] = np.random.randint(1, 10000)
+    if "templates" in params_dict["seeds"]:
+        if params_dict["seeds"]["templates"] is None:
+            params_dict["seeds"]["templates"] = np.random.randint(1, 10000)
     else:
-        params_dict['seeds']['templates'] = np.random.randint(1, 10000)
+        params_dict["seeds"]["templates"] = np.random.randint(1, 10000)
 
-    if 'convolution' in params_dict['seeds']:
-        if params_dict['seeds']['convolution'] is None:
-            params_dict['seeds']['convolution'] = np.random.randint(1, 10000)
+    if "convolution" in params_dict["seeds"]:
+        if params_dict["seeds"]["convolution"] is None:
+            params_dict["seeds"]["convolution"] = np.random.randint(1, 10000)
     else:
-        params_dict['seeds']['convolution'] = np.random.randint(1, 10000)
+        params_dict["seeds"]["convolution"] = np.random.randint(1, 10000)
 
-    if 'noise' in params_dict['seeds']:
-        if params_dict['seeds']['noise'] is None:
-            params_dict['seeds']['noise'] = np.random.randint(1, 10000)
+    if "noise" in params_dict["seeds"]:
+        if params_dict["seeds"]["noise"] is None:
+            params_dict["seeds"]["noise"] = np.random.randint(1, 10000)
     else:
-        params_dict['seeds']['noise'] = np.random.randint(1, 10000)
+        params_dict["seeds"]["noise"] = np.random.randint(1, 10000)
 
     if template_ids is not None:
-        celltype_params = params_dict['cell_types']
+        celltype_params = params_dict["cell_types"]
         celltypes = tempgen.celltypes
         if celltype_params is not None:
-            if 'excitatory' in celltype_params.keys() and 'inhibitory' in celltype_params.keys():
-                exc_categories = celltype_params['excitatory']
-                inh_categories = celltype_params['inhibitory']
-                bin_cat = get_binary_cat(celltypes, exc_categories, inh_categories)
+            if "excitatory" in celltype_params.keys() and "inhibitory" in celltype_params.keys():
+                exc_categories = celltype_params["excitatory"]
+                inh_categories = celltype_params["inhibitory"]
+                bin_cat = get_binary_cat(celltypes, exc_categories, inh_categories)[template_ids]
                 n_exc = int(np.sum(bin_cat == "E"))
                 n_inh = int(np.sum(bin_cat == "I"))
             else:
-                bin_cat = np.array(['U'] * len(celltypes))
+                bin_cat = np.array(["U"] * len(celltypes))
                 n_exc = len(celltypes)
                 n_inh = 0
         else:
-            bin_cat = np.array(['U'] * len(celltypes))
+            bin_cat = np.array(["U"] * len(celltypes))
             n_exc = len(celltypes)
             n_inh = 0
-        params_dict["spiketrains"]['n_exc'] = n_exc
-        params_dict["spiketrains"]['n_inh'] = n_inh
+        params_dict["spiketrains"]["n_exc"] = n_exc
+        params_dict["spiketrains"]["n_inh"] = n_inh
         if verbose:
             print(f"'template_ids' is given. Setting n_exc={n_exc} and n_inh={n_inh}")
 
-
     # Generate spike trains
     if spgen is None:
-        spgen = SpikeTrainGenerator(params_dict['spiketrains'], verbose=verbose,
-                                    seed=params_dict['seeds']['spiketrains'])
+        spgen = SpikeTrainGenerator(
+            params_dict["spiketrains"], verbose=verbose, seed=params_dict["seeds"]["spiketrains"]
+        )
         spgen.generate_spikes()
     else:
         assert isinstance(spgen, SpikeTrainGenerator), "'spgen' should be a SpikeTrainGenerator object"
-        spgen.info['custom'] = True
+        spgen.info["custom"] = True
 
-    params_dict['spiketrains'] = spgen.info
+    params_dict["spiketrains"] = spgen.info
     # Generate recordings
     recgen = RecordingGenerator(spgen, tempgen, params_dict)
-    recgen.generate_recordings(tmp_mode=tmp_mode, tmp_folder=tmp_folder, template_ids=template_ids,
-                               n_jobs=n_jobs, verbose=verbose, drift_dicts=drift_dicts)
+    recgen.generate_recordings(
+        tmp_mode=tmp_mode,
+        tmp_folder=tmp_folder,
+        template_ids=template_ids,
+        n_jobs=n_jobs,
+        verbose=verbose,
+        drift_dicts=drift_dicts,
+    )
 
     if verbose >= 1:
-        print('Elapsed time: ', time.perf_counter() - t_start)
+        print("Elapsed time: ", time.perf_counter() - t_start)
 
     return recgen
 
 
 def gen_spiketrains(params=None, spiketrains=None, seed=None, verbose=False):
     """
     Generates spike trains.
@@ -167,41 +176,48 @@
     Returns
     -------
     SpikeTrainGenerator
         Generated spike train generator object
     """
     if params is None:
         assert spiketrains is not None, "Pass either a 'params' or a 'spiketrains' argument"
-        assert isinstance(spiketrains, list) and isinstance(spiketrains[0], neo.SpikeTrain), \
-            "'spiketrains' should be a list of neo.SpikeTrain objects"
+        assert isinstance(spiketrains, list) and isinstance(
+            spiketrains[0], neo.SpikeTrain
+        ), "'spiketrains' should be a list of neo.SpikeTrain objects"
         params_dict = {}
     else:
         if isinstance(params, (str, Path)):
             params = Path(params)
-            if params.is_file() and params.suffix in ['.yaml', '.yml']:
-                with open(params, 'r') as pf:
-                    if use_loader:
-                        params_dict = yaml.load(pf, Loader=yaml.FullLoader)
-                    else:
-                        params_dict = yaml.load(pf)
+            if params.is_file() and params.suffix in [".yaml", ".yml"]:
+                params_dict = safe_yaml_load(params)
         elif isinstance(params, dict):
             params_dict = params
         else:
             params_dict = {}
         spiketrains = None
 
     spgen = SpikeTrainGenerator(params=params_dict, spiketrains=spiketrains, seed=seed, verbose=verbose)
     spgen.generate_spikes()
 
     return spgen
 
 
-def gen_templates(cell_models_folder, params=None, templates_tmp_folder=None, tempgen=None,
-                  intraonly=False, parallel=True, n_jobs=None, joblib_backend="loky",
-                  recompile=False, delete_tmp=True, verbose=True):
+def gen_templates(
+    cell_models_folder,
+    params=None,
+    templates_tmp_folder=None,
+    tempgen=None,
+    intraonly=False,
+    parallel=True,
+    n_jobs=None,
+    joblib_backend="loky",
+    recompile=False,
+    delete_tmp=True,
+    verbose=True,
+):
     """
 
     Parameters
     ----------
     cell_models_folder : str
         path to folder containing cell models
     params : str or dict
@@ -230,46 +246,43 @@
     -------
     TemplateGenerator
         Generated template generator object
 
     """
     if isinstance(params, (str, Path)):
         params = Path(params)
-        if params.is_file() and params.suffix in ['.yaml', '.yml']:
-            with open(params, 'r') as pf:
-                if use_loader:
-                    params_dict = yaml.load(pf, Loader=yaml.FullLoader)
-                else:
-                    params_dict = yaml.load(pf)
+        if params.is_file() and params.suffix in [".yaml", ".yml"]:
+            params_dict = safe_yaml_load(params)
     elif isinstance(params, dict):
         params_dict = params
     else:
         params_dict = None
 
     if tempgen is not None:
         if isinstance(tempgen, (str, Path)):
             tempgen_arg = load_templates(tempgen)
         else:
-            assert isinstance(tempgen, TemplateGenerator), \
-                "'tempgen' should be a TemplateGenerator"
+            assert isinstance(tempgen, TemplateGenerator), "'tempgen' should be a TemplateGenerator"
             tempgen_arg = tempgen
     else:
         tempgen_arg = tempgen
 
     if templates_tmp_folder is not None:
         if not Path(templates_tmp_folder).is_dir():
             os.makedirs(templates_tmp_folder)
 
-    tempgen = TemplateGenerator(cell_models_folder=cell_models_folder,
-                                params=params_dict,
-                                templates_folder=templates_tmp_folder,
-                                tempgen=tempgen_arg,
-                                intraonly=intraonly,
-                                parallel=parallel,
-                                recompile=recompile,
-                                n_jobs=n_jobs,
-                                joblib_backend=joblib_backend,
-                                delete_tmp=delete_tmp,
-                                verbose=verbose)
+    tempgen = TemplateGenerator(
+        cell_models_folder=cell_models_folder,
+        params=params_dict,
+        templates_folder=templates_tmp_folder,
+        tempgen=tempgen_arg,
+        intraonly=intraonly,
+        parallel=parallel,
+        recompile=recompile,
+        n_jobs=n_jobs,
+        joblib_backend=joblib_backend,
+        delete_tmp=delete_tmp,
+        verbose=verbose,
+    )
     tempgen.generate_templates()
 
     return tempgen
```

### Comparing `MEArec-1.8.0/MEArec/generators/recgensteps.py` & `MEArec-1.9.0/src/MEArec/generators/recgensteps.py`

 * *Files 7% similar despite different names*

```diff
@@ -12,63 +12,118 @@
 
 
 """
 import h5py
 import numpy as np
 import scipy.signal
 
-from MEArec.tools import (filter_analog_signals, convolve_templates_spiketrains,
-                          convolve_single_template, 
-                          compute_drift_idxs_from_drift_list
-                          )
+from MEArec.tools import (compute_drift_idxs_from_drift_list,
+                          convolve_single_template,
+                          convolve_templates_spiketrains,
+                          filter_analog_signals)
 
 
 class FuncThenAddChunk:
     """
-    Helper for functions that do chunk to assign one or several chunks at the 
-    good place.
+    Helper function to compute and add to an existing array by chunk.
+
+    E.g., used for convolution, additive noise
+    """
+
+    def __init__(self, func):
+        self.func = func
+
+    def __call__(self, *args, **kargs):
+        return_dict = self.func(*args)
+
+        (
+            ch,
+            i_start,
+            i_stop,
+        ) = args[:3]
+
+        assignment_dict = kargs["assignment_dict"]
+        tmp_mode = kargs["tmp_mode"]
+
+        if tmp_mode is None:
+            pass
+        elif tmp_mode == "memmap":
+            for key, full_arr in assignment_dict.items():
+                out_chunk = return_dict.pop(key)
+                full_arr[i_start:i_stop] += out_chunk.astype(full_arr.dtype)
+
+        return return_dict
+
+
+class FuncThenReplaceChunk:
+    """
+    Helper function to compute by and replace an existing array by chunk.
+
+    E.g., used for convolution, additive noise
     """
 
     def __init__(self, func):
         self.func = func
 
     def __call__(self, *args, **kargs):
         return_dict = self.func(*args)
 
-        ch, i_start, i_stop, = args[:3]
+        (
+            ch,
+            i_start,
+            i_stop,
+        ) = args[:3]
 
-        assignment_dict = kargs['assignment_dict']
-        tmp_mode = kargs['tmp_mode']
+        assignment_dict = kargs["assignment_dict"]
+        tmp_mode = kargs["tmp_mode"]
 
         if tmp_mode is None:
             pass
-        elif tmp_mode == 'memmap':
+        elif tmp_mode == "memmap":
             for key, full_arr in assignment_dict.items():
                 out_chunk = return_dict.pop(key)
-                full_arr[i_start:i_stop] += out_chunk
+                full_arr[i_start:i_stop] = out_chunk.astype(full_arr.dtype)
 
         return return_dict
 
 
-def chunk_convolution_(ch, i_start, i_stop, fs, lsb,
-                       st_idxs, pad_samples, modulation, drifting,
-                       drifting_units, templates,
-                       cut_outs_samples, drift_list,
-                       verbose, amp_mod, bursting_units, shape_mod,
-                       shape_stretch, extract_spike_traces, voltage_peaks, dtype, seed_list):
+def chunk_convolution_(
+    ch,
+    i_start,
+    i_stop,
+    fs,
+    lsb,
+    st_idxs,
+    pad_samples,
+    modulation,
+    drifting,
+    drifting_units,
+    templates,
+    cut_outs_samples,
+    drift_list,
+    verbose,
+    amp_mod,
+    bursting_units,
+    shape_mod,
+    shape_stretch,
+    extract_spike_traces,
+    voltage_peaks,
+    dtype,
+    seed_list,
+):
     """
     Perform full convolution for all spike trains by chunk.
 
     Parameters
     ----------
     ch: int
         Chunk id
     i_start: int
         first index of chunk
-    i_stop: 
+    i_stop:
         last index of chunk (exclude)
     fs: float
         Sampling frequency in Hz
     lsb: int or None
         If given, the signal is quantized given the lsb value
     st_idxs: list
         list of spike indexes for each spike train
@@ -98,70 +153,71 @@
         Low and high frequency for bursting
     extract_spike_traces: bool
         If True (default), spike traces are extracted
     voltage_peaks: np.array
         Array containing the voltage values at the peak
     """
     if verbose:
-        print('Start convolutions for chunk', ch)
+        print("Start convolutions for chunk", ch)
     # set seed
     np.random.seed(seed_list[ch])
+    traces_dtype = np.float32
 
     # checking boundaries not needed here because the recordings are created on the fly
     i_start_pad = i_start - pad_samples
     i_stop_pad = i_stop + pad_samples
     n_samples = i_stop_pad - i_start_pad
 
     template_idxs = []
     if extract_spike_traces:
-        spike_traces = np.zeros((n_samples, len(st_idxs)), dtype=dtype)
+        spike_traces = np.zeros((n_samples, len(st_idxs)), dtype=traces_dtype)
     if len(templates.shape) == 4:
         n_elec = templates.shape[2]
     elif len(templates.shape) == 5:
         n_elec = templates.shape[3]
         drift_steps = templates.shape[1]
         default_drift_ind = drift_steps // 2
     else:
         raise AttributeError("Wrong 'templates' shape!")
 
-    recordings = np.zeros((n_samples, n_elec), dtype=dtype)
+    recordings = np.zeros((n_samples, n_elec), dtype=traces_dtype)
 
     for st, st_idx in enumerate(st_idxs):
         if extract_spike_traces:
             max_electrode = np.argmax(voltage_peaks[st])
 
         seed = np.random.randint(10000)
         np.random.seed(seed)
 
-        if modulation in ['electrode', 'template']:
+        if modulation in ["electrode", "template"]:
             mod_bool = True
             if bursting_units is not None:
                 if st in bursting_units and shape_mod:
                     unit_burst = True
                 else:
                     unit_burst = False
             else:
                 unit_burst = False
             mod_array = amp_mod[st]
         else:  # modulation 'none'
             mod_bool = False
             mod_array = None
             unit_burst = False
 
-        spike_in_chunk, = np.nonzero((st_idx >= i_start_pad) & (st_idx < i_stop_pad))
+        (spike_in_chunk,) = np.nonzero((st_idx >= i_start_pad) & (st_idx < i_stop_pad))
 
         if len(spike_in_chunk) > 0:
             st_idx_in_chunk_pad = st_idx[spike_in_chunk] - i_start_pad
 
             if drifting:
                 drift_idxs_in_chunk = np.zeros(len(st_idx_in_chunk_pad), dtype="uint16")
-                
+
                 spike_times_in_chunk = st_idx[spike_in_chunk]
                 drift_idxs_in_chunk = compute_drift_idxs_from_drift_list(st, spike_times_in_chunk, drift_list, fs)
-                
+
                 # 4d
                 template = templates[st]
                 if extract_spike_traces:
                     central_template = templates[st, default_drift_ind, :, max_electrode, :]
             else:
                 drift_idxs_in_chunk = None
                 # drift_fs = None
@@ -174,121 +230,153 @@
                 elif templates.ndim == 5:
                     drift_vector = None
                     # 3d no drift
                     template = templates[st, default_drift_ind]
                     if extract_spike_traces:
                         central_template = templates[st, default_drift_ind, :, max_electrode, :]
                 else:
-                    raise Exception(f'templates.shape no 4 or 5 {templates.shape}')
+                    raise Exception(f"templates.shape no 4 or 5 {templates.shape}")
 
-            recordings = convolve_templates_spiketrains(st, st_idx_in_chunk_pad, 
-                                                        template,
-                                                        n_samples=n_samples,
-                                                        cut_out=cut_outs_samples,
-                                                        modulation=mod_bool,
-                                                        mod_array=mod_array,
-                                                        bursting=unit_burst,
-                                                        shape_stretch=shape_stretch,
-                                                        verbose=verbose,
-                                                        recordings=recordings,
-                                                        drift_idxs=drift_idxs_in_chunk)
+            recordings = convolve_templates_spiketrains(
+                st,
+                st_idx_in_chunk_pad,
+                template,
+                n_samples=n_samples,
+                cut_out=cut_outs_samples,
+                modulation=mod_bool,
+                mod_array=mod_array,
+                bursting=unit_burst,
+                shape_stretch=shape_stretch,
+                verbose=verbose,
+                recordings=recordings,
+                drift_idxs=drift_idxs_in_chunk,
+            )
             np.random.seed(seed)
             if extract_spike_traces:
-                spike_traces[:, st] = convolve_single_template(st, st_idx_in_chunk_pad,
-                                                               central_template,
-                                                               n_samples=n_samples,
-                                                               cut_out=cut_outs_samples,
-                                                               modulation=mod_bool,
-                                                               mod_array=mod_array,
-                                                               bursting=unit_burst,
-                                                               shape_stretch=shape_stretch)
+                spike_traces[:, st] = convolve_single_template(
+                    st,
+                    st_idx_in_chunk_pad,
+                    central_template,
+                    n_samples=n_samples,
+                    cut_out=cut_outs_samples,
+                    modulation=mod_bool,
+                    mod_array=mod_array,
+                    bursting=unit_burst,
+                    shape_stretch=shape_stretch,
+                )
         else:
             if verbose:
-                print('No spikes found in chunk', ch, 'for spike train', st)
+                print("No spikes found in chunk", ch, "for spike train", st)
 
     if verbose:
-        print('Done all convolutions for chunk', ch)
+        print("Done all convolutions for chunk", ch)
 
     return_dict = dict()
     if pad_samples > 0:
         recordings_ret = recordings[pad_samples:-pad_samples]
     else:
         recordings_ret = recordings
 
     if extract_spike_traces:
-        return_dict['spike_traces'] = spike_traces[pad_samples:-pad_samples]
+        return_dict["spike_traces"] = spike_traces[pad_samples:-pad_samples]
 
     if lsb is not None:
         recordings_ret = np.floor_divide(recordings_ret, lsb) * lsb
-    
-    return_dict['recordings'] = recordings_ret.astype(dtype)
-    return_dict['template_idxs'] = template_idxs
+
+    return_dict["recordings"] = recordings_ret.astype(dtype)
+    return_dict["template_idxs"] = template_idxs
 
     return return_dict
 
 
 chunk_convolution = FuncThenAddChunk(chunk_convolution_)
 
 
-def chunk_uncorrelated_noise_(ch, i_start, i_stop, fs, lsb, 
-                              num_chan, noise_level, noise_color, color_peak, color_q, color_noise_floor, dtype,
-                              seed_list):
+def chunk_uncorrelated_noise_(
+    ch,
+    i_start,
+    i_stop,
+    fs,
+    lsb,
+    num_chan,
+    noise_level,
+    noise_color,
+    color_peak,
+    color_q,
+    color_noise_floor,
+    dtype,
+    seed_list,
+):
     np.random.seed(seed_list[ch])
     length = i_stop - i_start
     additive_noise = noise_level * np.random.randn(length, num_chan)
 
     if noise_color:
         # iir peak filter
         b_iir, a_iir = scipy.signal.iirpeak(color_peak, Q=color_q, fs=fs)
         additive_noise = scipy.signal.filtfilt(b_iir, a_iir, additive_noise, axis=0, padlen=1000)
-        additive_noise += color_noise_floor * np.std(additive_noise) * \
-                          np.random.randn(additive_noise.shape[0], additive_noise.shape[1])
+        additive_noise += (
+            color_noise_floor
+            * np.std(additive_noise)
+            * np.random.randn(additive_noise.shape[0], additive_noise.shape[1])
+        )
         additive_noise = additive_noise * (noise_level / np.std(additive_noise))
 
     return_dict = {}
     if lsb is not None:
         additive_noise = np.floor_divide(additive_noise, lsb) * lsb
-    return_dict['additive_noise'] = additive_noise.astype(dtype)
+    return_dict["additive_noise"] = additive_noise.astype(dtype)
 
     return return_dict
 
 
 chunk_uncorrelated_noise = FuncThenAddChunk(chunk_uncorrelated_noise_)
 
 
-def chunk_distance_correlated_noise_(ch, i_start, i_stop, fs, lsb,
-                                     noise_level, cov_dist, n_elec, noise_color, color_peak, color_q, color_noise_floor,
-                                     dtype, seed_list):
+def chunk_distance_correlated_noise_(
+    ch,
+    i_start,
+    i_stop,
+    fs,
+    lsb,
+    noise_level,
+    cov_dist,
+    n_elec,
+    noise_color,
+    color_peak,
+    color_q,
+    color_noise_floor,
+    dtype,
+    seed_list,
+):
     np.random.seed(seed_list[ch])
     length = i_stop - i_start
 
-    additive_noise = noise_level * np.random.multivariate_normal(np.zeros(n_elec), cov_dist,
-                                                                 size=length)
+    additive_noise = noise_level * np.random.multivariate_normal(np.zeros(n_elec), cov_dist, size=length)
     if noise_color:
         # iir peak filter
         b_iir, a_iir = scipy.signal.iirpeak(color_peak, Q=color_q, fs=fs)
         additive_noise = scipy.signal.filtfilt(b_iir, a_iir, additive_noise, axis=0, padlen=1000)
-        additive_noise = additive_noise + color_noise_floor * np.std(additive_noise) * \
-                         np.random.multivariate_normal(np.zeros(n_elec), cov_dist,
-                                                       size=length)
+        additive_noise = additive_noise + color_noise_floor * np.std(additive_noise) * np.random.multivariate_normal(
+            np.zeros(n_elec), cov_dist, size=length
+        )
     additive_noise = additive_noise * (noise_level / np.std(additive_noise))
 
     return_dict = {}
     if lsb is not None:
         additive_noise = np.floor_divide(additive_noise, lsb) * lsb
-    return_dict['additive_noise'] = additive_noise.astype(dtype)
+    return_dict["additive_noise"] = additive_noise.astype(dtype)
 
     return return_dict
 
 
 chunk_distance_correlated_noise = FuncThenAddChunk(chunk_distance_correlated_noise_)
 
 
-def chunk_apply_filter_(ch, i_start, i_stop, fs, lsb,
-                        recordings, pad_samples, cutoff, order, dtype):
+def chunk_apply_filter_(ch, i_start, i_stop, fs, lsb, recordings, pad_samples, cutoff, order, mode, dtype):
     n_samples = recordings.shape[0]
 
     # compute padding idxs
     if pad_samples > 0:
         if i_start > pad_samples:
             i_start_pad = i_start - pad_samples
             pad_start_samples = pad_samples
@@ -302,29 +390,38 @@
             i_stop_pad = n_samples
             pad_stop_samples = n_samples - i_stop
     else:
         i_start_pad = i_start
         i_stop_pad = i_stop
 
     if cutoff.size == 1:
-        filtered_chunk = filter_analog_signals(recordings[i_start_pad:i_stop_pad], freq=cutoff, fs=fs,
-                                               filter_type='highpass', order=order)
+        filtered_chunk = filter_analog_signals(
+            recordings[i_start_pad:i_stop_pad], freq=cutoff, fs=fs, filter_type="highpass", mode=mode, order=order
+        )
     elif cutoff.size == 2:
-        if fs / 2. < cutoff[1]:
-            filtered_chunk = filter_analog_signals(recordings[i_start_pad:i_stop_pad], freq=cutoff[0], fs=fs,
-                                                   filter_type='highpass', order=order)
+        if fs / 2.0 < cutoff[1]:
+            filtered_chunk = filter_analog_signals(
+                recordings[i_start_pad:i_stop_pad],
+                freq=cutoff[0],
+                fs=fs,
+                filter_type="highpass",
+                mode=mode,
+                order=order,
+            )
         else:
-            filtered_chunk = filter_analog_signals(recordings[i_start_pad:i_stop_pad], freq=cutoff, fs=fs)
+            filtered_chunk = filter_analog_signals(
+                recordings[i_start_pad:i_stop_pad], freq=cutoff, fs=fs, filter_type="bandpass", mode=mode, order=order
+            )
 
     filtered_chunk = filtered_chunk
     if pad_samples > 0:
-        filtered_chunk = filtered_chunk[pad_start_samples:filtered_chunk.shape[0] - pad_stop_samples]
+        filtered_chunk = filtered_chunk[pad_start_samples : filtered_chunk.shape[0] - pad_stop_samples]
 
     return_dict = {}
     if lsb is not None:
         filtered_chunk = np.floor_divide(filtered_chunk, lsb) * lsb
-    return_dict['filtered_chunk'] = filtered_chunk.astype(dtype)
+    return_dict["filtered_chunk"] = filtered_chunk.astype(dtype)
 
     return return_dict
 
 
-chunk_apply_filter = FuncThenAddChunk(chunk_apply_filter_)
+chunk_apply_filter = FuncThenReplaceChunk(chunk_apply_filter_)
```

### Comparing `MEArec-1.8.0/MEArec/generators/recordinggenerator.py` & `MEArec-1.9.0/src/MEArec/generators/recordinggenerator.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,48 +1,41 @@
 # don't enter here without a good guide! (only one person in the world)
 
-from distutils.log import DEBUG
-import numpy as np
-import time
-from copy import deepcopy
-from MEArec.tools import (select_templates, find_overlapping_templates, get_binary_cat, sigmoid,
-                          resample_templates, jitter_templates, pad_templates, get_templates_features,
-                          compute_modulation, annotate_overlapping_spikes, extract_wf)
-
-from .recgensteps import (chunk_convolution, chunk_uncorrelated_noise,
-                          chunk_distance_correlated_noise, chunk_apply_filter)
-
-from ..drift_tools import generate_drift_dict_from_params
-
-import random
-import string
-import MEAutility as mu
-import yaml
 import os
+import random
 import shutil
-from warnings import warn
-import quantities as pq
-from packaging.version import parse
+import string
 import tempfile
+import time
+from copy import deepcopy
+from distutils.log import DEBUG
 from pathlib import Path
+from warnings import warn
 
+import MEAutility as mu
+import numpy as np
+import quantities as pq
+import yaml
 from joblib import Parallel, delayed
+from packaging.version import parse
 
-from MEArec.generators import SpikeTrainGenerator
+from ..drift_tools import generate_drift_dict_from_params
+from ..tools import (annotate_overlapping_spikes, compute_modulation,
+                     extract_wf, find_overlapping_templates, get_binary_cat,
+                     get_templates_features, jitter_templates, pad_templates,
+                     resample_templates, select_templates, sigmoid)
+from .recgensteps import (chunk_apply_filter, chunk_convolution,
+                          chunk_distance_correlated_noise,
+                          chunk_uncorrelated_noise)
 
-if parse(yaml.__version__) >= parse('5.0.0'):
-    use_loader = True
-else:
-    use_loader = False
-    
-    
 DEBUG = False
 
 if DEBUG:
     import matplotlib.pyplot as plt
+
     plt.ion()
     plt.show()
 
 
 class RecordingGenerator:
     """
     Class for generation of recordings called by the gen_recordings function.
@@ -70,94 +63,92 @@
           - voltage_peaks : float (n_spiketrains, n_electrodes)
           - spike_traces : float (n_spiketrains, n_samples)
     info :  dict
         Info dictionary to instantiate RecordingGenerator with existing data. Same fields as 'params'
     """
 
     def __init__(self, spgen=None, tempgen=None, params=None, rec_dict=None, info=None):
+        from . import SpikeTrainGenerator
+
         self._verbose = False
         self._verbose_1 = False
         self._verbose_2 = False
 
         if rec_dict is not None and info is not None:
-            if 'recordings' in rec_dict.keys():
-                self.recordings = rec_dict['recordings']
+            if "recordings" in rec_dict.keys():
+                self.recordings = rec_dict["recordings"]
             else:
                 self.recordings = np.array([])
-            if 'spiketrains' in rec_dict.keys():
-                self.spiketrains = deepcopy(rec_dict['spiketrains'])
+            if "spiketrains" in rec_dict.keys():
+                self.spiketrains = deepcopy(rec_dict["spiketrains"])
             else:
                 self.spiketrains = np.array([])
-            if 'templates' in rec_dict.keys():
-                self.templates = rec_dict['templates']
+            if "templates" in rec_dict.keys():
+                self.templates = rec_dict["templates"]
             else:
                 self.templates = np.array([])
-            if 'original_templates' in rec_dict.keys():
-                self.original_templates = rec_dict['original_templates']
+            if "original_templates" in rec_dict.keys():
+                self.original_templates = rec_dict["original_templates"]
             else:
                 self.original_templates = np.array([])
-            if 'template_locations' in rec_dict.keys():
-                self.template_locations = rec_dict['template_locations']
+            if "template_locations" in rec_dict.keys():
+                self.template_locations = rec_dict["template_locations"]
             else:
                 self.template_locations = np.array([])
-            if 'template_rotations' in rec_dict.keys():
-                self.template_rotations = rec_dict['template_rotations']
+            if "template_rotations" in rec_dict.keys():
+                self.template_rotations = rec_dict["template_rotations"]
             else:
                 self.template_rotations = np.array([])
-            if 'template_celltypes' in rec_dict.keys():
-                self.template_celltypes = rec_dict['template_celltypes']
+            if "template_celltypes" in rec_dict.keys():
+                self.template_celltypes = rec_dict["template_celltypes"]
             else:
                 self.template_celltypes = np.array([])
-            if 'channel_positions' in rec_dict.keys():
-                self.channel_positions = rec_dict['channel_positions']
+            if "channel_positions" in rec_dict.keys():
+                self.channel_positions = rec_dict["channel_positions"]
             else:
                 self.channel_positions = np.array([])
-            if 'timestamps' in rec_dict.keys():
-                self.timestamps = rec_dict['timestamps']
+            if "timestamps" in rec_dict.keys():
+                self.timestamps = rec_dict["timestamps"]
             else:
                 self.timestamps = np.array([])
-            if 'voltage_peaks' in rec_dict.keys():
-                self.voltage_peaks = rec_dict['voltage_peaks']
+            if "voltage_peaks" in rec_dict.keys():
+                self.voltage_peaks = rec_dict["voltage_peaks"]
             else:
                 self.voltage_peaks = np.array([])
-            if 'spike_traces' in rec_dict.keys():
-                self.spike_traces = rec_dict['spike_traces']
+            if "spike_traces" in rec_dict.keys():
+                self.spike_traces = rec_dict["spike_traces"]
             else:
                 self.spike_traces = np.array([])
-            if 'template_ids' in rec_dict.keys():
-                self.template_ids = rec_dict['template_ids']
+            if "template_ids" in rec_dict.keys():
+                self.template_ids = rec_dict["template_ids"]
             else:
                 self.template_ids = None
-            if 'drift_list' in rec_dict.keys():
-                self.drift_list = rec_dict['drift_list']
+            if "drift_list" in rec_dict.keys():
+                self.drift_list = rec_dict["drift_list"]
             else:
                 self.drift_list = None
 
             self.info = deepcopy(info)
             self.params = deepcopy(info)
             if len(self.spiketrains) > 0:
-                if 'spiketrains' in self.info:
-                    self.spgen = SpikeTrainGenerator(spiketrains=self.spiketrains, params=self.info['spiketrains'])
+                if "spiketrains" in self.info:
+                    self.spgen = SpikeTrainGenerator(spiketrains=self.spiketrains, params=self.info["spiketrains"])
                 else:
-                    self.spgen = SpikeTrainGenerator(spiketrains=self.spiketrains, params={'custom': True})
+                    self.spgen = SpikeTrainGenerator(spiketrains=self.spiketrains, params={"custom": True})
             self.tempgen = None
             if isinstance(self.recordings, np.memmap):
-                self.tmp_mode = 'memmap'
+                self.tmp_mode = "memmap"
             else:
                 self.tmp_mode = None
 
         else:
             if spgen is None or tempgen is None:
                 raise AttributeError("Specify SpikeTrainGenerator and TemplateGenerator objects!")
             if params is None:
-                params = {'spiketrains': {},
-                          'celltypes': {},
-                          'templates': {},
-                          'recordings': {},
-                          'seeds': {}}
+                params = {"spiketrains": {}, "celltypes": {}, "templates": {}, "recordings": {}, "seeds": {}}
             self.params = deepcopy(params)
             self.spgen = spgen
             self.tempgen = tempgen
             self.tmp_mode = None
             self.template_ids = None
 
         self.overlapping = []
@@ -169,32 +160,33 @@
 
     def __del__(self):
         if not self._is_tmp_folder_local:
             if self.tmp_folder is not None:
                 try:
                     shutil.rmtree(self.tmp_folder)
                     if self._verbose >= 1:
-                        print('Deleted', self.tmp_folder)
+                        print("Deleted", self.tmp_folder)
                 except Exception as e:
                     if self._verbose >= 1:
-                        print('Impossible to delete temp file:', self.tmp_folder, 'Error', e)
+                        print("Impossible to delete temp file:", self.tmp_folder, "Error", e)
         else:
             for fname in self._to_remove_on_delete:
                 try:
                     os.remove(fname)
                     if self._verbose >= 1:
-                        print('Deleted', fname)
+                        print("Deleted", fname)
                 except Exception as e:
                     if self._verbose >= 1:
-                        print('Impossible to delete temp file:', fname, 'Error', e)
+                        print("Impossible to delete temp file:", fname, "Error", e)
         self.recordings = None
         self.spike_traces = None
 
-    def generate_recordings(self, tmp_mode=None, tmp_folder=None, n_jobs=0, template_ids=None, 
-                            drift_dicts=None, verbose=None):
+    def generate_recordings(
+        self, tmp_mode=None, tmp_folder=None, n_jobs=0, template_ids=None, drift_dicts=None, verbose=None
+    ):
         """
         Generates recordings
 
         Parameters
         ----------
         tmp_mode : None, 'memmap'
             Use temporary file h5 memmap or None
@@ -215,15 +207,15 @@
 
         self.tmp_mode = tmp_mode
         self.tmp_folder = tmp_folder
         self.template_ids = template_ids
         self.n_jobs = n_jobs
 
         if tmp_mode is not None:
-            tmp_prefix = ''.join([random.choice(string.ascii_letters) for i in range(5)]) + '_'
+            tmp_prefix = "".join([random.choice(string.ascii_letters) for i in range(5)]) + "_"
         if self.tmp_mode is not None:
             if self.tmp_folder is None:
                 self.tmp_folder = Path(tempfile.mkdtemp())
                 self._is_tmp_folder_local = False
             else:
                 self.tmp_folder = Path(self.tmp_folder)
                 self._is_tmp_folder_local = True
@@ -244,427 +236,462 @@
         else:  # None
             verbose_1 = False
             verbose_2 = False
         self._verbose_1 = verbose_1
         self._verbose_2 = verbose_2
 
         params = deepcopy(self.params)
-        temp_params = self.params['templates']
-        rec_params = self.params['recordings']
-        st_params = self.params['spiketrains']
-        seeds = self.params['seeds']
+        temp_params = self.params["templates"]
+        rec_params = self.params["recordings"]
+        st_params = self.params["spiketrains"]
+        seeds = self.params["seeds"]
 
-        if 'chunk_duration' not in rec_params.keys():
+        if "chunk_duration" not in rec_params.keys():
             rec_params["chunk_duration"] = None
         if rec_params["chunk_duration"] is None:
             rec_params["chunk_duration"] = 0
-            
+
         if self.n_jobs > 1 and rec_params["chunk_duration"] == 0:
-            warn(f'For n_jobs {self.n_jobs} you should set chunk_duration > 0. Setting chunk_duration to 5s')
+            warn(f"For n_jobs {self.n_jobs} you should set chunk_duration > 0. Setting chunk_duration to 5s")
             rec_params["chunk_duration"] = 5
-            
-        if 'cell_types' in self.params.keys():
-            celltype_params = self.params['cell_types']
+
+        if "cell_types" in self.params.keys():
+            celltype_params = self.params["cell_types"]
         else:
             celltype_params = {}
 
         tempgen = self.tempgen
         spgen = self.spgen
         if tempgen is not None:
             eaps = tempgen.templates
             locs = tempgen.locations
             rots = tempgen.rotations
             celltypes = tempgen.celltypes
             temp_info = tempgen.info
-            cut_outs = temp_info['params']['cut_out']
+            cut_outs = temp_info["params"]["cut_out"]
         else:
             temp_info = None
-            cut_outs = self.params['templates']['cut_out']
+            cut_outs = self.params["templates"]["cut_out"]
 
         spiketrains = spgen.spiketrains
         n_neurons = len(spiketrains)
 
         if len(spiketrains) > 0:
             duration = spiketrains[0].t_stop - spiketrains[0].t_start
             only_noise = False
         else:
             if verbose_1:
-                print('No spike trains provided: only simulating noise')
+                print("No spike trains provided: only simulating noise")
             only_noise = True
-            duration = st_params['duration'] * pq.s
+            duration = st_params["duration"] * pq.s
 
-        if 'fs' not in rec_params.keys() and temp_info is not None:
+        if "fs" not in rec_params.keys() and temp_info is not None:
             # when computed from templates fs is in kHz
-            params['recordings']['fs'] = 1. / temp_info['params']['dt']
-            fs = (params['recordings']['fs'] * pq.kHz).rescale('Hz')
+            params["recordings"]["fs"] = 1.0 / temp_info["params"]["dt"]
+            fs = (params["recordings"]["fs"] * pq.kHz).rescale("Hz")
             spike_fs = fs
-        elif params['recordings']['fs'] is None and temp_info is not None:
-            params['recordings']['fs'] = 1. / temp_info['params']['dt']
-            fs = (params['recordings']['fs'] * pq.kHz).rescale('Hz')
+        elif params["recordings"]["fs"] is None and temp_info is not None:
+            params["recordings"]["fs"] = 1.0 / temp_info["params"]["dt"]
+            fs = (params["recordings"]["fs"] * pq.kHz).rescale("Hz")
             spike_fs = fs
         else:
             # In the rec_params fs is in Hz
-            fs = params['recordings']['fs'] * pq.Hz
+            fs = params["recordings"]["fs"] * pq.Hz
             if temp_info is not None:
-                spike_fs = (1. / temp_info['params']['dt'] * pq.kHz).rescale('Hz')
+                spike_fs = (1.0 / temp_info["params"]["dt"] * pq.kHz).rescale("Hz")
             else:
                 spike_fs = fs
 
-        if 'dtype' not in rec_params.keys():
-            params['recordings']['dtype'] = 'float32'
-        elif rec_params['dtype'] is None:
-            params['recordings']['dtype'] = 'float32'
-        else:
-            params['recordings']['dtype'] = rec_params['dtype']
-        dtype = params['recordings']['dtype']
-        
+        if "dtype" not in rec_params.keys():
+            params["recordings"]["dtype"] = "float32"
+        elif rec_params["dtype"] is None:
+            params["recordings"]["dtype"] = "float32"
+        else:
+            params["recordings"]["dtype"] = rec_params["dtype"]
+        dtype = params["recordings"]["dtype"]
+
         assert np.dtype(dtype).kind in ("i", "f"), "Only integers and float dtypes are supported"
-        
-        params['recordings']['adc_bit_depth'] = rec_params.get('adc_bit_depth', None)
-        adc_bit_depth = params['recordings']['adc_bit_depth']
-        params['recordings']['lsb'] = rec_params.get('lsb', None)
-        lsb = params['recordings']['lsb']
+
+        params["recordings"]["adc_bit_depth"] = rec_params.get("adc_bit_depth", None)
+        adc_bit_depth = params["recordings"]["adc_bit_depth"]
+        params["recordings"]["lsb"] = rec_params.get("lsb", None)
+        lsb = params["recordings"]["lsb"]
         if lsb is None and np.dtype(dtype).kind == "i":
             lsb = 1
-        params['recordings']['gain'] = rec_params.get('gain', None)
-        gain = params['recordings']['gain']
+        params["recordings"]["gain"] = rec_params.get("gain", None)
+        gain = params["recordings"]["gain"]
 
         if verbose_1:
             print(f"dtype {dtype}")
             if np.dtype(dtype).kind == "i":
                 print(f"ADC bit depth: {adc_bit_depth} -- LSB: {lsb}")
 
-        if 'noise_mode' not in rec_params.keys():
-            params['recordings']['noise_mode'] = 'uncorrelated'
-        noise_mode = params['recordings']['noise_mode']
-
-        assert noise_mode in ["uncorrelated", "distance-correlated", "far-neurons"], \
-            "'noise_mode can be: 'uncorrelated', 'distance-correlated', or 'far-neurons'"
-
-        if 'noise_color' not in rec_params.keys():
-            params['recordings']['noise_color'] = False
-        noise_color = params['recordings']['noise_color']
-
-        if 'sync_rate' not in rec_params.keys():
-            params['recordings']['sync_rate'] = None
-        sync_rate = params['recordings']['sync_rate']
-
-        if 'sync_jitt' not in rec_params.keys():
-            params['recordings']['sync_jitt'] = 1
-        sync_jitt = params['recordings']['sync_jitt'] * pq.ms
-
-        if noise_mode == 'distance-correlated':
-            if 'noise_half_distance' not in rec_params.keys():
-                params['recordings']['noise_half_distance'] = 30
-            half_dist = params['recordings']['noise_half_distance']
-
-        if noise_mode == 'far-neurons':
-            if 'far_neurons_n' not in rec_params.keys():
-                params['recordings']['far_neurons_n'] = 300
-            far_neurons_n = params['recordings']['far_neurons_n']
-            if 'far_neurons_max_amp' not in rec_params.keys():
-                params['recordings']['far_neurons_max_amp'] = 20
-            far_neurons_max_amp = params['recordings']['far_neurons_max_amp']
-            if 'far_neurons_noise_floor' not in rec_params.keys():
-                params['recordings']['far_neurons_noise_floor'] = 0.5
-            far_neurons_noise_floor = params['recordings']['far_neurons_noise_floor']
-            if 'far_neurons_exc_inh_ratio' not in rec_params.keys():
-                params['recordings']['far_neurons_exc_inh_ratio'] = 0.8
-            far_neurons_exc_inh_ratio = params['recordings']['far_neurons_exc_inh_ratio']
+        if "noise_mode" not in rec_params.keys():
+            params["recordings"]["noise_mode"] = "uncorrelated"
+        noise_mode = params["recordings"]["noise_mode"]
+
+        assert noise_mode in [
+            "uncorrelated",
+            "distance-correlated",
+            "far-neurons",
+        ], "'noise_mode can be: 'uncorrelated', 'distance-correlated', or 'far-neurons'"
+
+        if "noise_color" not in rec_params.keys():
+            params["recordings"]["noise_color"] = False
+        noise_color = params["recordings"]["noise_color"]
+
+        if "sync_rate" not in rec_params.keys():
+            params["recordings"]["sync_rate"] = None
+        sync_rate = params["recordings"]["sync_rate"]
+
+        if "sync_jitt" not in rec_params.keys():
+            params["recordings"]["sync_jitt"] = 1
+        sync_jitt = params["recordings"]["sync_jitt"] * pq.ms
+
+        if noise_mode == "distance-correlated":
+            if "noise_half_distance" not in rec_params.keys():
+                params["recordings"]["noise_half_distance"] = 30
+            half_dist = params["recordings"]["noise_half_distance"]
+
+        if noise_mode == "far-neurons":
+            if "far_neurons_n" not in rec_params.keys():
+                params["recordings"]["far_neurons_n"] = 300
+            far_neurons_n = params["recordings"]["far_neurons_n"]
+            if "far_neurons_max_amp" not in rec_params.keys():
+                params["recordings"]["far_neurons_max_amp"] = 20
+            far_neurons_max_amp = params["recordings"]["far_neurons_max_amp"]
+            if "far_neurons_noise_floor" not in rec_params.keys():
+                params["recordings"]["far_neurons_noise_floor"] = 0.5
+            far_neurons_noise_floor = params["recordings"]["far_neurons_noise_floor"]
+            if "far_neurons_exc_inh_ratio" not in rec_params.keys():
+                params["recordings"]["far_neurons_exc_inh_ratio"] = 0.8
+            far_neurons_exc_inh_ratio = params["recordings"]["far_neurons_exc_inh_ratio"]
 
         if noise_color:
-            if 'color_peak' not in rec_params.keys():
-                params['recordings']['color_peak'] = 500
-            color_peak = params['recordings']['color_peak']
-            if 'color_q' not in rec_params.keys():
-                params['recordings']['color_q'] = 1
-            color_q = params['recordings']['color_q']
-            if 'color_noise_floor' not in rec_params.keys():
-                params['recordings']['color_noise_floor'] = 1
-            color_noise_floor = params['recordings']['color_noise_floor']
+            if "color_peak" not in rec_params.keys():
+                params["recordings"]["color_peak"] = 500
+            color_peak = params["recordings"]["color_peak"]
+            if "color_q" not in rec_params.keys():
+                params["recordings"]["color_q"] = 1
+            color_q = params["recordings"]["color_q"]
+            if "color_noise_floor" not in rec_params.keys():
+                params["recordings"]["color_noise_floor"] = 1
+            color_noise_floor = params["recordings"]["color_noise_floor"]
         else:
             color_peak, color_q, color_noise_floor = None, None, None
 
-        if 'noise_level' not in rec_params.keys():
-            params['recordings']['noise_level'] = 10
-        noise_level = params['recordings']['noise_level']
+        if "noise_level" not in rec_params.keys():
+            params["recordings"]["noise_level"] = 10
+        noise_level = params["recordings"]["noise_level"]
 
         if verbose_1:
-            print('Noise Level ', noise_level)
+            print("Noise Level ", noise_level)
 
-        if 'filter' not in rec_params.keys():
-            params['recordings']['filter'] = True
-        filter = params['recordings']['filter']
-
-        if 'filter_cutoff' not in rec_params.keys():
-            params['recordings']['filter_cutoff'] = [300., 6000.]
-        cutoff = params['recordings']['filter_cutoff'] * pq.Hz
-
-        if 'filter_order' not in rec_params.keys():
-            params['recordings']['filter_order'] = 3
-        order = params['recordings']['filter_order']
-
-        if 'modulation' not in rec_params.keys():
-            params['recordings']['modulation'] = 'electrode'
-        elif params['recordings']['modulation'] not in ['none', 'electrode', 'template']:
+        if "filter" not in rec_params.keys():
+            params["recordings"]["filter"] = True
+        filter = params["recordings"]["filter"]
+
+        if "filter_cutoff" not in rec_params.keys():
+            params["recordings"]["filter_cutoff"] = [300.0, 6000.0]
+        cutoff = params["recordings"]["filter_cutoff"] * pq.Hz
+
+        if "filter_order" not in rec_params.keys():
+            params["recordings"]["filter_order"] = 3
+        filter_order = params["recordings"]["filter_order"]
+
+        if "filter_mode" not in rec_params.keys():
+            params["recordings"]["filter_mode"] = "filtfilt"
+        filter_mode = params["recordings"]["filter_mode"]
+
+        if "modulation" not in rec_params.keys():
+            params["recordings"]["modulation"] = "electrode"
+        elif params["recordings"]["modulation"] not in ["none", "electrode", "template"]:
             raise Exception("'modulation' can be 'none', 'template', or 'electrode'")
-        modulation = params['recordings']['modulation']
+        modulation = params["recordings"]["modulation"]
 
-        if 'bursting' not in rec_params.keys():
-            params['recordings']['bursting'] = False
-        bursting = params['recordings']['bursting']
-
-        if 'shape_mod' not in rec_params.keys():
-            params['recordings']['shape_mod'] = False
-        shape_mod = params['recordings']['shape_mod']
+        if "bursting" not in rec_params.keys():
+            params["recordings"]["bursting"] = False
+        bursting = params["recordings"]["bursting"]
+
+        if "shape_mod" not in rec_params.keys():
+            params["recordings"]["shape_mod"] = False
+        shape_mod = params["recordings"]["shape_mod"]
 
         if bursting:
-            if 'bursting_units' not in rec_params.keys():
-                rec_params['bursting_units'] = None
+            if "bursting_units" not in rec_params.keys():
+                rec_params["bursting_units"] = None
 
-            if rec_params['bursting_units'] is not None:
-                assert np.all([b < n_neurons for b in rec_params['bursting_units']]), \
-                    "'bursting_units' ids should be lower than the number of neurons"
-                n_bursting = len(rec_params['bursting_units'])
-                bursting_units = rec_params['bursting_units']
+            if rec_params["bursting_units"] is not None:
+                assert np.all(
+                    [b < n_neurons for b in rec_params["bursting_units"]]
+                ), "'bursting_units' ids should be lower than the number of neurons"
+                n_bursting = len(rec_params["bursting_units"])
+                bursting_units = rec_params["bursting_units"]
             else:
-                if rec_params['n_bursting'] is None:
+                if rec_params["n_bursting"] is None:
                     n_bursting = n_neurons
                     bursting_units = np.arange(n_neurons)
                 else:
-                    n_bursting = rec_params['n_bursting']
+                    n_bursting = rec_params["n_bursting"]
                     bursting_units = np.random.permutation(n_neurons)[:n_bursting]
 
-            if 'exp_decay' not in rec_params.keys():
-                params['recordings']['exp_decay'] = [0.2] * n_bursting
+            if "exp_decay" not in rec_params.keys():
+                params["recordings"]["exp_decay"] = [0.2] * n_bursting
             else:
-                if not isinstance(rec_params['exp_decay'], list):
-                    assert isinstance(rec_params['exp_decay'], float), "'exp_decay' can be list or float"
-                    params['recordings']['exp_decay'] = [rec_params['exp_decay']] * n_bursting
+                if not isinstance(rec_params["exp_decay"], list):
+                    assert isinstance(rec_params["exp_decay"], float), "'exp_decay' can be list or float"
+                    params["recordings"]["exp_decay"] = [rec_params["exp_decay"]] * n_bursting
                 else:
-                    assert len(rec_params['exp_decay']) == n_bursting, "'exp_decay' should have the same length as " \
-                                                                       "the number of bursting units"
-                    params['recordings']['exp_decay'] = rec_params['exp_decay']
-            exp_decay = params['recordings']['exp_decay']
-
-            if 'n_burst_spikes' not in rec_params.keys():
-                params['recordings']['exp_decay'] = [10] * n_bursting
-            else:
-                if not isinstance(rec_params['n_burst_spikes'], list):
-                    assert isinstance(rec_params['n_burst_spikes'], int), "'n_burst_spikes' can be list or int"
-                    params['recordings']['n_burst_spikes'] = [rec_params['n_burst_spikes']] * n_bursting
+                    assert len(rec_params["exp_decay"]) == n_bursting, (
+                        "'exp_decay' should have the same length as " "the number of bursting units"
+                    )
+                    params["recordings"]["exp_decay"] = rec_params["exp_decay"]
+            exp_decay = params["recordings"]["exp_decay"]
+
+            if "n_burst_spikes" not in rec_params.keys():
+                params["recordings"]["exp_decay"] = [10] * n_bursting
+            else:
+                if not isinstance(rec_params["n_burst_spikes"], list):
+                    assert isinstance(rec_params["n_burst_spikes"], int), "'n_burst_spikes' can be list or int"
+                    params["recordings"]["n_burst_spikes"] = [rec_params["n_burst_spikes"]] * n_bursting
                 else:
-                    assert len(rec_params['n_burst_spikes']) == n_bursting, "'n_burst_spikes' should have the same " \
-                                                                            "length as the number of bursting units"
-                    params['recordings']['n_burst_spikes'] = rec_params['n_burst_spikes']
-            n_burst_spikes = params['recordings']['n_burst_spikes']
-
-            if 'max_burst_duration' not in rec_params.keys():
-                params['recordings']['max_burst_duration'] = [100] * n_bursting
-            else:
-                if not isinstance(rec_params['max_burst_duration'], list):
-                    assert isinstance(rec_params['max_burst_duration'], (float, int, np.integer)), \
-                        "'max_burst_duration' can be list or scalar"
-                    params['recordings']['max_burst_duration'] = [rec_params['max_burst_duration']] * n_bursting
+                    assert len(rec_params["n_burst_spikes"]) == n_bursting, (
+                        "'n_burst_spikes' should have the same " "length as the number of bursting units"
+                    )
+                    params["recordings"]["n_burst_spikes"] = rec_params["n_burst_spikes"]
+            n_burst_spikes = params["recordings"]["n_burst_spikes"]
+
+            if "max_burst_duration" not in rec_params.keys():
+                params["recordings"]["max_burst_duration"] = [100] * n_bursting
+            else:
+                if not isinstance(rec_params["max_burst_duration"], list):
+                    assert isinstance(
+                        rec_params["max_burst_duration"], (float, int, np.integer)
+                    ), "'max_burst_duration' can be list or scalar"
+                    params["recordings"]["max_burst_duration"] = [rec_params["max_burst_duration"]] * n_bursting
                 else:
-                    assert len(rec_params['max_burst_duration']) == n_bursting, \
-                        "'max_burst_duration' should have the same length as the number of bursting units"
-                    params['recordings']['max_burst_duration'] = rec_params['max_burst_duration']
-            max_burst_duration = [m * pq.ms for m in params['recordings']['max_burst_duration']]
+                    assert (
+                        len(rec_params["max_burst_duration"]) == n_bursting
+                    ), "'max_burst_duration' should have the same length as the number of bursting units"
+                    params["recordings"]["max_burst_duration"] = rec_params["max_burst_duration"]
+            max_burst_duration = [m * pq.ms for m in params["recordings"]["max_burst_duration"]]
 
             if shape_mod:
-                if 'shape_stretch' not in rec_params.keys():
-                    params['recordings']['shape_stretch'] = 30
-                shape_stretch = params['recordings']['shape_stretch']
+                if "shape_stretch" not in rec_params.keys():
+                    params["recordings"]["shape_stretch"] = 30
+                shape_stretch = params["recordings"]["shape_stretch"]
                 if verbose_1:
-                    print('Bursting with modulation sigmoid: ', shape_stretch)
+                    print("Bursting with modulation sigmoid: ", shape_stretch)
             else:
                 shape_stretch = None
         else:
             exp_decay = None
             n_burst_spikes = None
             max_burst_duration = None
             shape_stretch = None
             bursting_units = []
 
-        chunk_duration = params['recordings'].get('chunk_duration', 0) * pq.s
+        chunk_duration = params["recordings"].get("chunk_duration", 0) * pq.s
         if chunk_duration == 0 * pq.s:
             chunk_duration = duration
 
-        if 'mrand' not in rec_params.keys():
-            params['recordings']['mrand'] = 1
-        mrand = params['recordings']['mrand']
-
-        if 'sdrand' not in rec_params.keys():
-            params['recordings']['sdrand'] = 0.05
-        sdrand = params['recordings']['sdrand']
-
-        if 'overlap' not in rec_params.keys():
-            params['recordings']['overlap'] = False
-        overlap = params['recordings']['overlap']
-
-        if 'extract_waveforms' not in rec_params.keys():
-            params['recordings']['extract_waveforms'] = False
-        extract_waveforms = params['recordings']['extract_waveforms']
-
-        if 'xlim' not in temp_params.keys():
-            params['templates']['xlim'] = None
-        x_lim = params['templates']['xlim']
-
-        if 'ylim' not in temp_params.keys():
-            params['templates']['ylim'] = None
-        y_lim = params['templates']['ylim']
-
-        if 'zlim' not in temp_params.keys():
-            params['templates']['zlim'] = None
-        z_lim = params['templates']['zlim']
-
-        if 'n_overlap_pairs' not in temp_params.keys():
-            params['templates']['n_overlap_pairs'] = None
-        n_overlap_pairs = params['templates']['n_overlap_pairs']
-
-        if 'min_amp' not in temp_params.keys():
-            params['templates']['min_amp'] = 50
-        min_amp = params['templates']['min_amp']
-
-        if 'max_amp' not in temp_params.keys():
-            params['templates']['max_amp'] = np.inf
-        max_amp = params['templates']['max_amp']
-
-        if 'min_dist' not in temp_params.keys():
-            params['templates']['min_dist'] = 25
-        min_dist = params['templates']['min_dist']
-
-        if 'overlap_threshold' not in temp_params.keys():
-            params['templates']['overlap_threshold'] = 0.8
-        overlap_threshold = params['templates']['overlap_threshold']
-
-        if 'pad_len' not in temp_params.keys():
-            params['templates']['pad_len'] = [3., 3.]
-        pad_len = params['templates']['pad_len']
-        
-        if 'smooth_percent' not in temp_params.keys():
-            params['templates']['smooth_percent'] = 0.5
-        smooth_percent = params['templates']['smooth_percent']
-        
-        if 'smooth_strength' not in temp_params.keys():
-            params['templates']['smooth_strength'] = 1
-        smooth_strength = params['templates']['smooth_strength']
-
-        if 'n_jitters' not in temp_params.keys():
-            params['templates']['n_jitters'] = 10
-        n_jitters = params['templates']['n_jitters']
-
-        if 'upsample' not in temp_params.keys():
-            params['templates']['upsample'] = 8
-        upsample = params['templates']['upsample']
-
-        if 'drifting' not in rec_params.keys():
-            params['recordings']['drifting'] = False
-        drifting = params['recordings']['drifting']
+        if "mrand" not in rec_params.keys():
+            params["recordings"]["mrand"] = 1
+        mrand = params["recordings"]["mrand"]
+
+        if "sdrand" not in rec_params.keys():
+            params["recordings"]["sdrand"] = 0.05
+        sdrand = params["recordings"]["sdrand"]
+
+        if "overlap" not in rec_params.keys():
+            params["recordings"]["overlap"] = False
+        overlap = params["recordings"]["overlap"]
+
+        if "extract_waveforms" not in rec_params.keys():
+            params["recordings"]["extract_waveforms"] = False
+        extract_waveforms = params["recordings"]["extract_waveforms"]
+
+        if "xlim" not in temp_params.keys():
+            params["templates"]["xlim"] = None
+        x_lim = params["templates"]["xlim"]
+
+        if "ylim" not in temp_params.keys():
+            params["templates"]["ylim"] = None
+        y_lim = params["templates"]["ylim"]
+
+        if "zlim" not in temp_params.keys():
+            params["templates"]["zlim"] = None
+        z_lim = params["templates"]["zlim"]
+
+        if "n_overlap_pairs" not in temp_params.keys():
+            params["templates"]["n_overlap_pairs"] = None
+        n_overlap_pairs = params["templates"]["n_overlap_pairs"]
+
+        if "min_amp" not in temp_params.keys():
+            params["templates"]["min_amp"] = 50
+        min_amp = params["templates"]["min_amp"]
+
+        if "max_amp" not in temp_params.keys():
+            params["templates"]["max_amp"] = np.inf
+        max_amp = params["templates"]["max_amp"]
+
+        if "min_dist" not in temp_params.keys():
+            params["templates"]["min_dist"] = 25
+        min_dist = params["templates"]["min_dist"]
+
+        if "overlap_threshold" not in temp_params.keys():
+            params["templates"]["overlap_threshold"] = 0.8
+        overlap_threshold = params["templates"]["overlap_threshold"]
+
+        if "pad_len" not in temp_params.keys():
+            params["templates"]["pad_len"] = [3.0, 3.0]
+        pad_len = params["templates"]["pad_len"]
+
+        if "smooth_percent" not in temp_params.keys():
+            params["templates"]["smooth_percent"] = 0.5
+        smooth_percent = params["templates"]["smooth_percent"]
+
+        if "smooth_strength" not in temp_params.keys():
+            params["templates"]["smooth_strength"] = 1
+        smooth_strength = params["templates"]["smooth_strength"]
+
+        if "n_jitters" not in temp_params.keys():
+            params["templates"]["n_jitters"] = 10
+        n_jitters = params["templates"]["n_jitters"]
+
+        if "upsample" not in temp_params.keys():
+            params["templates"]["upsample"] = 8
+        upsample = params["templates"]["upsample"]
+
+        if "drifting" not in rec_params.keys():
+            params["recordings"]["drifting"] = False
+        drifting = params["recordings"]["drifting"]
 
         # set seeds
-        if 'templates' not in seeds.keys():
+        if "templates" not in seeds.keys():
             temp_seed = np.random.randint(1, 1000)
-        elif seeds['templates'] is None:
+        elif seeds["templates"] is None:
             temp_seed = np.random.randint(1, 1000)
         else:
-            temp_seed = seeds['templates']
+            temp_seed = seeds["templates"]
 
-        if 'convolution' not in seeds.keys():
+        if "convolution" not in seeds.keys():
             conv_seed = np.random.randint(1, 1000)
-        elif seeds['convolution'] is None:
+        elif seeds["convolution"] is None:
             conv_seed = np.random.randint(1, 1000)
         else:
-            conv_seed = seeds['convolution']
+            conv_seed = seeds["convolution"]
 
-        if 'noise' not in seeds.keys():
+        if "noise" not in seeds.keys():
             noise_seed = np.random.randint(1, 1000)
-        elif seeds['noise'] is None:
+        elif seeds["noise"] is None:
             noise_seed = np.random.randint(1, 1000)
         else:
-            noise_seed = seeds['noise']
-        
-        n_samples = int(duration.rescale('s').magnitude * fs.rescale('Hz').magnitude)
-        
+            noise_seed = seeds["noise"]
+
+        n_samples = int(duration.rescale("s").magnitude * fs.rescale("Hz").magnitude)
+
         if drifting:
             if temp_info is not None:
-                assert temp_info['params']['drifting'], "For generating drifting recordings, templates must be drifting"
+                assert temp_info["params"]["drifting"], "For generating drifting recordings, templates must be drifting"
             else:
-                if params['n_jitters'] == 1:
+                if params["n_jitters"] == 1:
                     assert len(self.templates.shape) == 4
                 else:
                     assert len(self.templates.shape) == 5
-            preferred_dir = np.array(rec_params['preferred_dir'])
+            preferred_dir = np.array(rec_params["preferred_dir"])
             preferred_dir = preferred_dir / np.linalg.norm(preferred_dir)
-            angle_tol = rec_params['angle_tol']
-            if rec_params['n_drifting'] is None:
+            angle_tol = rec_params["angle_tol"]
+            if rec_params["n_drifting"] is None:
                 n_drifting = n_neurons
             else:
-                n_drifting = rec_params['n_drifting']
-                
-            drift_keys = ('drift_fs', 't_start_drift', 't_end_drift', 'drift_mode_probe', 'drift_mode_speed',
-                          'non_rigid_gradient_mode', 'slow_drift_velocity',
-                          'slow_drift_amplitude', 'slow_drift_waveform',
-                          'fast_drift_period', 'fast_drift_max_jump', 'fast_drift_min_jump')
+                n_drifting = rec_params["n_drifting"]
+
+            drift_keys = (
+                "drift_fs",
+                "t_start_drift",
+                "t_end_drift",
+                "drift_mode_probe",
+                "drift_mode_speed",
+                "non_rigid_gradient_mode",
+                "non_rigid_linear_direction",
+                "non_rigid_linear_min_factor",
+                "non_rigid_step_depth_boundary",
+                "non_rigid_step_factors",
+                "slow_drift_velocity",
+                "slow_drift_amplitude",
+                "slow_drift_waveform",
+                "fast_drift_period",
+                "fast_drift_max_jump",
+                "fast_drift_min_jump",
+            )
+
             if drift_dicts is None:
                 drift_params = {k: rec_params[k] for k in drift_keys}
                 drift_dicts = [drift_params]
             else:
                 if verbose:
                     print(f"Using {len(drift_dicts)} custom drift signals")
+                drift_keys += (
+                    "external_drift_vector_um",
+                    "external_drift_times",
+                    "external_drift_factors",
+                )
                 for drift_params in drift_dicts:
-                    assert np.all([k in drift_params for k in drift_keys]), "'drift_dicts have some missing keys!"
+                    for k in drift_params:
+                        assert k in drift_keys, f"Wrong drift key {k}"
+                    # assert np.all([k in drift_params for k in drift_keys]), "'drift_dicts have some missing keys!"
         else:
             # if drifting templates, but not recordings, consider initial template
             if temp_info is not None:
-                if temp_info['params']['drifting']:
+                if temp_info["params"]["drifting"]:
                     eaps = eaps[:, 0]
                     locs = locs[:, 0]
             elif len(self.templates.shape) == 5:
                 self.templates = self.templates[:, 0]
                 self.template_locs = self.template_locs[:, 0]
             preferred_dir = None
             angle_tol = None
             drift_list = None
             n_drifting = None
-        
+
         # load MEA info
         if temp_info is not None:
-            mea = mu.return_mea(info=temp_info['electrodes'])
-            params['electrodes'] = temp_info['electrodes']
+            mea = mu.return_mea(info=temp_info["electrodes"])
+            params["electrodes"] = temp_info["electrodes"]
         else:
-            mea = mu.return_mea(info=self.params['electrodes'])
-            params['electrodes'] = self.params['electrodes']
+            mea = mu.return_mea(info=self.params["electrodes"])
+            params["electrodes"] = self.params["electrodes"]
         mea_pos = mea.positions
         n_elec = mea_pos.shape[0]
-        #~ n_samples = int(duration.rescale('s').magnitude * fs.rescale('Hz').magnitude)
+        # ~ n_samples = int(duration.rescale('s').magnitude * fs.rescale('Hz').magnitude)
 
-        params['recordings'].update({'duration': float(duration.magnitude),
-                                     'fs': float(fs.rescale('Hz').magnitude),
-                                     'n_neurons': n_neurons})
-        params['templates'].update({'cut_out': cut_outs})
+        params["recordings"].update(
+            {"duration": float(duration.magnitude), "fs": float(fs.rescale("Hz").magnitude), "n_neurons": n_neurons}
+        )
+        params["templates"].update({"cut_out": cut_outs})
 
         # create buffer h5/memmap/memmory
-        if self.tmp_mode == 'memmap':
+        if self.tmp_mode == "memmap":
             tmp_path_0 = self.tmp_folder / (tmp_prefix + "mearec_tmp_file_recordings.raw")
-            recordings = np.memmap(tmp_path_0, shape=(n_samples, n_elec), dtype=dtype, mode='w+')
+            recordings = np.memmap(tmp_path_0, shape=(n_samples, n_elec), dtype=dtype, mode="w+")
             recordings[:] = 0
             # recordings = recordings.transpose()
             tmp_path_1 = self.tmp_folder / (tmp_prefix + "mearec_tmp_file_spike_traces.raw")
             if not only_noise:
-                spike_traces = np.memmap(tmp_path_1, shape=(n_samples, n_neurons), dtype=dtype, mode='w+')
+                spike_traces = np.memmap(tmp_path_1, shape=(n_samples, n_neurons), dtype=dtype, mode="w+")
                 spike_traces[:] = 0
                 # spike_traces = spike_traces.transpose()
             # file names for templates
             tmp_templates_pad = self.tmp_folder / (tmp_prefix + "templates_pad.raw")
             tmp_templates_rs = self.tmp_folder / (tmp_prefix + "templates_resample.raw")
             tmp_templates_jit = self.tmp_folder / (tmp_prefix + "templates_jitter.raw")
-            self._to_remove_on_delete.extend([tmp_path_0, tmp_path_1,
-                                              tmp_templates_pad, tmp_templates_rs, tmp_templates_jit])
+            self._to_remove_on_delete.extend(
+                [tmp_path_0, tmp_path_1, tmp_templates_pad, tmp_templates_rs, tmp_templates_jit]
+            )
         else:
             recordings = np.zeros((n_samples, n_elec), dtype=dtype)
             spike_traces = np.zeros((n_samples, n_neurons), dtype=dtype)
             tmp_templates_pad = None
             tmp_templates_rs = None
             tmp_templates_jit = None
 
@@ -678,75 +705,79 @@
             voltage_peaks = np.array([])
             spike_traces = np.array([])
             templates = np.array([])
             template_locs = np.array([])
             template_rots = np.array([])
             template_celltypes = np.array([])
             overlapping = np.array([])
-            
+
             # compute gain
             gain_to_int = None
             if np.dtype(dtype).kind == "i":
                 if gain is None:
                     if adc_bit_depth is not None:
                         signal_range = lsb * (2**adc_bit_depth)
                         dtype_depth = np.dtype(dtype).itemsize * 8
-                        assert signal_range <= 2 ** dtype_depth, (f"ADC bit depth and LSB exceed the range of the "
-                                                                  f"selected dtype {dtype}. Try reducing them or using "
-                                                                  f"a larger dtype")
+                        assert signal_range <= 2**dtype_depth, (
+                            f"ADC bit depth and LSB exceed the range of the "
+                            f"selected dtype {dtype}. Try reducing them or using "
+                            f"a larger dtype"
+                        )
                         # in this case we use 4 times the noise level (times 2 for positive-negative)
                         max_noise = 2 * (4 * noise_level)
                         gain_to_int = signal_range / max_noise
-                        gain = 1. / gain_to_int
+                        gain = 1.0 / gain_to_int
                 else:
-                    gain_to_int = 1. / gain
+                    gain_to_int = 1.0 / gain
         else:
             if tempgen is not None:
                 if celltype_params is not None:
-                    if 'excitatory' in celltype_params.keys() and 'inhibitory' in celltype_params.keys():
-                        exc_categories = celltype_params['excitatory']
-                        inh_categories = celltype_params['inhibitory']
+                    if "excitatory" in celltype_params.keys() and "inhibitory" in celltype_params.keys():
+                        exc_categories = celltype_params["excitatory"]
+                        inh_categories = celltype_params["inhibitory"]
                         bin_cat = get_binary_cat(celltypes, exc_categories, inh_categories)
                     else:
-                        bin_cat = np.array(['U'] * len(celltypes))
+                        bin_cat = np.array(["U"] * len(celltypes))
                 else:
-                    bin_cat = np.array(['U'] * len(celltypes))
+                    bin_cat = np.array(["U"] * len(celltypes))
 
-                if 'cell_type' in spiketrains[0].annotations.keys():
-                    n_exc = [st.annotations['cell_type'] for st in spiketrains].count('E')
+                if "cell_type" in spiketrains[0].annotations.keys():
+                    n_exc = [st.annotations["cell_type"] for st in spiketrains].count("E")
                     n_inh = n_neurons - n_exc
-                    st_types = np.array([st.annotations['cell_type'] for st in spiketrains])
-                elif 'rates' in st_params.keys():
-                    assert st_params['types'] is not None, "If 'rates' are provided as spiketrains parameters, " \
-                                                           "corresponding 'types' ('E'-'I') must be provided"
-                    n_exc = st_params['types'].count('E')
-                    n_inh = st_params['types'].count('I')
-                    st_types = np.array(st_params['types'])
+                    st_types = np.array([st.annotations["cell_type"] for st in spiketrains])
+                elif "rates" in st_params.keys():
+                    assert st_params["types"] is not None, (
+                        "If 'rates' are provided as spiketrains parameters, "
+                        "corresponding 'types' ('E'-'I') must be provided"
+                    )
+                    n_exc = st_params["types"].count("E")
+                    n_inh = st_params["types"].count("I")
+                    st_types = np.array(st_params["types"])
                 else:
                     if self._verbose:
-                        print('Setting random number of excitatory and inhibitory neurons as cell_type info is missing')
+                        print("Setting random number of excitatory and inhibitory neurons as cell_type info is missing")
                     n_exc = np.random.randint(n_neurons)
                     n_inh = n_neurons - n_exc
-                    st_types = np.array(['E'] * n_exc + ['I'] * n_inh)
+                    st_types = np.array(["E"] * n_exc + ["I"] * n_inh)
 
-                e_idx = np.where(st_types == 'E')
-                i_idx = np.where(st_types == 'I')
+                e_idx = np.where(st_types == "E")
+                i_idx = np.where(st_types == "I")
                 if len(e_idx) > 0 and len(i_idx) > 0:
                     if not np.all([[e < i for e in e_idx[0]] for i in i_idx[0]]):
                         if verbose_1:
-                            print('Re-arranging spike trains: Excitatory first, Inhibitory last')
+                            print("Re-arranging spike trains: Excitatory first, Inhibitory last")
                         order = np.argsort(st_types)
                         new_spiketrains = []
                         for idx in order:
                             new_spiketrains.append(spiketrains[idx])
                         spgen.spiketrains = new_spiketrains
                         spiketrains = new_spiketrains
 
                 if verbose_1:
-                    print('Templates selection seed: ', temp_seed)
+                    print("Templates selection seed: ", temp_seed)
                 np.random.seed(temp_seed)
 
                 if drifting:
                     drift_directions = np.array([(p[-1] - p[0]) / np.linalg.norm(p[-1] - p[0]) for p in locs])
                     n_elec = eaps.shape[2]
                 else:
                     drift_directions = None
@@ -754,155 +785,212 @@
 
                 if n_neurons > 100 or drifting:
                     parallel_templates = True
                 else:
                     parallel_templates = False
 
                 if verbose_1:
-                    print('Selecting cells')
+                    print("Selecting cells")
 
                 if self.template_ids is None:
-                    idxs_cells, selected_cat = select_templates(locs, eaps, bin_cat, n_exc, n_inh, x_lim=x_lim,
-                                                                y_lim=y_lim, z_lim=z_lim, min_amp=min_amp,
-                                                                max_amp=max_amp, min_dist=min_dist, drifting=drifting,
-                                                                drift_dir=drift_directions,
-                                                                preferred_dir=preferred_dir, angle_tol=angle_tol,
-                                                                n_overlap_pairs=n_overlap_pairs,
-                                                                overlap_threshold=overlap_threshold,
-                                                                verbose=verbose_2)
+                    idxs_cells, selected_cat = select_templates(
+                        locs,
+                        eaps,
+                        bin_cat,
+                        n_exc,
+                        n_inh,
+                        x_lim=x_lim,
+                        y_lim=y_lim,
+                        z_lim=z_lim,
+                        min_amp=min_amp,
+                        max_amp=max_amp,
+                        min_dist=min_dist,
+                        drifting=drifting,
+                        drift_dir=drift_directions,
+                        preferred_dir=preferred_dir,
+                        angle_tol=angle_tol,
+                        n_overlap_pairs=n_overlap_pairs,
+                        overlap_threshold=overlap_threshold,
+                        verbose=verbose_2,
+                    )
 
-                    if not np.any('U' in selected_cat):
-                        assert selected_cat.count('E') == n_exc and selected_cat.count('I') == n_inh
+                    if not np.any("U" in selected_cat):
+                        assert selected_cat.count("E") == n_exc and selected_cat.count("I") == n_inh
                         # Reorder templates according to E-I types
                         reordered_idx_cells = np.array(idxs_cells)[np.argsort(selected_cat)]
                     else:
                         reordered_idx_cells = idxs_cells
 
                     template_celltypes = celltypes[reordered_idx_cells]
                     template_locs = np.array(locs)[reordered_idx_cells]
                     template_rots = np.array(rots)[reordered_idx_cells]
                     template_bin = np.array(bin_cat)[reordered_idx_cells]
                     templates = np.array(eaps)[reordered_idx_cells]
                     self.template_ids = reordered_idx_cells
                 else:
                     print(f"Using provided template ids: {self.template_ids}")
-                    template_celltypes = celltypes[self.template_ids]
-                    template_locs = np.array(locs)[self.template_ids]
-                    template_rots = np.array(rots)[self.template_ids]
-                    template_bin = np.array(bin_cat)[self.template_ids]
-                    templates = np.array(eaps)[self.template_ids]
-                
+                    ordered_ids = np.all(np.diff(self.template_ids) > 0)
+                    if ordered_ids:
+                        template_celltypes = celltypes[self.template_ids]
+                        template_locs = np.array(locs[self.template_ids])
+                        template_rots = np.array(rots[self.template_ids])
+                        template_bin = np.array(bin_cat[self.template_ids])
+                        templates = np.array(eaps[self.template_ids])
+                    else:
+                        order = np.argsort(self.template_ids)
+                        order_back = np.argsort(order)
+                        sorted_ids = self.template_ids[order]
+                        template_celltypes = celltypes[sorted_ids][order_back]
+                        template_locs = np.array(locs[sorted_ids])[order_back]
+                        template_rots = np.array(rots[sorted_ids])[order_back]
+                        template_bin = np.array(bin_cat[sorted_ids])[order_back]
+                        templates = np.array(eaps[sorted_ids])[order_back]
+
                 # compute gain
                 gain_to_int = None
                 if np.dtype(dtype).kind == "i":
                     if gain is None:
                         if adc_bit_depth is not None:
                             signal_range = lsb * (2**adc_bit_depth)
                             dtype_depth = np.dtype(dtype).itemsize * 8
-                            assert signal_range <= 2 ** dtype_depth, (f"ADC bit depth and LSB exceed the range of the "
-                                                                      f"selected dtype {dtype}. Try reducing them or "
-                                                                      f"using a larger dtype")
+                            assert signal_range <= 2**dtype_depth, (
+                                f"ADC bit depth and LSB exceed the range of the "
+                                f"selected dtype {dtype}. Try reducing them or "
+                                f"using a larger dtype"
+                            )
                             # in this case we add 3 times the noise level to the amplitude to allow some margin
                             max_template_noise = np.max(np.abs(templates)) + 3 * noise_level
                             templates_noise_range = 2 * (max_template_noise)
                             gain_to_int = signal_range / templates_noise_range
-                            gain = 1. / gain_to_int
+                            gain = 1.0 / gain_to_int
                     else:
-                        gain_to_int = 1. / gain
-                
+                        gain_to_int = 1.0 / gain
+
                 if gain_to_int is not None:
                     if verbose_1:
-                        print(f'Templates and noise scaled by gain: {gain_to_int}')
+                        print(f"Templates and noise scaled by gain: {gain_to_int}")
                     templates *= gain_to_int
                     noise_level *= gain_to_int
 
                 self.original_templates = templates
-                
+
                 if drifting:
-                    
                     drift_list = []
                     for drift_params in drift_dicts:
-                        drift_signal = generate_drift_dict_from_params(duration=duration,
-                                                                       template_locations=template_locs, 
-                                                                       preferred_dir=preferred_dir,
-                                                                       **drift_params)
+                        drift_signal = generate_drift_dict_from_params(
+                            duration=duration,
+                            template_locations=template_locs,
+                            preferred_dir=preferred_dir,
+                            **drift_params,
+                        )
                         drift_list.append(drift_signal)
                     if verbose_1:
-                        print(f"Num. of drift vectors shape {len(drift_list)} with "
-                            f"{[len(d['drift_vector_idxs']) for d in drift_list]} samples")
+                        print(
+                            f"Num. of drift vectors shape {len(drift_list)} with "
+                            f"{[len(d['drift_vector_idxs']) for d in drift_list]} samples"
+                        )
 
                 self.drift_list = drift_list
 
                 # find overlapping templates
                 overlapping = find_overlapping_templates(templates, thresh=overlap_threshold)
 
                 # peak images
                 voltage_peaks = []
                 for tem in templates:
-                    dt = 1. / fs.magnitude
+                    dt = 1.0 / fs.magnitude
                     if not drifting:
-                        feat = get_templates_features(tem, ['neg'], dt=dt)
+                        feat = get_templates_features(tem, ["neg"], dt=dt)
                     else:
-                        feat = get_templates_features(tem[0], ['neg'], dt=dt)
-                    voltage_peaks.append(-np.squeeze(feat['neg']))
+                        feat = get_templates_features(tem[0], ["neg"], dt=dt)
+                    voltage_peaks.append(-np.squeeze(feat["neg"]))
                 voltage_peaks = np.array(voltage_peaks)
 
                 # pad templates
-                pad_samples = [int((pp * fs.rescale('kHz')).magnitude) for pp in pad_len]
+                pad_samples = [int((pp * spike_fs.rescale("kHz")).magnitude) for pp in pad_len]
                 if verbose_1:
-                    print('Padding template edges')
+                    print("Padding template edges")
                 t_pad = time.time()
-                templates_pad = pad_templates(templates, pad_samples, drifting, dtype, verbose_2,
-                                              tmp_file=tmp_templates_pad, parallel=parallel_templates)
+                templates_pad = pad_templates(
+                    templates,
+                    pad_samples,
+                    drifting,
+                    np.float32,
+                    verbose_2,
+                    tmp_file=tmp_templates_pad,
+                    parallel=parallel_templates,
+                )
 
                 if verbose_1:
-                    print('Elapsed pad time:', time.time() - t_pad)
+                    print("Elapsed pad time:", time.time() - t_pad)
 
                 # resample spikes
                 t_rs = time.time()
-                up = fs
-                down = spike_fs
+                f_up = fs
+                f_down = spike_fs
                 spike_duration_pad = templates_pad.shape[-1]
-                if up != down:
-                    n_resample = int(spike_duration_pad * (up / down))
-                    templates_rs = resample_templates(templates_pad, n_resample, up, down, drifting, dtype,
-                                                      verbose_2, tmp_file=tmp_templates_rs,
-                                                      parallel=parallel_templates)
+                if f_up != f_down:
+                    if verbose_1:
+                        print(f"Resampling templates at {f_up}")
+                    n_resample = int(spike_duration_pad * (f_up / f_down))
+                    templates_rs = resample_templates(
+                        templates_pad,
+                        n_resample,
+                        f_up,
+                        f_down,
+                        drifting,
+                        np.float32,
+                        verbose_2,
+                        tmp_file=tmp_templates_rs,
+                        parallel=parallel_templates,
+                    )
+                    # adjust pad_samples to account for resampling
+                    pad_samples = [int((pp * fs.rescale("kHz")).magnitude) for pp in pad_len]
                     if verbose_1:
-                        print('Elapsed resample time:', time.time() - t_rs)
+                        print("Elapsed resample time:", time.time() - t_rs)
                 else:
                     templates_rs = templates_pad
 
                 if verbose_1:
-                    print('Creating time jittering')
-                jitter = 1. / fs
+                    print("Creating time jittering")
+                jitter = 1.0 / fs
                 t_j = time.time()
-                templates = jitter_templates(templates_rs, upsample, fs, n_jitters, jitter, drifting, dtype,
-                                             verbose_2, tmp_file=tmp_templates_jit, parallel=parallel_templates)
+                templates = jitter_templates(
+                    templates_rs,
+                    upsample,
+                    fs,
+                    n_jitters,
+                    jitter,
+                    drifting,
+                    np.float32,
+                    verbose_2,
+                    tmp_file=tmp_templates_jit,
+                    parallel=parallel_templates,
+                )
                 if verbose_1:
-                    print('Elapsed jitter time:', time.time() - t_j)
+                    print("Elapsed jitter time:", time.time() - t_j)
 
                 # find cut out samples for convolution after padding and resampling
                 pre_peak_fraction = (pad_len[0] + cut_outs[0]) / (np.sum(pad_len) + np.sum(cut_outs))
                 samples_pre_peak = int(pre_peak_fraction * templates.shape[-1])
                 samples_post_peak = templates.shape[-1] - samples_pre_peak
                 cut_outs_samples = [samples_pre_peak, samples_post_peak]
-                
+
                 # smooth edges
                 if smooth_percent > 0:
                     sigmoid_samples = int(smooth_percent * pad_samples[0]) // 2 * 2
-                    sigmoid_x = np.arange(-sigmoid_samples//2, sigmoid_samples//2)
+                    sigmoid_x = np.arange(-sigmoid_samples // 2, sigmoid_samples // 2)
                     b = smooth_strength
                     sig = sigmoid(sigmoid_x, b) + 0.5
                     window = np.ones(templates.shape[-1])
                     window[:sigmoid_samples] = sig
                     window[-sigmoid_samples:] = sig[::-1]
-                    
+
                     if verbose_1:
-                        print('Smoothing templates')
+                        print("Smoothing templates")
                     templates = templates * window
 
                 # delete temporary preprocessed templates
                 del templates_rs, templates_pad
             else:
                 gain_to_int = None
                 templates = self.templates
@@ -910,367 +998,450 @@
                 samples_pre_peak = int(pre_peak_fraction * templates.shape[-1])
                 samples_post_peak = templates.shape[-1] - samples_pre_peak
                 cut_outs_samples = [samples_pre_peak, samples_post_peak]
                 template_locs = self.template_locations
                 template_rots = self.template_rotations
                 template_celltypes = self.template_celltypes
                 if celltype_params is not None:
-                    if 'excitatory' in celltype_params.keys() and 'inhibitory' in celltype_params.keys():
-                        exc_categories = celltype_params['excitatory']
-                        inh_categories = celltype_params['inhibitory']
+                    if "excitatory" in celltype_params.keys() and "inhibitory" in celltype_params.keys():
+                        exc_categories = celltype_params["excitatory"]
+                        inh_categories = celltype_params["inhibitory"]
                         template_bin = get_binary_cat(template_celltypes, exc_categories, inh_categories)
                     else:
-                        template_bin = np.array(['U'] * len(celltypes))
+                        template_bin = np.array(["U"] * len(celltypes))
                 else:
-                    template_bin = np.array(['U'] * len(celltypes))
+                    template_bin = np.array(["U"] * len(celltypes))
                 voltage_peaks = self.voltage_peaks
                 overlapping = np.array([])
-                #~ if not drifting:
-                    #~ velocity_vector = None
-                #~ else:
-                    #~ drift_velocity_ums = drift_velocity / 60.
-                    #~ velocity_vector = drift_velocity_ums * preferred_dir
-                    #~ if verbose_1:
-                        #~ print('Drift velocity vector: ', velocity_vector)
+                # ~ if not drifting:
+                # ~ velocity_vector = None
+                # ~ else:
+                # ~ drift_velocity_ums = drift_velocity / 60.
+                # ~ velocity_vector = drift_velocity_ums * preferred_dir
+                # ~ if verbose_1:
+                # ~ print('Drift velocity vector: ', velocity_vector)
 
             if sync_rate is not None:
                 if verbose_1:
-                    print('Modifying synchrony of spatially overlapping spikes')
+                    print("Modifying synchrony of spatially overlapping spikes")
                 if verbose_1:
-                    print('Overlapping templates: ', overlapping)
+                    print("Overlapping templates: ", overlapping)
                 for over in overlapping:
                     if verbose_1:
-                        print('Overlapping pair: ', over)
+                        print("Overlapping pair: ", over)
                     spgen.add_synchrony(over, rate=sync_rate, verbose=verbose_2, time_jitt=sync_jitt)
                     # annotate new firing rates
                     fr1 = len(spgen.spiketrains[over[0]].times) / spgen.spiketrains[over[0]].t_stop
                     fr2 = len(spgen.spiketrains[over[1]].times) / spgen.spiketrains[over[1]].t_stop
                     spgen.spiketrains[over[0]].annotate(fr=fr1)
                     spgen.spiketrains[over[1]].annotate(fr=fr2)
             self.overlapping = overlapping
 
             # find SNR and annotate
             if verbose_1:
-                print('Computing spike train SNR')
+                print("Computing spike train SNR")
 
             for t_i, temp in enumerate(templates):
                 min_peak = np.min(temp)
                 snr = np.abs(min_peak / float(noise_level))
                 spiketrains[t_i].annotate(snr=snr)
 
             if verbose_1:
-                print('Adding spiketrain annotations')
+                print("Adding spiketrain annotations")
             for i, st in enumerate(spiketrains):
                 st.annotate(bintype=template_bin[i], mtype=template_celltypes[i], soma_position=template_locs[i])
 
             if overlap:
                 annotate_overlapping_spikes(spiketrains, overlapping_pairs=overlapping, verbose=verbose_2)
 
             if verbose_1:
-                print('Convolution seed: ', conv_seed)
+                print("Convolution seed: ", conv_seed)
             np.random.seed(conv_seed)
 
             amp_mod = []
             cons_spikes = []
 
             # modulated convolution
             if drifting:
                 drifting_units = np.random.permutation(n_neurons)[:n_drifting]
             else:
                 drifting_units = []
 
-            if modulation == 'template':
+            if modulation == "template":
                 if verbose_1:
-                    print('Template modulation')
+                    print("Template modulation")
                 for i_s, st in enumerate(spiketrains):
                     if bursting and i_s in bursting_units:
                         if verbose_1:
-                            print('Bursting unit: ', i_s)
+                            print("Bursting unit: ", i_s)
                         bursting_idx = list(bursting_units).index(i_s)
-                        amp, cons = compute_modulation(st, sdrand=sdrand,
-                                                       n_spikes=n_burst_spikes[bursting_idx],
-                                                       exp=exp_decay[bursting_idx],
-                                                       max_burst_duration=max_burst_duration[bursting_idx])
+                        amp, cons = compute_modulation(
+                            st,
+                            sdrand=sdrand,
+                            n_spikes=n_burst_spikes[bursting_idx],
+                            exp=exp_decay[bursting_idx],
+                            max_burst_duration=max_burst_duration[bursting_idx],
+                        )
 
                         amp_mod.append(amp)
                         cons_spikes.append(cons)
-                        st.annotate(bursting=True, exp_decay=exp_decay[bursting_idx],
-                                    max_spikes_per_burst=n_burst_spikes[bursting_idx],
-                                    max_burst_duration=max_burst_duration[bursting_idx])
+                        st.annotate(
+                            bursting=True,
+                            exp_decay=exp_decay[bursting_idx],
+                            max_spikes_per_burst=n_burst_spikes[bursting_idx],
+                            max_burst_duration=max_burst_duration[bursting_idx],
+                        )
                     else:
-                        amp, cons = compute_modulation(st, mrand=mrand, sdrand=sdrand,
-                                                       n_spikes=0)
+                        amp, cons = compute_modulation(st, mrand=mrand, sdrand=sdrand, n_spikes=0)
                         amp_mod.append(amp)
                         cons_spikes.append(cons)
-                        st.annotate(bursting=False, exp_decay=None,
-                                    max_spikes_per_burst=None,
-                                    max_burst_duration=None)
+                        st.annotate(bursting=False, exp_decay=None, max_spikes_per_burst=None, max_burst_duration=None)
 
-            elif modulation == 'electrode':
+            elif modulation == "electrode":
                 if verbose_1:
-                    print('Electrode modulaton')
+                    print("Electrode modulaton")
                 for i_s, st in enumerate(spiketrains):
                     if bursting and i_s in bursting_units:
                         if verbose_1:
-                            print('Bursting unit: ', i_s)
+                            print("Bursting unit: ", i_s)
                         bursting_idx = list(bursting_units).index(i_s)
-                        amp, cons = compute_modulation(st, n_el=n_elec, mrand=mrand, sdrand=sdrand,
-                                                       n_spikes=n_burst_spikes[bursting_idx],
-                                                       exp=exp_decay[bursting_idx],
-                                                       max_burst_duration=max_burst_duration[bursting_idx])
+                        amp, cons = compute_modulation(
+                            st,
+                            n_el=n_elec,
+                            mrand=mrand,
+                            sdrand=sdrand,
+                            n_spikes=n_burst_spikes[bursting_idx],
+                            exp=exp_decay[bursting_idx],
+                            max_burst_duration=max_burst_duration[bursting_idx],
+                        )
                         amp_mod.append(amp)
 
                         cons_spikes.append(cons)
-                        st.annotate(bursting=True, exp_decay=exp_decay[bursting_idx],
-                                    max_spikes_per_burst=n_burst_spikes[bursting_idx],
-                                    max_burst_duration=max_burst_duration[bursting_idx])
+                        st.annotate(
+                            bursting=True,
+                            exp_decay=exp_decay[bursting_idx],
+                            max_spikes_per_burst=n_burst_spikes[bursting_idx],
+                            max_burst_duration=max_burst_duration[bursting_idx],
+                        )
                     else:
-                        amp, cons = compute_modulation(st, n_el=n_elec, mrand=mrand, sdrand=sdrand,
-                                                       n_spikes=0)
+                        amp, cons = compute_modulation(st, n_el=n_elec, mrand=mrand, sdrand=sdrand, n_spikes=0)
                         amp_mod.append(amp)
                         cons_spikes.append(cons)
-                        st.annotate(bursting=False, exp_decay=None,
-                                    max_spikes_per_burst=None,
-                                    max_burst_duration=None)
+                        st.annotate(bursting=False, exp_decay=None, max_spikes_per_burst=None, max_burst_duration=None)
 
             spike_idxs = []
             for st in spiketrains:
-                spike_idxs.append((st.times * fs).magnitude.astype('int'))
+                spike_idxs.append((st.times * fs).magnitude.astype("int"))
 
             # divide in chunks
             chunk_indexes = make_chunk_indexes(duration, chunk_duration, fs)
             seed_list_conv = [np.random.randint(1000) for i in np.arange(len(chunk_indexes))]
 
             pad_samples_conv = templates.shape[-1]
             # call the loop on chunks
-            args = (spike_idxs, pad_samples_conv, modulation, drifting,
-                    drifting_units, templates,
-                    cut_outs_samples, 
-                    self.drift_list,
-                    verbose_2,
-                    amp_mod, bursting_units, shape_mod, shape_stretch,
-                    True, voltage_peaks, dtype, seed_list_conv,)
-
-            assignment_dict = {
-                'recordings': recordings,
-                'spike_traces': spike_traces}
-            output_list = run_several_chunks(chunk_convolution, chunk_indexes, fs, lsb, args,
-                                             self.n_jobs, self.tmp_mode, assignment_dict)
+            args = (
+                spike_idxs,
+                pad_samples_conv,
+                modulation,
+                drifting,
+                drifting_units,
+                templates,
+                cut_outs_samples,
+                self.drift_list,
+                verbose_2,
+                amp_mod,
+                bursting_units,
+                shape_mod,
+                shape_stretch,
+                True,
+                voltage_peaks,
+                dtype,
+                seed_list_conv,
+            )
+
+            assignment_dict = {"recordings": recordings, "spike_traces": spike_traces}
+            output_list = run_several_chunks(
+                chunk_convolution, chunk_indexes, fs, lsb, args, self.n_jobs, self.tmp_mode, assignment_dict
+            )
 
             # if drift then propagate annoations to spiketrains
             for st in np.arange(n_neurons):
                 if drifting and st in drifting_units:
                     spiketrains[st].annotate(drifting=True)
-                    #~ template_idxs = np.array([], dtype='int')
-                    #~ for out in output_list:
-                        #~ template_idxs = np.concatenate((template_idxs, out['template_idxs'][st]))
-                    #~ assert len(template_idxs) == len(spiketrains[st])
-                    #~ spiketrains[st].annotate(template_idxs=template_idxs)
+                    # ~ template_idxs = np.array([], dtype='int')
+                    # ~ for out in output_list:
+                    # ~ template_idxs = np.concatenate((template_idxs, out['template_idxs'][st]))
+                    # ~ assert len(template_idxs) == len(spiketrains[st])
+                    # ~ spiketrains[st].annotate(template_idxs=template_idxs)
 
                     # TODO find correct drift index based on different sampling frequencies
                     # if drift_vectors.ndim ==1:
                     #     drift_vector = drift_vectors
                     # else:
                     #     drift_vector = drift_vectors[:, st]
                     # drift_index = drift_vector[spike_idxs[st]]
                     # spiketrains[st].annotate(drift_index=drift_index)
 
-
         #################
         # Step 2: noise #
         #################
         if verbose_1:
-            print('Adding noise')
-            print('Noise seed: ', noise_seed)
+            print("Adding noise")
+            print("Noise seed: ", noise_seed)
 
         np.random.seed(noise_seed)
 
         if noise_level == 0:
             if verbose_1:
-                print('Noise level is set to 0')
+                print("Noise level is set to 0")
         else:
             # divide in chunks
             chunk_indexes = make_chunk_indexes(duration, chunk_duration, fs)
             seed_list_noise = [np.random.randint(1000) for i in np.arange(len(chunk_indexes))]
 
-            if self.tmp_mode == 'memmap':
+            if self.tmp_mode == "memmap":
                 tmp_path_noise = self.tmp_folder / (tmp_prefix + "mearec_tmp_noise_file.raw")
-                additive_noise = np.memmap(tmp_path_noise, shape=(n_samples, n_elec), dtype=dtype, mode='w+')
+                additive_noise = np.memmap(tmp_path_noise, shape=(n_samples, n_elec), dtype=dtype, mode="w+")
                 # additive_noise = additive_noise.transpose()
                 self._to_remove_on_delete.append(tmp_path_noise)
             else:
                 additive_noise = np.zeros((n_samples, n_elec), dtype=dtype)
 
-            if noise_mode == 'uncorrelated':
+            if noise_mode == "uncorrelated":
                 func = chunk_uncorrelated_noise
-                args = (n_elec, noise_level, noise_color, color_peak, color_q, color_noise_floor,
-                        dtype, seed_list_noise,)
-                assignment_dict = {'additive_noise': additive_noise}
+                args = (
+                    n_elec,
+                    noise_level,
+                    noise_color,
+                    color_peak,
+                    color_q,
+                    color_noise_floor,
+                    dtype,
+                    seed_list_noise,
+                )
+                assignment_dict = {"additive_noise": additive_noise}
 
-                run_several_chunks(func, chunk_indexes, fs, lsb, args,
-                                   self.n_jobs, self.tmp_mode, assignment_dict)
+                run_several_chunks(func, chunk_indexes, fs, lsb, args, self.n_jobs, self.tmp_mode, assignment_dict)
 
-            elif noise_mode == 'distance-correlated':
+            elif noise_mode == "distance-correlated":
                 cov_dist = np.zeros((n_elec, n_elec))
                 for i, el in enumerate(mea.positions):
                     for j, p in enumerate(mea.positions):
                         if i != j:
                             cov_dist[i, j] = (0.5 * half_dist) / np.linalg.norm(el - p)
                         else:
                             cov_dist[i, j] = 1
 
                 func = chunk_distance_correlated_noise
-                args = (noise_level, cov_dist, n_elec, noise_color, color_peak, color_q, color_noise_floor,
-                        dtype, seed_list_noise,)
-                assignment_dict = {'additive_noise': additive_noise}
+                args = (
+                    noise_level,
+                    cov_dist,
+                    n_elec,
+                    noise_color,
+                    color_peak,
+                    color_q,
+                    color_noise_floor,
+                    dtype,
+                    seed_list_noise,
+                )
+                assignment_dict = {"additive_noise": additive_noise}
+
+                run_several_chunks(func, chunk_indexes, fs, lsb, args, self.n_jobs, self.tmp_mode, assignment_dict)
 
-                run_several_chunks(func, chunk_indexes, fs, lsb, args,
-                                   self.n_jobs, self.tmp_mode, assignment_dict)
+            elif noise_mode == "far-neurons":
+                from . import SpikeTrainGenerator
 
-            elif noise_mode == 'far-neurons':
-                if self.tmp_mode == 'memmap':
+                if self.tmp_mode == "memmap":
                     # file names for templates
                     tmp_templates_noise_pad = self.tmp_folder / (tmp_prefix + "templates_noise_pad.raw")
                     tmp_templates_noise_rs = self.tmp_folder / (tmp_prefix + "templates_noise_resample.raw")
                     self._to_remove_on_delete.extend([tmp_templates_noise_pad, tmp_templates_noise_rs])
                 else:
                     tmp_templates_noise_pad = None
                     tmp_templates_noise_rs = None
-                idxs_cells, selected_cat = select_templates(locs, eaps, bin_cat=None, n_exc=far_neurons_n, n_inh=0,
-                                                            x_lim=x_lim, y_lim=y_lim, z_lim=z_lim, min_amp=0,
-                                                            max_amp=far_neurons_max_amp, min_dist=1,
-                                                            verbose=False)
+                idxs_cells, selected_cat = select_templates(
+                    locs,
+                    eaps,
+                    bin_cat=None,
+                    n_exc=far_neurons_n,
+                    n_inh=0,
+                    x_lim=x_lim,
+                    y_lim=y_lim,
+                    z_lim=z_lim,
+                    min_amp=0,
+                    max_amp=far_neurons_max_amp,
+                    min_dist=1,
+                    verbose=False,
+                )
                 idxs_cells = sorted(idxs_cells)
                 templates_noise = eaps[idxs_cells]
                 # Alessio :
                 # TODO handle drift for far neurons ?????
-                # template_noise_locs = locs[idxs_cells]
+                # template_noise_locs = locs[idxs_cells]
                 if drifting:
                     templates_noise = templates_noise[:, 0]
                 if gain_to_int is not None:
                     template_noise *= gain_to_int
 
                 # pad spikes
-                pad_samples = [int((pp * fs.rescale('kHz')).magnitude) for pp in pad_len]
+                pad_samples = [int((pp * spike_fs.rescale("kHz")).magnitude) for pp in pad_len]
                 if verbose_1:
-                    print('Padding noisy template edges')
+                    print("Padding noisy template edges")
                 t_pad = time.time()
-                templates_noise_pad = pad_templates(templates_noise, pad_samples, drifting, dtype, verbose_2,
-                                                    tmp_file=tmp_templates_noise_pad, parallel=True)
+                templates_noise_pad = pad_templates(
+                    templates_noise,
+                    pad_samples,
+                    drifting,
+                    dtype,
+                    verbose_2,
+                    tmp_file=tmp_templates_noise_pad,
+                    parallel=True,
+                )
                 if verbose_1:
-                    print('Elapsed pad time:', time.time() - t_pad)
+                    print("Elapsed pad time:", time.time() - t_pad)
 
                 # resample templates
                 t_rs = time.time()
-                up = fs
-                down = spike_fs
+                f_up = fs
+                f_down = spike_fs
                 spike_duration_pad = templates_noise_pad.shape[-1]
-                if up != down:
-                    n_resample = int(spike_duration_pad * (up / down))
-                    templates_noise = resample_templates(templates_noise_pad, n_resample, up, down,
-                                                         drifting, dtype, verbose_2,
-                                                         tmp_file=tmp_templates_noise_rs)
+                if f_up != f_down:
+                    n_resample = int(spike_duration_pad * (f_up / f_down))
+                    templates_noise = resample_templates(
+                        templates_noise_pad,
+                        n_resample,
+                        f_up,
+                        f_down,
+                        drifting,
+                        dtype,
+                        verbose_2,
+                        tmp_file=tmp_templates_noise_rs,
+                    )
+                    # adjust pad_samples to account for resampling
+                    pad_samples = [int((pp * fs.rescale("kHz")).magnitude) for pp in pad_len]
                     if verbose_1:
-                        print('Elapsed resample time:', time.time() - t_rs)
+                        print("Elapsed resample time:", time.time() - t_rs)
                 else:
                     templates_noise = templates_noise_pad
 
                 # find cut out samples for convolution after padding and resampling
                 pre_peak_fraction = (pad_len[0] + cut_outs[0]) / (np.sum(pad_len) + np.sum(cut_outs))
-                samples_pre_peak = int(pre_peak_fraction * templates.shape[-1])
+                samples_pre_peak = int(pre_peak_fraction * templates_noise.shape[-1])
                 samples_post_peak = templates_noise.shape[-1] - samples_pre_peak
                 cut_outs_samples = [samples_pre_peak, samples_post_peak]
 
                 del templates_noise_pad
 
                 # create noisy spiketrains
                 if verbose_1:
-                    print('Generating noisy spike trains')
-                noisy_spiketrains_params = params['spiketrains']
-                noisy_spiketrains_params['n_exc'] = int(far_neurons_n * far_neurons_exc_inh_ratio)
-                noisy_spiketrains_params['n_inh'] = far_neurons_n - noisy_spiketrains_params['n_exc']
-                noisy_spiketrains_params['seed'] = noise_seed
+                    print("Generating noisy spike trains")
+                noisy_spiketrains_params = params["spiketrains"]
+                noisy_spiketrains_params["n_exc"] = int(far_neurons_n * far_neurons_exc_inh_ratio)
+                noisy_spiketrains_params["n_inh"] = far_neurons_n - noisy_spiketrains_params["n_exc"]
+                noisy_spiketrains_params["seed"] = noise_seed
                 spgen_noise = SpikeTrainGenerator(params=noisy_spiketrains_params)
                 spgen_noise.generate_spikes()
                 spiketrains_noise = spgen_noise.spiketrains
 
                 spike_idxs_noise = []
                 for st in spiketrains_noise:
-                    spike_idxs_noise.append((st.times * fs).magnitude.astype('int'))
+                    spike_idxs_noise.append((st.times * fs).magnitude.astype("int"))
 
                 if verbose_1:
-                    print('Convolving noisy spike trains')
-                templates_noise = templates_noise.reshape((templates_noise.shape[0], 1, templates_noise.shape[1],
-                                                           templates_noise.shape[2]))
+                    print("Convolving noisy spike trains")
+                templates_noise = templates_noise.reshape(
+                    (templates_noise.shape[0], 1, templates_noise.shape[1], templates_noise.shape[2])
+                )
 
                 # call the loop on chunks
-                args = (spike_idxs_noise, 0, 'none', False, 
-                        # None,
-                        None, templates_noise,
-                        cut_outs_samples,
-                        None,
-                        # template_noise_locs, None, None, None, None, None, None,
-                        
-                        verbose_2, None, None, False, None, False, None, dtype, seed_list_noise,)
-                assignment_dict = {'recordings': additive_noise}
-                run_several_chunks(chunk_convolution, chunk_indexes, fs, lsb, args,
-                                   self.n_jobs, self.tmp_mode, assignment_dict)
+                args = (
+                    spike_idxs_noise,
+                    0,
+                    "none",
+                    False,
+                    # None,
+                    None,
+                    templates_noise,
+                    cut_outs_samples,
+                    None,
+                    # template_noise_locs, None, None, None, None, None, None,
+                    verbose_2,
+                    None,
+                    None,
+                    False,
+                    None,
+                    False,
+                    None,
+                    dtype,
+                    seed_list_noise,
+                )
+                assignment_dict = {"recordings": additive_noise}
+                run_several_chunks(
+                    chunk_convolution, chunk_indexes, fs, lsb, args, self.n_jobs, self.tmp_mode, assignment_dict
+                )
 
                 # removing mean
                 for i, m in enumerate(np.mean(additive_noise, axis=0)):
                     additive_noise[:, i] -= m
                 # adding noise floor
                 for i, s in enumerate(np.std(additive_noise, axis=0)):
-                    additive_noise[:, i] += far_neurons_noise_floor * s * \
-                                            np.random.randn(additive_noise.shape[0])
+                    additive_noise[:, i] += far_neurons_noise_floor * s * np.random.randn(additive_noise.shape[0])
                 # scaling noise
                 noise_scale = noise_level / np.std(additive_noise, axis=0)
                 if verbose_1:
-                    print('Scaling to reach desired level')
+                    print("Scaling to reach desired level")
                 for i, n in enumerate(noise_scale):
                     additive_noise[:, i] *= n
 
             # Add it to recordings
             recordings += additive_noise
 
         ##################
         # Step 3: filter #
         ##################
         if filter:
             if verbose_1:
-                print('Filtering')
+                print("Filtering")
                 if cutoff.size == 1:
-                    print('High-pass cutoff', cutoff)
+                    print("High-pass cutoff", cutoff)
                 elif cutoff.size == 2:
-                    print('Band-pass cutoff', cutoff)
+                    print("Band-pass cutoff", cutoff)
 
             chunk_indexes = make_chunk_indexes(duration, chunk_duration, fs)
 
             # compute pad samples as 3 times the low-cutoff period
             if cutoff.size == 1:
-                pad_samples_filt = 3 * int((1. / cutoff * fs).magnitude)
+                pad_samples_filt = 3 * int((1.0 / cutoff * fs).magnitude)
             elif cutoff.size == 2:
-                pad_samples_filt = 3 * int((1. / cutoff[0] * fs).magnitude)
+                pad_samples_filt = 3 * int((1.0 / cutoff[0] * fs).magnitude)
 
             # call the loop on chunks
-            args = (recordings, pad_samples_filt, cutoff, order, dtype,)
+            args = (
+                recordings,
+                pad_samples_filt,
+                cutoff,
+                filter_order,
+                filter_mode,
+                dtype,
+            )
             assignment_dict = {
-                'filtered_chunk': recordings,
+                "filtered_chunk": recordings,
             }
             # Done in loop (as before) : this cannot be done in parralel because of bug transpose in joblib!!!!!!!!!!!!!
-            run_several_chunks(chunk_apply_filter, chunk_indexes, fs, lsb, args,
-                               self.n_jobs, self.tmp_mode, assignment_dict)
+            run_several_chunks(
+                chunk_apply_filter, chunk_indexes, fs, lsb, args, self.n_jobs, self.tmp_mode, assignment_dict
+            )
 
         if gain is not None:
             gain_to_uV = gain
         else:
-            gain_to_uV = 1.
-        
+            gain_to_uV = 1.0
+
         # assign class variables
-        params['templates']['overlapping'] = np.array(overlapping)
+        params["templates"]["overlapping"] = np.array(overlapping)
         self.recordings = recordings
         self.timestamps = timestamps
         self.gain_to_uV = gain_to_uV
         self.channel_positions = mea_pos
         self.templates = np.squeeze(templates)
         self.template_locations = template_locs
         self.template_rotations = template_rots
@@ -1283,119 +1454,122 @@
 
         #############################
         # Step 4: extract waveforms #
         #############################
         if not only_noise:
             if extract_waveforms:
                 if verbose_1:
-                    print('Extracting spike waveforms')
+                    print("Extracting spike waveforms")
                 self.extract_waveforms()
 
     def annotate_overlapping_spikes(self, parallel=True):
         """
         Annnotate spike trains with overlapping information.
 
         parallel : bool
             If True, spike trains are annotated in parallel
         """
-        if self.info['templates']['overlapping'] is None or len(self.info['templates']['overlapping']) == 0:
+        if self.info["templates"]["overlapping"] is None or len(self.info["templates"]["overlapping"]) == 0:
             if self._verbose_1:
-                print('Finding overlapping spikes')
+                print("Finding overlapping spikes")
             if len(self.templates.shape) == 3:
                 templates = self.templates
             elif len(self.templates.shape) == 4:
                 # drifting + no jitt or no drifting + jitt
                 templates = self.templates[:, 0]
             elif len(self.templates.shape) == 5:
                 # drifting + jitt
                 templates = self.templates[:, 0, 0]
-            self.overlapping = find_overlapping_templates(templates,
-                                                          thresh=self.info['templates']['overlap_threshold'])
-            print('Overlapping templates: ', self.overlapping)
-            self.info['templates']['overlapping'] = self.overlapping
+            self.overlapping = find_overlapping_templates(templates, thresh=self.info["templates"]["overlap_threshold"])
+            print("Overlapping templates: ", self.overlapping)
+            self.info["templates"]["overlapping"] = self.overlapping
         annotate_overlapping_spikes(self.spiketrains, overlapping_pairs=self.overlapping, parallel=parallel)
 
     def extract_waveforms(self, cut_out=[0.5, 2]):
         """
         Extract waveforms from spike trains and recordings.
 
         Parameters
         ----------
         cut_out : float or list
             Ms before and after peak to cut out. If float the cut is symmetric.
         """
-        fs = self.info['recordings']['fs'] * pq.Hz
+        fs = self.info["recordings"]["fs"] * pq.Hz
         extract_wf(self.spiketrains, self.recordings, fs=fs, cut_out=cut_out)
 
     def extract_templates(self, cut_out=[0.5, 2], recompute=False):
         """
         Extract templates from spike trains.
 
         Parameters
         ----------
         cut_out : float or list
             Ms before and after peak to cut out. If float the cut is symmetric.
         recompute :  bool
             If True, templates are recomputed from extracted waveforms
         """
-        fs = self.info['recordings']['fs'] * pq.Hz
+        fs = self.info["recordings"]["fs"] * pq.Hz
 
         if not len(self.spiketrains) == 0:
             if self.spiketrains[0].waveforms is None:
                 extract_wf(self.spiketrains, self.recordings, fs=fs, cut_out=cut_out)
 
         if self.tempgen is None or len(self.templates) == 0 or not recompute:
             wfs = [st.waveforms for st in self.spiketrains]
             templates = np.array([np.mean(wf, axis=0) for wf in wfs])
             if np.array(cut_out).size == 1:
                 cut_out = [cut_out, cut_out]
-            self.info['templates']['cut_out'] = cut_out
-            self.info['templates']['pad_len'] = [0, 0]
+            self.info["templates"]["cut_out"] = cut_out
+            self.info["templates"]["pad_len"] = [0, 0]
             self.templates = templates[:, np.newaxis]
         else:
-            raise Exception("templates are already computed. Use the 'recompute' argument to compute them from "
-                            "extracted waveforms")
+            raise Exception(
+                "templates are already computed. Use the 'recompute' argument to compute them from "
+                "extracted waveforms"
+            )
 
 
 def make_chunk_indexes(total_duration, chunk_duration, fs):
     """
     Construct chunks list.
     Return a list of (start, stop) indexes.
     """
-    fs_float = fs.rescale('Hz').magnitude
-    chunk_size = int(chunk_duration.rescale('s').magnitude * fs_float)
-    total_length = int(total_duration.rescale('s').magnitude * fs_float)
+    fs_float = fs.rescale("Hz").magnitude
+    chunk_size = int(chunk_duration.rescale("s").magnitude * fs_float)
+    total_length = int(total_duration.rescale("s").magnitude * fs_float)
 
     if chunk_size == 0:
-        chunk_indexes = [(0, total_length), ]
+        chunk_indexes = [
+            (0, total_length),
+        ]
     else:
         n = int(np.floor(total_length / chunk_size))
         chunk_indexes = [(i * chunk_size, (i + 1) * chunk_size) for i in range(n)]
         if (total_length % chunk_size) > 0:
             chunk_indexes.append((n * chunk_size, total_length))
 
     return chunk_indexes
 
 
 def run_several_chunks(func, chunk_indexes, fs, lsb, args, n_jobs, tmp_mode, assignment_dict):
     """
     Run a function on a list of chunks.
-    
+
     this can be done in loop if n_jobs=1 (or 0)
     or in paralell if n_jobs>1
-    
+
     The function can return
     """
 
     # create task list
     arg_tasks = []
     karg_tasks = []
-    
+
     for ch, (i_start, i_stop) in enumerate(chunk_indexes):
-        fs_Hz = fs.rescale('Hz').magnitude
+        fs_Hz = fs.rescale("Hz").magnitude
 
         arg_task = (ch, i_start, i_stop, fs_Hz, lsb) + args
         arg_tasks.append(arg_task)
 
         karg_task = dict(assignment_dict=assignment_dict, tmp_mode=tmp_mode)
         karg_tasks.append(karg_task)
 
@@ -1407,24 +1581,25 @@
             out = func(*arg_tasks[ch], **karg_tasks[ch])
             output_list.append(out)
 
             if tmp_mode is None:
                 for key, full_arr in assignment_dict.items():
                     out_chunk = out[key]
                     full_arr[i_start:i_stop] += out_chunk
-            elif tmp_mode == 'memmap':
+            elif tmp_mode == "memmap":
                 pass
                 # Nothing to do here because done inside the func with FuncThenAddChunk
 
     else:
         # parallel
         output_list = Parallel(n_jobs=n_jobs)(
-            delayed(func)(*arg_task, **karg_task) for arg_task, karg_task in zip(arg_tasks, karg_tasks))
+            delayed(func)(*arg_task, **karg_task) for arg_task, karg_task in zip(arg_tasks, karg_tasks)
+        )
 
-        if tmp_mode == 'memmap':
+        if tmp_mode == "memmap":
             pass
             # Nothing to do here because done inside the func
         else:
             # This case is very unefficient because it double the memory usage!!!!!!!
             for ch, (i_start, i_stop) in enumerate(chunk_indexes):
                 for key, full_arr in assignment_dict.items():
                     full_arr[i_start:i_stop] += output_list[ch][key]
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `MEArec-1.8.0/MEArec/generators/spiketraingenerator.py` & `MEArec-1.9.0/src/MEArec/generators/spiketraingenerator.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,15 +1,17 @@
-import numpy as np
-import neo
+from copy import deepcopy
+
 import elephant.spike_train_generation as stg
 import elephant.statistics as stat
-from copy import deepcopy
-from MEArec.tools import *
+import neo
+import numpy as np
 import quantities as pq
 
+from ..tools import annotate_overlapping_spikes, compute_sync_rate
+
 
 class SpikeTrainGenerator:
     """
     Class for generation of spike trains called by the gen_recordings function.
     The list of parameters is in default_params/recordings_params.yaml (spiketrains field).
 
     Parameters
@@ -31,77 +33,77 @@
             if self._verbose:
                 print("Using default parameters")
         if spiketrains is None:
             self.params = deepcopy(params)
             if seed is None:
                 seed = np.random.randint(1000)
             if self._verbose:
-                print('Spiketrains seed: ', seed)
-            self.params['seed'] = seed
-            np.random.seed(self.params['seed'])
-
-            if 't_start' not in self.params.keys():
-                params['t_start'] = 0
-            self.params['t_start'] = params['t_start'] * pq.s
-            if 'duration' not in self.params.keys():
-                params['duration'] = 10
-            self.params['t_stop'] = self.params['t_start'] + params['duration'] * pq.s
-            if 'min_rate' not in self.params.keys():
-                params['min_rate'] = 0.1
-            self.params['min_rate'] = params['min_rate'] * pq.Hz
-            if 'ref_per' not in self.params.keys():
-                params['ref_per'] = 2
-            self.params['ref_per'] = params['ref_per'] * pq.ms
-            if 'process' not in self.params.keys():
-                params['process'] = 'poisson'
-            self.params['process'] = params['process']
-            if 'gamma_shape' not in self.params.keys() and params['process'] == 'gamma':
-                params['gamma_shape'] = 2
-                self.params['gamma_shape'] = params['gamma_shape']
-
-            if 'rates' in self.params.keys():  # all firing rates are provided
-                self.params['rates'] = self.params['rates'] * pq.Hz
-                self.n_neurons = len(self.params['rates'])
+                print("Spiketrains seed: ", seed)
+            self.params["seed"] = seed
+            np.random.seed(self.params["seed"])
+
+            if "t_start" not in self.params.keys():
+                params["t_start"] = 0
+            self.params["t_start"] = params["t_start"] * pq.s
+            if "duration" not in self.params.keys():
+                params["duration"] = 10
+            self.params["t_stop"] = self.params["t_start"] + params["duration"] * pq.s
+            if "min_rate" not in self.params.keys():
+                params["min_rate"] = 0.1
+            self.params["min_rate"] = params["min_rate"] * pq.Hz
+            if "ref_per" not in self.params.keys():
+                params["ref_per"] = 2
+            self.params["ref_per"] = params["ref_per"] * pq.ms
+            if "process" not in self.params.keys():
+                params["process"] = "poisson"
+            self.params["process"] = params["process"]
+            if "gamma_shape" not in self.params.keys() and params["process"] == "gamma":
+                params["gamma_shape"] = 2
+                self.params["gamma_shape"] = params["gamma_shape"]
+
+            if "rates" in self.params.keys():  # all firing rates are provided
+                self.params["rates"] = self.params["rates"] * pq.Hz
+                self.n_neurons = len(self.params["rates"])
             else:
                 rates = []
                 types = []
-                if 'f_exc' not in self.params.keys():
-                    params['f_exc'] = 5
-                self.params['f_exc'] = params['f_exc'] * pq.Hz
-                if 'f_inh' not in self.params.keys():
-                    params['f_inh'] = 15
-                self.params['f_inh'] = params['f_inh'] * pq.Hz
-                if 'st_exc' not in self.params.keys():
-                    params['st_exc'] = 1
-                self.params['st_exc'] = params['st_exc'] * pq.Hz
-                if 'st_inh' not in self.params.keys():
-                    params['st_inh'] = 3
-                self.params['st_inh'] = params['st_inh'] * pq.Hz
-                if 'n_exc' not in self.params.keys():
-                    params['n_exc'] = 2
-                self.params['n_exc'] = params['n_exc']
-                if 'n_inh' not in self.params.keys():
-                    params['n_inh'] = 1
-                self.params['n_inh'] = params['n_inh']
-
-                for exc in np.arange(self.params['n_exc']):
-                    rate = self.params['st_exc'] * np.random.randn() + self.params['f_exc']
-                    if rate < self.params['min_rate']:
-                        rate = self.params['min_rate']
+                if "f_exc" not in self.params.keys():
+                    params["f_exc"] = 5
+                self.params["f_exc"] = params["f_exc"] * pq.Hz
+                if "f_inh" not in self.params.keys():
+                    params["f_inh"] = 15
+                self.params["f_inh"] = params["f_inh"] * pq.Hz
+                if "st_exc" not in self.params.keys():
+                    params["st_exc"] = 1
+                self.params["st_exc"] = params["st_exc"] * pq.Hz
+                if "st_inh" not in self.params.keys():
+                    params["st_inh"] = 3
+                self.params["st_inh"] = params["st_inh"] * pq.Hz
+                if "n_exc" not in self.params.keys():
+                    params["n_exc"] = 2
+                self.params["n_exc"] = params["n_exc"]
+                if "n_inh" not in self.params.keys():
+                    params["n_inh"] = 1
+                self.params["n_inh"] = params["n_inh"]
+
+                for exc in np.arange(self.params["n_exc"]):
+                    rate = self.params["st_exc"] * np.random.randn() + self.params["f_exc"]
+                    if rate < self.params["min_rate"]:
+                        rate = self.params["min_rate"]
                     rates.append(rate)
-                    types.append('e')
-                for inh in np.arange(self.params['n_inh']):
-                    rate = self.params['st_inh'] * np.random.randn() + self.params['f_inh']
-                    if rate < self.params['min_rate']:
-                        rate = self.params['min_rate']
+                    types.append("e")
+                for inh in np.arange(self.params["n_inh"]):
+                    rate = self.params["st_inh"] * np.random.randn() + self.params["f_inh"]
+                    if rate < self.params["min_rate"]:
+                        rate = self.params["min_rate"]
                     rates.append(rate)
-                    types.append('i')
-                self.params['rates'] = rates
-                self.params['types'] = types
-                self.n_neurons = len(self.params['rates'])
+                    types.append("i")
+                self.params["rates"] = rates
+                self.params["types"] = types
+                self.n_neurons = len(self.params["rates"])
 
             self.info = params
             self.spiketrains = False
         else:
             self.spiketrains = spiketrains
             self.info = {}
             self._has_spiketrains = True
@@ -127,42 +129,42 @@
         Generate spike trains based on default_params of the SpikeTrainGenerator class.
         self.spiketrains contains the newly generated spike trains
         """
         if not self._has_spiketrains:
             self.spiketrains = []
             idx = 0
             for n in np.arange(self.n_neurons):
-                rate = self.params['rates'][n]
-                if self.params['process'] == 'poisson':
-                    st = stg.homogeneous_poisson_process(rate,
-                                                         self.params['t_start'], self.params['t_stop'])
-                elif self.params['process'] == 'gamma':
-                    st = stg.homogeneous_gamma_process(self.params['gamma_shape'], rate,
-                                                       self.params['t_start'], self.params['t_stop'])
+                rate = self.params["rates"][n]
+                if self.params["process"] == "poisson":
+                    st = stg.homogeneous_poisson_process(rate, self.params["t_start"], self.params["t_stop"])
+                elif self.params["process"] == "gamma":
+                    st = stg.homogeneous_gamma_process(
+                        self.params["gamma_shape"], rate, self.params["t_start"], self.params["t_stop"]
+                    )
                 self.spiketrains.append(st)
                 self.spiketrains[-1].annotate(fr=rate)
-                if 'n_exc' in self.params.keys() and 'n_inh' in self.params.keys():
-                    if idx < self.params['n_exc']:
-                        self.spiketrains[-1].annotate(cell_type='E')
+                if "n_exc" in self.params.keys() and "n_inh" in self.params.keys():
+                    if idx < self.params["n_exc"]:
+                        self.spiketrains[-1].annotate(cell_type="E")
                     else:
-                        self.spiketrains[-1].annotate(cell_type='I')
+                        self.spiketrains[-1].annotate(cell_type="I")
                 idx += 1
 
             # check consistency and remove spikes below refractory period
             for idx, st in enumerate(self.spiketrains):
                 isi = stat.isi(st)
-                idx_remove = np.where(isi < self.params['ref_per'])[0]
+                idx_remove = np.where(isi < self.params["ref_per"])[0]
                 spikes_to_remove = len(idx_remove)
                 unit = st.times.units
 
                 while spikes_to_remove > 0:
                     new_times = np.delete(st.times, idx_remove[0]) * unit
-                    st = neo.SpikeTrain(new_times, t_start=self.params['t_start'], t_stop=self.params['t_stop'])
+                    st = neo.SpikeTrain(new_times, t_start=self.params["t_start"], t_stop=self.params["t_stop"])
                     isi = stat.isi(st)
-                    idx_remove = np.where(isi < self.params['ref_per'])[0]
+                    idx_remove = np.where(isi < self.params["ref_per"])[0]
                     spikes_to_remove = len(idx_remove)
 
                 st.annotations = self.spiketrains[idx].annotations
                 self.set_spiketrain(idx, st)
         else:
             print("SpikeTrainGenerator initialized with existing spike trains!")
 
@@ -211,89 +213,113 @@
             tot_spikes = len(times1) + len(times2)
 
             # this assumes that: target_overlaps = curr_overlaps + add_overlaps
             add_overlaps = int(np.round((curr_overlaps - rate * tot_spikes) / (rate - 1)))
 
             # find non-overlappping spikes
             annotate_overlapping_spikes(spiketrains)
-            st1_no_idx = np.where(spiketrains[0].annotations['overlap'] == 'NO')[0]
-            st2_no_idx = np.where(spiketrains[1].annotations['overlap'] == 'NO')[0]
+            st1_no_idx = np.where(spiketrains[0].annotations["overlap"] == "NO")[0]
+            st2_no_idx = np.where(spiketrains[1].annotations["overlap"] == "NO")[0]
 
             st1_no = times1[st1_no_idx]
             st2_no = times2[st2_no_idx]
 
             all_times_no_shuffle = np.concatenate((st1_no, st2_no))
             all_times_no_shuffle = all_times_no_shuffle[np.random.permutation(len(all_times_no_shuffle))] * unit
 
             for t in all_times_no_shuffle:
                 if added_spikes_t1 + added_spikes_t2 <= add_overlaps:
                     # check time difference (since they are NO, they most likely won't violate ref_period)
                     if t in times1:
-                        t1_jitt = time_jitt.rescale(unit).magnitude * np.random.rand(1) + t.rescale(
-                            unit).magnitude - \
-                                  (time_jitt.rescale(unit) / 2).magnitude
+                        t1_jitt = (
+                            time_jitt.rescale(unit).magnitude * np.random.rand(1)
+                            + t.rescale(unit).magnitude
+                            - (time_jitt.rescale(unit) / 2).magnitude
+                        )
                         if t1_jitt < t_stop:
                             times2 = np.concatenate((np.array(times2), np.array(t1_jitt)))
                             times2 = times2 * unit
                             added_spikes_t1 += 1
                     elif t in times2:
-                        t2_jitt = time_jitt.rescale(unit).magnitude * np.random.rand(1) + t.rescale(
-                            unit).magnitude - \
-                                  (time_jitt.rescale(unit) / 2).magnitude
+                        t2_jitt = (
+                            time_jitt.rescale(unit).magnitude * np.random.rand(1)
+                            + t.rescale(unit).magnitude
+                            - (time_jitt.rescale(unit) / 2).magnitude
+                        )
                         if t2_jitt < t_stop:
                             times1 = np.concatenate((np.array(times1), np.array(t2_jitt)))
                             times1 = times1 * unit
                             added_spikes_t2 += 1
                 else:
                     break
             times1 = np.sort(times1)
             times2 = np.sort(times2)
 
             # remove spike trains violating ref period
-            ref_violations_idxs1 = np.where(np.diff(times1) < self.params['ref_per'])[0]
-            ref_violations_idxs2 = np.where(np.diff(times2) < self.params['ref_per'])[0]
+            ref_violations_idxs1 = np.where(np.diff(times1) < self.params["ref_per"])[0]
+            ref_violations_idxs2 = np.where(np.diff(times2) < self.params["ref_per"])[0]
 
             if len(ref_violations_idxs1) > 0:
-                print(f'Remove {len(ref_violations_idxs1)} violations from times1')
+                print(f"Remove {len(ref_violations_idxs1)} violations from times1")
                 times1 = np.delete(times1, ref_violations_idxs1) * unit
             if len(ref_violations_idxs2) > 0:
-                print(f'Remove {len(ref_violations_idxs2)} violations from times2')
+                print(f"Remove {len(ref_violations_idxs2)} violations from times2")
                 times2 = np.delete(times2, ref_violations_idxs2) * unit
 
             sync_rate = compute_sync_rate(times1, times2, time_jitt)
             if verbose:
-                print("Added", added_spikes_t1, "spikes to spike train", idxs[0],
-                      "and", added_spikes_t2, "spikes to spike train", idxs[1], 'Sync rate:', sync_rate)
+                print(
+                    "Added",
+                    added_spikes_t1,
+                    "spikes to spike train",
+                    idxs[0],
+                    "and",
+                    added_spikes_t2,
+                    "spikes to spike train",
+                    idxs[1],
+                    "Sync rate:",
+                    sync_rate,
+                )
         else:
             spiketrains = [st1, st2]
             annotate_overlapping_spikes(spiketrains)
             max_overlaps = np.floor(rate * (len(times1) + len(times2)))
             curr_overlaps = np.floor(sync_rate * (len(times1) + len(times2)))
             remove_overlaps = int(curr_overlaps - max_overlaps)
             if curr_overlaps > max_overlaps:
-                st1_to_idx = np.where(spiketrains[0].annotations['overlap'] == 'TO')[0]
-                st2_to_idx = np.where(spiketrains[1].annotations['overlap'] == 'TO')[0]
+                st1_to_idx = np.where(spiketrains[0].annotations["overlap"] == "TO")[0]
+                st2_to_idx = np.where(spiketrains[1].annotations["overlap"] == "TO")[0]
                 perm = np.random.permutation(len(st1_to_idx))[:remove_overlaps]
                 st1_ovrl_idx = st1_to_idx[perm]
                 st2_ovrl_idx = st2_to_idx[perm]
-                idx_rm_1 = st1_ovrl_idx[:remove_overlaps // 2]
-                idx_rm_2 = st2_ovrl_idx[remove_overlaps // 2:]
+                idx_rm_1 = st1_ovrl_idx[: remove_overlaps // 2]
+                idx_rm_2 = st2_ovrl_idx[remove_overlaps // 2 :]
                 times1 = np.delete(st1.times, idx_rm_1)
                 times1 = times1 * unit
                 times2 = np.delete(st2.times, idx_rm_2)
                 times2 = times2 * unit
                 sync_rate = compute_sync_rate(times1, times2, time_jitt)
                 if verbose:
-                    print("Removed", len(idx_rm_1), "spikes from spike train", idxs[0],
-                          "and", len(idx_rm_2), "spikes from spike train", idxs[1], 'Sync rate:', sync_rate)
+                    print(
+                        "Removed",
+                        len(idx_rm_1),
+                        "spikes from spike train",
+                        idxs[0],
+                        "and",
+                        len(idx_rm_2),
+                        "spikes from spike train",
+                        idxs[1],
+                        "Sync rate:",
+                        sync_rate,
+                    )
 
         st1 = neo.SpikeTrain(times1, t_start=t_start, t_stop=t_stop)
         st2 = neo.SpikeTrain(times2, t_start=t_start, t_stop=t_stop)
         st1.annotations = self.spiketrains[idx1].annotations
         st2.annotations = self.spiketrains[idx2].annotations
         self.set_spiketrain(idx1, st1)
         self.set_spiketrain(idx2, st2)
 
         fr1 = len(st1.times) / st1.t_stop
         fr2 = len(st2.times) / st2.t_stop
 
-        return sync_rate, fr1, fr2
+        return sync_rate, fr1, fr2
```

### Comparing `MEArec-1.8.0/MEArec/generators/templategenerator.py` & `MEArec-1.9.0/src/MEArec/generators/templategenerator.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,42 +1,41 @@
+import os
+import shutil
 import sys
 import time
-import numpy as np
-from MEArec.tools import *
+from copy import deepcopy
+from pathlib import Path
+
 import MEAutility as mu
-import shutil
+import numpy as np
 import yaml
-import os
+from joblib import Parallel, cpu_count, delayed
 from packaging.version import parse
-from pathlib import Path
-from joblib import Parallel, delayed, cpu_count
-from MEArec.simulate_cells import compute_eap_for_cell_model, compute_eap_based_on_tempgen
-
-from MEArec.tools import clean_dict_for_yaml
 
+from ..simulate_cells import (compute_eap_based_on_tempgen,
+                              compute_eap_for_cell_model)
+from ..tools import (clean_dict_for_yaml, get_default_config, load_tmp_eap,
+                     safe_yaml_load)
 
-if parse(yaml.__version__) >= parse('5.0.0'):
-    use_loader = True
-else:
-    use_loader = False
+_intra_keys = ["sim_time", "target_spikes", "cut_out", "dt", "delay", "weights", "seed", "cell_models_folder"]
 
 
-def simulate_cell_templates(i, simulate_script, tot, cell_model,
-                            model_folder, intraonly, params, verbose):
+def simulate_cell_templates(i, simulate_script, tot, cell_model, model_folder, intraonly, params_path, verbose):
     model_folder = Path(model_folder)
-    print(f"Starting {i + 1}")
-    print(f'\n\n {cell_model} {i + 1}/{tot}\n\n')
+    print(f"Starting simulation {i + 1}/{tot} - cell: {Path(cell_model).name}\n", flush=True)
     python = sys.executable
     if verbose:
         verbose = 1
     else:
         verbose = 0
-    os.system(
-        f'{python} {simulate_script} {i} {str(model_folder / cell_model)} {intraonly} {params} {verbose}')
-    print(f"Exiting {i + 1}")
+    cmd = (
+        f"{python} {simulate_script} {i} {str(model_folder / cell_model)} "
+        f"{intraonly} {params_path.absolute()} {verbose}"
+    )
+    os.system(cmd)
 
 
 class TemplateGenerator:
     """
     Class for generation of templates called by the gen_templates function.
     The list of parameters is in default_params/templates_params.yaml.
 
@@ -72,28 +71,40 @@
         If None, all cpus are used
     delete_tmp : bool
         If True, temporary files are removed
     verbose : bool
         If True, output is verbose
     """
 
-    def __init__(self, cell_models_folder=None, templates_folder=None, temp_dict=None, info=None, tempgen=None,
-                 params=None, intraonly=False, parallel=True, recompile=False, n_jobs=None,
-                 joblib_backend="loky", delete_tmp=True,
-                 verbose=False):
+    def __init__(
+        self,
+        cell_models_folder=None,
+        templates_folder=None,
+        temp_dict=None,
+        info=None,
+        tempgen=None,
+        params=None,
+        intraonly=False,
+        parallel=True,
+        recompile=False,
+        n_jobs=None,
+        joblib_backend="loky",
+        delete_tmp=True,
+        verbose=False,
+    ):
         self._verbose = verbose
         if temp_dict is not None and info is not None:
-            if 'templates' in temp_dict.keys():
-                self.templates = temp_dict['templates']
-            if 'locations' in temp_dict.keys():
-                self.locations = temp_dict['locations']
-            if 'rotations' in temp_dict.keys():
-                self.rotations = temp_dict['rotations']
-            if 'celltypes' in temp_dict.keys():
-                self.celltypes = temp_dict['celltypes']
+            if "templates" in temp_dict.keys():
+                self.templates = temp_dict["templates"]
+            if "locations" in temp_dict.keys():
+                self.locations = temp_dict["locations"]
+            if "rotations" in temp_dict.keys():
+                self.rotations = temp_dict["rotations"]
+            if "celltypes" in temp_dict.keys():
+                self.celltypes = temp_dict["celltypes"]
             self.info = info
             self.params = deepcopy(info)
         else:
             if cell_models_folder is None:
                 raise AttributeError("Specify cell folder!")
             if params is None:
                 if self._verbose:
@@ -104,192 +115,251 @@
             self.cell_model_folder = Path(cell_models_folder).resolve()
             self.n_jobs = n_jobs
             self.joblib_backend = joblib_backend
             if templates_folder is not None:
                 templates_folder = Path(templates_folder).resolve()
             self.templates_folder = templates_folder
             self.tempgen = tempgen
-            self.simulation_params = {'intraonly': intraonly, 'parallel': parallel, 'delete_tmp': delete_tmp,
-                                      'recompile': recompile}
+            self.simulation_params = {
+                "intraonly": intraonly,
+                "parallel": parallel,
+                "delete_tmp": delete_tmp,
+                "recompile": recompile,
+            }
 
     def generate_templates(self):
         """
         Generate templates.
         """
         cell_models_folder = self.cell_model_folder
         templates_folder = self.templates_folder
-        intraonly = self.simulation_params['intraonly']
-        parallel = self.simulation_params['parallel']
-        recompile = self.simulation_params['recompile']
-        delete_tmp = self.simulation_params['delete_tmp']
+        intraonly = self.simulation_params["intraonly"]
+        parallel = self.simulation_params["parallel"]
+        recompile = self.simulation_params["recompile"]
+        delete_tmp = self.simulation_params["delete_tmp"]
 
         if cell_models_folder.is_dir():
-            cell_models = [f for f in cell_models_folder.iterdir() if 'mods' not in f.name
-                           and not f.name.startswith('.')]
+            cell_models = [
+                f for f in cell_models_folder.iterdir() if "mods" not in f.name and not f.name.startswith(".")
+            ]
             if len(cell_models) == 0:
-                raise AttributeError(cell_models_folder,
-                                     ' contains no cell models!')
+                raise AttributeError(cell_models_folder, " contains no cell models!")
         else:
-            raise NotADirectoryError('Cell models folder: does not exist!')
+            raise NotADirectoryError("Cell models folder: does not exist!")
 
         this_dir, this_filename = os.path.split(__file__)
-        simulate_script = str(Path(this_dir).parent / 'simulate_cells.py')
+        simulate_script = str(Path(this_dir).parent / "simulate_cells.py")
 
         # Compile NEURON models (nrnivmodl)
-        if not (cell_models_folder / 'mods').is_dir() or recompile:
+        if not (cell_models_folder / "mods").is_dir() or recompile:
             if self._verbose:
-                print('Compiling NEURON models')
+                print("Compiling NEURON models")
             python = sys.executable
-            os.system(f'{python} {simulate_script} compile {cell_models_folder}')
+            os.system(f"{python} {simulate_script} compile {cell_models_folder}")
 
         # sort cell model names
-        cell_models = np.array(cell_models)[
-            np.argsort([f.name for f in cell_models])]
+        cell_models = np.array(cell_models)[np.argsort([f.name for f in cell_models])]
 
-        if 'sim_time' not in self.params.keys():
-            self.params['sim_time'] = 1
-        if 'target_spikes' not in self.params.keys():
-            self.params['target_spikes'] = [3, 50]
-        if 'cut_out' not in self.params.keys():
-            self.params['cut_out'] = [2, 5]
-        if 'dt' not in self.params.keys():
-            self.params['dt'] = 2 ** -5
-        if 'delay' not in self.params.keys():
-            self.params['delay'] = 10
-        if 'weights' not in self.params.keys():
-            self.params['weights'] = [0.25, 1.75]
-
-        if 'rot' not in self.params.keys():
-            self.params['rot'] = 'physrot'
-        if 'probe' not in self.params.keys():
+        if "sim_time" not in self.params.keys():
+            self.params["sim_time"] = 1
+        if "target_spikes" not in self.params.keys():
+            self.params["target_spikes"] = [3, 50]
+        if "cut_out" not in self.params.keys():
+            self.params["cut_out"] = [2, 5]
+        if "dt" not in self.params.keys():
+            self.params["dt"] = 2**-5
+        if "delay" not in self.params.keys():
+            self.params["delay"] = 10
+        if "weights" not in self.params.keys():
+            self.params["weights"] = [0.25, 1.75]
+
+        if "rot" not in self.params.keys():
+            self.params["rot"] = "physrot"
+        if "probe" not in self.params.keys():
             available_mea = mu.return_mea_list()
             probe = available_mea[np.random.randint(len(available_mea))]
             if self._verbose:
                 print("Probe randomly set to: %s" % probe)
-            self.params['probe'] = probe
-        if 'ncontacts' not in self.params.keys():
-            self.params['ncontacts'] = 1
-        if 'overhang' not in self.params.keys():
-            self.params['overhang'] = 1
-        if 'xlim' not in self.params.keys():
-            self.params['xlim'] = [10, 80]
-        if 'ylim' not in self.params.keys():
-            self.params['ylim'] = None
-        if 'zlim' not in self.params.keys():
-            self.params['zlim'] = None
-        if 'x_distr' not in self.params.keys():
-            self.params['x_distr'] = 'uniform'
-        if 'beta_distr_params' not in self.params.keys():
-            self.params['beta_distr_params'] = [1.5, 5]
-        if 'offset' not in self.params.keys():
-            self.params['offset'] = 0
-        if 'det_thresh' not in self.params.keys():
-            self.params['det_thresh'] = 30
-        if 'n' not in self.params.keys():
-            self.params['n'] = 50
-        if 'min_amp' not in self.params.keys():
-            self.params['min_amp'] = 30
-        if 'seed' not in self.params.keys():
-            self.params['seed'] = np.random.randint(1, 10000)
-        elif self.params['seed'] is None:
-            self.params['seed'] = np.random.randint(1, 10000)
+            self.params["probe"] = probe
+        if "ncontacts" not in self.params.keys():
+            self.params["ncontacts"] = 1
+        if "overhang" not in self.params.keys():
+            self.params["overhang"] = 1
+        if "xlim" not in self.params.keys():
+            self.params["xlim"] = [10, 80]
+        if "ylim" not in self.params.keys():
+            self.params["ylim"] = None
+        if "zlim" not in self.params.keys():
+            self.params["zlim"] = None
+        if "x_distr" not in self.params.keys():
+            self.params["x_distr"] = "uniform"
+        if "beta_distr_params" not in self.params.keys():
+            self.params["beta_distr_params"] = [1.5, 5]
+        if "offset" not in self.params.keys():
+            self.params["offset"] = 0
+        if "det_thresh" not in self.params.keys():
+            self.params["det_thresh"] = 30
+        if "n" not in self.params.keys():
+            self.params["n"] = 50
+        if "check_eap_shape" not in self.params.keys():
+            self.params["check_eap_shape"] = True
+        if "min_amp" not in self.params.keys():
+            self.params["min_amp"] = 30
+        if "seed" not in self.params.keys():
+            self.params["seed"] = np.random.randint(1, 10000)
+        elif self.params["seed"] is None:
+            self.params["seed"] = np.random.randint(1, 10000)
         if templates_folder is None:
             info, _ = get_default_config()
-            self.params['templates_folder'] = info['templates_folder']
-            templates_folder = Path(self.params['templates_folder'])
+            self.params["templates_folder"] = info["templates_folder"]
+            templates_folder = Path(self.params["templates_folder"])
         else:
-            self.params['templates_folder'] = str(templates_folder)
-        self.params['cell_models_folder'] = str(cell_models_folder)
-        if 'drifting' not in self.params.keys():
-            self.params['drifting'] = False
-        if 'max_drift' not in self.params.keys():
-            self.params['max_drift'] = 100
-        if 'min_drift' not in self.params.keys():
-            self.params['min_drift'] = 30
-        if 'drift_steps' not in self.params.keys():
-            self.params['drift_steps'] = 10
-        if 'drift_xlim' not in self.params.keys():
-            self.params['drift_xlim'] = [-10, 10]
-        if 'drift_ylim' not in self.params.keys():
-            self.params['drift_ylim'] = [-10, 10]
-        if 'drift_zlim' not in self.params.keys():
-            self.params['drift_zlim'] = [20, 80]
-        if 'check_for_drift_amp' not in self.params.keys():
-            self.params['check_for_drift_amp'] = False
-        if 'drift_within_bounds' not in self.params.keys():
-            self.params['drift_within_bounds'] = False
-
-        rot = self.params['rot']
-        n = self.params['n']
-        probe = self.params['probe']
+            self.params["templates_folder"] = str(templates_folder)
+        self.params["cell_models_folder"] = str(cell_models_folder)
+        if "drifting" not in self.params.keys():
+            self.params["drifting"] = False
+        if "max_drift" not in self.params.keys():
+            self.params["max_drift"] = 100
+        if "min_drift" not in self.params.keys():
+            self.params["min_drift"] = 30
+        if "drift_steps" not in self.params.keys():
+            self.params["drift_steps"] = 10
+        if "drift_xlim" not in self.params.keys():
+            self.params["drift_xlim"] = [-10, 10]
+        if "drift_ylim" not in self.params.keys():
+            self.params["drift_ylim"] = [-10, 10]
+        if "drift_zlim" not in self.params.keys():
+            self.params["drift_zlim"] = [20, 80]
+        if "check_for_drift_amp" not in self.params.keys():
+            self.params["check_for_drift_amp"] = False
+        if "drift_within_bounds" not in self.params.keys():
+            self.params["drift_within_bounds"] = False
+
+        rot = self.params["rot"]
+        n = self.params["n"]
+        probe = self.params["probe"]
+
+        # check intra params
+        intra_params = {k: v for k, v in self.params.items() if k in _intra_keys}
+        # check params
+        intracellular_folder = Path(self.params["templates_folder"]) / "intracellular"
+        skip_existing_intracellular = check_intracellular_params(intracellular_folder, intra_params)
+        if skip_existing_intracellular:
+            if intracellular_folder.is_dir():
+                if self._verbose:
+                    print(f"Removing intracellular folder {intracellular_folder} because of intra parameter mismatch")
+                shutil.rmtree(intracellular_folder)
 
-        tmp_params_path = 'tmp_params_path.yaml'
-        with open(tmp_params_path, 'w') as f:
+        tmp_params_path = Path("tmp_params_path.yaml")
+        with open(tmp_params_path, "w") as f:
             # alessio we did have bug here because some params are numpy.int, numpy.bool
             # I did this fast debug but we need a way to convert then to standard float/int/bool
-            # yaml.dump(self.params, f)
+            # yaml.dump(self.params, f)
             yaml.dump(clean_dict_for_yaml(self.params), f)
 
         if self.tempgen is not None and parallel and self.n_jobs not in (0, 1):
-            print("\nWARNING: Generation of templates from a template generator is only supported without parallel "
-                  "processing. Setting parallel to False\n")
+            print(
+                "\nWARNING: Generation of templates from a template generator is only supported without parallel "
+                "processing. Setting parallel to False\n"
+            )
             parallel = False
 
         # Simulate neurons and EAP for different cell models separately
         if parallel and self.n_jobs not in (0, 1):
             start_time = time.time()
             tot = len(cell_models)
             if self.n_jobs is None:
                 n_jobs = cpu_count()
                 print(f"Setting n_jobs to {n_jobs} CPUs")
             else:
                 n_jobs = self.n_jobs
 
             if self._verbose:
-                print('Running with', n_jobs, 'jobs')
+                print("Running with", n_jobs, "jobs")
 
             Parallel(n_jobs=n_jobs, backend=self.joblib_backend)(
-                delayed(simulate_cell_templates)(i, simulate_script, tot, cell_model,
-                                                 cell_models_folder, intraonly, tmp_params_path,
-                                                 self._verbose, )
-                for i, cell_model in enumerate(cell_models))
+                delayed(simulate_cell_templates)(
+                    i,
+                    simulate_script,
+                    tot,
+                    cell_model,
+                    cell_models_folder,
+                    intraonly,
+                    tmp_params_path,
+                    self._verbose,
+                )
+                for i, cell_model in enumerate(cell_models)
+            )
         else:
             start_time = time.time()
             if self.tempgen is None:
                 for i, cell_model in enumerate(cell_models):
                     if self._verbose:
-                        print(
-                            f'\n\n {cell_model} {i + 1}/{len(cell_models)}\n\n')
-                    compute_eap_for_cell_model(i, cell_model=cell_model, params_path=tmp_params_path,
-                                               intraonly=intraonly, verbose=self._verbose)
+                        print(f"\n\n {cell_model} {i + 1}/{len(cell_models)}\n\n")
+                    compute_eap_for_cell_model(
+                        i,
+                        cell_model=cell_model,
+                        params_path=tmp_params_path,
+                        intraonly=intraonly,
+                        verbose=self._verbose,
+                    )
 
             else:
                 print("Using template generation info")
-                compute_eap_based_on_tempgen(cell_folder=cell_models_folder,
-                                             params_path=tmp_params_path,
-                                             tempgen=self.tempgen,
-                                             intraonly=intraonly,
-                                             verbose=self._verbose)
-
-        tmp_folder = Path(templates_folder) / rot / f'tmp_{n}_{probe}'
+                compute_eap_based_on_tempgen(
+                    cell_folder=cell_models_folder,
+                    params_path=tmp_params_path,
+                    tempgen=self.tempgen,
+                    intraonly=intraonly,
+                    verbose=self._verbose,
+                )
+        # save new intracellular params
+        if skip_existing_intracellular:
+            params_file = intracellular_folder / "intra_params.yaml"
+            if params_file.is_file():
+                params_file.unlink()
+            with params_file.open("w") as f:
+                yaml.dump(intra_params, f)
+            if self._verbose:
+                print(f"Saving new intracellular parameters in {params_file}")
 
+        tmp_folder = Path(templates_folder) / rot / f"tmp_{n}_{probe}"
         if not Path(tmp_folder).is_dir():
-            raise FileNotFoundError(
-                f'{tmp_folder} not found. Something went wrong in the template generation phase.')
+            raise FileNotFoundError(f"{tmp_folder} not found. Something went wrong in the template generation phase.")
 
         print("Aggregating templates")
         templates, locations, rotations, celltypes = load_tmp_eap(tmp_folder)
         if delete_tmp:
             shutil.rmtree(tmp_folder)
             os.remove(tmp_params_path)
 
         self.info = {}
 
         self.templates = templates
         self.locations = locations
         self.rotations = rotations
         self.celltypes = celltypes
 
-        self.info['params'] = self.params
-        self.info['electrodes'] = mu.return_mea_info(probe)
+        self.info["params"] = self.params
+        self.info["electrodes"] = mu.return_mea_info(probe)
+
+        print(f"\n\n\nSimulation time: {time.time() - start_time}\n\n\n")
 
-        print(f'\n\n\nSimulation time: {time.time() - start_time}\n\n\n')
+
+def check_intracellular_params(
+    vm_im_sim_folder, params, check_params=["dt", "cut_out", "cell_models_folder", "target_spikes"]
+):
+    skip_existing_intracellular = False
+    if not vm_im_sim_folder.is_dir():
+        skip_existing_intracellular = True
+    else:
+        params_files = [f for f in Path(vm_im_sim_folder).iterdir() if "intra_params.yaml" in f.name]
+        if len(params_files) == 0:
+            skip_existing_intracellular = True
+        if len(params_files) == 1:
+            params_file = params_files[0]
+            existing_intra_params = safe_yaml_load(params_file)
+            for param_key in check_params:
+                if existing_intra_params[param_key] != params[param_key]:
+                    print(f"{param_key} is different!")
+                    skip_existing_intracellular = True
+    return skip_existing_intracellular
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `MEArec-1.8.0/MEArec/simulate_cells.py` & `MEArec-1.9.0/src/MEArec/simulate_cells.py`

 * *Files 6% similar despite different names*

```diff
@@ -4,47 +4,42 @@
 https://bbpnmc.epfl.ch/nmc-portal/downloads are unzipped in the folder 'cell_models'
 
 The function compile_all_mechanisms must be run once before any cell simulation
 """
 
 import os
 import sys
-from glob import glob
-import numpy as np
-import MEAutility as mu
-import yaml
 import time
 from pathlib import Path
+
+import MEAutility as mu
+import numpy as np
 from packaging.version import parse
 
-if parse(yaml.__version__) >= parse('5.0.0'):
-    use_loader = True
-else:
-    use_loader = False
+from MEArec.tools import safe_yaml_load
 
 
 def import_LFPy_neuron():
     try:
         import LFPy
     except:
-        raise ModuleNotFoundError(
-            "LFPy is not installed. Install it with 'pip install LFPy'")
+        raise ModuleNotFoundError("LFPy is not installed. Install it with 'pip install LFPy'")
 
     try:
         # disable DISPLAY for subprocess
         # print("Disabling display")
         # os.environ["DISPLAY"] = ""
         import neuron
     except:
         raise ModuleNotFoundError(
-            "NEURON is not installed. Install it from https://www.neuron.yale.edu/neuron/download")
+            "NEURON is not installed. Install it from https://www.neuron.yale.edu/neuron/download"
+        )
 
-    if parse(LFPy.__version__) < parse('2.2'):
-        raise ImportError(
-            "LFPy version must be >= 2.2. To use a previous LFPy version, downgrade MEArec to <= 1.4.1")
+    if parse(LFPy.__version__) < parse("2.2"):
+        raise ImportError("LFPy version must be >= 2.2. To use a previous LFPy version, downgrade MEArec to <= 1.4.1")
 
     return LFPy, neuron
 
 
 def get_templatename(f):
     """
     Assess from hoc file the templatename being specified within
@@ -55,269 +50,269 @@
 
     Returns
     -------
     templatename : str
 
     """
     templatename = None
-    f = open("template.hoc", 'r')
+    f = open("template.hoc", "r")
     for line in f.readlines():
-        if 'begintemplate' in line.split():
+        if "begintemplate" in line.split():
             templatename = line.split()[-1]
             continue
     return templatename
 
 
 def compile_all_mechanisms(cell_folder, verbose=False):
-    """ Attempt to set up a folder with all unique mechanism *.mod files and 
+    """Attempt to set up a folder with all unique mechanism *.mod files and
         compile them all. assumes all cell models are in a folder 'cell_models'
-    
-    Parameters:
+
+    Parameters
     -----------
     cell_folder : str
         Path to cell folder
     """
     cell_folder = Path(cell_folder)
-    mod_folder = cell_folder / 'mods'
+    mod_folder = cell_folder / "mods"
     mod_folder.mkdir(exist_ok=True, parents=True)
 
-    neurons = [f for f in cell_folder.iterdir() if 'mods' not in str(f)
-               and not f.name.startswith('.')]
+    neurons = [f for f in cell_folder.iterdir() if "mods" not in str(f) and not f.name.startswith(".")]
 
     if verbose >= 1:
         print(neurons)
 
     for neuron in neurons:
-        for nmodl in (neuron / 'mechanisms').iterdir():
-            if nmodl.suffix == '.mod':
-                while not (cell_folder / 'mods' / nmodl.parts[-1]).is_file():
-                    if sys.platform == 'win32':
-                        _command = 'copy'
+        for nmodl in (neuron / "mechanisms").iterdir():
+            if nmodl.suffix == ".mod":
+                while not (cell_folder / "mods" / nmodl.parts[-1]).is_file():
+                    if sys.platform == "win32":
+                        _command = "copy"
                     else:
-                        _command = 'cp'
+                        _command = "cp"
                     if verbose >= 1:
                         print(f"{_command} {nmodl} {cell_folder / 'mods'}")
                     os.system(f"{_command} {nmodl} {cell_folder / 'mods'}")
     starting_dir = os.getcwd()
-    os.chdir(str(cell_folder / 'mods'))
-    os.system('nrnivmodl')
+    os.chdir(str(cell_folder / "mods"))
+    os.system("nrnivmodl")
     os.chdir(starting_dir)
 
 
 def return_bbp_cell(cell_folder, end_T, dt, start_T, verbose=0):
-    """ Function to load cell models
-    
-    Parameters:
-    -----------
+    """Function to load cell models
+
+    Parameters
+    ----------
     cell_folder : string
         Path to folder with the BBP cell model
     end_T : float
         Simulation length [ms]
     dt: float
         Time step of simulation [ms]
     start_T: float
         Simulation start time (recording starts at 0 ms)
 
-    Returns:
-    --------
+    Returns
+    -------
     cell : object
         LFPy cell object
     """
     LFPy, neuron = import_LFPy_neuron()
     neuron.h.load_file("stdrun.hoc")
     neuron.h.load_file("import3d.hoc")
 
     cwd = os.getcwd()
     os.chdir(cell_folder)
     if verbose >= 1:
         print(f"Simulating {cell_folder}")
 
-    neuron.load_mechanisms(str(Path(cell_folder).parent / 'mods'))
+    neuron.load_mechanisms(str(Path(cell_folder).parent / "mods"))
 
-    f = open("template.hoc", 'r')
+    f = open("template.hoc", "r")
     templatename = get_templatename(f)
     f.close()
 
-    f = open("biophysics.hoc", 'r')
+    f = open("biophysics.hoc", "r")
     biophysics = get_templatename(f)
     f.close()
 
-    f = open("morphology.hoc", 'r')
+    f = open("morphology.hoc", "r")
     morphology = get_templatename(f)
     f.close()
 
     # get synapses template name
     synapses_file = str(Path("synapses") / "synapses.hoc")
-    f = open(synapses_file, 'r')
+    f = open(synapses_file, "r")
     synapses = get_templatename(f)
     f.close()
 
-    neuron.h.load_file('constants.hoc')
+    neuron.h.load_file("constants.hoc")
     if not hasattr(neuron.h, morphology):
         neuron.h.load_file(1, "morphology.hoc")
 
     if not hasattr(neuron.h, biophysics):
         neuron.h.load_file(1, "biophysics.hoc")
 
     if not hasattr(neuron.h, synapses):
         # load synapses
         neuron.h.load_file(1, synapses_file)
 
     if not hasattr(neuron.h, templatename):
         neuron.h.load_file(1, "template.hoc")
 
-    morphologyfile = [f for f in Path('morphology').iterdir()][0]
+    morphologyfile = [f for f in Path("morphology").iterdir()][0]
 
     # Instantiate the cell(s) using LFPy
-    cell = LFPy.TemplateCell(morphology=str(morphologyfile),
-                             templatefile=str(Path('template.hoc').absolute()),
-                             templatename=templatename,
-                             templateargs=0,
-                             tstop=end_T,
-                             tstart=start_T,
-                             dt=dt,
-                             v_init=-70,
-                             pt3d=True,
-                             delete_sections=True,
-                             verbose=True)
+    cell = LFPy.TemplateCell(
+        morphology=str(morphologyfile),
+        templatefile=str(Path("template.hoc").absolute()),
+        templatename=templatename,
+        templateargs=0,
+        tstop=end_T,
+        tstart=start_T,
+        dt=dt,
+        v_init=-70,
+        pt3d=True,
+        delete_sections=True,
+        verbose=True,
+    )
 
     os.chdir(cwd)
     return cell
 
 
 def return_bbp_cell_morphology(cell_name, cell_folder, pt3d=False):
-    """ Function to load cell models
+    """Function to load cell models
 
-    Parameters:
-    -----------
+    Parameters
+    ----------
     cell_name : string
         Name of the cell type.
     cell_folder : string
         Folder containing cell models.
     pt3d : bool
         If True detailed 3d morphology is used
 
-    Returns:
-    --------
+    Returns
+    -------
     cell : object
         LFPy cell object
     """
     LFPy, neuron = import_LFPy_neuron()
     cell_folder = Path(cell_folder)
 
     if not (cell_folder / cell_name).is_dir():
-        raise NotImplementedError(
-            f'Cell model {cell_name} is not found in {cell_folder}')
+        raise NotImplementedError(f"Cell model {cell_name} is not found in {cell_folder}")
 
-    morphology_files = [f for f in (
-        cell_folder / cell_name / 'morphology').iterdir()]
+    morphology_files = [f for f in (cell_folder / cell_name / "morphology").iterdir()]
     if len(morphology_files) > 1:
-        raise Exception(
-            f"More than 1 morphology file found for cell {cell_name}")
+        raise Exception(f"More than 1 morphology file found for cell {cell_name}")
     morphology = morphology_files[0]
 
     cell = LFPy.Cell(morphology=str(morphology), pt3d=pt3d)
     return cell
 
 
 def find_spike_idxs(v, thresh=-30, find_max=30):
-    """ Find spike indices
-    
-    Parameters:
-    -----------
+    """Find spike indices
+
+    Parameters
+    ----------
     v: array_like
         Membrane potential
     thresh: float (optional, default = -30)
         Threshold for spike detections
     find_max: int
         Number of sample to find spike maximum after detection crossing
 
-    Returns:
-    --------
+    Returns
+    -------
     spikes : array_like
         Indices of spike peaks in the positive direction, i.e. spikes
     """
-    spikes_th = [idx for idx in range(
-        len(v) - 1) if v[idx] < thresh < v[idx + 1]]
+    spikes_th = [idx for idx in range(len(v) - 1) if v[idx] < thresh < v[idx + 1]]
     spikes = []
     for sp in spikes_th:
-        max_idx = np.argmax(v[sp:sp + find_max])
+        max_idx = np.argmax(v[sp : sp + find_max])
         spikes.append(sp + max_idx)
     return spikes
 
 
 def set_input(weight, dt, T, cell, delay, stim_length):
-    """ Set current input synapse in soma
-    
-    Parameters:
-    -----------
+    """Set current input synapse in soma
+
+    Parameters
+    ----------
     weight : float
         Strength of input current [nA]
     dt : float
         Time step of simulation [ms]
     T : float
         Total simulation time [ms]
     cell : object
         Cell object from LFPy
     delay : float
         Delay for input,i.e. when to start the input [ms]
     stim_length: float
         Duration of injected current [ms]
-    
-    Returns:
-    --------
+
+    Returns
+    -------
     noiseVec :  NEURON vector
         NEURON vector of input current
     cell : object
         LFPy cell object
     synapse : NEURON synapse
         NEURON synapse object
     """
     import neuron
+
     tot_ntsteps = int(round(T / dt + 1))
 
     I = np.ones(tot_ntsteps) * weight
     # I[stim_idxs] = weight
     noiseVec = neuron.h.Vector(I)
     syn = None
     for sec in cell.allseclist:
-        if 'soma' in sec.name():
+        if "soma" in sec.name():
             # syn = neuron.h.ISyn(0.5, sec=sec)
             syn = neuron.h.IClamp(0.5, sec=sec)
     syn.dur = stim_length
     syn.delay = delay  # cell.tstartms
     noiseVec.play(syn._ref_amp, dt)
 
     return noiseVec, cell, syn
 
 
-def run_cell_model(cell_model_folder, verbose=False, sim_folder=None, save=True, return_vi=False,
-                   custom_return_cell_function=None, **kwargs):
-    """ Run simulation and adjust input strength to have a certain number of
-        spikes (target_spikes[0] < num_spikes <= target_spikes[1]
-        where target_spikes=[10,30] by default)
+def run_cell_model(
+    cell_model_folder, verbose=False, sim_folder=None, save=True, custom_return_cell_function=None, **kwargs
+):
+    """
+    Run simulation and adjust input strength to have a certain number of
+    spikes (target_spikes[0] < num_spikes <= target_spikes[1]
+    where target_spikes=[10,30] by default)
 
-    Parameters:
-    -----------
+    Parameters
+    ----------
     cell_model_folder : string
         Path to folder where cell model is saved.
     verbose : int
         If 1, output is verbose
     save : bool
         If True, currents and membrane potentials are saved in 'sim_folder'. If False the function returns the simulated
         cell, the soma potentials of the spikes, and the transmembrane currents of the spikes
     sim_folder : string
         Data directory for transmembrane currents and membrane potential of the neuron.
     custom_return_cell_function : function
         Python function to to return an LFPy cell from the cell_model_folder
     **kwargs : keyword arguments
         Kwargs must include: 'sim_time', 'dt', 'delay', 'weights', 'target_spikes', 'cut_out', 'seed'
 
-    Returns:
-    --------
+    Returns
+    -------
     cell : object
         LFPy cell object (if save is False)
     v : np.array
         Array (N_spikes x t) with soma membrane potential (if save is False)
     i : np.array
         Array (N_spikes x N_compartments x t) with transmembrane currents (if save is False)
 
@@ -327,162 +322,106 @@
         sim_folder = Path(sim_folder)
 
     if custom_return_cell_function is None:
         return_function = return_bbp_cell
     else:
         return_function = custom_return_cell_function
 
+    intra_params = kwargs
+
     if save:
         assert sim_folder is not None, "Specify 'save_sim_folder' argument!"
         sim_folder.mkdir(exist_ok=True, parents=True)
 
-        imem_files = [f for f in sim_folder.iterdir() if 'imem' in f.name]
-        vmem_files = [f for f in sim_folder.iterdir() if 'vmem' in f.name]
-
-        if not (np.any([cell_name in ifile.name for ifile in imem_files]) and
-                np.any([cell_name in vfile.name for vfile in vmem_files])):
-            np.random.seed(kwargs['seed'])
-            T = kwargs['sim_time'] * 1000
-            dt = kwargs['dt']
-            cell = return_function(
-                cell_model_folder, end_T=T, dt=dt, start_T=0)
-
-            delay = kwargs['delay']
-            stim_length = T - delay
-            weights = kwargs['weights']
-            weight = weights[0]
-            target_spikes = kwargs['target_spikes']
-            cuts = kwargs['cut_out']
-            cut_out = [int(cuts[0] / dt), int(cuts[1] / dt)]
-
-            num_spikes = 0
-
-            i = 0
-            while not target_spikes[0] < num_spikes <= target_spikes[1]:
-                noiseVec, cell, syn = set_input(
-                    weight, dt, T, cell, delay, stim_length)
-                cell.simulate(rec_imem=True)
-
-                t = cell.tvec
-                v = cell.somav
-                t = t
-                v = v
-
-                spikes = find_spike_idxs(v[cut_out[0]:-cut_out[1]])
-                spikes = list(np.array(spikes) + cut_out[0])
-                num_spikes = len(spikes)
-
-                if verbose >= 1:
-                    print(f"Input weight: {weight} - Num Spikes: {num_spikes}")
-                if num_spikes >= target_spikes[1]:
-                    weight *= weights[0]
-                elif num_spikes <= target_spikes[0]:
-                    weight *= weights[1]
-
-                i += 1
-                if i >= 10:
-                    sys.exit()
-
-            t = t[0:(cut_out[0] + cut_out[1])] - t[cut_out[0]]
-            # discard first spike
-            i_spikes = np.zeros((num_spikes - 1, cell.totnsegs, len(t)))
-            v_spikes = np.zeros((num_spikes - 1, len(t)))
-
-            for idx, spike_idx in enumerate(spikes[1:]):
-                spike_idx = int(spike_idx)
-                v_spike = v[spike_idx - cut_out[0]:spike_idx + cut_out[1]]
-                i_spike = cell.imem[:, spike_idx -
-                                    cut_out[0]:spike_idx + cut_out[1]]
-                i_spikes[idx, :, :] = i_spike
-                v_spikes[idx, :] = v_spike
-
-            sim_folder.mkdir(exist_ok=True, parents=True)
-            np.save(
-                str(sim_folder / f'imem_{num_spikes - 1}_{cell_name}.npy'), i_spikes)
-            np.save(
-                str(sim_folder / f'vmem_{num_spikes - 1}_{cell_name}.npy'), v_spikes)
-
-        else:
-            if verbose >= 1:
-                print(
-                    '\n\n\nCell has already be simulated. Using stored membrane currents\n\n\n')
+        imem_names = [f.name for f in sim_folder.iterdir() if "imem" in f.name]
+        vmem_names = [f.name for f in sim_folder.iterdir() if "vmem" in f.name]
     else:
-        np.random.seed(kwargs['seed'])
-        T = kwargs['sim_time'] * 1000
-        dt = kwargs['dt']
+        imem_names = []
+        vmem_names = []
+
+    if not (
+        np.any([cell_name in iname for iname in imem_names]) and np.any([cell_name in vname for vname in vmem_names])
+    ):
+        np.random.seed(intra_params["seed"])
+        T = intra_params["sim_time"] * 1000
+        dt = intra_params["dt"]
         cell = return_function(cell_model_folder, end_T=T, dt=dt, start_T=0)
 
-        delay = kwargs['delay']
+        delay = intra_params["delay"]
         stim_length = T - delay
-        weights = kwargs['weights']
+        weights = intra_params["weights"]
         weight = weights[0]
-        target_spikes = kwargs['target_spikes']
-        cuts = kwargs['cut_out']
+        target_spikes = intra_params["target_spikes"]
+        cuts = intra_params["cut_out"]
         cut_out = [int(cuts[0] / dt), int(cuts[1] / dt)]
 
         num_spikes = 0
 
         i = 0
         while not target_spikes[0] < num_spikes <= target_spikes[1]:
-            noiseVec, cell, syn = set_input(
-                weight, dt, T, cell, delay, stim_length)
+            noiseVec, cell, syn = set_input(weight, dt, T, cell, delay, stim_length)
             cell.simulate(rec_imem=True)
 
             t = cell.tvec
             v = cell.somav
             t = t
             v = v
 
-            spikes = find_spike_idxs(v[cut_out[0]:-cut_out[1]])
+            spikes = find_spike_idxs(v[cut_out[0] : -cut_out[1]])
             spikes = list(np.array(spikes) + cut_out[0])
             num_spikes = len(spikes)
 
             if verbose >= 1:
                 print(f"Input weight: {weight} - Num Spikes: {num_spikes}")
             if num_spikes >= target_spikes[1]:
                 weight *= weights[0]
             elif num_spikes <= target_spikes[0]:
                 weight *= weights[1]
 
             i += 1
             if i >= 10:
                 sys.exit()
 
-        t = t[0:(cut_out[0] + cut_out[1])] - t[cut_out[0]]
+        t = t[0 : (cut_out[0] + cut_out[1])] - t[cut_out[0]]
         # discard first spike
         i_spikes = np.zeros((num_spikes - 1, cell.totnsegs, len(t)))
         v_spikes = np.zeros((num_spikes - 1, len(t)))
 
         for idx, spike_idx in enumerate(spikes[1:]):
             spike_idx = int(spike_idx)
-            v_spike = v[spike_idx - cut_out[0]:spike_idx + cut_out[1]]
-            i_spike = cell.imem[:, spike_idx -
-                                cut_out[0]:spike_idx + cut_out[1]]
+            v_spike = v[spike_idx - cut_out[0] : spike_idx + cut_out[1]]
+            i_spike = cell.imem[:, spike_idx - cut_out[0] : spike_idx + cut_out[1]]
             i_spikes[idx, :, :] = i_spike
             v_spikes[idx, :] = v_spike
-
-        return cell, v_spikes, i_spikes
+        if save:
+            np.save(str(sim_folder / f"imem_{num_spikes - 1}_{cell_name}.npy"), i_spikes)
+            np.save(str(sim_folder / f"vmem_{num_spikes - 1}_{cell_name}.npy"), v_spikes)
+        else:
+            return cell, v_spikes, i_spikes
+    else:
+        if verbose >= 1:
+            print("\n\n\nCell has already be simulated. Using stored membrane currents\n\n\n")
 
 
 def calculate_extracellular_potential(cell, mea, ncontacts=10, position=None, rotation=None):
-    '''
+    """
     Calculates extracellular signal in uV on MEA object.
 
     Parameters
     ----------
     cell : LFPy Cell
         The simulated cell
     mea : MEA, str, or dict
         Mea object from MEAutility, string with probe name, or dict with probe info
 
     Returns
     -------
     v_ext : np.array
         Extracellular potential computed on the electrodes (n_elec, n_timestamps)
-    '''
+    """
     LFPy, neuron = import_LFPy_neuron()
 
     if isinstance(mea, str):
         mea_obj = mu.return_mea(mea)
     elif isinstance(mea, dict):
         mea_obj = mu.return_mea(info=mea)
     elif isinstance(mea, mu.core.MEA):
@@ -504,31 +443,41 @@
         cell.set_rotation(x=rotation[0], y=rotation[1], z=rotation[2])
 
     lfp = electrodes.get_transformation_matrix() @ cell.imem
 
     # Reverse rotation to bring cell back into initial rotation state
     if rotation is not None:
         rev_rot = [-r for r in rotation]
-        cell.set_rotation(rev_rot[0], rev_rot[1],
-                          rev_rot[2], rotation_order='zyx')
+        cell.set_rotation(rev_rot[0], rev_rot[1], rev_rot[2], rotation_order="zyx")
 
     return 1000 * lfp
 
 
-def calc_extracellular(i, cell_model_folder, load_sim_folder, save_sim_folder=None, seed=0,
-                       verbose=0, position=None,
-                       custom_return_cell_function=None, cell_locations=None,
-                       cell_rotations=None, save=True, max_iterations=1000,
-                       timeout=300, **kwargs):
+def calc_extracellular(
+    i,
+    cell_model_folder,
+    load_sim_folder,
+    save_sim_folder=None,
+    seed=0,
+    verbose=0,
+    position=None,
+    custom_return_cell_function=None,
+    cell_locations=None,
+    cell_rotations=None,
+    save=True,
+    max_iterations=1000,
+    timeout=300,
+    **kwargs,
+):
     """
     Loads data from previous cell simulation, and use results to generate
     arbitrary number of spikes above a certain noise level.
 
-    Parameters:
-    -----------
+    Parameters
+    ----------
     i: int
         Index of cell model
     cell_model_folder : string
         Path to folder where cell model is saved.
     model_type : string
         Cell model type (e.g. 'bbp')
     load_sim_folder : string
@@ -549,78 +498,74 @@
     timeout : int
         Set the timeout in seconds for finding spikes over min_amp. Default 300
     max_iterations : int
         Set the maximum number of iterations for finding spikes over min_amp. Default 1000
     **kwargs: keyword arguments
         Template generation parameters (use mr.get_default_template_parameters() to retrieve the arguments)
 
-    Returns:
-    --------
-        nothing, but saves the result
     """
     LFPy, neuron = import_LFPy_neuron()
-    
+
     for sec in neuron.h.allsec():
-        neuron.h("%s{delete_section()}"%sec.name())
-    
+        neuron.h("%s{delete_section()}" % sec.name())
+
     cell_model_folder = Path(cell_model_folder)
     cell_name = cell_model_folder.parts[-1]
     cell_save_name = cell_name
     load_sim_folder = Path(load_sim_folder)
     if verbose >= 1:
         print(f"Seed = {seed + i}")
     np.random.seed(seed + i)
 
-    T = kwargs['sim_time'] * 1000
-    dt = kwargs['dt']
-    rotation = kwargs['rot']
-    nobs = kwargs['n']
-    ncontacts = kwargs['ncontacts']
-    overhang = kwargs['overhang']
-    x_lim = kwargs['xlim']
-    y_lim = kwargs['ylim']
-    z_lim = kwargs['zlim']
-    x_distr = kwargs['x_distr']
-    beta_distr_params = kwargs['beta_distr_params']
-    min_amp = kwargs['min_amp']
-    MEAname = kwargs['probe']
-    drifting = kwargs['drifting']
+    T = kwargs["sim_time"] * 1000
+    dt = kwargs["dt"]
+    rotation = kwargs["rot"]
+    nobs = kwargs["n"]
+    ncontacts = kwargs["ncontacts"]
+    overhang = kwargs["overhang"]
+    x_lim = kwargs["xlim"]
+    y_lim = kwargs["ylim"]
+    z_lim = kwargs["zlim"]
+    x_distr = kwargs["x_distr"]
+    beta_distr_params = kwargs["beta_distr_params"]
+    min_amp = kwargs["min_amp"]
+    check_shape = kwargs["check_eap_shape"]
+    MEAname = kwargs["probe"]
+    drifting = kwargs["drifting"]
 
     if drifting:
-        max_drift = kwargs['max_drift']
-        min_drift = kwargs['min_drift']
-        drift_steps = kwargs['drift_steps']
-        drift_x_lim = kwargs['drift_xlim']
-        drift_y_lim = kwargs['drift_ylim']
-        drift_z_lim = kwargs['drift_zlim']
-        check_for_drift_amp = kwargs['check_for_drift_amp']
-        drift_within_bounds = kwargs['drift_within_bounds']
-
-    if 'timeout' in kwargs:
-        timeout = kwargs.get('timeout')
-    if 'max_iterations' in kwargs:
-        max_iterations = kwargs.get('max_iterations')
+        max_drift = kwargs["max_drift"]
+        min_drift = kwargs["min_drift"]
+        drift_steps = kwargs["drift_steps"]
+        drift_x_lim = kwargs["drift_xlim"]
+        drift_y_lim = kwargs["drift_ylim"]
+        drift_z_lim = kwargs["drift_zlim"]
+        check_for_drift_amp = kwargs["check_for_drift_amp"]
+        drift_within_bounds = kwargs["drift_within_bounds"]
+
+    if "timeout" in kwargs:
+        timeout = kwargs.get("timeout")
+    if "max_iterations" in kwargs:
+        max_iterations = kwargs.get("max_iterations")
 
     if custom_return_cell_function is None:
         return_function = return_bbp_cell
-        model_type = 'bbp'
+        model_type = "bbp"
     else:
         return_function = custom_return_cell_function
-        model_type = 'custom'
+        model_type = "custom"
 
-    cuts = kwargs['cut_out']
+    cuts = kwargs["cut_out"]
     cut_out = [int(cuts[0] / dt), int(cuts[1] / dt)]
 
     cell = return_function(cell_model_folder, end_T=T, dt=dt, start_T=0)
 
     # Load data from previous cell simulation
-    imem_file = [f for f in load_sim_folder.iterdir(
-    ) if cell_name in f.name and 'imem' in f.name][0]
-    vmem_file = [f for f in load_sim_folder.iterdir(
-    ) if cell_name in f.name and 'vmem' in f.name][0]
+    imem_file = [f for f in load_sim_folder.iterdir() if cell_name in f.name and "imem" in f.name][0]
+    vmem_file = [f for f in load_sim_folder.iterdir() if cell_name in f.name and "vmem" in f.name][0]
     i_spikes = np.load(str(imem_file))
     v_spikes = np.load(str(vmem_file))
     cell.tvec = np.arange(i_spikes.shape[-1]) * dt
 
     saved_eaps = []
     saved_positions = []
     saved_rotations = []
@@ -630,49 +575,47 @@
     elinfo = mu.return_mea_info(electrode_name=MEAname)
 
     # Create save folder
     if save:
         assert save_sim_folder is not None, "Specify 'save_sim_folder' argument!"
         save_sim_folder = Path(save_sim_folder)
         sim_folder = save_sim_folder / rotation
-        save_folder = sim_folder / f'tmp_{target_num_spikes}_{MEAname}'
+        save_folder = sim_folder / f"tmp_{target_num_spikes}_{MEAname}"
         save_folder.mkdir(exist_ok=True, parents=True)
 
     if verbose >= 1:
-        print(f'Cell {cell_save_name} extracellular spikes to be simulated')
+        print(f"Cell {cell_save_name} extracellular spikes to be simulated")
 
     mea = mu.return_mea(MEAname)
     if ncontacts > 1:
         electrodes = LFPy.RecExtElectrode(cell, probe=mea, n=ncontacts)
     else:
         electrodes = LFPy.RecExtElectrode(cell, probe=mea)
     pos = mea.positions
     elec_x = pos[:, 0]
     elec_y = pos[:, 1]
     elec_z = pos[:, 2]
 
     if x_lim is None:
-        x_lim = [float(np.min(elec_x) - overhang),
-                 float(np.max(elec_x) + overhang)]
+        x_lim = [float(np.min(elec_x) - overhang), float(np.max(elec_x) + overhang)]
     if y_lim is None:
-        y_lim = [float(np.min(elec_y) - overhang),
-                 float(np.max(elec_y) + overhang)]
+        y_lim = [float(np.min(elec_y) - overhang), float(np.max(elec_y) + overhang)]
     if z_lim is None:
-        z_lim = [float(np.min(elec_z) - overhang),
-                 float(np.max(elec_z) + overhang)]
+        z_lim = [float(np.min(elec_z) - overhang), float(np.max(elec_z) + overhang)]
 
     # pre-simulate positions
     n_rand_positions = int(target_num_spikes * 1e5)
     print(f"Pre-generating {n_rand_positions} random positions")
 
-    if x_distr == 'uniform':
+    if x_distr == "uniform":
         x_rands = np.random.uniform(x_lim[0], x_lim[1], n_rand_positions)
     else:
-        x_rands = x_lim[0] + np.random.beta(beta_distr_params[0], beta_distr_params[1],
-                                            n_rand_positions) * (x_lim[1] - x_lim[0])
+        x_rands = x_lim[0] + np.random.beta(beta_distr_params[0], beta_distr_params[1], n_rand_positions) * (
+            x_lim[1] - x_lim[0]
+        )
     y_rands = np.random.uniform(y_lim[0], y_lim[1], n_rand_positions)
     z_rands = np.random.uniform(z_lim[0], z_lim[1], n_rand_positions)
 
     saved = 0
     i = 0
     tested_loc_idx = 0
     saved_amplitudes = []
@@ -681,293 +624,294 @@
         assert cell_rotations is not None, "If 'cell_locations' is not None, 'cell_rotations' should be given"
 
     if cell_locations is None:
         start_time = time.time()
         while len(saved_eaps) < target_num_spikes and tested_loc_idx < n_rand_positions:
             if i > max_iterations * target_num_spikes:
                 if verbose >= 1:
-                    print(
-                        f"Gave up finding spikes above noise level for {cell_name}")
+                    print(f"Gave up finding spikes above noise level for {cell_name}")
                 break
             # Each cell has several spikes to choose from
             spike_idx = np.random.randint(0, i_spikes.shape[0])
             cell.imem = i_spikes[spike_idx, :, :]
             cell.somav = v_spikes[spike_idx, :]
-            tested_pos = [x_rands[tested_loc_idx],
-                          y_rands[tested_loc_idx], 
-                          z_rands[tested_loc_idx]]
-
-            espikes, pos, rot, found_position = return_extracellular_spike(cell=cell, cell_name=cell_name,
-                                                                           model_type=model_type,
-                                                                           electrodes=electrodes,
-                                                                           limits=[
-                                                                               x_lim, y_lim, z_lim],
-                                                                           rotation=rotation,
-                                                                           saved_pos=saved_positions,
-                                                                           pos=tested_pos, verbose=False)
+            tested_pos = [x_rands[tested_loc_idx], y_rands[tested_loc_idx], z_rands[tested_loc_idx]]
+
+            espikes, pos, rot, found_position = return_extracellular_spike(
+                cell=cell,
+                cell_name=cell_name,
+                model_type=model_type,
+                electrodes=electrodes,
+                limits=[x_lim, y_lim, z_lim],
+                rotation=rotation,
+                saved_pos=saved_positions,
+                pos=tested_pos,
+                verbose=False,
+            )
             tested_loc_idx += 1
             if not found_position:
                 continue
 
             # Method of Images for semi-infinite planes
-            if elinfo['type'] == 'mea':
+            if elinfo["type"] == "mea":
                 espikes = espikes * 2
 
             if not drifting:
-                if check_espike(espikes, min_amp):
-                    skip = skip_duplicate(
-                        pos, saved_positions, drifting, verbose)
+                if check_espike(espikes, min_amp, check_shape):
+                    skip = skip_duplicate(pos, saved_positions, drifting, verbose)
                     if skip:
                         continue
 
                     espikes = center_espike(espikes, cut_out)
                     saved_eaps.append(espikes)
                     saved_positions.append(pos)
                     saved_rotations.append(rot)
                     if verbose >= 1:
-                        print(
-                            f'Cell: {cell_name} Progress: [{len(saved_eaps)}/{target_num_spikes}]')
+                        print(f"Cell: {cell_name} Progress: [{len(saved_eaps)}/{target_num_spikes}]")
                     saved += 1
             else:
-                if check_espike(espikes, min_amp):
+                if check_espike(espikes, min_amp, check_shape):
                     if verbose >= 2:
-                        print('template amplitude:', np.round(np.abs(np.min(espikes)), 1))
+                        print("template amplitude:", np.round(np.abs(np.min(espikes)), 1))
 
                     drift_ok = False
                     # fix rotation while drifting
                     cell.set_rotation(rot[0], rot[1], rot[2])
                     max_trials = 100
                     tr = 0
 
                     while not drift_ok and tr < max_trials:
                         init_pos = pos
                         # find drifting final position within drift limits
-                        x_rand = np.random.uniform(
-                            init_pos[0] + drift_x_lim[0], init_pos[0] + drift_x_lim[1])
-                        y_rand = np.random.uniform(
-                            init_pos[1] + drift_y_lim[0], init_pos[1] + drift_y_lim[1])
-                        z_rand = np.random.uniform(
-                            init_pos[2] + drift_z_lim[0], init_pos[2] + drift_z_lim[1])
+                        x_rand = np.random.uniform(init_pos[0] + drift_x_lim[0], init_pos[0] + drift_x_lim[1])
+                        y_rand = np.random.uniform(init_pos[1] + drift_y_lim[0], init_pos[1] + drift_y_lim[1])
+                        z_rand = np.random.uniform(init_pos[2] + drift_z_lim[0], init_pos[2] + drift_z_lim[1])
                         final_pos = [x_rand, y_rand, z_rand]
-                        drift_dist = np.linalg.norm(
-                            np.array(init_pos) - np.array(final_pos))
+                        drift_dist = np.linalg.norm(np.array(init_pos) - np.array(final_pos))
 
                         # check location and boundaries
                         if drift_within_bounds:
-                            if not (x_lim[0] < x_rand < x_lim[1] and y_lim[0] < y_rand < y_lim[1] and
-                                    z_lim[0] < z_rand < z_lim[1]):
+                            if not (
+                                x_lim[0] < x_rand < x_lim[1]
+                                and y_lim[0] < y_rand < y_lim[1]
+                                and z_lim[0] < z_rand < z_lim[1]
+                            ):
                                 if verbose == 2:
-                                    print(
-                                        f"Discarded for final drift position {cell_name}")
+                                    print(f"Discarded for final drift position {cell_name}")
                                 tr += 1
                                 continue
                         if max_drift >= drift_dist >= min_drift:
                             if check_for_drift_amp:
                                 # check final position spike amplitude
-                                espikes, pos, rot_, found_position = return_extracellular_spike(cell=cell,
-                                                                                                cell_name=cell_name,
-                                                                                                model_type=model_type,
-                                                                                                electrodes=electrodes,
-                                                                                                limits=[x_lim, y_lim,
-                                                                                                        z_lim],
-                                                                                                rotation=None,
-                                                                                                saved_pos=saved_positions,
-                                                                                                pos=final_pos)
+                                espikes, pos, rot_, found_position = return_extracellular_spike(
+                                    cell=cell,
+                                    cell_name=cell_name,
+                                    model_type=model_type,
+                                    electrodes=electrodes,
+                                    limits=[x_lim, y_lim, z_lim],
+                                    rotation=None,
+                                    saved_pos=saved_positions,
+                                    pos=final_pos,
+                                )
                                 if not found_position:
                                     continue
 
                                 # Method of Images for semi-infinite planes
-                                if elinfo['type'] == 'mea':
+                                if elinfo["type"] == "mea":
                                     espikes = espikes * 2
 
-                                if check_espike(espikes, min_amp):
+                                if check_espike(espikes, min_amp, check_shape):
                                     if verbose == 2:
-                                        print('Found final drifting position')
+                                        print("Found final drifting position")
                                     drift_ok = True
                                 else:
                                     tr += 1
                                     if verbose == 2:
-                                        print(
-                                            f"Discarded for final drift amplitude {cell_name}")
+                                        print(f"Discarded for final drift amplitude {cell_name}")
                                     continue
                             else:
                                 drift_ok = True
                         else:
                             tr += 1
                             if verbose == 2:
-                                print(
-                                    f"Discarded for drift distance {cell_name}")
+                                print(f"Discarded for drift distance {cell_name}")
 
                     # now compute drifting templates
                     if drift_ok:
                         drift_spikes = []
                         drift_pos = []
                         drift_dir = np.array(final_pos) - np.array(init_pos)
                         for i, dp in enumerate(np.linspace(0, 1, drift_steps)):
                             pos_drift = init_pos + dp * drift_dir
-                            espikes, pos, r_, found_position = return_extracellular_spike(cell=cell,
-                                                                                          cell_name=cell_name,
-                                                                                          model_type=model_type,
-                                                                                          electrodes=electrodes,
-                                                                                          limits=[
-                                                                                              x_lim, y_lim, z_lim],
-                                                                                          rotation=None,
-                                                                                          saved_pos=saved_positions,
-                                                                                          pos=pos_drift)
+                            espikes, pos, r_, found_position = return_extracellular_spike(
+                                cell=cell,
+                                cell_name=cell_name,
+                                model_type=model_type,
+                                electrodes=electrodes,
+                                limits=[x_lim, y_lim, z_lim],
+                                rotation=None,
+                                saved_pos=saved_positions,
+                                pos=pos_drift,
+                            )
                             if not found_position:
                                 continue
 
                             # Method of Images for semi-infinite planes
-                            if elinfo['type'] == 'mea':
+                            if elinfo["type"] == "mea":
                                 espikes = espikes * 2
                             espikes = center_espike(espikes, cut_out)
                             drift_spikes.append(espikes)
                             drift_pos.append(pos)
 
                         # reverse rotation
                         rev_rot = [-r for r in rot]
-                        cell.set_rotation(
-                            rev_rot[0], rev_rot[1], rev_rot[2], rotation_order='zyx')
+                        cell.set_rotation(rev_rot[0], rev_rot[1], rev_rot[2], rotation_order="zyx")
 
                         drift_spikes = np.array(drift_spikes)
                         drift_pos = np.array(drift_pos)
                         if verbose == 2:
-                            print(f'Drift done from {np.round(init_pos, 1)} to {np.round(final_pos, 1)} um'
-                                  f' with {drift_steps} steps')
+                            print(
+                                f"Drift done from {np.round(init_pos, 1)} to {np.round(final_pos, 1)} um"
+                                f" with {drift_steps} steps"
+                            )
 
                         amp = np.round(np.max(np.abs(drift_spikes[0])), 3)
 
                         saved_amplitudes.append(amp)
                         saved_eaps.append(drift_spikes)
                         saved_positions.append(drift_pos)
                         saved_rotations.append(rot)
                         if verbose >= 1:
-                            print(
-                                f'Cell: {cell_name} Progress: [{len(saved_eaps)}/{target_num_spikes}]')
+                            print(f"Cell: {cell_name} Progress: [{len(saved_eaps)}/{target_num_spikes}]")
                         saved += 1
                     else:
                         if verbose == 2:
-                            print(f'Discarded for trials {cell_name}')
+                            print(f"Discarded for trials {cell_name}")
                 else:
                     if verbose == 2:
                         print(f"Discarded for minimum amp {cell_name}")
                     pass
             i += 1
 
             if timeout is not None:
                 if time.time() - start_time > timeout:
                     if verbose >= 1:
-                        print(f"Timeout finding spikes above noise level for "
-                              f"{cell_name}, more than {timeout}")
+                        print(f"Timeout finding spikes above noise level for " f"{cell_name}, more than {timeout}")
                     break
 
     else:
         target_num_spikes = len(cell_locations)
-        for (loc, rot) in zip(cell_locations, cell_rotations):
+        for loc, rot in zip(cell_locations, cell_rotations):
             # Each cell has several spikes to choose from
             spike_idx = np.random.randint(0, i_spikes.shape[0])
             cell.imem = i_spikes[spike_idx, :, :]
             cell.somav = v_spikes[spike_idx, :]
             cell.set_rotation(rot[0], rot[1], rot[2])
 
             if not drifting:
                 if loc.ndim == 1:
                     pos = loc
                 elif loc.ndim == 1:
                     # take first drifting location
                     pos = loc[0]
 
-                espikes, pos_, rot_, found_position = return_extracellular_spike(cell=cell, cell_name=cell_name,
-                                                                                 model_type=model_type,
-                                                                                 electrodes=electrodes,
-                                                                                 limits=[
-                                                                                     x_lim, y_lim, z_lim],
-                                                                                 rotation=None,
-                                                                                 saved_pos=saved_positions,
-                                                                                 pos=pos)
+                espikes, pos_, rot_, found_position = return_extracellular_spike(
+                    cell=cell,
+                    cell_name=cell_name,
+                    model_type=model_type,
+                    electrodes=electrodes,
+                    limits=[x_lim, y_lim, z_lim],
+                    rotation=None,
+                    saved_pos=saved_positions,
+                    pos=pos,
+                )
                 if not found_position:
                     continue
 
                 # Method of Images for semi-infinite planes
-                if elinfo['type'] == 'mea':
+                if elinfo["type"] == "mea":
                     espikes = espikes * 2
 
                 espikes = center_espike(espikes, cut_out)
                 saved_eaps.append(espikes)
                 saved_positions.append(pos)
                 saved_rotations.append(rot)
             else:
                 assert loc.ndim == 2
                 drift_spikes = []
                 for pos_drift in loc:
-                    espikes, pos, r_, found_position = return_extracellular_spike(cell=cell, cell_name=cell_name,
-                                                                                  model_type=model_type,
-                                                                                  electrodes=electrodes,
-                                                                                  limits=[
-                                                                                      x_lim, y_lim, z_lim],
-                                                                                  rotation=None,
-                                                                                  saved_pos=saved_positions,
-                                                                                  pos=pos_drift)
+                    espikes, pos, r_, found_position = return_extracellular_spike(
+                        cell=cell,
+                        cell_name=cell_name,
+                        model_type=model_type,
+                        electrodes=electrodes,
+                        limits=[x_lim, y_lim, z_lim],
+                        rotation=None,
+                        saved_pos=saved_positions,
+                        pos=pos_drift,
+                    )
                     if not found_position:
                         continue
 
                     # Method of Images for semi-infinite planes
-                    if elinfo['type'] == 'mea':
+                    if elinfo["type"] == "mea":
                         espikes = espikes * 2
                     espikes = center_espike(espikes, cut_out)
                     drift_spikes.append(espikes)
 
                 saved_eaps.append(drift_spikes)
                 saved_positions.append(loc)
                 saved_rotations.append(rot)
 
             # reverse rotation
             rev_rot = [-r for r in rot]
-            cell.set_rotation(rev_rot[0], rev_rot[1],
-                              rev_rot[2], rotation_order='zyx')
+            cell.set_rotation(rev_rot[0], rev_rot[1], rev_rot[2], rotation_order="zyx")
 
             if verbose >= 1:
-                print(
-                    f'Cell: {cell_name} Progress: [{len(saved_eaps)}/{target_num_spikes}]')
+                print(f"Cell: {cell_name} Progress: [{len(saved_eaps)}/{target_num_spikes}]")
             saved += 1
         else:
             pass
 
     if verbose >= 1:
         print(f"Done generating EAPs for {cell_name}")
 
     saved_eaps = np.array(saved_eaps)
     saved_positions = np.array(saved_positions)
     saved_rotations = np.array(saved_rotations)
 
     if save:
-        np.save(str(save_folder / f'eap-{cell_save_name}'), saved_eaps)
-        np.save(str(save_folder / f'pos-{cell_save_name}'), saved_positions)
-        np.save(str(save_folder / f'rot-{cell_save_name}'), saved_rotations)
+        np.save(str(save_folder / f"eap-{cell_save_name}"), saved_eaps)
+        np.save(str(save_folder / f"pos-{cell_save_name}"), saved_positions)
+        np.save(str(save_folder / f"rot-{cell_save_name}"), saved_rotations)
     else:
         return saved_eaps, saved_positions, saved_rotations
 
 
-def check_espike(espikes, min_amp):
+def check_espike(espikes, min_amp, check_shape=True):
     """
     Check extracellular spike amplitude and shape (neg peak > pos peak)
 
     Parameters
     ----------
     espike: np.array
         EAP (n_elec, n_samples)
     min_amp: float
         Minimum amplitude
+    check_shape: bool
+        If True, it checks that the minimum peak is larger than the maximum peak
 
     Returns
     -------
     valid: bool
         If True EAP is valid
     """
-    if np.abs(np.min(espikes)) < min_amp or np.abs(np.min(espikes)) < np.abs(np.max(espikes)):
+    if np.abs(np.min(espikes)) < min_amp:
+        return False
+    elif check_shape and np.abs(np.min(espikes)) < np.abs(np.max(espikes)):
         return False
     else:
         return True
 
 
 def center_espike(espike, cut_out_samples, tol=1):
     """
@@ -991,29 +935,25 @@
     peak_idx = np.unravel_index(np.argmin(espike), espike.shape)[1]
 
     if np.abs(expexted_peak - peak_idx) >= tol:
         if expexted_peak - peak_idx < 0:
             diff = peak_idx - expexted_peak
             cent_espike = np.zeros_like(espike)
             cent_espike[:, :-diff] = espike[:, diff:]
-            cent_espike[:, -
-                        diff:] = np.tile(espike[:, -1, np.newaxis], [1, diff])
+            cent_espike[:, -diff:] = np.tile(espike[:, -1, np.newaxis], [1, diff])
         elif expexted_peak - peak_idx > 0:
             diff = expexted_peak - peak_idx
             cent_espike = np.zeros_like(espike)
             cent_espike[:, diff:] = espike[:, :-diff]
-            cent_espike[:, :diff] = np.tile(
-                espike[:, 0, np.newaxis], [1, diff])
+            cent_espike[:, :diff] = np.tile(espike[:, 0, np.newaxis], [1, diff])
     else:
         cent_espike = espike
 
-    cent_peak_idx = np.unravel_index(
-        np.argmin(cent_espike), cent_espike.shape)[1]
-    assert np.abs(
-        expexted_peak - cent_peak_idx) < tol, "Something went wrong in centering the spike"
+    cent_peak_idx = np.unravel_index(np.argmin(cent_espike), cent_espike.shape)[1]
+    assert np.abs(expexted_peak - cent_peak_idx) < tol, "Something went wrong in centering the spike"
 
     return cent_espike
 
 
 def skip_duplicate(pos, saved_positions, drifting, verbose=False):
     """
     Checks if a position has to be skipped because already used.
@@ -1039,262 +979,260 @@
         for pos_s in saved_positions:
             if not drifting:
                 test_pos = pos_s
             else:
                 test_pos = pos_s[0]
             if np.all(np.round(test_pos, 2) == np.round(pos, 2)):
                 if verbose >= 2:
-                    print(
-                        f"Duplicated position: {np.round(pos, 2)} -- {np.round(pos_s, 2)}. Skipping")
+                    print(f"Duplicated position: {np.round(pos, 2)} -- {np.round(pos_s, 2)}. Skipping")
                 skip_pos = True
     return skip_pos
 
 
 def get_physrot_specs(cell_name, model):
-    """  Return physrot specifications for cell types
+    """Return physrot specifications for cell types
 
-    Parameters:
+    Parameters
     -----------
     cell_name : string
         The name of the cell.
-    Returns:
+    Returns
     --------
     polarlim : array_like
         lower and upper bound for the polar angle
     pref_orient : array_like
         3-dim vetor of preferred orientation
     """
-    if model == 'bbp':
-        polarlim = {'BP': [0., 15.],
-                    'AC': None,
-                    'BTC': None,  # [0.,15.],
-                    'ChC': None,  # [0.,15.],
-                    'DBC': None,  # [0.,15.],
-                    'LBC': None,  # [0.,15.],
-                    'MC': [0., 15.],
-                    'NBC': None,
-                    'NGC': None,
-                    'SBC': None,
-                    'PC': [0., 15.],
-                    'SS': [0., 15.],
-                    'SP': [0., 15.]}
+    if model == "bbp":
+        polarlim = {
+            "BP": [0.0, 15.0],
+            "AC": None,
+            "BTC": None,  # [0.,15.],
+            "ChC": None,  # [0.,15.],
+            "DBC": None,  # [0.,15.],
+            "LBC": None,  # [0.,15.],
+            "MC": [0.0, 15.0],
+            "NBC": None,
+            "NGC": None,
+            "SBC": None,
+            "PC": [0.0, 15.0],
+            "SS": [0.0, 15.0],
+            "SP": [0.0, 15.0],
+        }
         # how it's implemented, the NMC y axis points into the pref_orient direction after rotation
-        pref_orient = {'BP': [0., 0., 1.],
-                       'AC': None,
-                       'BTC': None,  # [0.,0.,1.],
-                       'ChC': None,  # [0.,0.,1.],
-                       'DBC': None,  # [0.,0.,1.],
-                       'LBC': None,  # [0.,0.,1.],
-                       'MC': [0., 0., 1.],
-                       'NBC': None,
-                       'NGC': None,
-                       'SBC': None,
-                       'PC': [0., 0., 1.],
-                       'SS': [0., 0., 1.],
-                       'SP': [0., 0., 1.]}
+        pref_orient = {
+            "BP": [0.0, 0.0, 1.0],
+            "AC": None,
+            "BTC": None,  # [0.,0.,1.],
+            "ChC": None,  # [0.,0.,1.],
+            "DBC": None,  # [0.,0.,1.],
+            "LBC": None,  # [0.,0.,1.],
+            "MC": [0.0, 0.0, 1.0],
+            "NBC": None,
+            "NGC": None,
+            "SBC": None,
+            "PC": [0.0, 0.0, 1.0],
+            "SS": [0.0, 0.0, 1.0],
+            "SP": [0.0, 0.0, 1.0],
+        }
         polar = None
         orient = None
         for k in polarlim.keys():
-            if k in cell_name.split('_')[1]:
+            if k in cell_name.split("_")[1]:
                 polar = polarlim[k]
                 orient = pref_orient[k]
                 break
         return polar, orient
     else:
-        raise NotImplementedError('Cell model %s is not implemented' % model)
+        raise NotImplementedError("Cell model %s is not implemented" % model)
 
 
-def return_extracellular_spike(cell, cell_name, model_type,
-                               electrodes, limits, rotation, saved_pos, pos=None,
-                               max_iter=1000, verbose=False):
+def return_extracellular_spike(
+    cell, cell_name, model_type, electrodes, limits, rotation, saved_pos, pos=None, max_iter=1000, verbose=False
+):
     """
     Calculate extracellular spike on MEA at random position relative to cell
 
-    Parameters:
-    -----------
+    Parameters
+    ----------
     cell: LFPy.Cell
         cell object from LFPy
     cell_name: string
         name of cell model
     electrodes: LFPyRecExtElectrode
         The LFPy electrode object
     limits: array_like
         boundaries for neuron locations, shape=(3,2)
-    rotation: string 
+    rotation: string
         random rotation to apply to the neuron ('Norot', '3drot', 'physrot')
     saved_pos: np.array
         List of positions already used to be skipped
     pos: array_like, (optional, default None)
         Can be used to set the cell soma to a specific position. If ``None``,
         the random position is used.
     max_iter: int
         Max number of iterations to find a position that hasn't been used yet
 
-    Returns:
-    --------
+    Returns
+    -------
     Extracellular spike for each MEA contact site
     """
 
     def get_xyz_angles(R):
-        """ Get rotation angles for each axis from rotation matrix
+        """Get rotation angles for each axis from rotation matrix
 
         Parameters;
         -----------
         R : matrix
             3x3 rotation matrix
 
-        Returns:
+        Returns
         --------
         R_z : float
         R_y : float
         R_x : float
             Three angles for rotations around axis, defined by R = R_z.R_y.R_x
         """
         rot_x = np.arctan2(R[2, 1], R[2, 2])
         rot_y = np.arcsin(-R[2, 0])
         rot_z = np.arctan2(R[1, 0], R[0, 0])
         return rot_x, rot_y, rot_z
 
     def get_rnd_rot_Arvo():
-        """ Generate uniformly distributed random rotation matrices
+        """Generate uniformly distributed random rotation matrices
         see: 'Fast Random Rotation Matrices' by Arvo (1992)
-        
-        Returns:
+
+        Returns
         --------
         R : 3x3 matrix
             random rotation matrix
         """
-        gamma = np.random.uniform(0, 2. * np.pi)
-        rotation_z = np.matrix([[np.cos(gamma), -np.sin(gamma), 0],
-                                [np.sin(gamma), np.cos(gamma), 0],
-                                [0, 0, 1]])
+        gamma = np.random.uniform(0, 2.0 * np.pi)
+        rotation_z = np.matrix([[np.cos(gamma), -np.sin(gamma), 0], [np.sin(gamma), np.cos(gamma), 0], [0, 0, 1]])
         x = np.random.uniform(size=2)
-        v = np.array([np.cos(2. * np.pi * x[0]) * np.sqrt(x[1]),
-                      np.sin(2. * np.pi * x[0]) * np.sqrt(x[1]),
-                      np.sqrt(1 - x[1])])
-        H = np.identity(3) - 2. * np.outer(v, v)
+        v = np.array(
+            [np.cos(2.0 * np.pi * x[0]) * np.sqrt(x[1]), np.sin(2.0 * np.pi * x[0]) * np.sqrt(x[1]), np.sqrt(1 - x[1])]
+        )
+        H = np.identity(3) - 2.0 * np.outer(v, v)
         M = -np.dot(H, rotation_z)
         return M
 
     def check_solidangle(matrix, pre, post, polarlim):
-        """ Check whether a matrix rotates the vector 'pre' into a region
+        """Check whether a matrix rotates the vector 'pre' into a region
             defined by 'polarlim' around the vector 'post'
 
-        Parameters:
+        Parameters
         -----------
         matrix : matrix
             3x3 rotation matrix
         pre : array_like
             3-dim vector to be rotated
         post : array_like
             axis of the cones defining the post-rotation region
         polarlim : [float,float]
-            Angles specifying the opening of the inner and outer cone 
+            Angles specifying the opening of the inner and outer cone
             (aperture = 2*polarlim),
-            i.e. the angle between rotated pre vector and post vector has to ly 
-            within these polar limits.  
+            i.e. the angle between rotated pre vector and post vector has to ly
+            within these polar limits.
 
-        Returns:
+        Returns
         --------
         test : bool
             True if the vector np.dot(matrix,pre) lies inside the specified region.
         """
         postest = np.dot(matrix, pre)
-        c = np.dot(post / np.linalg.norm(post),
-                   postest / np.linalg.norm(postest))
+        c = np.dot(post / np.linalg.norm(post), postest / np.linalg.norm(postest))
         if np.cos(np.deg2rad(polarlim[1])) <= c <= np.cos(np.deg2rad(polarlim[0])):
             return True
         else:
             return False
 
     # rotate neuron
-    if rotation == 'norot':
-        if model_type == 'bbp':
+    if rotation == "norot":
+        if model_type == "bbp":
             # orientate cells in z direction
-            x_rot_offset = np.pi / 2.
+            x_rot_offset = np.pi / 2.0
             y_rot_offset = 0
             z_rot_offset = 0
         else:
             x_rot_offset = 0
             y_rot_offset = 0
             z_rot_offset = 0
         x_rot = x_rot_offset
         y_rot = y_rot_offset
         z_rot = z_rot_offset
-    elif rotation == 'xrot':
-        if model_type == 'bbp':
+    elif rotation == "xrot":
+        if model_type == "bbp":
             # orientate cells in z direction
-            x_rot_offset = np.pi / 2.
+            x_rot_offset = np.pi / 2.0
             y_rot_offset = 0
             z_rot_offset = 0
         else:
             x_rot_offset = 0
             y_rot_offset = 0
             z_rot_offset = 0
         x_rot, _, _ = get_xyz_angles(np.array(get_rnd_rot_Arvo()))
         x_rot = x_rot + x_rot_offset
         y_rot = y_rot_offset
         z_rot = z_rot_offset
-    elif rotation == 'yrot':
-        if model_type == 'bbp':
+    elif rotation == "yrot":
+        if model_type == "bbp":
             # orientate cells in z direction
-            x_rot_offset = np.pi / 2.
+            x_rot_offset = np.pi / 2.0
             y_rot_offset = 0
             z_rot_offset = 0
         else:
             x_rot_offset = 0
             y_rot_offset = 0
             z_rot_offset = 0
         _, y_rot, _ = get_xyz_angles(np.array(get_rnd_rot_Arvo()))
         x_rot = x_rot_offset
         y_rot = y_rot + y_rot_offset
         z_rot = z_rot_offset
-    elif rotation == 'zrot':
-        if model_type == 'bbp':
+    elif rotation == "zrot":
+        if model_type == "bbp":
             # orientate cells in z direction
-            x_rot_offset = np.pi / 2.
+            x_rot_offset = np.pi / 2.0
             y_rot_offset = 0
             z_rot_offset = 0
         else:
             x_rot_offset = 0
             y_rot_offset = 0
             z_rot_offset = 0
         _, _, z_rot = get_xyz_angles(np.array(get_rnd_rot_Arvo()))
         x_rot = x_rot_offset
         y_rot = y_rot_offset
         z_rot = z_rot + z_rot_offset
-    elif rotation == '3drot':
-        if model_type == 'bbp':
-            x_rot_offset = np.pi / 2.  # align neuron with z axis
+    elif rotation == "3drot":
+        if model_type == "bbp":
+            x_rot_offset = np.pi / 2.0  # align neuron with z axis
             y_rot_offset = 0  # align neuron with z axis
             z_rot_offset = 0  # align neuron with z axis
         else:
             x_rot_offset = 0
             y_rot_offset = 0
             z_rot_offset = 0
         x_rot, y_rot, z_rot = get_xyz_angles(np.array(get_rnd_rot_Arvo()))
         x_rot = x_rot + x_rot_offset
         y_rot = y_rot + y_rot_offset
         z_rot = z_rot + z_rot_offset
-    elif rotation == 'physrot':
+    elif rotation == "physrot":
         polarlim, pref_orient = get_physrot_specs(cell_name, model_type)
-        if model_type == 'bbp':
-            x_rot_offset = np.pi / 2.  # align neuron with z axis
+        if model_type == "bbp":
+            x_rot_offset = np.pi / 2.0  # align neuron with z axis
             y_rot_offset = 0  # align neuron with z axis
             z_rot_offset = 0  # align neuron with z axis
         else:
-            raise NotImplementedError(
-                "'physrot' rotation is only available with BBP cells")
+            raise NotImplementedError("'physrot' rotation is only available with BBP cells")
         while True:
             R = np.array(get_rnd_rot_Arvo())
             if polarlim is None or pref_orient is None:
                 valid = True
             else:
-                valid = check_solidangle(
-                    R, [0., 0., 1.], pref_orient, polarlim)
+                valid = check_solidangle(R, [0.0, 0.0, 1.0], pref_orient, polarlim)
             if valid:
                 x_rot, y_rot, z_rot = get_xyz_angles(R)
                 x_rot = x_rot + x_rot_offset
                 y_rot = y_rot + y_rot_offset
                 z_rot = z_rot + z_rot_offset
                 break
     else:
@@ -1311,16 +1249,15 @@
         y_rands = np.random.uniform(limits[1][0], limits[1][1], 1000)
         z_rands = np.random.uniform(limits[2][0], limits[2][1], 1000)
         while skip_dup and iter < max_iter:
             x_rand = x_rands[iter]
             y_rand = y_rands[iter]
             z_rand = z_rands[iter]
             pos = [x_rand, y_rand, z_rand]
-            skip_dup = skip_duplicate(
-                pos, saved_pos, drifting=False, verbose=verbose)
+            skip_dup = skip_duplicate(pos, saved_pos, drifting=False, verbose=verbose)
             iter += 1
         if iter == max_iter:
             found_position = False
             return None, None, None, found_position
         else:
             found_position = True
         cell.set_pos(x_rand, y_rand, z_rand)
@@ -1332,145 +1269,136 @@
     rot = [x_rot, y_rot, z_rot]
 
     lfp = electrodes.get_transformation_matrix() @ cell.imem
 
     # Reverse rotation to bring cell back into initial rotation state
     if rotation is not None:
         rev_rot = [-r for r in rot]
-        cell.set_rotation(rev_rot[0], rev_rot[1],
-                          rev_rot[2], rotation_order='zyx')
+        cell.set_rotation(rev_rot[0], rev_rot[1], rev_rot[2], rotation_order="zyx")
 
     return 1000 * lfp, pos, rot, found_position
 
 
 def str2bool(v):
-    """ Transform string to bool
-    
-    Parameters:
+    """Transform string to bool
+
+    Parameters
     -----------
     v : str
-    
-    Returns:
+
+    Returns
     --------
     transformed_v, bool
-        If v is any of ("yes", "true", "t", "1") (case insensitive) 
+        If v is any of ("yes", "true", "t", "1") (case insensitive)
         ``True`` is returned, else ``False``
     """
     return v.lower() in ("yes", "true", "t", "1")
 
 
 def simulate_templates_one_cell(cell_model, intra_save_folder, params, verbose, custom_return_cell_function=None):
-    '''
+    """
 
     Parameters
     ----------
     cell_model
     intra_save_folder
     params
     verbose
     custom_return_cell_function
 
     Returns
     -------
 
-    '''
-    run_cell_model(cell_model, save=True, sim_folder=intra_save_folder, verbose=verbose,
-                   custom_return_cell_function=custom_return_cell_function, **params)
-    print(f'Extracellular simulation: {cell_model}')
-    eaps, locs, rots = calc_extracellular(0, cell_model, intra_save_folder, verbose=verbose,
-                                          save=False, custom_return_cell_function=custom_return_cell_function,
-                                          **params)
+    """
+    run_cell_model(
+        cell_model,
+        save=True,
+        sim_folder=intra_save_folder,
+        verbose=verbose,
+        custom_return_cell_function=custom_return_cell_function,
+        **params,
+    )
+    print(f"Extracellular simulation: {cell_model}")
+    eaps, locs, rots = calc_extracellular(
+        0,
+        cell_model,
+        intra_save_folder,
+        verbose=verbose,
+        save=False,
+        custom_return_cell_function=custom_return_cell_function,
+        **params,
+    )
 
     return eaps, locs, rots
 
 
 def compile_models(cell_folder):
     compile_all_mechanisms(cell_folder)
     print(f"Compiled all cell models in {cell_folder}")
 
 
 def compute_eap_for_cell_model(i, cell_model, params_path, intraonly=False, verbose=False):
-    with open(params_path, 'r') as f:
-        if use_loader:
-            params = yaml.load(f, Loader=yaml.FullLoader)
-        else:
-            params = yaml.load(f)
+    params = safe_yaml_load(params_path)
 
-    extra_sim_folder = params['templates_folder']
-    vm_im_sim_folder = str(Path(params['templates_folder']) / 'intracellular')
+    extra_sim_folder = Path(params["templates_folder"])
+    vm_im_sim_folder = Path(params["templates_folder"]) / "intracellular"
 
-    print(f'Intracellular simulation: {cell_model}')
-    run_cell_model(cell_model_folder=cell_model,
-                   sim_folder=vm_im_sim_folder, verbose=verbose, **params)
+    print(f"Intracellular simulation: {cell_model}")
+    run_cell_model(cell_model_folder=cell_model, save=True, sim_folder=vm_im_sim_folder, verbose=verbose, **params)
     if not intraonly:
-        print(f'Extracellular simulation: {cell_model}')
-        calc_extracellular(i, cell_model_folder=cell_model, save_sim_folder=extra_sim_folder,
-                           load_sim_folder=vm_im_sim_folder, verbose=verbose, **params)
+        print(f"Extracellular simulation: {cell_model}")
+        calc_extracellular(
+            i,
+            cell_model_folder=cell_model,
+            save_sim_folder=extra_sim_folder,
+            load_sim_folder=vm_im_sim_folder,
+            verbose=verbose,
+            **params,
+        )
 
 
-def compute_eap_based_on_tempgen(cell_folder, params_path,
-                                 tempgen, intraonly=False, verbose=False):
-    with open(params_path, 'r') as f:
-        if use_loader:
-            params = yaml.load(f, Loader=yaml.FullLoader)
-        else:
-            params = yaml.load(f)
+def compute_eap_based_on_tempgen(cell_folder, params_path, tempgen, intraonly=False, verbose=False):
+    params = safe_yaml_load(params_path)
 
-    extra_sim_folder = params['templates_folder']
-    vm_im_sim_folder = str(Path(params['templates_folder']) / 'intracellular')
+    extra_sim_folder = params["templates_folder"]
+    vm_im_sim_folder = str(Path(params["templates_folder"]) / "intracellular")
 
     celltypes = np.unique(tempgen.celltypes)
 
     for celltype in celltypes:
         celltype_idxs = np.where(tempgen.celltypes == celltype)
         if np.any(np.diff(celltype_idxs) != 1):
-            raise NotImplementedError(
-                "Cell types in the template generator must be contiguous.")
+            raise NotImplementedError("Cell types in the template generator must be contiguous.")
 
     # print(f'Intracellular simulation: {cell_model}')
     for i, celltype in enumerate(celltypes):
         cell_model = cell_folder / celltype
-        run_cell_model(cell_model_folder=cell_model,
-                       sim_folder=vm_im_sim_folder, verbose=verbose, **params)
+        run_cell_model(cell_model_folder=cell_model, sim_folder=vm_im_sim_folder, verbose=verbose, **params)
         celltype_idxs = np.where(tempgen.celltypes == celltype)
         cell_locations = tempgen.locations[celltype_idxs]
         cell_rotations = tempgen.rotations[celltype_idxs]
         if not intraonly:
-            print(f'Extracellular simulation: {cell_model}')
-            calc_extracellular(i, cell_model_folder=cell_model, save_sim_folder=extra_sim_folder,
-                               load_sim_folder=vm_im_sim_folder, verbose=verbose, cell_locations=cell_locations,
-                               cell_rotations=cell_rotations, **params)
+            print(f"Extracellular simulation: {cell_model}")
+            calc_extracellular(
+                i,
+                cell_model_folder=cell_model,
+                save_sim_folder=extra_sim_folder,
+                load_sim_folder=vm_im_sim_folder,
+                verbose=verbose,
+                cell_locations=cell_locations,
+                cell_rotations=cell_rotations,
+                **params,
+            )
 
 
-if __name__ == '__main__':
-    if len(sys.argv) == 3 and sys.argv[1] == 'compile':
+if __name__ == "__main__":
+    if len(sys.argv) == 3 and sys.argv[1] == "compile":
         cell_folder = sys.argv[2]
         compile_all_mechanisms(cell_folder)
         sys.exit(0)
     elif len(sys.argv) == 6:
         i = int(sys.argv[1])
         cell_model = sys.argv[2]
         intraonly = str2bool(sys.argv[3])
         params_path = sys.argv[4]
         verbose = int(sys.argv[5])
-
-        with open(params_path, 'r') as f:
-            if use_loader:
-                params = yaml.load(f, Loader=yaml.FullLoader)
-            else:
-                params = yaml.load(f)
-
-        sim_folder = params['templates_folder']
-        cell_folder = params['cell_models_folder']
-        rot = params['rot']
-
-        extra_sim_folder = params['templates_folder']
-        vm_im_sim_folder = str(
-            Path(params['templates_folder']) / 'intracellular')
-
-        print(f'Intracellular simulation: {cell_model}')
-        run_cell_model(cell_model_folder=cell_model,
-                       sim_folder=vm_im_sim_folder, verbose=verbose, **params)
-        if not intraonly:
-            print(f'Extracellular simulation: {cell_model}')
-            calc_extracellular(i, cell_model_folder=cell_model, save_sim_folder=extra_sim_folder,
-                               load_sim_folder=vm_im_sim_folder, verbose=verbose, **params)
+        compute_eap_for_cell_model(i, cell_model, params_path, intraonly=intraonly, verbose=verbose)
```

### Comparing `MEArec-1.8.0/MEArec/tests/test_generators.py` & `MEArec-1.9.0/src/MEArec/tests/test_generators.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,274 +1,282 @@
-import numpy as np
-import unittest
-import MEArec as mr
-from pathlib import Path
 import shutil
-import yaml
-import elephant.statistics as stat
-from packaging.version import parse
 import tempfile
+import unittest
 from copy import deepcopy
+from pathlib import Path
+
+import elephant.statistics as stat
+import numpy as np
+import yaml
 from click.testing import CliRunner
+from packaging.version import parse
 
+import MEArec as mr
 from MEArec.cli import cli
 
-if parse(yaml.__version__) >= parse('5.0.0'):
-    use_loader = True
-else:
-    use_loader = False
-
 DEBUG = False
 
+
 if DEBUG:
     import matplotlib.pyplot as plt
+
     plt.ion()
     plt.show()
 
 
 class TestGenerators(unittest.TestCase):
     @classmethod
     def setUpClass(self):
         info, info_folder = mr.get_default_config()
         cell_models_folder = mr.get_default_cell_models_folder()
-        self.num_cells = len([f for f in Path(cell_models_folder).iterdir() if 'mods' not in
-                              f.name and not f.name.startswith('.')])
+        self.num_cells = len(
+            [f for f in Path(cell_models_folder).iterdir() if "mods" not in f.name and not f.name.startswith(".")]
+        )
         self.n = 10
         self.n_drift = 5
 
         templates_params = mr.get_default_templates_params()
         rec_params = mr.get_default_recordings_params()
 
         # Set seed
         np.random.seed(2308)
 
         if not DEBUG:
             self.test_dir = Path(tempfile.mkdtemp())
         else:
-            self.test_dir = Path('./tmp').absolute()
+            self.test_dir = Path("./tmp").absolute()
 
-        if not (self.test_dir / 'templates.h5').is_file() and not (self.test_dir / 'templates_drift.h5').is_file():
-            templates_params['n'] = self.n
-            templates_params['ncontacts'] = 1
-            templates_params['probe'] = 'Neuronexus-32'
-            templates_folder = info['templates_folder']
-            print('Generating non-drifting templates')
-            templates_params['min_amp'] = 10
+        if not (self.test_dir / "templates.h5").is_file() and not (self.test_dir / "templates_drift.h5").is_file():
+            templates_params["n"] = self.n
+            templates_params["ncontacts"] = 1
+            templates_params["probe"] = "Neuronexus-32"
+            templates_folder = info["templates_folder"]
+            print("Generating non-drifting templates")
+            templates_params["min_amp"] = 10
             print(templates_params)
-            self.tempgen = mr.gen_templates(cell_models_folder, templates_tmp_folder=templates_folder,
-                                            params=templates_params, parallel=True, delete_tmp=True, 
-                                            verbose=False)
+            self.tempgen = mr.gen_templates(
+                cell_models_folder,
+                templates_tmp_folder=templates_folder,
+                params=templates_params,
+                parallel=True,
+                delete_tmp=True,
+                verbose=False,
+            )
             self.templates_params = deepcopy(templates_params)
             self.num_templates, self.num_chan, self.num_samples = self.tempgen.templates.shape
 
-            templates_params['drifting'] = True
-            templates_params['n'] = self.n_drift
-            templates_params['drift_steps'] = 10
-            templates_params['rot'] = 'norot'
-            templates_params['min_amp'] = 10
-            print('Generating drifting templates')
-            self.tempgen_drift = mr.gen_templates(cell_models_folder, templates_tmp_folder=templates_folder,
-                                                  params=templates_params, parallel=True, delete_tmp=True, 
-                                                  verbose=False)
+            templates_params["drifting"] = True
+            templates_params["n"] = self.n_drift
+            templates_params["drift_steps"] = 10
+            templates_params["rot"] = "norot"
+            templates_params["min_amp"] = 10
+            print("Generating drifting templates")
+            self.tempgen_drift = mr.gen_templates(
+                cell_models_folder,
+                templates_tmp_folder=templates_folder,
+                params=templates_params,
+                parallel=True,
+                delete_tmp=True,
+                verbose=False,
+            )
             self.templates_params_drift = deepcopy(templates_params)
             self.num_steps_drift = self.tempgen_drift.templates.shape[1]
 
-            print('Making test recordings to test load functions')
-            mr.save_template_generator(self.tempgen, self.test_dir / 'templates.h5')
-            mr.save_template_generator(self.tempgen_drift, self.test_dir / 'templates_drift.h5')
+            print("Making test recordings to test load functions")
+            mr.save_template_generator(self.tempgen, self.test_dir / "templates.h5")
+            mr.save_template_generator(self.tempgen_drift, self.test_dir / "templates_drift.h5")
         else:
-            print(self.test_dir / 'templates.h5')
-            self.tempgen = mr.load_templates(self.test_dir / 'templates.h5', return_h5_objects=False)
-            self.tempgen_drift = mr.load_templates(self.test_dir / 'templates_drift.h5')
-            self.templates_params = self.tempgen.info['params']
-            self.templates_params_drift = self.tempgen_drift.info['params']
+            print(self.test_dir / "templates.h5")
+            self.tempgen = mr.load_templates(self.test_dir / "templates.h5", return_h5_objects=False)
+            self.tempgen_drift = mr.load_templates(self.test_dir / "templates_drift.h5")
+            self.templates_params = self.tempgen.info["params"]
+            self.templates_params_drift = self.tempgen_drift.info["params"]
             self.num_steps_drift = self.tempgen_drift.templates.shape[1]
             self.num_templates, self.num_chan, self.num_samples = self.tempgen.templates.shape
 
-        if not (self.test_dir / 'recordings.h5').is_file():
+        if not (self.test_dir / "recordings.h5").is_file():
             ne = 2
             ni = 1
-            rec_params['spiketrains']['n_exc'] = ne
-            rec_params['spiketrains']['n_inh'] = ni
-            rec_params['recordings']['modulation'] = 'none'
-            rec_params['recordings']['filter'] = False
-            rec_params['recordings']['extract_waveforms'] = True
-            rec_params['recordings']['overlap'] = True
-            rec_params['spiketrains']['duration'] = 2
-            rec_params['templates']['min_dist'] = 1
+            rec_params["spiketrains"]["n_exc"] = ne
+            rec_params["spiketrains"]["n_inh"] = ni
+            rec_params["recordings"]["modulation"] = "none"
+            rec_params["recordings"]["filter"] = False
+            rec_params["recordings"]["extract_waveforms"] = True
+            rec_params["recordings"]["overlap"] = True
+            rec_params["spiketrains"]["duration"] = 2
+            rec_params["templates"]["min_dist"] = 1
 
             self.recgen = mr.gen_recordings(params=rec_params, tempgen=self.tempgen, verbose=False)
             self.recgen.annotate_overlapping_spikes(parallel=False)
-            mr.save_recording_generator(self.recgen, self.test_dir / 'recordings.h5')
+            mr.save_recording_generator(self.recgen, self.test_dir / "recordings.h5")
         else:
-            self.recgen = mr.load_recordings(self.test_dir / 'recordings.h5', return_h5_objects=False)
+            self.recgen = mr.load_recordings(self.test_dir / "recordings.h5", return_h5_objects=False)
 
     @classmethod
     def tearDownClass(self):
         # Remove the directory after the test
         if not DEBUG:
             shutil.rmtree(self.test_dir)
 
     def test_gen_templates(self):
-        print('Test templates generation')
+        print("Test templates generation")
         n = self.n
         num_cells = self.num_cells
         templates_params = self.templates_params
 
         assert self.tempgen.templates.shape[0] == (n * num_cells)
         assert len(self.tempgen.locations) == (n * num_cells)
         assert len(self.tempgen.rotations) == (n * num_cells)
         assert len(self.tempgen.celltypes) == (n * num_cells)
         assert len(np.unique(self.tempgen.celltypes)) == num_cells
-        assert np.min(self.tempgen.locations[:, 0]) > templates_params['xlim'][0] \
-               and np.max(self.tempgen.locations[:, 0]) < templates_params['xlim'][1]
+        assert (
+            np.min(self.tempgen.locations[:, 0]) > templates_params["xlim"][0]
+            and np.max(self.tempgen.locations[:, 0]) < templates_params["xlim"][1]
+        )
 
     def test_gen_templates_drift(self):
-        print('Test drifting templates generation')
+        print("Test drifting templates generation")
         n = self.n_drift
         num_cells = self.num_cells
         n_steps = self.num_steps_drift
 
         assert self.tempgen_drift.templates.shape[0] == (n * num_cells)
         assert self.tempgen_drift.locations.shape == (n * num_cells, n_steps, 3)
         assert len(self.tempgen_drift.rotations) == (n * num_cells)
         assert len(self.tempgen_drift.celltypes) == (n * num_cells)
         assert len(np.unique(self.tempgen_drift.celltypes)) == num_cells
         assert self.tempgen_drift.templates.shape[1] == self.num_steps_drift
 
     def test_gen_templates_from_tempgen(self):
-        print('Test templates generation from existing template generator')
+        print("Test templates generation from existing template generator")
         cell_models_folder = mr.get_default_cell_models_folder()
 
         # no drift
         params = self.templates_params
         params["probe"] = "Neuropixels-24"
-        tempgen2 = mr.gen_templates(cell_models_folder=cell_models_folder,
-                                    params=params, tempgen=self.tempgen)
+        tempgen2 = mr.gen_templates(cell_models_folder=cell_models_folder, params=params, tempgen=self.tempgen)
 
         assert tempgen2.templates.shape[0] == self.tempgen.templates.shape[0]
         # assert that all locations are the same
-        for (loc_new, loc_old) in zip(tempgen2.locations, self.tempgen.locations):
+        for loc_new, loc_old in zip(tempgen2.locations, self.tempgen.locations):
             assert np.allclose(loc_new, loc_old)
 
         # drift
         params = self.templates_params_drift
         params["probe"] = "Neuropixels-24"
-        tempgen_drift2 = mr.gen_templates(cell_models_folder=cell_models_folder,
-                                    params=params, tempgen=self.tempgen_drift)
+        tempgen_drift2 = mr.gen_templates(
+            cell_models_folder=cell_models_folder, params=params, tempgen=self.tempgen_drift
+        )
 
         assert tempgen_drift2.templates.shape[0] == self.tempgen_drift.templates.shape[0]
         # assert that all locations are the same
-        for (loc_new, loc_old) in zip(tempgen2.locations, self.tempgen.locations):
-            for (loc_new_d, loc_old_d) in zip(loc_new, loc_old):
+        for loc_new, loc_old in zip(tempgen2.locations, self.tempgen.locations):
+            for loc_new_d, loc_old_d in zip(loc_new, loc_old):
                 assert np.allclose(loc_new_d, loc_old_d)
-                
+
     def test_gen_templates_beta_distr(self):
-        print('Test templates generation from beta distributions')
+        print("Test templates generation from beta distributions")
         cell_models_folder = mr.get_default_cell_models_folder()
 
         # no drift
         params = self.templates_params
         params["probe"] = "Neuronexus-32"
-        
+
         # beta distr
         params["x_distr"] = "beta"
-        tempgen_beta = mr.gen_templates(cell_models_folder=cell_models_folder,
-                                        params=params)
+        tempgen_beta = mr.gen_templates(cell_models_folder=cell_models_folder, params=params)
 
         assert tempgen_beta.templates.shape[0] == self.tempgen.templates.shape[0]
 
         # drift
         params = self.templates_params_drift
         params["probe"] = "Neuronexus-32"
         params["x_distr"] = "beta"
         params["beta_distr_params"] = [2, 5]
 
-        tempgen_drift_beta = mr.gen_templates(cell_models_folder=cell_models_folder,
-                                              params=params)
+        tempgen_drift_beta = mr.gen_templates(cell_models_folder=cell_models_folder, params=params)
 
         assert tempgen_drift_beta.templates.shape[0] == self.tempgen_drift.templates.shape[0]
 
-
     def test_gen_spiketrains(self):
-        print('Test spike train generation')
+        print("Test spike train generation")
         rec_params = mr.get_default_recordings_params()
-        sp_params = rec_params['spiketrains']
+        sp_params = rec_params["spiketrains"]
         spgen = mr.SpikeTrainGenerator(sp_params, seed=0)
         spgen.generate_spikes()
 
         # check ref period
         for st in spgen.spiketrains:
-            isi = stat.isi(st).rescale('ms')
-            assert np.all(isi.magnitude > sp_params['ref_per'])
-            assert (1 / np.mean(isi.rescale('s'))) > sp_params['min_rate']
+            isi = stat.isi(st).rescale("ms")
+            assert np.all(isi.magnitude > sp_params["ref_per"])
+            assert (1 / np.mean(isi.rescale("s"))) > sp_params["min_rate"]
 
-        sp_params['process'] = 'gamma'
+        sp_params["process"] = "gamma"
         spgen = mr.SpikeTrainGenerator(sp_params, seed=0)
         spgen.generate_spikes()
         for st in spgen.spiketrains:
-            isi = stat.isi(st).rescale('ms')
-            assert np.all(isi.magnitude > sp_params['ref_per'])
-            assert (1 / np.mean(isi.rescale('s'))) > sp_params['min_rate']
+            isi = stat.isi(st).rescale("ms")
+            assert np.all(isi.magnitude > sp_params["ref_per"])
+            assert (1 / np.mean(isi.rescale("s"))) > sp_params["min_rate"]
 
         spgen = mr.gen_spiketrains(sp_params, seed=0)
         spiketrains = spgen.spiketrains
         spgen_st = mr.gen_spiketrains(spiketrains=spiketrains)
-        for (st, st_) in zip(spgen.spiketrains, spgen_st.spiketrains):
+        for st, st_ in zip(spgen.spiketrains, spgen_st.spiketrains):
             assert np.allclose(st.times.magnitude, st_.times.magnitude)
 
     def test_gen_recordings_with_spiketrains(self):
-        print('Test recording generation - from spiketrains')
+        print("Test recording generation - from spiketrains")
         rec_params = mr.get_default_recordings_params()
-        sp_params = rec_params['spiketrains']
-        sp_params['n_exc'] = 2
-        sp_params['n_inh'] = 1
-        sp_params['duration'] = 5
+        sp_params = rec_params["spiketrains"]
+        sp_params["n_exc"] = 2
+        sp_params["n_inh"] = 1
+        sp_params["duration"] = 5
         spgen = mr.gen_spiketrains(sp_params)
         recgen = mr.gen_recordings(params=rec_params, spgen=spgen, tempgen=self.tempgen, verbose=False)
 
-        for (st, st_) in zip(spgen.spiketrains, recgen.spiketrains):
+        for st, st_ in zip(spgen.spiketrains, recgen.spiketrains):
             assert np.allclose(st.times.magnitude, st_.times.magnitude)
         del recgen
 
     def test_gen_recordings_modulations(self):
-        print('Test recording generation - modulation')
+        print("Test recording generation - modulation")
         ne = 1
         ni = 2
         fe = 30
         fi = 50
         num_chan = self.num_chan
         n_neurons = ne + ni
 
         rec_params = mr.get_default_recordings_params()
 
-        rec_params['spiketrains']['n_exc'] = ne
-        rec_params['spiketrains']['n_inh'] = ni
-        rec_params['spiketrains']['f_exc'] = fe
-        rec_params['spiketrains']['f_inh'] = fi
-        rec_params['spiketrains']['duration'] = 3
+        rec_params["spiketrains"]["n_exc"] = ne
+        rec_params["spiketrains"]["n_inh"] = ni
+        rec_params["spiketrains"]["f_exc"] = fe
+        rec_params["spiketrains"]["f_inh"] = fi
+        rec_params["spiketrains"]["duration"] = 3
         n_jitter = [1, 5]
-        modulations = ['none', 'electrode', 'template']
+        modulations = ["none", "electrode", "template"]
         chunk_rec = [0, 2]
 
-        rec_params['templates']['min_dist'] = 1
+        rec_params["templates"]["min_dist"] = 1
         bursting = [False, True]
 
         for mod in modulations:
             for b in bursting:
                 for j in n_jitter:
                     for ch in chunk_rec:
-                        print('Modulation: modulation', mod, 'bursting', b, 'jitter', j, 'chunk', ch)
-                        rec_params['templates']['n_jitters'] = j
-                        rec_params['recordings']['modulation'] = mod
-                        rec_params['recordings']['bursting'] = b
-                        rec_params['recordings']['chunk_duration'] = ch
+                        print("Modulation: modulation", mod, "bursting", b, "jitter", j, "chunk", ch)
+                        rec_params["templates"]["n_jitters"] = j
+                        rec_params["recordings"]["modulation"] = mod
+                        rec_params["recordings"]["bursting"] = b
+                        rec_params["recordings"]["chunk_duration"] = ch
 
-                        if mod == 'electrode' and b is True and j == 5:
-                            rec_params['cell_types'] = None
+                        if mod == "electrode" and b is True and j == 5:
+                            rec_params["cell_types"] = None
 
                         recgen_mod = mr.gen_recordings(params=rec_params, tempgen=self.tempgen, verbose=False)
 
                         assert recgen_mod.recordings.shape[1] == num_chan
                         assert len(recgen_mod.spiketrains) == n_neurons
                         assert recgen_mod.channel_positions.shape == (num_chan, 3)
                         if j == 1:
@@ -276,88 +284,88 @@
                         else:
                             assert recgen_mod.templates.shape[:3] == (n_neurons, j, num_chan)
                         assert recgen_mod.voltage_peaks.shape == (n_neurons, num_chan)
                         assert recgen_mod.spike_traces.shape[1] == n_neurons
                         del recgen_mod
 
     def test_gen_recordings_bursting(self):
-        print('Test recording generation - shape_mod')
+        print("Test recording generation - shape_mod")
         rates = [30, 50]
-        types = ['E', 'I']
+        types = ["E", "I"]
         num_chan = self.num_chan
         n_neurons = len(rates)
 
         rec_params = mr.get_default_recordings_params()
 
-        rec_params['spiketrains']['rates'] = rates
-        rec_params['spiketrains']['types'] = types
-        rec_params['spiketrains']['duration'] = 3
+        rec_params["spiketrains"]["rates"] = rates
+        rec_params["spiketrains"]["types"] = types
+        rec_params["spiketrains"]["duration"] = 3
         n_jitter = 4
-        rec_params['templates']['n_jitters'] = n_jitter
-        rec_params['recordings']['modulation'] = 'electrode'
-        rec_params['recordings']['bursting'] = True
-        rec_params['recordings']['shape_mod'] = True
-        rec_params['recordings']['sync_rate'] = 0.2
-        rec_params['recordings']['overlap'] = True
-        rec_params['recordings']['extract_waveforms'] = True
-        rec_params['templates']['min_dist'] = 1
-        rec_params['templates']['min_amp'] = 0
+        rec_params["templates"]["n_jitters"] = n_jitter
+        rec_params["recordings"]["modulation"] = "electrode"
+        rec_params["recordings"]["bursting"] = True
+        rec_params["recordings"]["shape_mod"] = True
+        rec_params["recordings"]["sync_rate"] = 0.2
+        rec_params["recordings"]["overlap"] = True
+        rec_params["recordings"]["extract_waveforms"] = True
+        rec_params["templates"]["min_dist"] = 1
+        rec_params["templates"]["min_amp"] = 0
 
         recgen_burst = mr.gen_recordings(params=rec_params, tempgen=self.tempgen, verbose=False)
         recgen_burst.extract_waveforms()
 
         assert recgen_burst.recordings.shape[1] == num_chan
         assert len(recgen_burst.spiketrains) == n_neurons
         assert recgen_burst.channel_positions.shape == (num_chan, 3)
         assert recgen_burst.templates.shape[:3] == (n_neurons, n_jitter, num_chan)
         assert recgen_burst.voltage_peaks.shape == (n_neurons, num_chan)
         assert recgen_burst.spike_traces.shape[1] == n_neurons
         del recgen_burst
 
-        rec_params['recordings']['modulation'] = 'template'
-        rec_params['recordings']['n_bursting'] = 2
+        rec_params["recordings"]["modulation"] = "template"
+        rec_params["recordings"]["n_bursting"] = 2
 
         recgen_burst = mr.gen_recordings(params=rec_params, tempgen=self.tempgen, verbose=False)
         recgen_burst.extract_waveforms()
 
         assert recgen_burst.recordings.shape[1] == num_chan
         assert len(recgen_burst.spiketrains) == n_neurons
         assert recgen_burst.channel_positions.shape == (num_chan, 3)
         assert recgen_burst.templates.shape[:3] == (n_neurons, n_jitter, num_chan)
         assert recgen_burst.voltage_peaks.shape == (n_neurons, num_chan)
         assert recgen_burst.spike_traces.shape[1] == n_neurons
         del recgen_burst
 
     def test_gen_recordings_multiple_bursting_modulation(self):
-        print('Test recording generation - multiple bursting modulation')
+        print("Test recording generation - multiple bursting modulation")
         rates = [10, 20, 30]
-        types = ['E', 'E', 'I']
+        types = ["E", "E", "I"]
         num_chan = self.num_chan
         n_neurons = len(rates)
 
         rec_params = mr.get_default_recordings_params()
 
-        rec_params['spiketrains']['rates'] = rates
-        rec_params['spiketrains']['types'] = types
-        rec_params['spiketrains']['duration'] = 3
+        rec_params["spiketrains"]["rates"] = rates
+        rec_params["spiketrains"]["types"] = types
+        rec_params["spiketrains"]["duration"] = 3
         n_jitter = 4
-        rec_params['templates']['n_jitters'] = n_jitter
-        rec_params['recordings']['modulation'] = 'electrode'
-        rec_params['recordings']['bursting'] = True
-        rec_params['recordings']['shape_mod'] = True
-        rec_params['recordings']['sync_rate'] = 0.2
-        rec_params['recordings']['overlap'] = True
-        rec_params['recordings']['extract_waveforms'] = True
-        rec_params['templates']['min_dist'] = 1
-        rec_params['templates']['min_amp'] = 0
-
-        rec_params['recordings']['exp_decay'] = [0.1, 0.15, 0.2]
-        rec_params['recordings']['max_burst_duration'] = [50, 100, 150]
-        rec_params['recordings']['n_burst_spikes'] = [5, 10, 15]
-        rec_params['recordings']['shape_stretch'] = 10
+        rec_params["templates"]["n_jitters"] = n_jitter
+        rec_params["recordings"]["modulation"] = "electrode"
+        rec_params["recordings"]["bursting"] = True
+        rec_params["recordings"]["shape_mod"] = True
+        rec_params["recordings"]["sync_rate"] = 0.2
+        rec_params["recordings"]["overlap"] = True
+        rec_params["recordings"]["extract_waveforms"] = True
+        rec_params["templates"]["min_dist"] = 1
+        rec_params["templates"]["min_amp"] = 0
+
+        rec_params["recordings"]["exp_decay"] = [0.1, 0.15, 0.2]
+        rec_params["recordings"]["max_burst_duration"] = [50, 100, 150]
+        rec_params["recordings"]["n_burst_spikes"] = [5, 10, 15]
+        rec_params["recordings"]["shape_stretch"] = 10
 
         recgen_burst = mr.gen_recordings(params=rec_params, tempgen=self.tempgen, verbose=False)
         recgen_burst.extract_waveforms()
 
         assert recgen_burst.recordings.shape[1] == num_chan
         assert len(recgen_burst.spiketrains) == n_neurons
         assert recgen_burst.channel_positions.shape == (num_chan, 3)
@@ -365,489 +373,550 @@
         assert recgen_burst.voltage_peaks.shape == (n_neurons, num_chan)
         assert recgen_burst.spike_traces.shape[1] == n_neurons
 
         for st in recgen_burst.spiketrains:
             assert st.annotations["bursting"]
         del recgen_burst
 
-        rec_params['recordings']['modulation'] = 'template'
-        rec_params['recordings']['bursting_units'] = [1, 2]
-        rec_params['recordings']['exp_decay'] = [0.1, 0.15]
-        rec_params['recordings']['max_burst_duration'] = [50, 100]
-        rec_params['recordings']['n_burst_spikes'] = [10, 15]
-        rec_params['recordings']['shape_stretch'] = 20
+        rec_params["recordings"]["modulation"] = "template"
+        rec_params["recordings"]["bursting_units"] = [1, 2]
+        rec_params["recordings"]["exp_decay"] = [0.1, 0.15]
+        rec_params["recordings"]["max_burst_duration"] = [50, 100]
+        rec_params["recordings"]["n_burst_spikes"] = [10, 15]
+        rec_params["recordings"]["shape_stretch"] = 20
 
         recgen_burst = mr.gen_recordings(params=rec_params, tempgen=self.tempgen, verbose=False)
         recgen_burst.extract_waveforms()
 
         assert recgen_burst.recordings.shape[1] == num_chan
         assert len(recgen_burst.spiketrains) == n_neurons
         assert recgen_burst.channel_positions.shape == (num_chan, 3)
         assert recgen_burst.templates.shape[:3] == (n_neurons, n_jitter, num_chan)
         assert recgen_burst.voltage_peaks.shape == (n_neurons, num_chan)
         assert recgen_burst.spike_traces.shape[1] == n_neurons
         for i, st in enumerate(recgen_burst.spiketrains):
-            if i in rec_params['recordings']['bursting_units']:
+            if i in rec_params["recordings"]["bursting_units"]:
                 assert st.annotations["bursting"]
             else:
                 assert not st.annotations["bursting"]
         del recgen_burst
 
     def test_gen_recordings_noise(self):
-        print('Test recording generation - noise')
+        print("Test recording generation - noise")
         ne = 0
         ni = 0
         num_chan = self.num_chan
         n_neurons = ne + ni
 
         rec_params = mr.get_default_recordings_params()
 
-        rec_params['spiketrains']['n_exc'] = ne
-        rec_params['spiketrains']['n_inh'] = ni
-        rec_params['spiketrains']['duration'] = 3
+        rec_params["spiketrains"]["n_exc"] = ne
+        rec_params["spiketrains"]["n_inh"] = ni
+        rec_params["spiketrains"]["duration"] = 3
         n_jitter = 3
-        rec_params['templates']['n_jitters'] = n_jitter
-        rec_params['templates']['min_dist'] = 1
-        rec_params['recordings']['modulation'] = 'none'
-        noise_modes = ['uncorrelated', 'distance-correlated']
+        rec_params["templates"]["n_jitters"] = n_jitter
+        rec_params["templates"]["min_dist"] = 1
+        rec_params["recordings"]["modulation"] = "none"
+        noise_modes = ["uncorrelated", "distance-correlated"]
         chunk_noise = [0, 2]
         noise_color = [True, False]
         noise_level = 10
-        rec_params['recordings']['noise_level'] = noise_level
-        rec_params['recordings']['filter'] = False
+        rec_params["recordings"]["noise_level"] = noise_level
+        rec_params["recordings"]["filter"] = False
 
         for mode in noise_modes:
             for ch in chunk_noise:
                 for color in noise_color:
-                    print('Noise: mode', mode, 'chunks', ch, 'color', color)
-                    rec_params['recordings']['noise_mode'] = mode
-                    rec_params['recordings']['chunk_duration'] = ch
-                    rec_params['recordings']['noise_color'] = color
+                    print("Noise: mode", mode, "chunks", ch, "color", color)
+                    rec_params["recordings"]["noise_mode"] = mode
+                    rec_params["recordings"]["chunk_duration"] = ch
+                    rec_params["recordings"]["noise_color"] = color
                     recgen_noise = mr.gen_recordings(params=rec_params, tempgen=self.tempgen, verbose=False)
 
-                    if mode == 'uncorrelated' and ch == 0 and not noise_color:
-                        rec_params['recordings']['fs'] = 30000
-                        rec_params['recordings']['chunk_duration'] = 1
+                    if mode == "uncorrelated" and ch == 0 and not noise_color:
+                        rec_params["recordings"]["fs"] = 30000
+                        rec_params["recordings"]["chunk_duration"] = 1
                     if noise_color:
-                        rec_params['recordings']['filter_cutoff'] = 500
+                        rec_params["recordings"]["filter_cutoff"] = 500
 
                     assert recgen_noise.recordings.shape[1] == num_chan
                     assert len(recgen_noise.spiketrains) == n_neurons
                     assert recgen_noise.channel_positions.shape == (num_chan, 3)
                     assert len(recgen_noise.spike_traces) == n_neurons
                     assert np.isclose(np.std(recgen_noise.recordings), noise_level, atol=1)
                     del recgen_noise
 
     def test_gen_recordings_far_neurons(self):
-        print('Test recording generation - far neurons')
+        print("Test recording generation - far neurons")
         ne = 0
         ni = 0
         num_chan = self.num_chan
         n_neurons = ne + ni
 
         rec_params = mr.get_default_recordings_params()
 
-        rec_params['spiketrains']['n_exc'] = ne
-        rec_params['spiketrains']['n_inh'] = ni
-        rec_params['spiketrains']['duration'] = 3
+        rec_params["spiketrains"]["n_exc"] = ne
+        rec_params["spiketrains"]["n_inh"] = ni
+        rec_params["spiketrains"]["duration"] = 3
         n_jitter = 3
-        rec_params['templates']['n_jitters'] = n_jitter
-        rec_params['templates']['min_dist'] = 1
-        rec_params['recordings']['modulation'] = 'none'
-        rec_params['recordings']['noise_mode'] = 'far-neurons'
-        rec_params['recordings']['far_neurons_n'] = 10
-        rec_params['recordings']['far_neurons_max_amp'] = 100
-        rec_params['recordings']['far_neurons_exc_inh_ratio'] = 0.8
+        rec_params["templates"]["n_jitters"] = n_jitter
+        rec_params["templates"]["min_dist"] = 1
+        rec_params["recordings"]["modulation"] = "none"
+        rec_params["recordings"]["noise_mode"] = "far-neurons"
+        rec_params["recordings"]["far_neurons_n"] = 10
+        rec_params["recordings"]["far_neurons_max_amp"] = 100
+        rec_params["recordings"]["far_neurons_exc_inh_ratio"] = 0.8
         noise_level = 20
-        rec_params['recordings']['noise_level'] = noise_level
-        rec_params['recordings']['filter'] = False
+        rec_params["recordings"]["noise_level"] = noise_level
+        rec_params["recordings"]["filter"] = False
         recgen_noise = mr.gen_recordings(params=rec_params, tempgen=self.tempgen, verbose=False)
 
         assert recgen_noise.recordings.shape[1] == num_chan
         assert recgen_noise.channel_positions.shape == (num_chan, 3)
         assert len(recgen_noise.spiketrains) == n_neurons
         assert len(recgen_noise.spike_traces) == n_neurons
         assert np.isclose(np.std(recgen_noise.recordings), noise_level, atol=1)
         del recgen_noise
 
-        rec_params['recordings']['chunk_duration'] = 1
+        rec_params["recordings"]["chunk_duration"] = 1
         recgen_noise = mr.gen_recordings(params=rec_params, tempgen=self.tempgen, verbose=False)
 
         assert recgen_noise.recordings.shape[1] == num_chan
         assert recgen_noise.channel_positions.shape == (num_chan, 3)
         assert len(recgen_noise.spiketrains) == n_neurons
         assert len(recgen_noise.spike_traces) == n_neurons
         assert np.isclose(np.std(recgen_noise.recordings), noise_level, atol=1)
         del recgen_noise
 
-    
+    def test_gen_recordings_filters(self):
+        print("Test recording generation - filters")
+        ne = 1
+        ni = 1
+        num_chan = self.num_chan
+        n_neurons = ne + ni
+
+        rec_params = mr.get_default_recordings_params()
+
+        filter_modes = ["filtfilt", "lfilter"]
+        filter_orders = [1, 3, 5]
+        filter_cutoffs = [300, 500, [300, 3000], [300, 6000]]
+        chunk_rec = [0, 2]
+
+        rec_params["spiketrains"]["n_exc"] = ne
+        rec_params["spiketrains"]["n_inh"] = ni
+        rec_params["spiketrains"]["duration"] = 5
+        rec_params["recordings"]["filter"] = True
+        rec_params["templates"]["min_dist"] = 1
+
+        for mode in filter_modes:
+            for order in filter_orders:
+                for cutoff in filter_cutoffs:
+                    for ch in chunk_rec:
+                        print(f"Filter: mode {mode} order {order} cutoff {cutoff} chunk dur {ch}")
+                        rec_params["recordings"]["chunk_duration"] = ch
+                        rec_params["recordings"]["filter_mode"] = mode
+                        rec_params["recordings"]["filter_order"] = order
+                        rec_params["recordings"]["filter_cutoff"] = cutoff
+
+                        recgen_filt = mr.gen_recordings(params=rec_params, tempgen=self.tempgen, verbose=False)
+                        assert recgen_filt.recordings.shape[1] == num_chan
+                        assert len(recgen_filt.spiketrains) == n_neurons
+                        assert recgen_filt.channel_positions.shape == (num_chan, 3)
+                        assert recgen_filt.spike_traces.shape[1] == n_neurons
+                        del recgen_filt
+
     def test_gen_recordings_drift(self):
-        print('Test recording generation - drift')
+        print("Test recording generation - drift")
         ne = 1
         ni = 1
         num_chan = self.num_chan
         n_neurons = ne + ni
 
         rec_params = mr.get_default_recordings_params()
 
-        rec_params['spiketrains']['n_exc'] = ne
-        rec_params['spiketrains']['n_inh'] = ni
-        rec_params['spiketrains']['duration'] = 5
+        rec_params["spiketrains"]["n_exc"] = ne
+        rec_params["spiketrains"]["n_inh"] = ni
+        rec_params["spiketrains"]["duration"] = 5
         n_jitter = [1, 3]
-        rec_params['recordings']['drifting'] = True
-        rec_params['recordings']['slow_drift_velocity'] = 500
-        rec_params['templates']['min_dist'] = 1
+        rec_params["recordings"]["drifting"] = True
+        rec_params["recordings"]["slow_drift_velocity"] = 500
+        rec_params["templates"]["min_dist"] = 1
         chunk_rec = [0, 2]
 
-        modulations = ['none', 'template', 'electrode']
+        modulations = ["none", "template", "electrode"]
         bursting = [False, True]
-        drift_mode_speeds = ['slow', 'fast']
-        drift_mode_probes = ['rigid', 'non-rigid']
+        drift_mode_speeds = ["slow", "fast"]
+        drift_mode_probes = ["rigid", "non-rigid"]
 
         for i, mod in enumerate(modulations):
             for dms in drift_mode_speeds:
                 for dmp in drift_mode_probes:
                     for b in bursting:
                         for j in n_jitter:
                             for ch in chunk_rec:
-                                print('Drifting: modulation', mod, 'bursting', b, 'jitter', j, 'drift mode speed', dms,
-                                      'drift mode probe', dmp,'chunk', ch)
-                                rec_params['templates']['n_jitters'] = j
-                                rec_params['recordings']['modulation'] = mod
-                                rec_params['recordings']['bursting'] = b
-                                rec_params['recordings']['chunk_duration'] = ch
-                                rec_params['recordings']['drift_mode_speed'] = dms
-                                rec_params['recordings']['drift_mode_probe'] = dmp
+                                print(
+                                    "Drifting: modulation",
+                                    mod,
+                                    "bursting",
+                                    b,
+                                    "jitter",
+                                    j,
+                                    "drift mode speed",
+                                    dms,
+                                    "drift mode probe",
+                                    dmp,
+                                    "chunk",
+                                    ch,
+                                )
+                                rec_params["templates"]["n_jitters"] = j
+                                rec_params["recordings"]["modulation"] = mod
+                                rec_params["recordings"]["bursting"] = b
+                                rec_params["recordings"]["chunk_duration"] = ch
+                                rec_params["recordings"]["drift_mode_speed"] = dms
+                                rec_params["recordings"]["drift_mode_probe"] = dmp
 
                                 if i == len(modulations) - 1:
-                                    rec_params['recordings']['fs'] = 30000
-                                    rec_params['recordings']['n_drifting'] = 1
-                                if mod == 'electrode' and b is True and j == 5:
-                                    rec_params['cell_types'] = None
-                                    rec_params['recordings']['shape_mod'] = True
-                                recgen_drift = mr.gen_recordings(params=rec_params, tempgen=self.tempgen_drift,
-                                                                verbose=False)
+                                    rec_params["recordings"]["fs"] = 30000
+                                    rec_params["recordings"]["n_drifting"] = 1
+                                if mod == "electrode" and b is True and j == 5:
+                                    rec_params["cell_types"] = None
+                                    rec_params["recordings"]["shape_mod"] = True
+                                recgen_drift = mr.gen_recordings(
+                                    params=rec_params, tempgen=self.tempgen_drift, verbose=False
+                                )
                                 assert recgen_drift.recordings.shape[1] == num_chan
                                 assert len(recgen_drift.spiketrains) == n_neurons
                                 assert recgen_drift.channel_positions.shape == (num_chan, 3)
                                 if j == 1:
                                     assert recgen_drift.templates.shape[0] == n_neurons
                                     assert recgen_drift.templates.shape[2] == num_chan
                                 else:
                                     assert recgen_drift.templates.shape[0] == n_neurons
                                     assert recgen_drift.templates.shape[2] == j
                                     assert recgen_drift.templates.shape[3] == num_chan
                                 assert recgen_drift.spike_traces.shape[1] == n_neurons
                                 del recgen_drift
-                                
+
     def test_recording_custom_drifts(self):
-        print('Test recording generation - drift')
+        print("Test recording generation - drift")
         ne = 2
         ni = 1
         num_chan = self.num_chan
         n_neurons = ne + ni
 
         rec_params = mr.get_default_recordings_params()
 
-        rec_params['spiketrains']['n_exc'] = ne
-        rec_params['spiketrains']['n_inh'] = ni
-        rec_params['spiketrains']['duration'] = 10
-        rec_params['recordings']['drifting'] = True
+        rec_params["spiketrains"]["n_exc"] = ne
+        rec_params["spiketrains"]["n_inh"] = ni
+        rec_params["spiketrains"]["duration"] = 10
+        rec_params["recordings"]["drifting"] = True
         chunk_rec = [0, 2]
 
         # generate drift signals
         drift_dict1 = mr.get_default_drift_dict()
         drift_dict2 = mr.get_default_drift_dict()
         drift_dict3 = mr.get_default_drift_dict()
-        
+
         drift_dict1["drift_mode_probe"] = "rigid"
         drift_dict1["drift_fs"] = 5
         drift_dict1["slow_drift_velocity"] = 10
         drift_dict1["slow_drift_amplitude"] = 50
-        
+
         drift_dict2["drift_mode_speed"] = "fast"
         drift_dict2["fast_drift_period"] = 2
         drift_dict2["fast_drift_max_jump"] = 15
-        
+
         drift_dict3["drift_mode_probe"] = "non-rigid"
         drift_dict3["drift_mode_speed"] = "slow"
         drift_dict3["slow_drift_waveform"] = "sine"
         drift_dict3["slow_drift_velocity"] = 80
         drift_dict3["slow_drift_amplitude"] = 10
-        
+
         drift_dicts = [drift_dict1, drift_dict2, drift_dict3]
-        
+
         for ch in chunk_rec:
-            print('Drifting mixed: chunk', ch)
-            rec_params['recordings']['chunk_duration'] = ch
+            print("Drifting mixed: chunk", ch)
+            rec_params["recordings"]["chunk_duration"] = ch
 
-            recgen_drift = mr.gen_recordings(params=rec_params, tempgen=self.tempgen_drift,
-                                             verbose=False, drift_dicts=drift_dicts)
+            recgen_drift = mr.gen_recordings(
+                params=rec_params, tempgen=self.tempgen_drift, verbose=False, drift_dicts=drift_dicts
+            )
             assert recgen_drift.recordings.shape[1] == num_chan
             assert len(recgen_drift.spiketrains) == n_neurons
             assert recgen_drift.channel_positions.shape == (num_chan, 3)
             assert recgen_drift.spike_traces.shape[1] == n_neurons
             assert len(recgen_drift.drift_list) == 3
-            
-            recgen_mixed_file = self.test_dir / 'recordings_drift_mixed.h5'
+
+            recgen_mixed_file = self.test_dir / "recordings_drift_mixed.h5"
             mr.save_recording_generator(recgen_drift, filename=recgen_mixed_file)
             recgen_drift_loaded = mr.load_recordings(recgen_mixed_file)
             assert len(recgen_drift_loaded.drift_list) == 3
-            
+
             # test plotting drift
             _ = mr.plot_cell_drifts(recgen_drift_loaded)
-            
+
             del recgen_drift_loaded
             del recgen_drift
             recgen_mixed_file.unlink()
 
     def test_save_load_templates(self):
-        tempgen = mr.load_templates(self.test_dir / 'templates.h5', verbose=True)
-        tempgen_drift = mr.load_templates(self.test_dir / 'templates_drift.h5')
-        tempgen_drift_f = mr.load_templates(self.test_dir / 'templates_drift.h5', return_h5_objects=True)
+        tempgen = mr.load_templates(self.test_dir / "templates.h5", verbose=True)
+        tempgen_drift = mr.load_templates(self.test_dir / "templates_drift.h5")
+        tempgen_drift_f = mr.load_templates(self.test_dir / "templates_drift.h5", return_h5_objects=True)
 
         assert np.allclose(tempgen.templates, self.tempgen.templates)
         assert np.allclose(tempgen.locations, self.tempgen.locations)
         assert np.allclose(tempgen.rotations, self.tempgen.rotations)
         assert np.allclose(tempgen_drift.templates, self.tempgen_drift.templates)
         assert np.allclose(tempgen_drift.locations, self.tempgen_drift.locations)
         assert np.allclose(tempgen_drift.rotations, self.tempgen_drift.rotations)
         assert np.allclose(tempgen_drift.templates, np.array(tempgen_drift_f.templates))
 
     def test_save_load_recordings(self):
-        recgen_loaded = mr.load_recordings(self.test_dir / 'recordings.h5', return_h5_objects=False, verbose=True, )
-        recgen_loaded_f = mr.load_recordings(self.test_dir / 'recordings.h5', return_h5_objects=False, verbose=True)
-        recgen_loaded_r = mr.load_recordings(self.test_dir / 'recordings.h5', load=['recordings'],
-                                             return_h5_objects=True, verbose=True)
+        recgen_loaded = mr.load_recordings(
+            self.test_dir / "recordings.h5",
+            return_h5_objects=False,
+            verbose=True,
+        )
+        recgen_loaded_f = mr.load_recordings(self.test_dir / "recordings.h5", return_h5_objects=False, verbose=True)
+        recgen_loaded_r = mr.load_recordings(
+            self.test_dir / "recordings.h5", load=["recordings"], return_h5_objects=True, verbose=True
+        )
 
         assert np.allclose(recgen_loaded.templates, self.recgen.templates)
         assert np.allclose(recgen_loaded.recordings, self.recgen.recordings)
         assert np.allclose(recgen_loaded.spike_traces, self.recgen.spike_traces)
         assert np.allclose(recgen_loaded.voltage_peaks, self.recgen.voltage_peaks)
         assert np.allclose(recgen_loaded.channel_positions, self.recgen.channel_positions)
         assert np.allclose(recgen_loaded.timestamps.magnitude, self.recgen.timestamps.magnitude)
         assert np.allclose(recgen_loaded.recordings, np.array(recgen_loaded_f.recordings))
         assert np.allclose(recgen_loaded.recordings, np.array(recgen_loaded_r.recordings))
 
     def test_plots(self):
         _ = mr.plot_rasters(self.recgen.spiketrains)
         _ = mr.plot_rasters(self.recgen.spiketrains, overlap=True)
         _ = mr.plot_rasters(self.recgen.spiketrains, cell_type=True)
-        _ = mr.plot_rasters(self.recgen.spiketrains, color='g')
-        _ = mr.plot_rasters(self.recgen.spiketrains, color=['g'] * len(self.recgen.spiketrains))
+        _ = mr.plot_rasters(self.recgen.spiketrains, color="g")
+        _ = mr.plot_rasters(self.recgen.spiketrains, color=["g"] * len(self.recgen.spiketrains))
         _ = mr.plot_recordings(self.recgen)
         _ = mr.plot_recordings(self.recgen, overlay_templates=True)
         _ = mr.plot_recordings(self.recgen, overlay_templates=True, max_channels_per_template=3)
         _ = mr.plot_templates(self.recgen)
         _ = mr.plot_templates(self.recgen, single_axes=True)
         _ = mr.plot_waveforms(self.recgen)
         _ = mr.plot_waveforms(self.recgen, electrode=0)
-        _ = mr.plot_waveforms(self.recgen, electrode='max')
-        _ = mr.plot_waveforms(self.recgen, electrode='max', max_waveforms=2)
+        _ = mr.plot_waveforms(self.recgen, electrode="max")
+        _ = mr.plot_waveforms(self.recgen, electrode="max", max_waveforms=2)
         self.recgen.spiketrains[0].waveforms = None
-        _ = mr.plot_waveforms(self.recgen, electrode='max')
+        _ = mr.plot_waveforms(self.recgen, electrode="max")
 
     def test_extract_features(self):
-        feat_t0 = mr.get_templates_features(self.tempgen.templates, feat_list=['neg', 'pos', 'amp', 'width', 'fwhm',
-                                                                               'ratio', 'speed'],
-                                            dt=self.tempgen.info['params']['dt'])
-        assert feat_t0['neg'].shape == (self.tempgen.templates.shape[0], self.tempgen.templates.shape[1])
-        assert feat_t0['pos'].shape == (self.tempgen.templates.shape[0], self.tempgen.templates.shape[1])
-        assert feat_t0['amp'].shape == (self.tempgen.templates.shape[0], self.tempgen.templates.shape[1])
-        assert feat_t0['width'].shape == (self.tempgen.templates.shape[0], self.tempgen.templates.shape[1])
-        assert feat_t0['fwhm'].shape == (self.tempgen.templates.shape[0], self.tempgen.templates.shape[1])
-        assert feat_t0['ratio'].shape == (self.tempgen.templates.shape[0], self.tempgen.templates.shape[1])
-        assert feat_t0['speed'].shape == (self.tempgen.templates.shape[0], self.tempgen.templates.shape[1])
+        feat_t0 = mr.get_templates_features(
+            self.tempgen.templates,
+            feat_list=["neg", "pos", "amp", "width", "fwhm", "ratio", "speed"],
+            dt=self.tempgen.info["params"]["dt"],
+        )
+        assert feat_t0["neg"].shape == (self.tempgen.templates.shape[0], self.tempgen.templates.shape[1])
+        assert feat_t0["pos"].shape == (self.tempgen.templates.shape[0], self.tempgen.templates.shape[1])
+        assert feat_t0["amp"].shape == (self.tempgen.templates.shape[0], self.tempgen.templates.shape[1])
+        assert feat_t0["width"].shape == (self.tempgen.templates.shape[0], self.tempgen.templates.shape[1])
+        assert feat_t0["fwhm"].shape == (self.tempgen.templates.shape[0], self.tempgen.templates.shape[1])
+        assert feat_t0["ratio"].shape == (self.tempgen.templates.shape[0], self.tempgen.templates.shape[1])
+        assert feat_t0["speed"].shape == (self.tempgen.templates.shape[0], self.tempgen.templates.shape[1])
 
     def test_recordings_resample(self):
-        print('Test recording generation - resampling')
+        print("Test recording generation - resampling")
         ne = 2
         ni = 1
         num_chan = self.num_chan
         n_neurons = ne + ni
         fs = 10000
         duration = 5
 
         rec_params = mr.get_default_recordings_params()
 
-        rec_params['spiketrains']['n_exc'] = ne
-        rec_params['spiketrains']['n_inh'] = ni
-        rec_params['spiketrains']['duration'] = duration
+        rec_params["spiketrains"]["n_exc"] = ne
+        rec_params["spiketrains"]["n_inh"] = ni
+        rec_params["spiketrains"]["duration"] = duration
         n_jitter = 3
-        rec_params['templates']['n_jitters'] = n_jitter
-        rec_params['recordings']['modulation'] = 'none'
-        rec_params['recordings']['fs'] = fs
+        rec_params["templates"]["n_jitters"] = n_jitter
+        rec_params["recordings"]["modulation"] = "none"
+        rec_params["recordings"]["fs"] = fs
         recgen_rs = mr.gen_recordings(params=rec_params, tempgen=self.tempgen, verbose=False)
 
         assert recgen_rs.recordings.shape[0] == int(duration * fs)
         assert recgen_rs.recordings.shape[1] == num_chan
         assert recgen_rs.channel_positions.shape == (num_chan, 3)
         assert len(recgen_rs.spiketrains) == n_neurons
         assert len(recgen_rs.spiketrains) == n_neurons
         assert len(recgen_rs.spiketrains) == n_neurons
         assert recgen_rs.spike_traces.shape[1] == n_neurons
         del recgen_rs
 
     def test_recordings_backend(self):
-        print('Test recording generation - backend')
+        print("Test recording generation - backend")
         ne = 2
         ni = 1
         duration = 3
 
         rec_params = mr.get_default_recordings_params()
 
-        rec_params['spiketrains']['n_exc'] = ne
-        rec_params['spiketrains']['n_inh'] = ni
-        rec_params['spiketrains']['duration'] = duration
+        rec_params["spiketrains"]["n_exc"] = ne
+        rec_params["spiketrains"]["n_inh"] = ni
+        rec_params["spiketrains"]["duration"] = duration
         n_jitter = 10
-        rec_params['templates']['n_jitters'] = n_jitter
-        rec_params['recordings']['modulation'] = 'none'
-        rec_params['recordings']['filter'] = False
-
-
-        rec_params['seeds']['templates'] = 0
-        rec_params['seeds']['spiketrains'] = 0
-        rec_params['seeds']['convolution'] = 0
-        rec_params['seeds']['noise'] = 0
-
+        rec_params["templates"]["n_jitters"] = n_jitter
+        rec_params["recordings"]["modulation"] = "none"
+        rec_params["recordings"]["filter"] = False
+
+        rec_params["seeds"]["templates"] = 0
+        rec_params["seeds"]["spiketrains"] = 0
+        rec_params["seeds"]["convolution"] = 0
+        rec_params["seeds"]["noise"] = 0
 
         n_jobs = [1, 2]
         chunk_durations = [0, 1]
 
         for n in n_jobs:
             for ch in chunk_durations:
-                print('Test recording backend with', n, 'jobs - chunk', ch)
-                rec_params['recordings']['chunk_duration'] = ch
+                print("Test recording backend with", n, "jobs - chunk", ch)
+                rec_params["recordings"]["chunk_duration"] = ch
 
-                recgen_memmap = mr.gen_recordings(params=rec_params, tempgen=self.tempgen, tmp_mode='memmap',
-                                                  verbose=False, n_jobs=n)
-                recgen_np = mr.gen_recordings(params=rec_params, tempgen=self.tempgen, tmp_mode=None, verbose=False,
-                                              n_jobs=n)
+                recgen_memmap = mr.gen_recordings(
+                    params=rec_params, tempgen=self.tempgen, tmp_mode="memmap", verbose=False, n_jobs=n
+                )
+                recgen_np = mr.gen_recordings(
+                    params=rec_params, tempgen=self.tempgen, tmp_mode=None, verbose=False, n_jobs=n
+                )
                 assert np.allclose(np.array(recgen_np.recordings), recgen_memmap.recordings.copy(), atol=1e-4)
                 del recgen_memmap, recgen_np
 
     def test_recordings_seeds(self):
-        print('Test recording generation - seeds')
+        print("Test recording generation - seeds")
         ne = 2
         ni = 1
         duration = 3
 
         rec_params = mr.get_default_recordings_params()
 
-        rec_params['spiketrains']['n_exc'] = ne
-        rec_params['spiketrains']['n_inh'] = ni
-        rec_params['spiketrains']['duration'] = duration
+        rec_params["spiketrains"]["n_exc"] = ne
+        rec_params["spiketrains"]["n_inh"] = ni
+        rec_params["spiketrains"]["duration"] = duration
         n_jitter = 2
-        rec_params['templates']['n_jitters'] = n_jitter
-        rec_params['recordings']['modulation'] = 'none'
+        rec_params["templates"]["n_jitters"] = n_jitter
+        rec_params["recordings"]["modulation"] = "none"
 
-        rec_params['seeds']['templates'] = 0
-        rec_params['seeds']['spiketrains'] = 0
-        rec_params['seeds']['convolution'] = 0
-        rec_params['seeds']['noise'] = 0
+        rec_params["seeds"]["templates"] = 0
+        rec_params["seeds"]["spiketrains"] = 0
+        rec_params["seeds"]["convolution"] = 0
+        rec_params["seeds"]["noise"] = 0
 
         n_jobs = [1, 2]
         chunk_durations = [0, 1]
 
         for n in n_jobs:
             for ch in chunk_durations:
-                print('Test recording seeds with', n, 'jobs - chunk', ch)
-                rec_params['chunk_duration'] = n
+                print("Test recording seeds with", n, "jobs - chunk", ch)
+                rec_params["chunk_duration"] = n
 
                 print("memmap")
-                recgen1 = mr.gen_recordings(params=rec_params, tempgen=self.tempgen, tmp_mode='memmap',
-                                            verbose=False, n_jobs=n)
-                recgen2 = mr.gen_recordings(params=rec_params, tempgen=self.tempgen, tmp_mode='memmap',
-                                            verbose=False, n_jobs=n)
+                recgen1 = mr.gen_recordings(
+                    params=rec_params, tempgen=self.tempgen, tmp_mode="memmap", verbose=False, n_jobs=n
+                )
+                recgen2 = mr.gen_recordings(
+                    params=rec_params, tempgen=self.tempgen, tmp_mode="memmap", verbose=False, n_jobs=n
+                )
 
                 assert np.allclose(np.array(recgen1.recordings), np.array(recgen2.recordings), atol=1e-4)
                 del recgen1, recgen2
 
                 print("memory")
-                recgen1 = mr.gen_recordings(params=rec_params, tempgen=self.tempgen, tmp_mode=None,
-                                            verbose=False, n_jobs=n)
-                recgen2 = mr.gen_recordings(params=rec_params, tempgen=self.tempgen, tmp_mode=None,
-                                            verbose=False, n_jobs=n)
+                recgen1 = mr.gen_recordings(
+                    params=rec_params, tempgen=self.tempgen, tmp_mode=None, verbose=False, n_jobs=n
+                )
+                recgen2 = mr.gen_recordings(
+                    params=rec_params, tempgen=self.tempgen, tmp_mode=None, verbose=False, n_jobs=n
+                )
 
                 assert np.allclose(np.array(recgen1.recordings), recgen2.recordings, atol=1e-4)
                 del recgen1, recgen2
 
     def test_recordings_dtype(self):
-        print('Test recording generation - dtype')
+        print("Test recording generation - dtype")
         ne = 2
         ni = 1
         duration = 1
 
-        dtypes = ['int16', 'int32', 'float16', 'float32', 'float64']
-        modulations = ['none', 'template', 'electrode']
+        dtypes = ["int16", "int32", "float16", "float32", "float64"]
+        modulations = ["none", "template", "electrode"]
 
         rec_params = mr.get_default_recordings_params()
-        rec_params['spiketrains']['n_exc'] = ne
-        rec_params['spiketrains']['n_inh'] = ni
-        rec_params['spiketrains']['duration'] = duration
+        rec_params["spiketrains"]["n_exc"] = ne
+        rec_params["spiketrains"]["n_inh"] = ni
+        rec_params["spiketrains"]["duration"] = duration
         n_jitter = 3
-        rec_params['templates']['n_jitters'] = n_jitter
+        rec_params["templates"]["n_jitters"] = n_jitter
 
         for i, dt in enumerate(dtypes):
             for mod in modulations:
-                rec_params['recordings']['modulation'] = mod
+                rec_params["recordings"]["modulation"] = mod
 
-                print('Dtype:', dt, 'modulation', mod)
-                rec_params['recordings']['dtype'] = dt
+                print("Dtype:", dt, "modulation", mod)
+                rec_params["recordings"]["dtype"] = dt
                 recgen_dt = mr.gen_recordings(params=rec_params, tempgen=self.tempgen, verbose=False)
 
                 assert recgen_dt.recordings[0, 0].dtype == dt
                 del recgen_dt
 
     def test_adc_bit_depth_lsb_gain(self):
-        print('Test recording generation - adc depth and lsb')
+        print("Test recording generation - adc depth and lsb")
         ne = 2
         ni = 1
         duration = 1
 
         bit_depths = [10, 11, 12]
         lsbs = [1, 2, 4]
         gains = [0.1, 0.2, 0.3]
 
         rec_params = mr.get_default_recordings_params()
-        rec_params['spiketrains']['n_exc'] = ne
-        rec_params['spiketrains']['n_inh'] = ni
-        rec_params['spiketrains']['duration'] = duration
+        rec_params["spiketrains"]["n_exc"] = ne
+        rec_params["spiketrains"]["n_inh"] = ni
+        rec_params["spiketrains"]["duration"] = duration
         n_jitter = 3
-        rec_params['templates']['n_jitters'] = n_jitter
-        rec_params['recordings']['dtype'] = "int16"
-        rec_params['recordings']['filter'] = False
+        rec_params["templates"]["n_jitters"] = n_jitter
+        rec_params["recordings"]["dtype"] = "int16"
+        rec_params["recordings"]["filter"] = False
 
         for bd in bit_depths:
             for lsb in lsbs:
-                rec_params['recordings']['adc_bit_depth'] = bd
-                rec_params['recordings']['lsb'] = lsb
+                rec_params["recordings"]["adc_bit_depth"] = bd
+                rec_params["recordings"]["lsb"] = lsb
 
-                print('ADC bit depth:', bd, 'lsb', lsb)
+                print("ADC bit depth:", bd, "lsb", lsb)
                 recgen_adc_lsb = mr.gen_recordings(params=rec_params, tempgen=self.tempgen, verbose=False)
 
-                assert np.ptp(recgen_adc_lsb.recordings) / lsb <= 2 ** bd
+                assert np.ptp(recgen_adc_lsb.recordings) / lsb <= 2**bd
                 lsb_rec = np.min(np.diff(np.sort(np.unique(recgen_adc_lsb.recordings.ravel()))))
                 assert lsb_rec == lsb
 
                 # save and reload gain
                 save_path = self.test_dir / f"{bd}_{lsb}.h5"
                 mr.save_recording_generator(recgen_adc_lsb, save_path)
                 recgen_loaded = mr.load_recordings(save_path)
                 assert recgen_loaded.gain_to_uV == recgen_adc_lsb.gain_to_uV
 
                 del recgen_adc_lsb
                 save_path.unlink()
-                
+
         for gain in gains:
             for lsb in lsbs:
-                rec_params['recordings']['gain'] = gain
-                rec_params['recordings']['lsb'] = lsb
+                rec_params["recordings"]["gain"] = gain
+                rec_params["recordings"]["lsb"] = lsb
 
-                print('Gain:', gain, 'lsb', lsb)
+                print("Gain:", gain, "lsb", lsb)
                 recgen_gain_lsb = mr.gen_recordings(params=rec_params, tempgen=self.tempgen, verbose=False)
 
                 assert recgen_gain_lsb.gain_to_uV == gain
                 lsb_rec = np.min(np.diff(np.sort(np.unique(recgen_gain_lsb.recordings.ravel()))))
                 assert lsb_rec == lsb
 
                 # save and reload gain
@@ -855,39 +924,40 @@
                 mr.save_recording_generator(recgen_gain_lsb, save_path)
                 recgen_loaded = mr.load_recordings(save_path)
                 assert recgen_loaded.gain_to_uV == recgen_gain_lsb.gain_to_uV
 
                 del recgen_gain_lsb
                 save_path.unlink()
 
-
     def test_default_params(self):
-        print('Test default params')
+        print("Test default params")
         info, info_folder = mr.get_default_config()
-        cell_models_folder = info['cell_models_folder']
-        tempgen = mr.gen_templates(cell_models_folder, params={'n': 2}, templates_tmp_folder=info['templates_folder'])
-        recgen = mr.gen_recordings(templates=self.test_dir / 'templates.h5', verbose=False)
-        recgen.params['recordings']['noise_level'] = 0
+        cell_models_folder = info["cell_models_folder"]
+        tempgen = mr.gen_templates(cell_models_folder, params={"n": 2}, templates_tmp_folder=info["templates_folder"])
+        recgen = mr.gen_recordings(templates=self.test_dir / "templates.h5", verbose=False)
+        recgen.params["recordings"]["noise_level"] = 0
         recgen.generate_recordings()
-        recgen_loaded = mr.load_recordings(self.test_dir / 'recordings.h5', verbose=True)
-        recgen_loaded.params['recordings']['noise_level'] = 0
+        recgen_loaded = mr.load_recordings(self.test_dir / "recordings.h5", verbose=True)
+        recgen_loaded.params["recordings"]["noise_level"] = 0
         recgen_loaded.generate_recordings()
         recgen_empty = mr.RecordingGenerator(rec_dict={}, info={})
 
         n = 2
         num_cells = self.num_cells
         templates_params = self.templates_params
 
         assert tempgen.templates.shape[0] == (n * num_cells)
         assert len(tempgen.locations) == (n * num_cells)
         assert len(tempgen.rotations) == (n * num_cells)
         assert len(tempgen.celltypes) == (n * num_cells)
         assert len(np.unique(tempgen.celltypes)) == num_cells
-        assert np.min(tempgen.locations[:, 0]) > templates_params['xlim'][0] \
-               and np.max(tempgen.locations[:, 0]) < templates_params['xlim'][1]
+        assert (
+            np.min(tempgen.locations[:, 0]) > templates_params["xlim"][0]
+            and np.max(tempgen.locations[:, 0]) < templates_params["xlim"][1]
+        )
 
         assert recgen.recordings.shape[1] == self.num_chan
         assert recgen.channel_positions.shape == (self.num_chan, 3)
         assert recgen_loaded.recordings.shape[1] == self.num_chan
         assert recgen_loaded.channel_positions.shape == (self.num_chan, 3)
         assert len(recgen_empty.recordings) == 0
         del recgen, recgen_empty
@@ -898,68 +968,159 @@
         runner = CliRunner()
         result = runner.invoke(cli, ["--help"])
         assert result.exit_code == 0
         result = runner.invoke(cli, ["default-config"])
         assert result.exit_code == 0
         result = runner.invoke(cli, ["available-probes"])
         assert result.exit_code == 0
-        result = runner.invoke(cli, ["gen-templates", '-n', '2', '--no-parallel', '--recompile', '-r', '3drot',
-                                     '-nc', '2', '-ov', '20', '-s', '1', '-mind', '10', '-maxd', '100',
-                                     '-drst', '10', '-v'])
-        assert result.exit_code == 0
-        result = runner.invoke(cli, ["gen-recordings", '-t', str(self.test_dir / 'templates.h5'), '-ne', '2', '-ni', '1',
-                                     '-fe', '5', '-fi', '15', '-se', '1', '-si', '1', '-mr', '0.2',
-                                     '-rp', '2', '-p', 'poisson', '-md', '1', '-mina', '10', '-maxa', '1000',
-                                     '--fs', '32000', '-sr', '0', '-sj', '1', '-nl', '10', '-m', 'none',
-                                     '-chd', '0', '-nseed', '10', '-hd', '30', '-cn', '-cp', '500',
-                                     '-cq', '1', '-rnf', '1', '-stseed', '100', '-tseed', '10',
-                                     '--filter', '-fc', '500', '-fo', '3', '--overlap', '-ot', '0.8', '--extract-wf',
-                                     '-angt', '15', '-drvel', '10', '-tsd', '1', '-v'])
+        result = runner.invoke(
+            cli,
+            [
+                "gen-templates",
+                "-n",
+                "2",
+                "--no-parallel",
+                "--recompile",
+                "-r",
+                "3drot",
+                "-nc",
+                "2",
+                "-ov",
+                "20",
+                "-s",
+                "1",
+                "-mind",
+                "10",
+                "-maxd",
+                "100",
+                "-drst",
+                "10",
+                "-v",
+            ],
+        )
+        assert result.exit_code == 0
+        result = runner.invoke(
+            cli,
+            [
+                "gen-recordings",
+                "-t",
+                str(self.test_dir / "templates.h5"),
+                "-ne",
+                "2",
+                "-ni",
+                "1",
+                "-fe",
+                "5",
+                "-fi",
+                "15",
+                "-se",
+                "1",
+                "-si",
+                "1",
+                "-mr",
+                "0.2",
+                "-rp",
+                "2",
+                "-p",
+                "poisson",
+                "-md",
+                "1",
+                "-mina",
+                "10",
+                "-maxa",
+                "1000",
+                "--fs",
+                "32000",
+                "-sr",
+                "0",
+                "-sj",
+                "1",
+                "-nl",
+                "10",
+                "-m",
+                "none",
+                "-chd",
+                "0",
+                "-nseed",
+                "10",
+                "-hd",
+                "30",
+                "-cn",
+                "-cp",
+                "500",
+                "-cq",
+                "1",
+                "-rnf",
+                "1",
+                "-stseed",
+                "100",
+                "-tseed",
+                "10",
+                "--filter",
+                "-fc",
+                "500",
+                "-fo",
+                "3",
+                "--overlap",
+                "-ot",
+                "0.8",
+                "--extract-wf",
+                "-angt",
+                "15",
+                "-drvel",
+                "10",
+                "-tsd",
+                "1",
+                "-v",
+            ],
+        )
         print(result.output)
         assert result.exit_code == 0
-        result = runner.invoke(cli, ["set-templates-params", '.'])
+        result = runner.invoke(cli, ["set-templates-params", "."])
         assert result.exit_code == 0
-        result = runner.invoke(cli, ["set-templates-params", default_config['templates_params']])
+        result = runner.invoke(cli, ["set-templates-params", default_config["templates_params"]])
         assert result.exit_code == 0
-        result = runner.invoke(cli, ["set-recordings-params", '.'])
+        result = runner.invoke(cli, ["set-recordings-params", "."])
         assert result.exit_code == 0
-        result = runner.invoke(cli, ["set-recordings-params", default_config['recordings_params']])
+        result = runner.invoke(cli, ["set-recordings-params", default_config["recordings_params"]])
         assert result.exit_code == 0
-        result = runner.invoke(cli, ["set-cell-models-folder", './cell_models'])
+        result = runner.invoke(cli, ["set-cell-models-folder", "./cell_models"])
         assert result.exit_code == 0
-        result = runner.invoke(cli, ["set-cell-models-folder", default_config['cell_models_folder']])
+        result = runner.invoke(cli, ["set-cell-models-folder", default_config["cell_models_folder"]])
         assert result.exit_code == 0
-        result = runner.invoke(cli, ["set-templates-folder", '.'])
+        result = runner.invoke(cli, ["set-templates-folder", "."])
         assert result.exit_code == 0
-        result = runner.invoke(cli, ["set-recordings-folder", '.'])
+        result = runner.invoke(cli, ["set-recordings-folder", "."])
         assert result.exit_code == 0
-        result = runner.invoke(cli, ["set-templates-folder", './templates', '--create'])
+        result = runner.invoke(cli, ["set-templates-folder", "./templates", "--create"])
         assert result.exit_code == 0
-        result = runner.invoke(cli, ["set-recordings-folder", './recordings', '--create'])
+        result = runner.invoke(cli, ["set-recordings-folder", "./recordings", "--create"])
         assert result.exit_code == 0
-        result = runner.invoke(cli, ["set-templates-folder", default_config['templates_folder']])
+        result = runner.invoke(cli, ["set-templates-folder", default_config["templates_folder"]])
         assert result.exit_code == 0
-        result = runner.invoke(cli, ["set-recordings-folder", default_config['recordings_folder']])
+        result = runner.invoke(cli, ["set-recordings-folder", default_config["recordings_folder"]])
         assert result.exit_code == 0
 
     def test_simulate_cell(self):
         cell_folder = Path(mr.get_default_cell_models_folder())
         params = mr.get_default_templates_params()
 
         target_spikes = [3, 50]
-        params['target_spikes'] = target_spikes
-        cell_path = [c for c in cell_folder.iterdir() if 'TTPC1' in c.name][0]
+        params["target_spikes"] = target_spikes
+        cell_path = [c for c in cell_folder.iterdir() if "TTPC1" in c.name][0]
         cell_name = cell_path.parts[-1]
 
-        cell, v, i = mr.run_cell_model(cell_model_folder=str(cell_path), sim_folder=None, verbose=True,
-                                       save=False, return_vi=True, **params)
+        cell, v, i = mr.run_cell_model(
+            cell_model_folder=str(cell_path), sim_folder=None, verbose=True, save=False, return_vi=True, **params
+        )
         c = mr.return_bbp_cell_morphology(str(cell_name), cell_folder)
         assert target_spikes[0] <= len(v) <= target_spikes[1]
         assert target_spikes[0] <= len(i) <= target_spikes[1]
         assert len(c.x) == len(c.y) and len(c.x) == len(c.z)
 
 
-if __name__ == '__main__':
-    TestGenerators().setUpClass()
+if __name__ == "__main__":
+    test = TestGenerators()
+    test.setUpClass()
     # TestGenerators().test_gen_recordings_drift()
-    # TestGenerators().test_default_params()
-    TestGenerators().test_recordings_backend()
+    test.test_gen_recordings_filters()
+    # test.test_simulate_cell()
```

### Comparing `MEArec-1.8.0/MEArec/tools.py` & `MEArec-1.9.0/src/MEArec/tools.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,8749 +1,9075 @@
-00000000: 696d 706f 7274 206e 756d 7079 2061 7320  import numpy as 
-00000010: 6e70 0a69 6d70 6f72 7420 7175 616e 7469  np.import quanti
-00000020: 7469 6573 2061 7320 7071 0a66 726f 6d20  ties as pq.from 
-00000030: 7175 616e 7469 7469 6573 2069 6d70 6f72  quantities impor
-00000040: 7420 5175 616e 7469 7479 0a69 6d70 6f72  t Quantity.impor
-00000050: 7420 7961 6d6c 0a69 6d70 6f72 7420 6e65  t yaml.import ne
-00000060: 6f0a 696d 706f 7274 2073 6369 7079 2e73  o.import scipy.s
-00000070: 6967 6e61 6c20 6173 2073 730a 696d 706f  ignal as ss.impo
-00000080: 7274 2073 6875 7469 6c0a 696d 706f 7274  rt shutil.import
-00000090: 206f 730a 696d 706f 7274 204d 4541 7574   os.import MEAut
-000000a0: 696c 6974 7920 6173 206d 750a 696d 706f  ility as mu.impo
-000000b0: 7274 2068 3570 790a 6672 6f6d 2070 6174  rt h5py.from pat
-000000c0: 686c 6962 2069 6d70 6f72 7420 5061 7468  hlib import Path
-000000d0: 0a66 726f 6d20 636f 7079 2069 6d70 6f72  .from copy impor
-000000e0: 7420 6465 6570 636f 7079 2c20 636f 7079  t deepcopy, copy
-000000f0: 0a66 726f 6d20 7061 636b 6167 696e 672e  .from packaging.
-00000100: 7665 7273 696f 6e20 696d 706f 7274 2070  version import p
-00000110: 6172 7365 0a66 726f 6d20 6a6f 626c 6962  arse.from joblib
-00000120: 2069 6d70 6f72 7420 5061 7261 6c6c 656c   import Parallel
-00000130: 2c20 6465 6c61 7965 640a 6672 6f6d 2064  , delayed.from d
-00000140: 6174 6574 696d 6520 696d 706f 7274 2064  atetime import d
-00000150: 6174 6574 696d 650a 6672 6f6d 206c 617a  atetime.from laz
-00000160: 795f 6f70 7320 696d 706f 7274 2044 6174  y_ops import Dat
-00000170: 6173 6574 5669 6577 0a0a 6672 6f6d 202e  asetView..from .
-00000180: 7665 7273 696f 6e20 696d 706f 7274 2076  version import v
-00000190: 6572 7369 6f6e 0a0a 6966 2070 6172 7365  ersion..if parse
-000001a0: 2879 616d 6c2e 5f5f 7665 7273 696f 6e5f  (yaml.__version_
-000001b0: 5f29 203e 3d20 7061 7273 6528 2735 2e30  _) >= parse('5.0
-000001c0: 2e30 2729 3a0a 2020 2020 7573 655f 6c6f  .0'):.    use_lo
-000001d0: 6164 6572 203d 2054 7275 650a 656c 7365  ader = True.else
-000001e0: 3a0a 2020 2020 7573 655f 6c6f 6164 6572  :.    use_loader
-000001f0: 203d 2046 616c 7365 0a0a 0a23 2323 2047   = False...### G
-00000200: 4554 2044 4546 4155 4c54 2053 4554 5449  ET DEFAULT SETTI
-00000210: 4e47 5320 2323 230a 6465 6620 6765 745f  NGS ###.def get_
-00000220: 6465 6661 756c 745f 636f 6e66 6967 2870  default_config(p
-00000230: 7269 6e74 5f76 6572 7369 6f6e 3d46 616c  rint_version=Fal
-00000240: 7365 293a 0a20 2020 2022 2222 0a20 2020  se):.    """.   
-00000250: 2052 6574 7572 6e73 2064 6566 6175 6c74   Returns default
-00000260: 5f69 6e66 6f20 616e 6420 6d65 6172 6563  _info and mearec
-00000270: 5f68 6f6d 6520 7061 7468 2e0a 0a20 2020  _home path...   
-00000280: 2052 6574 7572 6e73 0a20 2020 202d 2d2d   Returns.    ---
-00000290: 2d2d 2d2d 0a20 2020 2064 6566 6175 6c74  ----.    default
-000002a0: 5f69 6e66 6f20 3a20 6469 6374 0a20 2020  _info : dict.   
-000002b0: 2020 2020 2044 6566 6175 6c74 5f69 6e66       Default_inf
-000002c0: 6f20 6672 6f6d 2063 6f6e 6669 6720 6669  o from config fi
-000002d0: 6c65 0a20 2020 206d 6561 7265 635f 7061  le.    mearec_pa
-000002e0: 7468 203a 2073 7472 0a20 2020 2020 2020  th : str.       
-000002f0: 204d 6561 7265 6320 686f 6d65 2070 6174   Mearec home pat
-00000300: 680a 2020 2020 2222 220a 2020 2020 7468  h.    """.    th
-00000310: 6973 5f64 6972 2c20 7468 6973 5f66 696c  is_dir, this_fil
-00000320: 656e 616d 6520 3d20 6f73 2e70 6174 682e  ename = os.path.
-00000330: 7370 6c69 7428 5f5f 6669 6c65 5f5f 290a  split(__file__).
-00000340: 2020 2020 7468 6973 5f64 6972 203d 2050      this_dir = P
-00000350: 6174 6828 7468 6973 5f64 6972 290a 2020  ath(this_dir).  
-00000360: 2020 686f 6d65 203d 2050 6174 6828 6f73    home = Path(os
-00000370: 2e70 6174 682e 6578 7061 6e64 7573 6572  .path.expanduser
-00000380: 2822 7e22 2929 0a20 2020 206d 6561 7265  ("~")).    meare
-00000390: 635f 686f 6d65 203d 2068 6f6d 6520 2f20  c_home = home / 
-000003a0: 272e 636f 6e66 6967 2720 2f20 276d 6561  '.config' / 'mea
-000003b0: 7265 6327 0a20 2020 2076 6572 7369 6f6e  rec'.    version
-000003c0: 5f66 6f6c 6465 7220 3d20 6d65 6172 6563  _folder = mearec
-000003d0: 5f68 6f6d 6520 2f20 7665 7273 696f 6e0a  _home / version.
-000003e0: 0a20 2020 2069 6620 7072 696e 745f 7665  .    if print_ve
-000003f0: 7273 696f 6e3a 0a20 2020 2020 2020 2070  rsion:.        p
-00000400: 7269 6e74 2866 224d 4541 7265 6320 7665  rint(f"MEArec ve
-00000410: 7273 696f 6e3a 207b 7665 7273 696f 6e7d  rsion: {version}
-00000420: 5c6e 2229 0a20 2020 200a 2020 2020 6966  \n").    .    if
-00000430: 206e 6f74 206d 6561 7265 635f 686f 6d65   not mearec_home
-00000440: 2e69 735f 6469 7228 293a 0a20 2020 2020  .is_dir():.     
-00000450: 2020 206d 6561 7265 635f 686f 6d65 2e6d     mearec_home.m
-00000460: 6b64 6972 2865 7869 7374 5f6f 6b3d 5472  kdir(exist_ok=Tr
-00000470: 7565 2c20 7061 7265 6e74 733d 5472 7565  ue, parents=True
-00000480: 290a 2020 2020 237e 2065 6c73 653a 0a20  ).    #~ else:. 
-00000490: 2020 2020 2020 2023 7e20 7665 7273 696f         #~ versio
-000004a0: 6e73 203d 205b 7665 722e 6e61 6d65 2066  ns = [ver.name f
-000004b0: 6f72 2076 6572 2069 6e20 6d65 6172 6563  or ver in mearec
-000004c0: 5f68 6f6d 652e 6974 6572 6469 7228 2920  _home.iterdir() 
-000004d0: 6966 2076 6572 2e69 735f 6469 7228 2920  if ver.is_dir() 
-000004e0: 616e 6420 6c65 6e28 7665 722e 6e61 6d65  and len(ver.name
-000004f0: 2e73 706c 6974 2827 2e27 2929 203e 2031  .split('.')) > 1
-00000500: 5d0a 2020 2020 2020 2020 237e 2069 6620  ].        #~ if 
-00000510: 6c65 6e28 7665 7273 696f 6e73 2920 3e20  len(versions) > 
-00000520: 303a 0a20 2020 2020 2020 2020 2020 2023  0:.            #
-00000530: 7e20 6966 206e 702e 616c 6c28 6e70 2e61  ~ if np.all(np.a
-00000540: 7272 6179 2876 6572 7369 6f6e 7329 2021  rray(versions) !
-00000550: 3d20 7665 7273 696f 6e29 3a0a 2020 2020  = version):.    
-00000560: 2020 2020 2020 2020 2020 2020 237e 2023              #~ #
-00000570: 2066 696e 6420 6d6f 7374 2072 6563 656e   find most recen
-00000580: 7420 7665 7273 696f 6e0a 2020 2020 2020  t version.      
-00000590: 2020 2020 2020 2020 2020 237e 206f 6c64            #~ old
-000005a0: 5f76 6572 7369 6f6e 203d 206e 702e 736f  _version = np.so
-000005b0: 7274 2876 6572 7369 6f6e 7329 5b3a 3a2d  rt(versions)[::-
-000005c0: 315d 5b30 5d0a 2020 2020 2020 2020 2020  1][0].          
-000005d0: 2020 2020 2020 237e 2072 6563 656e 745f        #~ recent_
-000005e0: 7665 7273 696f 6e20 3d20 6d65 6172 6563  version = mearec
-000005f0: 5f68 6f6d 6520 2f20 6f6c 645f 7665 7273  _home / old_vers
-00000600: 696f 6e0a 2020 2020 2020 2020 2020 2020  ion.            
-00000610: 2020 2020 237e 2070 7269 6e74 2866 2243      #~ print(f"C
-00000620: 6f70 7969 6e67 2073 6574 7469 6e67 7320  opying settings 
-00000630: 6672 6f6d 2076 6572 7369 6f6e 207b 6f6c  from version {ol
-00000640: 645f 7665 7273 696f 6e7d 2074 6f20 6e65  d_version} to ne
-00000650: 7720 7665 7273 696f 6e20 7b76 6572 7369  w version {versi
-00000660: 6f6e 7d5c 6e22 290a 2020 2020 2020 2020  on}\n").        
-00000670: 2020 2020 2020 2020 237e 2073 6875 7469          #~ shuti
-00000680: 6c2e 636f 7079 7472 6565 2872 6563 656e  l.copytree(recen
-00000690: 745f 7665 7273 696f 6e2c 2076 6572 7369  t_version, versi
-000006a0: 6f6e 5f66 6f6c 6465 7229 0a20 2020 2020  on_folder).     
-000006b0: 2020 2023 7e20 656c 7365 3a0a 2020 2020     #~ else:.    
-000006c0: 2020 2020 2020 2020 237e 2076 6572 7369          #~ versi
-000006d0: 6f6e 5f66 6f6c 6465 722e 6d6b 6469 7228  on_folder.mkdir(
-000006e0: 6578 6973 745f 6f6b 3d54 7275 652c 2070  exist_ok=True, p
-000006f0: 6172 656e 7473 3d54 7275 6529 0a0a 2020  arents=True)..  
-00000700: 2020 6966 206e 6f74 2028 7665 7273 696f    if not (versio
-00000710: 6e5f 666f 6c64 6572 202f 2027 6d65 6172  n_folder / 'mear
-00000720: 6563 2e63 6f6e 6627 292e 6973 5f66 696c  ec.conf').is_fil
-00000730: 6528 293a 0a20 2020 2020 2020 2076 6572  e():.        ver
-00000740: 7369 6f6e 5f66 6f6c 6465 722e 6d6b 6469  sion_folder.mkdi
-00000750: 7228 6578 6973 745f 6f6b 3d54 7275 652c  r(exist_ok=True,
-00000760: 2070 6172 656e 7473 3d54 7275 6529 0a20   parents=True). 
-00000770: 2020 2020 2020 2073 6875 7469 6c2e 636f         shutil.co
-00000780: 7079 7472 6565 2873 7472 2874 6869 735f  pytree(str(this_
-00000790: 6469 7220 2f20 2764 6566 6175 6c74 5f70  dir / 'default_p
-000007a0: 6172 616d 7327 292c 2073 7472 2876 6572  arams'), str(ver
-000007b0: 7369 6f6e 5f66 6f6c 6465 7220 2f20 2764  sion_folder / 'd
-000007c0: 6566 6175 6c74 5f70 6172 616d 7327 2929  efault_params'))
-000007d0: 0a20 2020 2020 2020 2073 6875 7469 6c2e  .        shutil.
-000007e0: 636f 7079 7472 6565 2873 7472 2874 6869  copytree(str(thi
-000007f0: 735f 6469 7220 2f20 2763 656c 6c5f 6d6f  s_dir / 'cell_mo
-00000800: 6465 6c73 2729 2c20 7374 7228 7665 7273  dels'), str(vers
-00000810: 696f 6e5f 666f 6c64 6572 202f 2027 6365  ion_folder / 'ce
-00000820: 6c6c 5f6d 6f64 656c 7327 2929 0a20 2020  ll_models')).   
-00000830: 2020 2020 2064 6566 6175 6c74 5f69 6e66       default_inf
-00000840: 6f20 3d20 7b27 7465 6d70 6c61 7465 735f  o = {'templates_
-00000850: 7061 7261 6d73 273a 2073 7472 2876 6572  params': str(ver
-00000860: 7369 6f6e 5f66 6f6c 6465 7220 2f20 2764  sion_folder / 'd
-00000870: 6566 6175 6c74 5f70 6172 616d 7327 202f  efault_params' /
-00000880: 2027 7465 6d70 6c61 7465 735f 7061 7261   'templates_para
-00000890: 6d73 2e79 616d 6c27 292c 0a20 2020 2020  ms.yaml'),.     
-000008a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000008b0: 2020 2027 7265 636f 7264 696e 6773 5f70     'recordings_p
-000008c0: 6172 616d 7327 3a20 7374 7228 7665 7273  arams': str(vers
-000008d0: 696f 6e5f 666f 6c64 6572 202f 2027 6465  ion_folder / 'de
-000008e0: 6661 756c 745f 7061 7261 6d73 2720 2f20  fault_params' / 
-000008f0: 2772 6563 6f72 6469 6e67 735f 7061 7261  'recordings_para
-00000900: 6d73 2e79 616d 6c27 292c 0a20 2020 2020  ms.yaml'),.     
-00000910: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00000920: 2020 2027 7465 6d70 6c61 7465 735f 666f     'templates_fo
-00000930: 6c64 6572 273a 2073 7472 2876 6572 7369  lder': str(versi
-00000940: 6f6e 5f66 6f6c 6465 7220 2f20 2774 656d  on_folder / 'tem
-00000950: 706c 6174 6573 2729 2c0a 2020 2020 2020  plates'),.      
-00000960: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00000970: 2020 2772 6563 6f72 6469 6e67 735f 666f    'recordings_fo
-00000980: 6c64 6572 273a 2073 7472 2876 6572 7369  lder': str(versi
-00000990: 6f6e 5f66 6f6c 6465 7220 2f20 2772 6563  on_folder / 'rec
-000009a0: 6f72 6469 6e67 7327 292c 0a20 2020 2020  ordings'),.     
-000009b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000009c0: 2020 2027 6365 6c6c 5f6d 6f64 656c 735f     'cell_models_
-000009d0: 666f 6c64 6572 273a 2073 7472 2876 6572  folder': str(ver
-000009e0: 7369 6f6e 5f66 6f6c 6465 7220 2f20 2763  sion_folder / 'c
-000009f0: 656c 6c5f 6d6f 6465 6c73 2720 2f20 2762  ell_models' / 'b
-00000a00: 6270 2729 7d0a 2020 2020 2020 2020 7769  bp')}.        wi
-00000a10: 7468 2028 7665 7273 696f 6e5f 666f 6c64  th (version_fold
-00000a20: 6572 202f 2027 6d65 6172 6563 2e63 6f6e  er / 'mearec.con
-00000a30: 6627 292e 6f70 656e 2827 7727 2920 6173  f').open('w') as
-00000a40: 2066 3a0a 2020 2020 2020 2020 2020 2020   f:.            
-00000a50: 7961 6d6c 2e64 756d 7028 6465 6661 756c  yaml.dump(defaul
-00000a60: 745f 696e 666f 2c20 6629 0a20 2020 2065  t_info, f).    e
-00000a70: 6c73 653a 0a20 2020 2020 2020 2077 6974  lse:.        wit
-00000a80: 6820 2876 6572 7369 6f6e 5f66 6f6c 6465  h (version_folde
-00000a90: 7220 2f20 276d 6561 7265 632e 636f 6e66  r / 'mearec.conf
-00000aa0: 2729 2e6f 7065 6e28 2920 6173 2066 3a0a  ').open() as f:.
-00000ab0: 2020 2020 2020 2020 2020 2020 6966 2075              if u
-00000ac0: 7365 5f6c 6f61 6465 723a 0a20 2020 2020  se_loader:.     
-00000ad0: 2020 2020 2020 2020 2020 2064 6566 6175             defau
-00000ae0: 6c74 5f69 6e66 6f20 3d20 7961 6d6c 2e6c  lt_info = yaml.l
-00000af0: 6f61 6428 662c 204c 6f61 6465 723d 7961  oad(f, Loader=ya
-00000b00: 6d6c 2e46 756c 6c4c 6f61 6465 7229 0a20  ml.FullLoader). 
-00000b10: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
-00000b20: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00000b30: 2064 6566 6175 6c74 5f69 6e66 6f20 3d20   default_info = 
-00000b40: 7961 6d6c 2e6c 6f61 6428 6629 0a20 2020  yaml.load(f).   
-00000b50: 2072 6574 7572 6e20 6465 6661 756c 745f   return default_
-00000b60: 696e 666f 2c20 7374 7228 6d65 6172 6563  info, str(mearec
-00000b70: 5f68 6f6d 6529 0a0a 0a64 6566 2067 6574  _home)...def get
-00000b80: 5f64 6566 6175 6c74 5f63 656c 6c5f 6d6f  _default_cell_mo
-00000b90: 6465 6c73 5f66 6f6c 6465 7228 293a 0a20  dels_folder():. 
-00000ba0: 2020 2022 2222 0a20 2020 2052 6574 7572     """.    Retur
-00000bb0: 6e73 2064 6566 6175 6c74 2063 656c 6c20  ns default cell 
-00000bc0: 6d6f 6465 6c73 2066 6f6c 6465 722e 0a0a  models folder...
-00000bd0: 2020 2020 5265 7475 726e 730a 2020 2020      Returns.    
-00000be0: 2d2d 2d2d 2d2d 2d0a 2020 2020 6365 6c6c  -------.    cell
-00000bf0: 5f6d 6f64 656c 735f 666f 6c64 6572 203a  _models_folder :
-00000c00: 2073 7472 0a20 2020 2020 2020 2050 6174   str.        Pat
-00000c10: 6820 746f 2064 6566 6175 6c74 2063 656c  h to default cel
-00000c20: 6c20 6d6f 6465 6c73 2066 6f6c 6465 720a  l models folder.
-00000c30: 2020 2020 2222 220a 2020 2020 6465 6661      """.    defa
-00000c40: 756c 745f 696e 666f 2c20 6d65 6172 6563  ult_info, mearec
-00000c50: 5f68 6f6d 6520 3d20 6765 745f 6465 6661  _home = get_defa
-00000c60: 756c 745f 636f 6e66 6967 2829 0a20 2020  ult_config().   
-00000c70: 2063 656c 6c5f 6d6f 6465 6c73 5f66 6f6c   cell_models_fol
-00000c80: 6465 7220 3d20 6465 6661 756c 745f 696e  der = default_in
-00000c90: 666f 5b27 6365 6c6c 5f6d 6f64 656c 735f  fo['cell_models_
-00000ca0: 666f 6c64 6572 275d 0a0a 2020 2020 7265  folder']..    re
-00000cb0: 7475 726e 2063 656c 6c5f 6d6f 6465 6c73  turn cell_models
-00000cc0: 5f66 6f6c 6465 720a 0a0a 6465 6620 6765  _folder...def ge
-00000cd0: 745f 6465 6661 756c 745f 7465 6d70 6c61  t_default_templa
-00000ce0: 7465 735f 7061 7261 6d73 2829 3a0a 2020  tes_params():.  
-00000cf0: 2020 2222 220a 2020 2020 5265 7475 726e    """.    Return
-00000d00: 7320 6465 6661 756c 7420 7465 6d70 6c61  s default templa
-00000d10: 7465 7320 7061 7261 6d65 7465 7273 2e0a  tes parameters..
-00000d20: 0a20 2020 2052 6574 7572 6e73 0a20 2020  .    Returns.   
-00000d30: 202d 2d2d 2d2d 2d2d 0a20 2020 2074 656d   -------.    tem
-00000d40: 706c 6174 6573 5f70 6172 616d 7320 3a20  plates_params : 
-00000d50: 6469 6374 0a20 2020 2020 2020 2044 6963  dict.        Dic
-00000d60: 7469 6f6e 6172 7920 7769 7468 2064 6566  tionary with def
-00000d70: 6175 6c74 2074 6570 6c61 7465 7320 7061  ault teplates pa
-00000d80: 7261 6d65 7465 7273 0a20 2020 2022 2222  rameters.    """
-00000d90: 0a20 2020 2064 6566 6175 6c74 5f69 6e66  .    default_inf
-00000da0: 6f2c 206d 6561 7265 635f 686f 6d65 203d  o, mearec_home =
-00000db0: 2067 6574 5f64 6566 6175 6c74 5f63 6f6e   get_default_con
-00000dc0: 6669 6728 290a 2020 2020 7465 6d70 6c61  fig().    templa
-00000dd0: 7465 735f 7061 7261 6d73 5f66 696c 6520  tes_params_file 
-00000de0: 3d20 6465 6661 756c 745f 696e 666f 5b27  = default_info['
-00000df0: 7465 6d70 6c61 7465 735f 7061 7261 6d73  templates_params
-00000e00: 275d 0a0a 2020 2020 2320 6c6f 6164 2074  ']..    # load t
-00000e10: 656d 706c 6174 6520 7061 7261 6d65 7465  emplate paramete
-00000e20: 7273 0a20 2020 2077 6974 6820 6f70 656e  rs.    with open
-00000e30: 2874 656d 706c 6174 6573 5f70 6172 616d  (templates_param
-00000e40: 735f 6669 6c65 2c20 2772 2729 2061 7320  s_file, 'r') as 
-00000e50: 663a 0a20 2020 2020 2020 2069 6620 7573  f:.        if us
-00000e60: 655f 6c6f 6164 6572 3a0a 2020 2020 2020  e_loader:.      
-00000e70: 2020 2020 2020 7465 6d70 6c61 7465 735f        templates_
-00000e80: 7061 7261 6d73 203d 2079 616d 6c2e 6c6f  params = yaml.lo
-00000e90: 6164 2866 2c20 4c6f 6164 6572 3d79 616d  ad(f, Loader=yam
-00000ea0: 6c2e 4675 6c6c 4c6f 6164 6572 290a 2020  l.FullLoader).  
-00000eb0: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
-00000ec0: 2020 2020 2020 2020 7465 6d70 6c61 7465          template
-00000ed0: 735f 7061 7261 6d73 203d 2079 616d 6c2e  s_params = yaml.
-00000ee0: 6c6f 6164 2866 290a 2020 2020 7265 7475  load(f).    retu
-00000ef0: 726e 2074 656d 706c 6174 6573 5f70 6172  rn templates_par
-00000f00: 616d 730a 0a0a 6465 6620 6765 745f 6465  ams...def get_de
-00000f10: 6661 756c 745f 7265 636f 7264 696e 6773  fault_recordings
-00000f20: 5f70 6172 616d 7328 293a 0a20 2020 2022  _params():.    "
-00000f30: 2222 0a20 2020 2052 6574 7572 6e73 2064  "".    Returns d
-00000f40: 6566 6175 6c74 2072 6563 6f72 6469 6e67  efault recording
-00000f50: 7320 7061 7261 6d65 7465 7273 2e0a 0a20  s parameters... 
-00000f60: 2020 2052 6574 7572 6e73 0a20 2020 202d     Returns.    -
-00000f70: 2d2d 2d2d 2d2d 0a20 2020 2072 6563 6f72  ------.    recor
-00000f80: 6469 6e67 735f 7061 7261 6d73 203a 2064  dings_params : d
-00000f90: 6963 740a 2020 2020 2020 2020 4469 6374  ict.        Dict
-00000fa0: 696f 6e61 7279 2077 6974 6820 6465 6661  ionary with defa
-00000fb0: 756c 7420 7265 636f 7264 696e 6720 7061  ult recording pa
-00000fc0: 7261 6d65 7465 7273 0a20 2020 2022 2222  rameters.    """
-00000fd0: 0a20 2020 2064 6566 6175 6c74 5f69 6e66  .    default_inf
-00000fe0: 6f2c 206d 6561 7265 635f 686f 6d65 203d  o, mearec_home =
-00000ff0: 2067 6574 5f64 6566 6175 6c74 5f63 6f6e   get_default_con
-00001000: 6669 6728 290a 2020 2020 7265 636f 7264  fig().    record
-00001010: 696e 6773 5f70 6172 616d 735f 6669 6c65  ings_params_file
-00001020: 203d 2064 6566 6175 6c74 5f69 6e66 6f5b   = default_info[
-00001030: 2772 6563 6f72 6469 6e67 735f 7061 7261  'recordings_para
-00001040: 6d73 275d 0a0a 2020 2020 2320 6c6f 6164  ms']..    # load
-00001050: 2074 656d 706c 6174 6520 7061 7261 6d65   template parame
-00001060: 7465 7273 0a20 2020 2077 6974 6820 6f70  ters.    with op
-00001070: 656e 2872 6563 6f72 6469 6e67 735f 7061  en(recordings_pa
-00001080: 7261 6d73 5f66 696c 652c 2027 7227 2920  rams_file, 'r') 
-00001090: 6173 2066 3a0a 2020 2020 2020 2020 6966  as f:.        if
-000010a0: 2075 7365 5f6c 6f61 6465 723a 0a20 2020   use_loader:.   
-000010b0: 2020 2020 2020 2020 2072 6563 6f72 6469           recordi
-000010c0: 6e67 735f 7061 7261 6d73 203d 2079 616d  ngs_params = yam
-000010d0: 6c2e 6c6f 6164 2866 2c20 4c6f 6164 6572  l.load(f, Loader
-000010e0: 3d79 616d 6c2e 4675 6c6c 4c6f 6164 6572  =yaml.FullLoader
-000010f0: 290a 2020 2020 2020 2020 656c 7365 3a0a  ).        else:.
-00001100: 2020 2020 2020 2020 2020 2020 7265 636f              reco
-00001110: 7264 696e 6773 5f70 6172 616d 7320 3d20  rdings_params = 
-00001120: 7961 6d6c 2e6c 6f61 6428 6629 0a20 2020  yaml.load(f).   
-00001130: 2072 6574 7572 6e20 7265 636f 7264 696e   return recordin
-00001140: 6773 5f70 6172 616d 730a 0a0a 6465 6620  gs_params...def 
-00001150: 6765 745f 6465 6661 756c 745f 6472 6966  get_default_drif
-00001160: 745f 6469 6374 2829 3a0a 2020 2020 7265  t_dict():.    re
-00001170: 7475 726e 207b 2264 7269 6674 5f6d 6f64  turn {"drift_mod
-00001180: 655f 7370 6565 6422 3a20 2773 6c6f 7727  e_speed": 'slow'
-00001190: 2c20 0a20 2020 2020 2020 2020 2020 2022  , .            "
-000011a0: 6472 6966 745f 6d6f 6465 5f70 726f 6265  drift_mode_probe
-000011b0: 223a 2027 7269 6769 6427 2c0a 2020 2020  ": 'rigid',.    
-000011c0: 2020 2020 2020 2020 2264 7269 6674 5f66          "drift_f
-000011d0: 7322 3a20 3130 302c 0a20 2020 2020 2020  s": 100,.       
-000011e0: 2020 2020 2022 6e6f 6e5f 7269 6769 645f       "non_rigid_
-000011f0: 6772 6164 6965 6e74 5f6d 6f64 6522 3a20  gradient_mode": 
-00001200: 276c 696e 6561 7227 2c0a 2020 2020 2020  'linear',.      
-00001210: 2020 2020 2020 2273 6c6f 775f 6472 6966        "slow_drif
-00001220: 745f 7665 6c6f 6369 7479 223a 2035 2c0a  t_velocity": 5,.
-00001230: 2020 2020 2020 2020 2020 2020 2273 6c6f              "slo
-00001240: 775f 6472 6966 745f 616d 706c 6974 7564  w_drift_amplitud
-00001250: 6522 3a20 4e6f 6e65 2c0a 2020 2020 2020  e": None,.      
-00001260: 2020 2020 2020 2273 6c6f 775f 6472 6966        "slow_drif
-00001270: 745f 7761 7665 666f 726d 223a 2027 7472  t_waveform": 'tr
-00001280: 6961 6e67 6c75 6172 272c 0a20 2020 2020  iangluar',.     
-00001290: 2020 2020 2020 2022 6661 7374 5f64 7269         "fast_dri
-000012a0: 6674 5f70 6572 696f 6422 3a20 3130 2c0a  ft_period": 10,.
-000012b0: 2020 2020 2020 2020 2020 2020 2266 6173              "fas
-000012c0: 745f 6472 6966 745f 6d61 785f 6a75 6d70  t_drift_max_jump
-000012d0: 223a 2032 302c 0a20 2020 2020 2020 2020  ": 20,.         
-000012e0: 2020 2022 6661 7374 5f64 7269 6674 5f6d     "fast_drift_m
-000012f0: 696e 5f6a 756d 7022 3a20 352c 0a20 2020  in_jump": 5,.   
-00001300: 2020 2020 2020 2020 2022 745f 7374 6172           "t_star
-00001310: 745f 6472 6966 7422 3a20 302c 0a20 2020  t_drift": 0,.   
-00001320: 2020 2020 2020 2020 2022 745f 656e 645f           "t_end_
-00001330: 6472 6966 7422 3a20 4e6f 6e65 7d0a 2020  drift": None}.  
-00001340: 2020 0a0a 6465 6620 6176 6169 6c61 626c    ..def availabl
-00001350: 655f 7072 6f62 6573 2829 3a0a 2020 2020  e_probes():.    
-00001360: 2222 220a 2020 2020 5265 7475 726e 7320  """.    Returns 
-00001370: 6c69 7374 206f 6620 6176 6169 6c61 626c  list of availabl
-00001380: 6520 7072 6f62 6573 0a0a 2020 2020 5265  e probes..    Re
-00001390: 7475 726e 730a 2020 2020 2d2d 2d2d 2d2d  turns.    ------
-000013a0: 2d0a 2020 2020 7072 6f62 655f 6c69 7374  -.    probe_list
-000013b0: 203a 206c 6973 740a 2020 2020 2020 2020   : list.        
-000013c0: 4c69 7374 206f 6620 6176 6169 6c61 626c  List of availabl
-000013d0: 6520 7072 6f62 6573 2069 6e20 4d45 4175  e probes in MEAu
-000013e0: 7469 6c69 7479 0a20 2020 2022 2222 0a20  tility.    """. 
-000013f0: 2020 2072 6574 7572 6e20 6d75 2e72 6574     return mu.ret
-00001400: 7572 6e5f 6d65 615f 6c69 7374 2829 0a0a  urn_mea_list()..
-00001410: 0a23 2323 204c 4f41 4420 4655 4e43 5449  .### LOAD FUNCTI
-00001420: 4f4e 5320 2323 230a 6465 6620 6c6f 6164  ONS ###.def load
-00001430: 5f74 6d70 5f65 6170 2874 656d 706c 6174  _tmp_eap(templat
-00001440: 6573 5f66 6f6c 6465 722c 2063 656c 6c74  es_folder, cellt
-00001450: 7970 6573 3d4e 6f6e 652c 2073 616d 706c  ypes=None, sampl
-00001460: 6573 5f70 6572 5f63 6174 3d4e 6f6e 652c  es_per_cat=None,
-00001470: 2076 6572 626f 7365 3d46 616c 7365 293a   verbose=False):
-00001480: 0a20 2020 2022 2222 0a20 2020 204c 6f61  .    """.    Loa
-00001490: 6473 2045 4150 2066 726f 6d20 7465 6d70  ds EAP from temp
-000014a0: 6f72 6172 7920 666f 6c64 6572 2e0a 0a20  orary folder... 
-000014b0: 2020 2050 6172 616d 6574 6572 730a 2020     Parameters.  
-000014c0: 2020 2d2d 2d2d 2d2d 2d2d 2d2d 0a20 2020    ----------.   
-000014d0: 2074 656d 706c 6174 6573 5f66 6f6c 6465   templates_folde
-000014e0: 7220 3a20 7374 720a 2020 2020 2020 2020  r : str.        
-000014f0: 5061 7468 2074 6f20 7465 6d70 6f72 6172  Path to temporar
-00001500: 7920 666f 6c64 6572 0a20 2020 2063 656c  y folder.    cel
-00001510: 6c74 7970 6573 203a 206c 6973 7420 286f  ltypes : list (o
-00001520: 7074 696f 6e61 6c29 0a20 2020 2020 2020  ptional).       
-00001530: 204c 6973 7420 6f66 2063 656c 6c74 7970   List of celltyp
-00001540: 6573 2074 6f20 6265 206c 6f61 6465 640a  es to be loaded.
-00001550: 2020 2020 7361 6d70 6c65 735f 7065 725f      samples_per_
-00001560: 6361 7420 3a20 696e 7420 286f 7074 696f  cat : int (optio
-00001570: 6e61 6c29 0a20 2020 2020 2020 2054 6865  nal).        The
-00001580: 206e 756d 6265 7220 6f66 2065 6170 2074   number of eap t
-00001590: 6f20 6c6f 6164 2070 6572 2063 6174 6567  o load per categ
-000015a0: 6f72 790a 0a20 2020 2052 6574 7572 6e73  ory..    Returns
-000015b0: 0a20 2020 202d 2d2d 2d2d 2d2d 0a20 2020  .    -------.   
-000015c0: 2074 656d 706c 6174 6573 203a 206e 702e   templates : np.
-000015d0: 6172 7261 790a 2020 2020 2020 2020 5465  array.        Te
-000015e0: 6d70 6c61 7465 7320 286e 5f65 6170 2c20  mplates (n_eap, 
-000015f0: 6e5f 656c 6563 2c20 6e5f 7361 6d70 6c65  n_elec, n_sample
-00001600: 290a 2020 2020 6c6f 6361 7469 6f6e 7320  ).    locations 
-00001610: 3a20 6e70 2e61 7272 6179 0a20 2020 2020  : np.array.     
-00001620: 2020 204c 6f63 6174 696f 6e73 2028 6e5f     Locations (n_
-00001630: 6561 702c 2033 290a 2020 2020 726f 7461  eap, 3).    rota
-00001640: 7469 6f6e 7320 3a20 6e70 2e61 7272 6179  tions : np.array
-00001650: 0a20 2020 2020 2020 2052 6f74 6174 696f  .        Rotatio
-00001660: 6e73 2028 6e5f 6561 702c 2033 290a 2020  ns (n_eap, 3).  
-00001670: 2020 6365 6c6c 7479 7065 7320 3a20 6e70    celltypes : np
-00001680: 2e61 7272 6179 0a20 2020 2020 2020 2043  .array.        C
-00001690: 656c 6c20 7479 7065 7320 286e 5f65 6170  ell types (n_eap
-000016a0: 290a 0a20 2020 2022 2222 0a20 2020 2069  )..    """.    i
-000016b0: 6620 7665 7262 6f73 653a 0a20 2020 2020  f verbose:.     
-000016c0: 2020 2070 7269 6e74 2822 4c6f 6164 696e     print("Loadin
-000016d0: 6720 6561 7020 6461 7461 202e 2e2e 2229  g eap data ...")
-000016e0: 0a0a 2020 2020 7465 6d70 6c61 7465 735f  ..    templates_
-000016f0: 666f 6c64 6572 203d 2050 6174 6828 7465  folder = Path(te
-00001700: 6d70 6c61 7465 735f 666f 6c64 6572 290a  mplates_folder).
-00001710: 2020 2020 6561 706c 6973 7420 3d20 5b66      eaplist = [f
-00001720: 2066 6f72 2066 2069 6e20 7465 6d70 6c61   for f in templa
-00001730: 7465 735f 666f 6c64 6572 2e69 7465 7264  tes_folder.iterd
-00001740: 6972 2829 2069 6620 662e 6e61 6d65 2e73  ir() if f.name.s
-00001750: 7461 7274 7377 6974 6828 2765 6170 2729  tartswith('eap')
-00001760: 5d0a 2020 2020 6c6f 636c 6973 7420 3d20  ].    loclist = 
-00001770: 5b66 2066 6f72 2066 2069 6e20 7465 6d70  [f for f in temp
-00001780: 6c61 7465 735f 666f 6c64 6572 2e69 7465  lates_folder.ite
-00001790: 7264 6972 2829 2069 6620 662e 6e61 6d65  rdir() if f.name
-000017a0: 2e73 7461 7274 7377 6974 6828 2770 6f73  .startswith('pos
-000017b0: 2729 5d0a 2020 2020 726f 746c 6973 7420  ')].    rotlist 
-000017c0: 3d20 5b66 2066 6f72 2066 2069 6e20 7465  = [f for f in te
-000017d0: 6d70 6c61 7465 735f 666f 6c64 6572 2e69  mplates_folder.i
-000017e0: 7465 7264 6972 2829 2069 6620 662e 6e61  terdir() if f.na
-000017f0: 6d65 2e73 7461 7274 7377 6974 6828 2772  me.startswith('r
-00001800: 6f74 2729 5d0a 0a20 2020 2065 6170 5f6c  ot')]..    eap_l
-00001810: 6973 7420 3d20 5b5d 0a20 2020 206c 6f63  ist = [].    loc
-00001820: 5f6c 6973 7420 3d20 5b5d 0a20 2020 2072  _list = [].    r
-00001830: 6f74 5f6c 6973 7420 3d20 5b5d 0a20 2020  ot_list = [].   
-00001840: 2063 6174 5f6c 6973 7420 3d20 5b5d 0a0a   cat_list = []..
-00001850: 2020 2020 6561 706c 6973 7420 3d20 736f      eaplist = so
-00001860: 7274 6564 2865 6170 6c69 7374 290a 2020  rted(eaplist).  
-00001870: 2020 6c6f 636c 6973 7420 3d20 736f 7274    loclist = sort
-00001880: 6564 286c 6f63 6c69 7374 290a 2020 2020  ed(loclist).    
-00001890: 726f 746c 6973 7420 3d20 736f 7274 6564  rotlist = sorted
-000018a0: 2872 6f74 6c69 7374 290a 0a20 2020 206c  (rotlist)..    l
-000018b0: 6f61 6465 645f 6361 7465 676f 7269 6573  oaded_categories
-000018c0: 203d 2073 6574 2829 0a20 2020 2069 676e   = set().    ign
-000018d0: 6f72 6564 5f63 6174 6567 6f72 6965 7320  ored_categories 
-000018e0: 3d20 7365 7428 290a 0a20 2020 2066 6f72  = set()..    for
-000018f0: 2069 6478 2c20 6620 696e 2065 6e75 6d65   idx, f in enume
-00001900: 7261 7465 2865 6170 6c69 7374 293a 0a20  rate(eaplist):. 
-00001910: 2020 2020 2020 2063 656c 6c74 7970 6520         celltype 
-00001920: 3d20 662e 7061 7274 735b 2d31 5d2e 7370  = f.parts[-1].sp
-00001930: 6c69 7428 272d 2729 5b31 5d5b 3a2d 345d  lit('-')[1][:-4]
-00001940: 0a20 2020 2020 2020 2069 6620 7665 7262  .        if verb
-00001950: 6f73 653a 0a20 2020 2020 2020 2020 2020  ose:.           
-00001960: 2070 7269 6e74 2827 6c6f 6164 696e 6720   print('loading 
-00001970: 6365 6c6c 2074 7970 653a 2027 2c20 6629  cell type: ', f)
-00001980: 0a20 2020 2020 2020 2069 6620 6365 6c6c  .        if cell
-00001990: 7479 7065 7320 6973 206e 6f74 204e 6f6e  types is not Non
-000019a0: 653a 0a20 2020 2020 2020 2020 2020 2069  e:.            i
-000019b0: 6620 6365 6c6c 7479 7065 2069 6e20 6365  f celltype in ce
-000019c0: 6c6c 7479 7065 733a 0a20 2020 2020 2020  lltypes:.       
-000019d0: 2020 2020 2020 2020 2065 6170 7320 3d20           eaps = 
-000019e0: 6e70 2e6c 6f61 6428 7374 7228 6561 706c  np.load(str(eapl
-000019f0: 6973 745b 6964 785d 2929 0a20 2020 2020  ist[idx])).     
-00001a00: 2020 2020 2020 2020 2020 206c 6f63 7320             locs 
-00001a10: 3d20 6e70 2e6c 6f61 6428 7374 7228 6c6f  = np.load(str(lo
-00001a20: 636c 6973 745b 6964 785d 2929 0a20 2020  clist[idx])).   
-00001a30: 2020 2020 2020 2020 2020 2020 2072 6f74               rot
-00001a40: 7320 3d20 6e70 2e6c 6f61 6428 7374 7228  s = np.load(str(
-00001a50: 726f 746c 6973 745b 6964 785d 2929 0a0a  rotlist[idx]))..
-00001a60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001a70: 6966 2073 616d 706c 6573 5f70 6572 5f63  if samples_per_c
-00001a80: 6174 2069 7320 4e6f 6e65 206f 7220 7361  at is None or sa
-00001a90: 6d70 6c65 735f 7065 725f 6361 7420 3e20  mples_per_cat > 
-00001aa0: 6c65 6e28 6561 7073 293a 0a20 2020 2020  len(eaps):.     
-00001ab0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-00001ac0: 616d 706c 6573 5f74 6f5f 7265 6164 203d  amples_to_read =
-00001ad0: 206c 656e 2865 6170 7329 0a20 2020 2020   len(eaps).     
-00001ae0: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
+00000000: 696d 706f 7274 206f 730a 696d 706f 7274  import os.import
+00000010: 2073 6875 7469 6c0a 6672 6f6d 2063 6f70   shutil.from cop
+00000020: 7920 696d 706f 7274 2063 6f70 792c 2064  y import copy, d
+00000030: 6565 7063 6f70 790a 6672 6f6d 2064 6174  eepcopy.from dat
+00000040: 6574 696d 6520 696d 706f 7274 2064 6174  etime import dat
+00000050: 6574 696d 650a 6672 6f6d 2070 6174 686c  etime.from pathl
+00000060: 6962 2069 6d70 6f72 7420 5061 7468 0a0a  ib import Path..
+00000070: 696d 706f 7274 2068 3570 790a 696d 706f  import h5py.impo
+00000080: 7274 204d 4541 7574 696c 6974 7920 6173  rt MEAutility as
+00000090: 206d 750a 696d 706f 7274 206e 656f 0a69   mu.import neo.i
+000000a0: 6d70 6f72 7420 6e75 6d70 7920 6173 206e  mport numpy as n
+000000b0: 700a 696d 706f 7274 2071 7561 6e74 6974  p.import quantit
+000000c0: 6965 7320 6173 2070 710a 696d 706f 7274  ies as pq.import
+000000d0: 2073 6369 7079 2e73 6967 6e61 6c20 6173   scipy.signal as
+000000e0: 2073 730a 696d 706f 7274 2079 616d 6c0a   ss.import yaml.
+000000f0: 6672 6f6d 206a 6f62 6c69 6220 696d 706f  from joblib impo
+00000100: 7274 2050 6172 616c 6c65 6c2c 2064 656c  rt Parallel, del
+00000110: 6179 6564 0a66 726f 6d20 6c61 7a79 5f6f  ayed.from lazy_o
+00000120: 7073 2069 6d70 6f72 7420 4461 7461 7365  ps import Datase
+00000130: 7456 6965 770a 6672 6f6d 2070 6163 6b61  tView.from packa
+00000140: 6769 6e67 2e76 6572 7369 6f6e 2069 6d70  ging.version imp
+00000150: 6f72 7420 7061 7273 650a 6672 6f6d 2071  ort parse.from q
+00000160: 7561 6e74 6974 6965 7320 696d 706f 7274  uantities import
+00000170: 2051 7561 6e74 6974 790a 0a66 726f 6d20   Quantity..from 
+00000180: 2e20 696d 706f 7274 205f 5f76 6572 7369  . import __versi
+00000190: 6f6e 5f5f 2061 7320 6d65 6172 6563 5f76  on__ as mearec_v
+000001a0: 6572 7369 6f6e 0a0a 6966 2070 6172 7365  ersion..if parse
+000001b0: 2879 616d 6c2e 5f5f 7665 7273 696f 6e5f  (yaml.__version_
+000001c0: 5f29 203e 3d20 7061 7273 6528 2235 2e30  _) >= parse("5.0
+000001d0: 2e30 2229 3a0a 2020 2020 7573 655f 6c6f  .0"):.    use_lo
+000001e0: 6164 6572 203d 2054 7275 650a 656c 7365  ader = True.else
+000001f0: 3a0a 2020 2020 7573 655f 6c6f 6164 6572  :.    use_loader
+00000200: 203d 2046 616c 7365 0a0a 0a64 6566 2073   = False...def s
+00000210: 6166 655f 7961 6d6c 5f6c 6f61 6428 7961  afe_yaml_load(ya
+00000220: 6d6c 5f66 696c 6529 3a0a 2020 2020 7769  ml_file):.    wi
+00000230: 7468 206f 7065 6e28 7961 6d6c 5f66 696c  th open(yaml_fil
+00000240: 652c 2022 7222 2920 6173 2066 3a0a 2020  e, "r") as f:.  
+00000250: 2020 2020 2020 6966 2075 7365 5f6c 6f61        if use_loa
+00000260: 6465 723a 0a20 2020 2020 2020 2020 2020  der:.           
+00000270: 2064 6174 6120 3d20 7961 6d6c 2e6c 6f61   data = yaml.loa
+00000280: 6428 662c 204c 6f61 6465 723d 7961 6d6c  d(f, Loader=yaml
+00000290: 2e46 756c 6c4c 6f61 6465 7229 0a20 2020  .FullLoader).   
+000002a0: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+000002b0: 2020 2020 2020 2064 6174 6120 3d20 7961         data = ya
+000002c0: 6d6c 2e6c 6f61 6428 6629 0a20 2020 2072  ml.load(f).    r
+000002d0: 6574 7572 6e20 6461 7461 0a0a 0a23 2323  eturn data...###
+000002e0: 2047 4554 2044 4546 4155 4c54 2053 4554   GET DEFAULT SET
+000002f0: 5449 4e47 5320 2323 230a 6465 6620 6765  TINGS ###.def ge
+00000300: 745f 6465 6661 756c 745f 636f 6e66 6967  t_default_config
+00000310: 2870 7269 6e74 5f76 6572 7369 6f6e 3d46  (print_version=F
+00000320: 616c 7365 293a 0a20 2020 2022 2222 0a20  alse):.    """. 
+00000330: 2020 2052 6574 7572 6e73 2064 6566 6175     Returns defau
+00000340: 6c74 5f69 6e66 6f20 616e 6420 6d65 6172  lt_info and mear
+00000350: 6563 5f68 6f6d 6520 7061 7468 2e0a 0a20  ec_home path... 
+00000360: 2020 2052 6574 7572 6e73 0a20 2020 202d     Returns.    -
+00000370: 2d2d 2d2d 2d2d 0a20 2020 2064 6566 6175  ------.    defau
+00000380: 6c74 5f69 6e66 6f20 3a20 6469 6374 0a20  lt_info : dict. 
+00000390: 2020 2020 2020 2044 6566 6175 6c74 5f69         Default_i
+000003a0: 6e66 6f20 6672 6f6d 2063 6f6e 6669 6720  nfo from config 
+000003b0: 6669 6c65 0a20 2020 206d 6561 7265 635f  file.    mearec_
+000003c0: 7061 7468 203a 2073 7472 0a20 2020 2020  path : str.     
+000003d0: 2020 204d 6561 7265 6320 686f 6d65 2070     Mearec home p
+000003e0: 6174 680a 2020 2020 2222 220a 2020 2020  ath.    """.    
+000003f0: 7468 6973 5f64 6972 2c20 7468 6973 5f66  this_dir, this_f
+00000400: 696c 656e 616d 6520 3d20 6f73 2e70 6174  ilename = os.pat
+00000410: 682e 7370 6c69 7428 5f5f 6669 6c65 5f5f  h.split(__file__
+00000420: 290a 2020 2020 7468 6973 5f64 6972 203d  ).    this_dir =
+00000430: 2050 6174 6828 7468 6973 5f64 6972 290a   Path(this_dir).
+00000440: 2020 2020 686f 6d65 203d 2050 6174 6828      home = Path(
+00000450: 6f73 2e70 6174 682e 6578 7061 6e64 7573  os.path.expandus
+00000460: 6572 2822 7e22 2929 0a20 2020 206d 6561  er("~")).    mea
+00000470: 7265 635f 686f 6d65 203d 2068 6f6d 6520  rec_home = home 
+00000480: 2f20 222e 636f 6e66 6967 2220 2f20 226d  / ".config" / "m
+00000490: 6561 7265 6322 0a20 2020 2076 6572 7369  earec".    versi
+000004a0: 6f6e 5f66 6f6c 6465 7220 3d20 6d65 6172  on_folder = mear
+000004b0: 6563 5f68 6f6d 6520 2f20 6d65 6172 6563  ec_home / mearec
+000004c0: 5f76 6572 7369 6f6e 0a0a 2020 2020 6966  _version..    if
+000004d0: 2070 7269 6e74 5f76 6572 7369 6f6e 3a0a   print_version:.
+000004e0: 2020 2020 2020 2020 7072 696e 7428 6622          print(f"
+000004f0: 4d45 4172 6563 2076 6572 7369 6f6e 3a20  MEArec version: 
+00000500: 7b6d 6561 7265 635f 7665 7273 696f 6e7d  {mearec_version}
+00000510: 5c6e 2229 0a0a 2020 2020 6966 206e 6f74  \n")..    if not
+00000520: 206d 6561 7265 635f 686f 6d65 2e69 735f   mearec_home.is_
+00000530: 6469 7228 293a 0a20 2020 2020 2020 206d  dir():.        m
+00000540: 6561 7265 635f 686f 6d65 2e6d 6b64 6972  earec_home.mkdir
+00000550: 2865 7869 7374 5f6f 6b3d 5472 7565 2c20  (exist_ok=True, 
+00000560: 7061 7265 6e74 733d 5472 7565 290a 0a20  parents=True).. 
+00000570: 2020 2069 6620 6e6f 7420 2876 6572 7369     if not (versi
+00000580: 6f6e 5f66 6f6c 6465 7220 2f20 226d 6561  on_folder / "mea
+00000590: 7265 632e 636f 6e66 2229 2e69 735f 6669  rec.conf").is_fi
+000005a0: 6c65 2829 3a0a 2020 2020 2020 2020 7665  le():.        ve
+000005b0: 7273 696f 6e5f 666f 6c64 6572 2e6d 6b64  rsion_folder.mkd
+000005c0: 6972 2865 7869 7374 5f6f 6b3d 5472 7565  ir(exist_ok=True
+000005d0: 2c20 7061 7265 6e74 733d 5472 7565 290a  , parents=True).
+000005e0: 2020 2020 2020 2020 7368 7574 696c 2e63          shutil.c
+000005f0: 6f70 7974 7265 6528 7374 7228 7468 6973  opytree(str(this
+00000600: 5f64 6972 202f 2022 6465 6661 756c 745f  _dir / "default_
+00000610: 7061 7261 6d73 2229 2c20 7374 7228 7665  params"), str(ve
+00000620: 7273 696f 6e5f 666f 6c64 6572 202f 2022  rsion_folder / "
+00000630: 6465 6661 756c 745f 7061 7261 6d73 2229  default_params")
+00000640: 290a 2020 2020 2020 2020 7368 7574 696c  ).        shutil
+00000650: 2e63 6f70 7974 7265 6528 7374 7228 7468  .copytree(str(th
+00000660: 6973 5f64 6972 202f 2022 6365 6c6c 5f6d  is_dir / "cell_m
+00000670: 6f64 656c 7322 292c 2073 7472 2876 6572  odels"), str(ver
+00000680: 7369 6f6e 5f66 6f6c 6465 7220 2f20 2263  sion_folder / "c
+00000690: 656c 6c5f 6d6f 6465 6c73 2229 290a 2020  ell_models")).  
+000006a0: 2020 2020 2020 6465 6661 756c 745f 696e        default_in
+000006b0: 666f 203d 207b 0a20 2020 2020 2020 2020  fo = {.         
+000006c0: 2020 2022 7465 6d70 6c61 7465 735f 7061     "templates_pa
+000006d0: 7261 6d73 223a 2073 7472 2876 6572 7369  rams": str(versi
+000006e0: 6f6e 5f66 6f6c 6465 7220 2f20 2264 6566  on_folder / "def
+000006f0: 6175 6c74 5f70 6172 616d 7322 202f 2022  ault_params" / "
+00000700: 7465 6d70 6c61 7465 735f 7061 7261 6d73  templates_params
+00000710: 2e79 616d 6c22 292c 0a20 2020 2020 2020  .yaml"),.       
+00000720: 2020 2020 2022 7265 636f 7264 696e 6773       "recordings
+00000730: 5f70 6172 616d 7322 3a20 7374 7228 7665  _params": str(ve
+00000740: 7273 696f 6e5f 666f 6c64 6572 202f 2022  rsion_folder / "
+00000750: 6465 6661 756c 745f 7061 7261 6d73 2220  default_params" 
+00000760: 2f20 2272 6563 6f72 6469 6e67 735f 7061  / "recordings_pa
+00000770: 7261 6d73 2e79 616d 6c22 292c 0a20 2020  rams.yaml"),.   
+00000780: 2020 2020 2020 2020 2022 7465 6d70 6c61           "templa
+00000790: 7465 735f 666f 6c64 6572 223a 2073 7472  tes_folder": str
+000007a0: 2876 6572 7369 6f6e 5f66 6f6c 6465 7220  (version_folder 
+000007b0: 2f20 2274 656d 706c 6174 6573 2229 2c0a  / "templates"),.
+000007c0: 2020 2020 2020 2020 2020 2020 2272 6563              "rec
+000007d0: 6f72 6469 6e67 735f 666f 6c64 6572 223a  ordings_folder":
+000007e0: 2073 7472 2876 6572 7369 6f6e 5f66 6f6c   str(version_fol
+000007f0: 6465 7220 2f20 2272 6563 6f72 6469 6e67  der / "recording
+00000800: 7322 292c 0a20 2020 2020 2020 2020 2020  s"),.           
+00000810: 2022 6365 6c6c 5f6d 6f64 656c 735f 666f   "cell_models_fo
+00000820: 6c64 6572 223a 2073 7472 2876 6572 7369  lder": str(versi
+00000830: 6f6e 5f66 6f6c 6465 7220 2f20 2263 656c  on_folder / "cel
+00000840: 6c5f 6d6f 6465 6c73 2220 2f20 2262 6270  l_models" / "bbp
+00000850: 2229 2c0a 2020 2020 2020 2020 7d0a 2020  "),.        }.  
+00000860: 2020 2020 2020 7769 7468 2028 7665 7273        with (vers
+00000870: 696f 6e5f 666f 6c64 6572 202f 2022 6d65  ion_folder / "me
+00000880: 6172 6563 2e63 6f6e 6622 292e 6f70 656e  arec.conf").open
+00000890: 2822 7722 2920 6173 2066 3a0a 2020 2020  ("w") as f:.    
+000008a0: 2020 2020 2020 2020 7961 6d6c 2e64 756d          yaml.dum
+000008b0: 7028 6465 6661 756c 745f 696e 666f 2c20  p(default_info, 
+000008c0: 6629 0a20 2020 2065 6c73 653a 0a20 2020  f).    else:.   
+000008d0: 2020 2020 2064 6566 6175 6c74 5f69 6e66       default_inf
+000008e0: 6f20 3d20 7361 6665 5f79 616d 6c5f 6c6f  o = safe_yaml_lo
+000008f0: 6164 2876 6572 7369 6f6e 5f66 6f6c 6465  ad(version_folde
+00000900: 7220 2f20 226d 6561 7265 632e 636f 6e66  r / "mearec.conf
+00000910: 2229 0a20 2020 2072 6574 7572 6e20 6465  ").    return de
+00000920: 6661 756c 745f 696e 666f 2c20 7374 7228  fault_info, str(
+00000930: 6d65 6172 6563 5f68 6f6d 6529 0a0a 0a64  mearec_home)...d
+00000940: 6566 2067 6574 5f64 6566 6175 6c74 5f63  ef get_default_c
+00000950: 656c 6c5f 6d6f 6465 6c73 5f66 6f6c 6465  ell_models_folde
+00000960: 7228 293a 0a20 2020 2022 2222 0a20 2020  r():.    """.   
+00000970: 2052 6574 7572 6e73 2064 6566 6175 6c74   Returns default
+00000980: 2063 656c 6c20 6d6f 6465 6c73 2066 6f6c   cell models fol
+00000990: 6465 722e 0a0a 2020 2020 5265 7475 726e  der...    Return
+000009a0: 730a 2020 2020 2d2d 2d2d 2d2d 2d0a 2020  s.    -------.  
+000009b0: 2020 6365 6c6c 5f6d 6f64 656c 735f 666f    cell_models_fo
+000009c0: 6c64 6572 203a 2073 7472 0a20 2020 2020  lder : str.     
+000009d0: 2020 2050 6174 6820 746f 2064 6566 6175     Path to defau
+000009e0: 6c74 2063 656c 6c20 6d6f 6465 6c73 2066  lt cell models f
+000009f0: 6f6c 6465 720a 2020 2020 2222 220a 2020  older.    """.  
+00000a00: 2020 6465 6661 756c 745f 696e 666f 2c20    default_info, 
+00000a10: 6d65 6172 6563 5f68 6f6d 6520 3d20 6765  mearec_home = ge
+00000a20: 745f 6465 6661 756c 745f 636f 6e66 6967  t_default_config
+00000a30: 2829 0a20 2020 2063 656c 6c5f 6d6f 6465  ().    cell_mode
+00000a40: 6c73 5f66 6f6c 6465 7220 3d20 6465 6661  ls_folder = defa
+00000a50: 756c 745f 696e 666f 5b22 6365 6c6c 5f6d  ult_info["cell_m
+00000a60: 6f64 656c 735f 666f 6c64 6572 225d 0a0a  odels_folder"]..
+00000a70: 2020 2020 7265 7475 726e 2063 656c 6c5f      return cell_
+00000a80: 6d6f 6465 6c73 5f66 6f6c 6465 720a 0a0a  models_folder...
+00000a90: 6465 6620 6765 745f 6465 6661 756c 745f  def get_default_
+00000aa0: 7465 6d70 6c61 7465 735f 7061 7261 6d73  templates_params
+00000ab0: 2829 3a0a 2020 2020 2222 220a 2020 2020  ():.    """.    
+00000ac0: 5265 7475 726e 7320 6465 6661 756c 7420  Returns default 
+00000ad0: 7465 6d70 6c61 7465 7320 7061 7261 6d65  templates parame
+00000ae0: 7465 7273 2e0a 0a20 2020 2052 6574 7572  ters...    Retur
+00000af0: 6e73 0a20 2020 202d 2d2d 2d2d 2d2d 0a20  ns.    -------. 
+00000b00: 2020 2074 656d 706c 6174 6573 5f70 6172     templates_par
+00000b10: 616d 7320 3a20 6469 6374 0a20 2020 2020  ams : dict.     
+00000b20: 2020 2044 6963 7469 6f6e 6172 7920 7769     Dictionary wi
+00000b30: 7468 2064 6566 6175 6c74 2074 6570 6c61  th default tepla
+00000b40: 7465 7320 7061 7261 6d65 7465 7273 0a20  tes parameters. 
+00000b50: 2020 2022 2222 0a20 2020 2064 6566 6175     """.    defau
+00000b60: 6c74 5f69 6e66 6f2c 206d 6561 7265 635f  lt_info, mearec_
+00000b70: 686f 6d65 203d 2067 6574 5f64 6566 6175  home = get_defau
+00000b80: 6c74 5f63 6f6e 6669 6728 290a 2020 2020  lt_config().    
+00000b90: 7465 6d70 6c61 7465 735f 7061 7261 6d73  templates_params
+00000ba0: 5f66 696c 6520 3d20 6465 6661 756c 745f  _file = default_
+00000bb0: 696e 666f 5b22 7465 6d70 6c61 7465 735f  info["templates_
+00000bc0: 7061 7261 6d73 225d 0a0a 2020 2020 2320  params"]..    # 
+00000bd0: 6c6f 6164 2074 656d 706c 6174 6520 7061  load template pa
+00000be0: 7261 6d65 7465 7273 0a20 2020 2074 656d  rameters.    tem
+00000bf0: 706c 6174 6573 5f70 6172 616d 7320 3d20  plates_params = 
+00000c00: 7361 6665 5f79 616d 6c5f 6c6f 6164 2874  safe_yaml_load(t
+00000c10: 656d 706c 6174 6573 5f70 6172 616d 735f  emplates_params_
+00000c20: 6669 6c65 290a 0a20 2020 2072 6574 7572  file)..    retur
+00000c30: 6e20 7465 6d70 6c61 7465 735f 7061 7261  n templates_para
+00000c40: 6d73 0a0a 0a64 6566 2067 6574 5f64 6566  ms...def get_def
+00000c50: 6175 6c74 5f72 6563 6f72 6469 6e67 735f  ault_recordings_
+00000c60: 7061 7261 6d73 2829 3a0a 2020 2020 2222  params():.    ""
+00000c70: 220a 2020 2020 5265 7475 726e 7320 6465  ".    Returns de
+00000c80: 6661 756c 7420 7265 636f 7264 696e 6773  fault recordings
+00000c90: 2070 6172 616d 6574 6572 732e 0a0a 2020   parameters...  
+00000ca0: 2020 5265 7475 726e 730a 2020 2020 2d2d    Returns.    --
+00000cb0: 2d2d 2d2d 2d0a 2020 2020 7265 636f 7264  -----.    record
+00000cc0: 696e 6773 5f70 6172 616d 7320 3a20 6469  ings_params : di
+00000cd0: 6374 0a20 2020 2020 2020 2044 6963 7469  ct.        Dicti
+00000ce0: 6f6e 6172 7920 7769 7468 2064 6566 6175  onary with defau
+00000cf0: 6c74 2072 6563 6f72 6469 6e67 2070 6172  lt recording par
+00000d00: 616d 6574 6572 730a 2020 2020 2222 220a  ameters.    """.
+00000d10: 2020 2020 6465 6661 756c 745f 696e 666f      default_info
+00000d20: 2c20 6d65 6172 6563 5f68 6f6d 6520 3d20  , mearec_home = 
+00000d30: 6765 745f 6465 6661 756c 745f 636f 6e66  get_default_conf
+00000d40: 6967 2829 0a20 2020 2072 6563 6f72 6469  ig().    recordi
+00000d50: 6e67 735f 7061 7261 6d73 5f66 696c 6520  ngs_params_file 
+00000d60: 3d20 6465 6661 756c 745f 696e 666f 5b22  = default_info["
+00000d70: 7265 636f 7264 696e 6773 5f70 6172 616d  recordings_param
+00000d80: 7322 5d0a 0a20 2020 2023 206c 6f61 6420  s"]..    # load 
+00000d90: 7465 6d70 6c61 7465 2070 6172 616d 6574  template paramet
+00000da0: 6572 730a 2020 2020 7265 636f 7264 696e  ers.    recordin
+00000db0: 6773 5f70 6172 616d 7320 3d20 7361 6665  gs_params = safe
+00000dc0: 5f79 616d 6c5f 6c6f 6164 2872 6563 6f72  _yaml_load(recor
+00000dd0: 6469 6e67 735f 7061 7261 6d73 5f66 696c  dings_params_fil
+00000de0: 6529 0a0a 2020 2020 7265 7475 726e 2072  e)..    return r
+00000df0: 6563 6f72 6469 6e67 735f 7061 7261 6d73  ecordings_params
+00000e00: 0a0a 0a64 6566 2067 6574 5f64 6566 6175  ...def get_defau
+00000e10: 6c74 5f64 7269 6674 5f64 6963 7428 293a  lt_drift_dict():
+00000e20: 0a20 2020 2072 6574 7572 6e20 7b0a 2020  .    return {.  
+00000e30: 2020 2020 2020 2264 7269 6674 5f6d 6f64        "drift_mod
+00000e40: 655f 7370 6565 6422 3a20 2273 6c6f 7722  e_speed": "slow"
+00000e50: 2c0a 2020 2020 2020 2020 2264 7269 6674  ,.        "drift
+00000e60: 5f6d 6f64 655f 7072 6f62 6522 3a20 2272  _mode_probe": "r
+00000e70: 6967 6964 222c 0a20 2020 2020 2020 2022  igid",.        "
+00000e80: 6472 6966 745f 6673 223a 2031 3030 2c0a  drift_fs": 100,.
+00000e90: 2020 2020 2020 2020 226e 6f6e 5f72 6967          "non_rig
+00000ea0: 6964 5f67 7261 6469 656e 745f 6d6f 6465  id_gradient_mode
+00000eb0: 223a 2022 6c69 6e65 6172 222c 0a20 2020  ": "linear",.   
+00000ec0: 2020 2020 2022 6e6f 6e5f 7269 6769 645f       "non_rigid_
+00000ed0: 6c69 6e65 6172 5f64 6972 6563 7469 6f6e  linear_direction
+00000ee0: 223a 2031 2c0a 2020 2020 2020 2020 226e  ": 1,.        "n
+00000ef0: 6f6e 5f72 6967 6964 5f73 7465 705f 6465  on_rigid_step_de
+00000f00: 7074 685f 626f 756e 6461 7279 223a 204e  pth_boundary": N
+00000f10: 6f6e 652c 0a20 2020 2020 2020 2022 6e6f  one,.        "no
+00000f20: 6e5f 7269 6769 645f 7374 6570 5f66 6163  n_rigid_step_fac
+00000f30: 746f 7273 223a 204e 6f6e 652c 0a20 2020  tors": None,.   
+00000f40: 2020 2020 2022 736c 6f77 5f64 7269 6674       "slow_drift
+00000f50: 5f76 656c 6f63 6974 7922 3a20 352c 0a20  _velocity": 5,. 
+00000f60: 2020 2020 2020 2022 736c 6f77 5f64 7269         "slow_dri
+00000f70: 6674 5f61 6d70 6c69 7475 6465 223a 204e  ft_amplitude": N
+00000f80: 6f6e 652c 0a20 2020 2020 2020 2022 736c  one,.        "sl
+00000f90: 6f77 5f64 7269 6674 5f77 6176 6566 6f72  ow_drift_wavefor
+00000fa0: 6d22 3a20 2274 7269 616e 676c 7561 7222  m": "triangluar"
+00000fb0: 2c0a 2020 2020 2020 2020 2266 6173 745f  ,.        "fast_
+00000fc0: 6472 6966 745f 7065 7269 6f64 223a 2031  drift_period": 1
+00000fd0: 302c 0a20 2020 2020 2020 2022 6661 7374  0,.        "fast
+00000fe0: 5f64 7269 6674 5f6d 6178 5f6a 756d 7022  _drift_max_jump"
+00000ff0: 3a20 3230 2c0a 2020 2020 2020 2020 2266  : 20,.        "f
+00001000: 6173 745f 6472 6966 745f 6d69 6e5f 6a75  ast_drift_min_ju
+00001010: 6d70 223a 2035 2c0a 2020 2020 2020 2020  mp": 5,.        
+00001020: 2274 5f73 7461 7274 5f64 7269 6674 223a  "t_start_drift":
+00001030: 204e 6f6e 652c 0a20 2020 2020 2020 2022   None,.        "
+00001040: 745f 656e 645f 6472 6966 7422 3a20 4e6f  t_end_drift": No
+00001050: 6e65 2c0a 2020 2020 2020 2020 2265 7874  ne,.        "ext
+00001060: 6572 6e61 6c5f 6472 6966 745f 7665 6374  ernal_drift_vect
+00001070: 6f72 5f75 6d22 3a20 4e6f 6e65 2c0a 2020  or_um": None,.  
+00001080: 2020 2020 2020 2265 7874 6572 6e61 6c5f        "external_
+00001090: 6472 6966 745f 7469 6d65 7322 3a20 4e6f  drift_times": No
+000010a0: 6e65 2c0a 2020 2020 2020 2020 2265 7874  ne,.        "ext
+000010b0: 6572 6e61 6c5f 6472 6966 745f 6661 6374  ernal_drift_fact
+000010c0: 6f72 7322 3a20 4e6f 6e65 2c0a 2020 2020  ors": None,.    
+000010d0: 7d0a 0a0a 6465 6620 6176 6169 6c61 626c  }...def availabl
+000010e0: 655f 7072 6f62 6573 2829 3a0a 2020 2020  e_probes():.    
+000010f0: 2222 220a 2020 2020 5265 7475 726e 7320  """.    Returns 
+00001100: 6c69 7374 206f 6620 6176 6169 6c61 626c  list of availabl
+00001110: 6520 7072 6f62 6573 0a0a 2020 2020 5265  e probes..    Re
+00001120: 7475 726e 730a 2020 2020 2d2d 2d2d 2d2d  turns.    ------
+00001130: 2d0a 2020 2020 7072 6f62 655f 6c69 7374  -.    probe_list
+00001140: 203a 206c 6973 740a 2020 2020 2020 2020   : list.        
+00001150: 4c69 7374 206f 6620 6176 6169 6c61 626c  List of availabl
+00001160: 6520 7072 6f62 6573 2069 6e20 4d45 4175  e probes in MEAu
+00001170: 7469 6c69 7479 0a20 2020 2022 2222 0a20  tility.    """. 
+00001180: 2020 2072 6574 7572 6e20 6d75 2e72 6574     return mu.ret
+00001190: 7572 6e5f 6d65 615f 6c69 7374 2829 0a0a  urn_mea_list()..
+000011a0: 0a23 2323 204c 4f41 4420 4655 4e43 5449  .### LOAD FUNCTI
+000011b0: 4f4e 5320 2323 230a 6465 6620 6c6f 6164  ONS ###.def load
+000011c0: 5f74 6d70 5f65 6170 2874 656d 706c 6174  _tmp_eap(templat
+000011d0: 6573 5f66 6f6c 6465 722c 2063 656c 6c74  es_folder, cellt
+000011e0: 7970 6573 3d4e 6f6e 652c 2073 616d 706c  ypes=None, sampl
+000011f0: 6573 5f70 6572 5f63 6174 3d4e 6f6e 652c  es_per_cat=None,
+00001200: 2076 6572 626f 7365 3d46 616c 7365 293a   verbose=False):
+00001210: 0a20 2020 2022 2222 0a20 2020 204c 6f61  .    """.    Loa
+00001220: 6473 2045 4150 2066 726f 6d20 7465 6d70  ds EAP from temp
+00001230: 6f72 6172 7920 666f 6c64 6572 2e0a 0a20  orary folder... 
+00001240: 2020 2050 6172 616d 6574 6572 730a 2020     Parameters.  
+00001250: 2020 2d2d 2d2d 2d2d 2d2d 2d2d 0a20 2020    ----------.   
+00001260: 2074 656d 706c 6174 6573 5f66 6f6c 6465   templates_folde
+00001270: 7220 3a20 7374 720a 2020 2020 2020 2020  r : str.        
+00001280: 5061 7468 2074 6f20 7465 6d70 6f72 6172  Path to temporar
+00001290: 7920 666f 6c64 6572 0a20 2020 2063 656c  y folder.    cel
+000012a0: 6c74 7970 6573 203a 206c 6973 7420 286f  ltypes : list (o
+000012b0: 7074 696f 6e61 6c29 0a20 2020 2020 2020  ptional).       
+000012c0: 204c 6973 7420 6f66 2063 656c 6c74 7970   List of celltyp
+000012d0: 6573 2074 6f20 6265 206c 6f61 6465 640a  es to be loaded.
+000012e0: 2020 2020 7361 6d70 6c65 735f 7065 725f      samples_per_
+000012f0: 6361 7420 3a20 696e 7420 286f 7074 696f  cat : int (optio
+00001300: 6e61 6c29 0a20 2020 2020 2020 2054 6865  nal).        The
+00001310: 206e 756d 6265 7220 6f66 2065 6170 2074   number of eap t
+00001320: 6f20 6c6f 6164 2070 6572 2063 6174 6567  o load per categ
+00001330: 6f72 790a 0a20 2020 2052 6574 7572 6e73  ory..    Returns
+00001340: 0a20 2020 202d 2d2d 2d2d 2d2d 0a20 2020  .    -------.   
+00001350: 2074 656d 706c 6174 6573 203a 206e 702e   templates : np.
+00001360: 6172 7261 790a 2020 2020 2020 2020 5465  array.        Te
+00001370: 6d70 6c61 7465 7320 286e 5f65 6170 2c20  mplates (n_eap, 
+00001380: 6e5f 656c 6563 2c20 6e5f 7361 6d70 6c65  n_elec, n_sample
+00001390: 290a 2020 2020 6c6f 6361 7469 6f6e 7320  ).    locations 
+000013a0: 3a20 6e70 2e61 7272 6179 0a20 2020 2020  : np.array.     
+000013b0: 2020 204c 6f63 6174 696f 6e73 2028 6e5f     Locations (n_
+000013c0: 6561 702c 2033 290a 2020 2020 726f 7461  eap, 3).    rota
+000013d0: 7469 6f6e 7320 3a20 6e70 2e61 7272 6179  tions : np.array
+000013e0: 0a20 2020 2020 2020 2052 6f74 6174 696f  .        Rotatio
+000013f0: 6e73 2028 6e5f 6561 702c 2033 290a 2020  ns (n_eap, 3).  
+00001400: 2020 6365 6c6c 7479 7065 7320 3a20 6e70    celltypes : np
+00001410: 2e61 7272 6179 0a20 2020 2020 2020 2043  .array.        C
+00001420: 656c 6c20 7479 7065 7320 286e 5f65 6170  ell types (n_eap
+00001430: 290a 0a20 2020 2022 2222 0a20 2020 2069  )..    """.    i
+00001440: 6620 7665 7262 6f73 653a 0a20 2020 2020  f verbose:.     
+00001450: 2020 2070 7269 6e74 2822 4c6f 6164 696e     print("Loadin
+00001460: 6720 6561 7020 6461 7461 202e 2e2e 2229  g eap data ...")
+00001470: 0a0a 2020 2020 7465 6d70 6c61 7465 735f  ..    templates_
+00001480: 666f 6c64 6572 203d 2050 6174 6828 7465  folder = Path(te
+00001490: 6d70 6c61 7465 735f 666f 6c64 6572 290a  mplates_folder).
+000014a0: 2020 2020 6561 706c 6973 7420 3d20 5b66      eaplist = [f
+000014b0: 2066 6f72 2066 2069 6e20 7465 6d70 6c61   for f in templa
+000014c0: 7465 735f 666f 6c64 6572 2e69 7465 7264  tes_folder.iterd
+000014d0: 6972 2829 2069 6620 662e 6e61 6d65 2e73  ir() if f.name.s
+000014e0: 7461 7274 7377 6974 6828 2265 6170 2229  tartswith("eap")
+000014f0: 5d0a 2020 2020 6c6f 636c 6973 7420 3d20  ].    loclist = 
+00001500: 5b66 2066 6f72 2066 2069 6e20 7465 6d70  [f for f in temp
+00001510: 6c61 7465 735f 666f 6c64 6572 2e69 7465  lates_folder.ite
+00001520: 7264 6972 2829 2069 6620 662e 6e61 6d65  rdir() if f.name
+00001530: 2e73 7461 7274 7377 6974 6828 2270 6f73  .startswith("pos
+00001540: 2229 5d0a 2020 2020 726f 746c 6973 7420  ")].    rotlist 
+00001550: 3d20 5b66 2066 6f72 2066 2069 6e20 7465  = [f for f in te
+00001560: 6d70 6c61 7465 735f 666f 6c64 6572 2e69  mplates_folder.i
+00001570: 7465 7264 6972 2829 2069 6620 662e 6e61  terdir() if f.na
+00001580: 6d65 2e73 7461 7274 7377 6974 6828 2272  me.startswith("r
+00001590: 6f74 2229 5d0a 0a20 2020 2065 6170 5f6c  ot")]..    eap_l
+000015a0: 6973 7420 3d20 5b5d 0a20 2020 206c 6f63  ist = [].    loc
+000015b0: 5f6c 6973 7420 3d20 5b5d 0a20 2020 2072  _list = [].    r
+000015c0: 6f74 5f6c 6973 7420 3d20 5b5d 0a20 2020  ot_list = [].   
+000015d0: 2063 6174 5f6c 6973 7420 3d20 5b5d 0a0a   cat_list = []..
+000015e0: 2020 2020 6561 706c 6973 7420 3d20 736f      eaplist = so
+000015f0: 7274 6564 2865 6170 6c69 7374 290a 2020  rted(eaplist).  
+00001600: 2020 6c6f 636c 6973 7420 3d20 736f 7274    loclist = sort
+00001610: 6564 286c 6f63 6c69 7374 290a 2020 2020  ed(loclist).    
+00001620: 726f 746c 6973 7420 3d20 736f 7274 6564  rotlist = sorted
+00001630: 2872 6f74 6c69 7374 290a 0a20 2020 206c  (rotlist)..    l
+00001640: 6f61 6465 645f 6361 7465 676f 7269 6573  oaded_categories
+00001650: 203d 2073 6574 2829 0a20 2020 2069 676e   = set().    ign
+00001660: 6f72 6564 5f63 6174 6567 6f72 6965 7320  ored_categories 
+00001670: 3d20 7365 7428 290a 0a20 2020 2066 6f72  = set()..    for
+00001680: 2069 6478 2c20 6620 696e 2065 6e75 6d65   idx, f in enume
+00001690: 7261 7465 2865 6170 6c69 7374 293a 0a20  rate(eaplist):. 
+000016a0: 2020 2020 2020 2063 656c 6c74 7970 6520         celltype 
+000016b0: 3d20 662e 7061 7274 735b 2d31 5d2e 7370  = f.parts[-1].sp
+000016c0: 6c69 7428 222d 2229 5b31 5d5b 3a2d 345d  lit("-")[1][:-4]
+000016d0: 0a20 2020 2020 2020 2069 6620 7665 7262  .        if verb
+000016e0: 6f73 653a 0a20 2020 2020 2020 2020 2020  ose:.           
+000016f0: 2070 7269 6e74 2822 6c6f 6164 696e 6720   print("loading 
+00001700: 6365 6c6c 2074 7970 653a 2022 2c20 6629  cell type: ", f)
+00001710: 0a20 2020 2020 2020 2069 6620 6365 6c6c  .        if cell
+00001720: 7479 7065 7320 6973 206e 6f74 204e 6f6e  types is not Non
+00001730: 653a 0a20 2020 2020 2020 2020 2020 2069  e:.            i
+00001740: 6620 6365 6c6c 7479 7065 2069 6e20 6365  f celltype in ce
+00001750: 6c6c 7479 7065 733a 0a20 2020 2020 2020  lltypes:.       
+00001760: 2020 2020 2020 2020 2065 6170 7320 3d20           eaps = 
+00001770: 6e70 2e6c 6f61 6428 7374 7228 6561 706c  np.load(str(eapl
+00001780: 6973 745b 6964 785d 2929 0a20 2020 2020  ist[idx])).     
+00001790: 2020 2020 2020 2020 2020 206c 6f63 7320             locs 
+000017a0: 3d20 6e70 2e6c 6f61 6428 7374 7228 6c6f  = np.load(str(lo
+000017b0: 636c 6973 745b 6964 785d 2929 0a20 2020  clist[idx])).   
+000017c0: 2020 2020 2020 2020 2020 2020 2072 6f74               rot
+000017d0: 7320 3d20 6e70 2e6c 6f61 6428 7374 7228  s = np.load(str(
+000017e0: 726f 746c 6973 745b 6964 785d 2929 0a0a  rotlist[idx]))..
+000017f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001800: 6966 2073 616d 706c 6573 5f70 6572 5f63  if samples_per_c
+00001810: 6174 2069 7320 4e6f 6e65 206f 7220 7361  at is None or sa
+00001820: 6d70 6c65 735f 7065 725f 6361 7420 3e20  mples_per_cat > 
+00001830: 6c65 6e28 6561 7073 293a 0a20 2020 2020  len(eaps):.     
+00001840: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+00001850: 616d 706c 6573 5f74 6f5f 7265 6164 203d  amples_to_read =
+00001860: 206c 656e 2865 6170 7329 0a20 2020 2020   len(eaps).     
+00001870: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
+00001880: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00001890: 2020 2020 2073 616d 706c 6573 5f74 6f5f       samples_to_
+000018a0: 7265 6164 203d 2073 616d 706c 6573 5f70  read = samples_p
+000018b0: 6572 5f63 6174 0a0a 2020 2020 2020 2020  er_cat..        
+000018c0: 2020 2020 2020 2020 6561 705f 6c69 7374          eap_list
+000018d0: 2e65 7874 656e 6428 6561 7073 5b3a 7361  .extend(eaps[:sa
+000018e0: 6d70 6c65 735f 746f 5f72 6561 645d 290a  mples_to_read]).
+000018f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001900: 726f 745f 6c69 7374 2e65 7874 656e 6428  rot_list.extend(
+00001910: 726f 7473 5b3a 7361 6d70 6c65 735f 746f  rots[:samples_to
+00001920: 5f72 6561 645d 290a 2020 2020 2020 2020  _read]).        
+00001930: 2020 2020 2020 2020 6c6f 635f 6c69 7374          loc_list
+00001940: 2e65 7874 656e 6428 6c6f 6373 5b3a 7361  .extend(locs[:sa
+00001950: 6d70 6c65 735f 746f 5f72 6561 645d 290a  mples_to_read]).
+00001960: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001970: 6361 745f 6c69 7374 2e65 7874 656e 6428  cat_list.extend(
+00001980: 5b63 656c 6c74 7970 655d 202a 2073 616d  [celltype] * sam
+00001990: 706c 6573 5f74 6f5f 7265 6164 290a 2020  ples_to_read).  
+000019a0: 2020 2020 2020 2020 2020 2020 2020 6c6f                lo
+000019b0: 6164 6564 5f63 6174 6567 6f72 6965 732e  aded_categories.
+000019c0: 6164 6428 6365 6c6c 7479 7065 290a 2020  add(celltype).  
+000019d0: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
+000019e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000019f0: 6967 6e6f 7265 645f 6361 7465 676f 7269  ignored_categori
+00001a00: 6573 2e61 6464 2863 656c 6c74 7970 6529  es.add(celltype)
+00001a10: 0a20 2020 2020 2020 2065 6c73 653a 0a20  .        else:. 
+00001a20: 2020 2020 2020 2020 2020 2065 6170 7320             eaps 
+00001a30: 3d20 6e70 2e6c 6f61 6428 7374 7228 6561  = np.load(str(ea
+00001a40: 706c 6973 745b 6964 785d 2929 0a20 2020  plist[idx])).   
+00001a50: 2020 2020 2020 2020 206c 6f63 7320 3d20           locs = 
+00001a60: 6e70 2e6c 6f61 6428 7374 7228 6c6f 636c  np.load(str(locl
+00001a70: 6973 745b 6964 785d 2929 0a20 2020 2020  ist[idx])).     
+00001a80: 2020 2020 2020 2072 6f74 7320 3d20 6e70         rots = np
+00001a90: 2e6c 6f61 6428 7374 7228 726f 746c 6973  .load(str(rotlis
+00001aa0: 745b 6964 785d 2929 0a0a 2020 2020 2020  t[idx]))..      
+00001ab0: 2020 2020 2020 6966 2073 616d 706c 6573        if samples
+00001ac0: 5f70 6572 5f63 6174 2069 7320 4e6f 6e65  _per_cat is None
+00001ad0: 206f 7220 7361 6d70 6c65 735f 7065 725f   or samples_per_
+00001ae0: 6361 7420 3e20 6c65 6e28 6561 7073 293a  cat > len(eaps):
 00001af0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00001b00: 2020 2020 2073 616d 706c 6573 5f74 6f5f       samples_to_
-00001b10: 7265 6164 203d 2073 616d 706c 6573 5f70  read = samples_p
-00001b20: 6572 5f63 6174 0a0a 2020 2020 2020 2020  er_cat..        
-00001b30: 2020 2020 2020 2020 6561 705f 6c69 7374          eap_list
-00001b40: 2e65 7874 656e 6428 6561 7073 5b3a 7361  .extend(eaps[:sa
-00001b50: 6d70 6c65 735f 746f 5f72 6561 645d 290a  mples_to_read]).
-00001b60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001b70: 726f 745f 6c69 7374 2e65 7874 656e 6428  rot_list.extend(
-00001b80: 726f 7473 5b3a 7361 6d70 6c65 735f 746f  rots[:samples_to
-00001b90: 5f72 6561 645d 290a 2020 2020 2020 2020  _read]).        
-00001ba0: 2020 2020 2020 2020 6c6f 635f 6c69 7374          loc_list
-00001bb0: 2e65 7874 656e 6428 6c6f 6373 5b3a 7361  .extend(locs[:sa
-00001bc0: 6d70 6c65 735f 746f 5f72 6561 645d 290a  mples_to_read]).
-00001bd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001be0: 6361 745f 6c69 7374 2e65 7874 656e 6428  cat_list.extend(
-00001bf0: 5b63 656c 6c74 7970 655d 202a 2073 616d  [celltype] * sam
-00001c00: 706c 6573 5f74 6f5f 7265 6164 290a 2020  ples_to_read).  
-00001c10: 2020 2020 2020 2020 2020 2020 2020 6c6f                lo
-00001c20: 6164 6564 5f63 6174 6567 6f72 6965 732e  aded_categories.
-00001c30: 6164 6428 6365 6c6c 7479 7065 290a 2020  add(celltype).  
-00001c40: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
-00001c50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00001c60: 6967 6e6f 7265 645f 6361 7465 676f 7269  ignored_categori
-00001c70: 6573 2e61 6464 2863 656c 6c74 7970 6529  es.add(celltype)
-00001c80: 0a20 2020 2020 2020 2065 6c73 653a 0a20  .        else:. 
-00001c90: 2020 2020 2020 2020 2020 2065 6170 7320             eaps 
-00001ca0: 3d20 6e70 2e6c 6f61 6428 7374 7228 6561  = np.load(str(ea
-00001cb0: 706c 6973 745b 6964 785d 2929 0a20 2020  plist[idx])).   
-00001cc0: 2020 2020 2020 2020 206c 6f63 7320 3d20           locs = 
-00001cd0: 6e70 2e6c 6f61 6428 7374 7228 6c6f 636c  np.load(str(locl
-00001ce0: 6973 745b 6964 785d 2929 0a20 2020 2020  ist[idx])).     
-00001cf0: 2020 2020 2020 2072 6f74 7320 3d20 6e70         rots = np
-00001d00: 2e6c 6f61 6428 7374 7228 726f 746c 6973  .load(str(rotlis
-00001d10: 745b 6964 785d 2929 0a0a 2020 2020 2020  t[idx]))..      
-00001d20: 2020 2020 2020 6966 2073 616d 706c 6573        if samples
-00001d30: 5f70 6572 5f63 6174 2069 7320 4e6f 6e65  _per_cat is None
-00001d40: 206f 7220 7361 6d70 6c65 735f 7065 725f   or samples_per_
-00001d50: 6361 7420 3e20 6c65 6e28 6561 7073 293a  cat > len(eaps):
-00001d60: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00001d70: 2073 616d 706c 6573 5f74 6f5f 7265 6164   samples_to_read
-00001d80: 203d 206c 656e 2865 6170 7329 0a20 2020   = len(eaps).   
-00001d90: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
-00001da0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-00001db0: 616d 706c 6573 5f74 6f5f 7265 6164 203d  amples_to_read =
-00001dc0: 2073 616d 706c 6573 5f70 6572 5f63 6174   samples_per_cat
-00001dd0: 0a0a 2020 2020 2020 2020 2020 2020 6561  ..            ea
-00001de0: 705f 6c69 7374 2e65 7874 656e 6428 6561  p_list.extend(ea
-00001df0: 7073 5b3a 7361 6d70 6c65 735f 746f 5f72  ps[:samples_to_r
-00001e00: 6561 645d 290a 2020 2020 2020 2020 2020  ead]).          
-00001e10: 2020 726f 745f 6c69 7374 2e65 7874 656e    rot_list.exten
-00001e20: 6428 726f 7473 5b3a 7361 6d70 6c65 735f  d(rots[:samples_
-00001e30: 746f 5f72 6561 645d 290a 2020 2020 2020  to_read]).      
-00001e40: 2020 2020 2020 6c6f 635f 6c69 7374 2e65        loc_list.e
-00001e50: 7874 656e 6428 6c6f 6373 5b3a 7361 6d70  xtend(locs[:samp
-00001e60: 6c65 735f 746f 5f72 6561 645d 290a 2020  les_to_read]).  
-00001e70: 2020 2020 2020 2020 2020 6361 745f 6c69            cat_li
-00001e80: 7374 2e65 7874 656e 6428 5b63 656c 6c74  st.extend([cellt
-00001e90: 7970 655d 202a 2073 616d 706c 6573 5f74  ype] * samples_t
-00001ea0: 6f5f 7265 6164 290a 2020 2020 2020 2020  o_read).        
-00001eb0: 2020 2020 6c6f 6164 6564 5f63 6174 6567      loaded_categ
-00001ec0: 6f72 6965 732e 6164 6428 6365 6c6c 7479  ories.add(cellty
-00001ed0: 7065 290a 0a20 2020 2069 6620 7665 7262  pe)..    if verb
-00001ee0: 6f73 653a 0a20 2020 2020 2020 2070 7269  ose:.        pri
-00001ef0: 6e74 2822 446f 6e65 206c 6f61 6469 6e67  nt("Done loading
-00001f00: 2073 7069 6b65 2064 6174 6120 2e2e 2e22   spike data ..."
-00001f10: 290a 0a20 2020 2072 6574 7572 6e20 6e70  )..    return np
-00001f20: 2e61 7272 6179 2865 6170 5f6c 6973 7429  .array(eap_list)
-00001f30: 2c20 6e70 2e61 7272 6179 286c 6f63 5f6c  , np.array(loc_l
-00001f40: 6973 7429 2c20 6e70 2e61 7272 6179 2872  ist), np.array(r
-00001f50: 6f74 5f6c 6973 7429 2c20 6e70 2e61 7272  ot_list), np.arr
-00001f60: 6179 2863 6174 5f6c 6973 742c 2064 7479  ay(cat_list, dty
-00001f70: 7065 3d73 7472 290a 0a0a 6465 6620 6c6f  pe=str)...def lo
-00001f80: 6164 5f74 656d 706c 6174 6573 2874 656d  ad_templates(tem
-00001f90: 706c 6174 6573 2c20 7265 7475 726e 5f68  plates, return_h
-00001fa0: 355f 6f62 6a65 6374 733d 5472 7565 2c20  5_objects=True, 
-00001fb0: 7665 7262 6f73 653d 4661 6c73 652c 2063  verbose=False, c
-00001fc0: 6865 636b 5f73 7566 6669 783d 5472 7565  heck_suffix=True
-00001fd0: 293a 0a20 2020 2022 2222 0a20 2020 204c  ):.    """.    L
-00001fe0: 6f61 6420 6765 6e65 7261 7465 6420 6561  oad generated ea
-00001ff0: 7020 7465 6d70 6c61 7465 732e 0a0a 2020  p templates...  
-00002000: 2020 5061 7261 6d65 7465 7273 0a20 2020    Parameters.   
-00002010: 202d 2d2d 2d2d 2d2d 2d2d 2d0a 2020 2020   ----------.    
-00002020: 7465 6d70 6c61 7465 7320 3a20 7374 7220  templates : str 
-00002030: 6f72 2050 6174 6820 6f62 6a65 6374 0a20  or Path object. 
-00002040: 2020 2020 2020 2074 656d 706c 6174 6573         templates
-00002050: 2066 696c 650a 2020 2020 7265 7475 726e   file.    return
-00002060: 5f68 355f 6f62 6a65 6374 7320 3a20 626f  _h5_objects : bo
-00002070: 6f6c 0a20 2020 2020 2020 2049 6620 5472  ol.        If Tr
-00002080: 7565 206f 7574 7075 7420 6f62 6a65 6374  ue output object
-00002090: 7320 6172 6520 6835 206f 626a 6563 7473  s are h5 objects
-000020a0: 0a20 2020 2076 6572 626f 7365 203a 2062  .    verbose : b
-000020b0: 6f6f 6c0a 2020 2020 2020 2020 4966 2054  ool.        If T
-000020c0: 7275 6520 6f75 7470 7574 2069 7320 7665  rue output is ve
-000020d0: 7262 6f73 650a 2020 2020 6368 6563 6b5f  rbose.    check_
-000020e0: 7375 6666 6978 203a 2062 6f6f 6c0a 2020  suffix : bool.  
-000020f0: 2020 2020 2020 4966 2054 7275 652c 2068        If True, h
-00002100: 6466 3520 7375 6666 6978 2069 7320 6368  df5 suffix is ch
-00002110: 6563 6b65 640a 0a20 2020 2052 6574 7572  ecked..    Retur
-00002120: 6e73 0a20 2020 202d 2d2d 2d2d 2d2d 0a20  ns.    -------. 
-00002130: 2020 2074 656d 7067 656e 203a 2054 656d     tempgen : Tem
-00002140: 706c 6174 6547 656e 6572 6174 6f72 0a20  plateGenerator. 
-00002150: 2020 2020 2020 2054 656d 706c 6174 6547         TemplateG
-00002160: 656e 6572 6174 6f72 206f 626a 6563 740a  enerator object.
-00002170: 0a20 2020 2022 2222 0a20 2020 2066 726f  .    """.    fro
-00002180: 6d20 4d45 4172 6563 2069 6d70 6f72 7420  m MEArec import 
-00002190: 5465 6d70 6c61 7465 4765 6e65 7261 746f  TemplateGenerato
-000021a0: 720a 2020 2020 6966 2076 6572 626f 7365  r.    if verbose
-000021b0: 3a0a 2020 2020 2020 2020 7072 696e 7428  :.        print(
-000021c0: 224c 6f61 6469 6e67 2074 656d 706c 6174  "Loading templat
-000021d0: 6573 2e2e 2e22 290a 0a20 2020 2074 656d  es...")..    tem
-000021e0: 705f 6469 6374 203d 207b 7d0a 2020 2020  p_dict = {}.    
-000021f0: 7465 6d70 6c61 7465 7320 3d20 5061 7468  templates = Path
-00002200: 2874 656d 706c 6174 6573 290a 2020 2020  (templates).    
-00002210: 6966 2028 7465 6d70 6c61 7465 732e 7375  if (templates.su
-00002220: 6666 6978 2069 6e20 5b27 2e68 3527 2c20  ffix in ['.h5', 
-00002230: 272e 6864 6635 275d 2920 6f72 2028 6e6f  '.hdf5']) or (no
-00002240: 7420 6368 6563 6b5f 7375 6666 6978 293a  t check_suffix):
-00002250: 0a20 2020 2020 2020 2066 203d 2068 3570  .        f = h5p
-00002260: 792e 4669 6c65 2873 7472 2874 656d 706c  y.File(str(templ
-00002270: 6174 6573 292c 2027 7227 290a 2020 2020  ates), 'r').    
-00002280: 2020 2020 696e 666f 203d 206c 6f61 645f      info = load_
-00002290: 6469 6374 5f66 726f 6d5f 6864 6635 2866  dict_from_hdf5(f
-000022a0: 2c20 2769 6e66 6f2f 2729 0a20 2020 2020  , 'info/').     
-000022b0: 2020 2063 656c 6c74 7970 6573 203d 206e     celltypes = n
-000022c0: 702e 6172 7261 7928 662e 6765 7428 2763  p.array(f.get('c
-000022d0: 656c 6c74 7970 6573 2729 290a 2020 2020  elltypes')).    
-000022e0: 2020 2020 7465 6d70 5f64 6963 745b 2763      temp_dict['c
-000022f0: 656c 6c74 7970 6573 275d 203d 206e 702e  elltypes'] = np.
-00002300: 6172 7261 7928 5b63 2e64 6563 6f64 6528  array([c.decode(
-00002310: 2775 7466 2d38 2729 2066 6f72 2063 2069  'utf-8') for c i
-00002320: 6e20 6365 6c6c 7479 7065 735d 290a 2020  n celltypes]).  
-00002330: 2020 2020 2020 6966 2072 6574 7572 6e5f        if return_
-00002340: 6835 5f6f 626a 6563 7473 3a0a 2020 2020  h5_objects:.    
-00002350: 2020 2020 2020 2020 7465 6d70 5f64 6963          temp_dic
-00002360: 745b 276c 6f63 6174 696f 6e73 275d 203d  t['locations'] =
-00002370: 2066 2e67 6574 2827 6c6f 6361 7469 6f6e   f.get('location
-00002380: 7327 290a 2020 2020 2020 2020 656c 7365  s').        else
-00002390: 3a0a 2020 2020 2020 2020 2020 2020 7465  :.            te
-000023a0: 6d70 5f64 6963 745b 276c 6f63 6174 696f  mp_dict['locatio
-000023b0: 6e73 275d 203d 206e 702e 6172 7261 7928  ns'] = np.array(
-000023c0: 662e 6765 7428 276c 6f63 6174 696f 6e73  f.get('locations
-000023d0: 2729 290a 2020 2020 2020 2020 6966 2072  ')).        if r
-000023e0: 6574 7572 6e5f 6835 5f6f 626a 6563 7473  eturn_h5_objects
-000023f0: 3a0a 2020 2020 2020 2020 2020 2020 7465  :.            te
-00002400: 6d70 5f64 6963 745b 2772 6f74 6174 696f  mp_dict['rotatio
-00002410: 6e73 275d 203d 2066 2e67 6574 2827 726f  ns'] = f.get('ro
-00002420: 7461 7469 6f6e 7327 290a 2020 2020 2020  tations').      
-00002430: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
-00002440: 2020 2020 7465 6d70 5f64 6963 745b 2772      temp_dict['r
-00002450: 6f74 6174 696f 6e73 275d 203d 206e 702e  otations'] = np.
-00002460: 6172 7261 7928 662e 6765 7428 2772 6f74  array(f.get('rot
-00002470: 6174 696f 6e73 2729 290a 2020 2020 2020  ations')).      
-00002480: 2020 6966 2072 6574 7572 6e5f 6835 5f6f    if return_h5_o
-00002490: 626a 6563 7473 3a0a 2020 2020 2020 2020  bjects:.        
-000024a0: 2020 2020 7465 6d70 5f64 6963 745b 2774      temp_dict['t
-000024b0: 656d 706c 6174 6573 275d 203d 2066 2e67  emplates'] = f.g
-000024c0: 6574 2827 7465 6d70 6c61 7465 7327 290a  et('templates').
-000024d0: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
-000024e0: 2020 2020 2020 2020 2020 7465 6d70 5f64            temp_d
-000024f0: 6963 745b 2774 656d 706c 6174 6573 275d  ict['templates']
-00002500: 203d 206e 702e 6172 7261 7928 662e 6765   = np.array(f.ge
-00002510: 7428 2774 656d 706c 6174 6573 2729 290a  t('templates')).
-00002520: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-00002530: 2020 7261 6973 6520 4578 6365 7074 696f    raise Exceptio
-00002540: 6e28 2252 6563 6f72 6469 6e67 7320 6d75  n("Recordings mu
-00002550: 7374 2062 6520 616e 2068 6466 3520 6669  st be an hdf5 fi
-00002560: 6c65 2028 2e68 3520 6f72 202e 6864 6635  le (.h5 or .hdf5
-00002570: 2922 290a 0a20 2020 2069 6620 7665 7262  )")..    if verb
-00002580: 6f73 653a 0a20 2020 2020 2020 2070 7269  ose:.        pri
-00002590: 6e74 2822 446f 6e65 206c 6f61 6469 6e67  nt("Done loading
-000025a0: 2074 656d 706c 6174 6573 2e2e 2e22 290a   templates...").
-000025b0: 2020 2020 6966 206e 6f74 2072 6574 7572      if not retur
-000025c0: 6e5f 6835 5f6f 626a 6563 7473 3a0a 2020  n_h5_objects:.  
-000025d0: 2020 2020 2020 662e 636c 6f73 6528 290a        f.close().
-000025e0: 2020 2020 7465 6d70 6765 6e20 3d20 5465      tempgen = Te
-000025f0: 6d70 6c61 7465 4765 6e65 7261 746f 7228  mplateGenerator(
-00002600: 7465 6d70 5f64 6963 743d 7465 6d70 5f64  temp_dict=temp_d
-00002610: 6963 742c 2069 6e66 6f3d 696e 666f 290a  ict, info=info).
-00002620: 2020 2020 7265 7475 726e 2074 656d 7067      return tempg
-00002630: 656e 0a0a 0a64 6566 206c 6f61 645f 7265  en...def load_re
-00002640: 636f 7264 696e 6773 2872 6563 6f72 6469  cordings(recordi
-00002650: 6e67 732c 2072 6574 7572 6e5f 6835 5f6f  ngs, return_h5_o
-00002660: 626a 6563 7473 3d54 7275 652c 0a20 2020  bjects=True,.   
-00002670: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002680: 206c 6f61 643d 4e6f 6e65 2c20 6c6f 6164   load=None, load
-00002690: 5f77 6176 6566 6f72 6d73 3d54 7275 652c  _waveforms=True,
-000026a0: 2063 6865 636b 5f73 7566 6669 783d 5472   check_suffix=Tr
-000026b0: 7565 2c20 7665 7262 6f73 653d 4661 6c73  ue, verbose=Fals
-000026c0: 6529 3a0a 2020 2020 2222 220a 2020 2020  e):.    """.    
-000026d0: 4c6f 6164 2067 656e 6572 6174 6564 2072  Load generated r
-000026e0: 6563 6f72 6469 6e67 732e 0a0a 2020 2020  ecordings...    
-000026f0: 5061 7261 6d65 7465 7273 0a20 2020 202d  Parameters.    -
-00002700: 2d2d 2d2d 2d2d 2d2d 2d0a 2020 2020 7265  ---------.    re
-00002710: 636f 7264 696e 6773 203a 2073 7472 206f  cordings : str o
-00002720: 7220 5061 7468 206f 626a 6563 740a 2020  r Path object.  
-00002730: 2020 2020 2020 5265 636f 7264 696e 6773        Recordings
-00002740: 2066 696c 650a 2020 2020 7265 7475 726e   file.    return
-00002750: 5f68 355f 6f62 6a65 6374 7320 3a20 626f  _h5_objects : bo
-00002760: 6f6c 0a20 2020 2020 2020 2049 6620 5472  ol.        If Tr
-00002770: 7565 206f 7574 7075 7420 6f62 6a65 6374  ue output object
-00002780: 7320 6172 6520 6835 206f 626a 6563 7473  s are h5 objects
-00002790: 0a20 2020 206c 6f61 6420 3a20 6c69 7374  .    load : list
-000027a0: 0a20 2020 2020 2020 204c 6973 7420 6f66  .        List of
-000027b0: 2066 6965 6c64 7320 746f 2062 6520 6c6f   fields to be lo
-000027c0: 6164 6564 2028 2827 7265 636f 7264 696e  aded (('recordin
-000027d0: 6773 272c 2027 6368 616e 6e65 6c5f 706f  gs', 'channel_po
-000027e0: 7369 7469 6f6e 7327 2c20 2776 6f6c 7461  sitions', 'volta
-000027f0: 6765 5f70 6561 6b73 272c 2027 7370 696b  ge_peaks', 'spik
-00002800: 6574 7261 696e 7327 2c0a 2020 2020 2020  etrains',.      
-00002810: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002820: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002830: 2027 7469 6d65 7374 616d 7073 272c 2027   'timestamps', '
-00002840: 7370 696b 655f 7472 6163 6573 272c 2027  spike_traces', '
-00002850: 7465 6d70 6c61 7465 7327 2929 0a20 2020  templates')).   
-00002860: 206c 6f61 645f 7761 7665 666f 726d 7320   load_waveforms 
-00002870: 3a20 626f 6f6c 0a20 2020 2020 2020 2049  : bool.        I
-00002880: 6620 5472 7565 2077 6176 6566 6f72 6d73  f True waveforms
-00002890: 2061 7265 206c 6f61 6465 6420 746f 2073   are loaded to s
-000028a0: 7069 6b65 7472 6169 6e73 0a20 2020 2076  piketrains.    v
-000028b0: 6572 626f 7365 203a 2062 6f6f 6c0a 2020  erbose : bool.  
-000028c0: 2020 2020 2020 4966 2054 7275 6520 6f75        If True ou
-000028d0: 7470 7574 2069 7320 7665 7262 6f73 650a  tput is verbose.
-000028e0: 2020 2020 6368 6563 6b5f 7375 6666 6978      check_suffix
-000028f0: 203a 2062 6f6f 6c0a 2020 2020 2020 2020   : bool.        
-00002900: 4966 2054 7275 652c 2068 6466 3520 7375  If True, hdf5 su
-00002910: 6666 6978 2069 7320 6368 6563 6b65 640a  ffix is checked.
-00002920: 0a20 2020 2052 6574 7572 6e73 0a20 2020  .    Returns.   
-00002930: 202d 2d2d 2d2d 2d2d 0a20 2020 2072 6563   -------.    rec
-00002940: 6765 6e20 3a20 5265 636f 7264 696e 6747  gen : RecordingG
-00002950: 656e 6572 6174 6f72 0a20 2020 2020 2020  enerator.       
-00002960: 2052 6563 6f72 6469 6e67 4765 6e65 7261   RecordingGenera
-00002970: 746f 7220 6f62 6a65 6374 0a0a 2020 2020  tor object..    
-00002980: 2222 220a 2020 2020 6672 6f6d 204d 4541  """.    from MEA
-00002990: 7265 6320 696d 706f 7274 2052 6563 6f72  rec import Recor
-000029a0: 6469 6e67 4765 6e65 7261 746f 720a 2020  dingGenerator.  
-000029b0: 2020 6966 2076 6572 626f 7365 3a0a 2020    if verbose:.  
-000029c0: 2020 2020 2020 7072 696e 7428 224c 6f61        print("Loa
-000029d0: 6469 6e67 2072 6563 6f72 6469 6e67 732e  ding recordings.
-000029e0: 2e2e 2229 0a0a 2020 2020 7265 635f 6469  ..")..    rec_di
-000029f0: 6374 203d 207b 7d0a 2020 2020 7265 636f  ct = {}.    reco
-00002a00: 7264 696e 6773 203d 2050 6174 6828 7265  rdings = Path(re
-00002a10: 636f 7264 696e 6773 290a 2020 2020 6966  cordings).    if
-00002a20: 2028 7265 636f 7264 696e 6773 2e73 7566   (recordings.suf
-00002a30: 6669 7820 696e 205b 272e 6835 272c 2027  fix in ['.h5', '
-00002a40: 2e68 6466 3527 5d29 206f 7220 286e 6f74  .hdf5']) or (not
-00002a50: 2063 6865 636b 5f73 7566 6669 7829 3a0a   check_suffix):.
-00002a60: 2020 2020 2020 2020 6620 3d20 6835 7079          f = h5py
-00002a70: 2e46 696c 6528 7374 7228 7265 636f 7264  .File(str(record
-00002a80: 696e 6773 292c 2027 7227 290a 2020 2020  ings), 'r').    
-00002a90: 2020 2020 6d65 6172 6563 5f76 6572 7369      mearec_versi
-00002aa0: 6f6e 203d 2066 2e61 7474 7273 2e67 6574  on = f.attrs.get
-00002ab0: 2827 6d65 6172 6563 5f76 6572 7369 6f6e  ('mearec_version
-00002ac0: 272c 2027 312e 342e 3027 290a 0a20 2020  ', '1.4.0')..   
-00002ad0: 2020 2020 2069 6620 7061 7273 6528 6d65       if parse(me
-00002ae0: 6172 6563 5f76 6572 7369 6f6e 2920 3e3d  arec_version) >=
-00002af0: 2070 6172 7365 2827 312e 352e 3027 293a   parse('1.5.0'):
-00002b00: 0a20 2020 2020 2020 2020 2020 2023 2076  .            # v
-00002b10: 6572 7369 6f6e 2061 6674 6572 2031 2e35  ersion after 1.5
-00002b20: 2e30 2069 7320 286e 5f73 616d 706c 6573  .0 is (n_samples
-00002b30: 2c20 6e5f 6368 616e 6e65 6c29 2069 6e73  , n_channel) ins
-00002b40: 6964 6520 7468 6520 6835 2066 696c 650a  ide the h5 file.
-00002b50: 2020 2020 2020 2020 2020 2020 6e65 6564              need
-00002b60: 5f74 7261 6e73 706f 7365 203d 2046 616c  _transpose = Fal
-00002b70: 7365 0a20 2020 2020 2020 2065 6c73 653a  se.        else:
-00002b80: 0a20 2020 2020 2020 2020 2020 2023 2076  .            # v
-00002b90: 6572 7369 6f6e 2020 312e 342e 3020 616e  ersion  1.4.0 an
-00002ba0: 6420 6265 666f 7265 2069 7320 286e 5f63  d before is (n_c
-00002bb0: 6861 6e6e 656c 2c20 6e5f 7361 6d70 6c65  hannel, n_sample
-00002bc0: 7329 2069 6e73 6964 6520 7468 6520 6835  s) inside the h5
-00002bd0: 2066 696c 650a 2020 2020 2020 2020 2020   file.          
-00002be0: 2020 7072 696e 7428 2257 6172 6e69 6e67    print("Warning
-00002bf0: 3a20 4d45 4172 6563 2066 696c 6520 6372  : MEArec file cr
-00002c00: 6561 7465 6420 7769 7468 2076 6572 7369  eated with versi
-00002c10: 6f6e 203c 312e 352e 2054 6869 7320 636f  on <1.5. This co
-00002c20: 756c 6420 7265 7375 6c74 2069 6e20 6c6f  uld result in lo
-00002c30: 7765 7220 6566 6669 6369 656e 6379 2e20  wer efficiency. 
-00002c40: 546f 2075 7067 7261 6465 220a 2020 2020  To upgrade".    
-00002c50: 2020 2020 2020 2020 2020 2020 2020 2279                "y
-00002c60: 6f75 7220 6669 6c65 2074 6f20 7468 6520  our file to the 
-00002c70: 6e65 7720 666f 726d 6174 2075 7365 3a20  new format use: 
-00002c80: 6d72 2e63 6f6e 7665 7274 5f72 6563 6f72  mr.convert_recor
-00002c90: 6469 6e67 5f74 6f5f 6e65 775f 7665 7273  ding_to_new_vers
-00002ca0: 696f 6e28 6669 6c65 6e61 6d65 2922 290a  ion(filename)").
-00002cb0: 2020 2020 2020 2020 2020 2020 6e65 6564              need
-00002cc0: 5f74 7261 6e73 706f 7365 203d 2054 7275  _transpose = Tru
-00002cd0: 650a 0a20 2020 2020 2020 2072 6563 5f64  e..        rec_d
-00002ce0: 6963 742c 2069 6e66 6f20 3d20 6c6f 6164  ict, info = load
-00002cf0: 5f72 6563 6f72 6469 6e67 735f 6672 6f6d  _recordings_from
-00002d00: 5f66 696c 6528 662c 0a20 2020 2020 2020  _file(f,.       
-00002d10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002d20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002d30: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-00002d40: 726e 5f68 355f 6f62 6a65 6374 733d 7265  rn_h5_objects=re
-00002d50: 7475 726e 5f68 355f 6f62 6a65 6374 732c  turn_h5_objects,
-00002d60: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00002d70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002d80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002d90: 2020 2020 6c6f 6164 3d6c 6f61 642c 0a20      load=load,. 
-00002da0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002db0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002dc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002dd0: 2020 6e65 6564 5f74 7261 6e73 706f 7365    need_transpose
-00002de0: 3d6e 6565 645f 7472 616e 7370 6f73 652c  =need_transpose,
-00002df0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00002e00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002e10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002e20: 2020 2020 6c6f 6164 5f77 6176 6566 6f72      load_wavefor
-00002e30: 6d73 3d6c 6f61 645f 7761 7665 666f 726d  ms=load_waveform
-00002e40: 7329 0a0a 2020 2020 656c 7365 3a0a 2020  s)..    else:.  
-00002e50: 2020 2020 2020 7261 6973 6520 4578 6365        raise Exce
-00002e60: 7074 696f 6e28 2252 6563 6f72 6469 6e67  ption("Recording
-00002e70: 7320 6d75 7374 2062 6520 616e 2068 6466  s must be an hdf
-00002e80: 3520 6669 6c65 2028 2e68 3520 6f72 202e  5 file (.h5 or .
-00002e90: 6864 6635 2922 290a 0a20 2020 2069 6620  hdf5)")..    if 
-00002ea0: 7665 7262 6f73 653a 0a20 2020 2020 2020  verbose:.       
-00002eb0: 2070 7269 6e74 2822 446f 6e65 206c 6f61   print("Done loa
-00002ec0: 6469 6e67 2072 6563 6f72 6469 6e67 732e  ding recordings.
-00002ed0: 2e2e 2229 0a0a 2020 2020 6966 206e 6f74  ..")..    if not
-00002ee0: 2072 6574 7572 6e5f 6835 5f6f 626a 6563   return_h5_objec
-00002ef0: 7473 3a0a 2020 2020 2020 2020 662e 636c  ts:.        f.cl
-00002f00: 6f73 6528 290a 2020 2020 7265 6367 656e  ose().    recgen
-00002f10: 203d 2052 6563 6f72 6469 6e67 4765 6e65   = RecordingGene
-00002f20: 7261 746f 7228 7265 635f 6469 6374 3d72  rator(rec_dict=r
-00002f30: 6563 5f64 6963 742c 2069 6e66 6f3d 696e  ec_dict, info=in
-00002f40: 666f 290a 2020 2020 6966 2022 6761 696e  fo).    if "gain
-00002f50: 5f74 6f5f 7556 2220 696e 2072 6563 5f64  _to_uV" in rec_d
-00002f60: 6963 743a 0a20 2020 2020 2020 2072 6563  ict:.        rec
-00002f70: 6765 6e2e 6761 696e 5f74 6f5f 7556 203d  gen.gain_to_uV =
-00002f80: 2072 6563 5f64 6963 745b 2267 6169 6e5f   rec_dict["gain_
-00002f90: 746f 5f75 5622 5d0a 2020 2020 7265 7475  to_uV"].    retu
-00002fa0: 726e 2072 6563 6765 6e0a 0a64 6566 206c  rn recgen..def l
-00002fb0: 6f61 645f 7265 636f 7264 696e 6773 5f66  oad_recordings_f
-00002fc0: 726f 6d5f 6669 6c65 2866 2c20 7061 7468  rom_file(f, path
-00002fd0: 3d22 222c 2072 6574 7572 6e5f 6835 5f6f  ="", return_h5_o
-00002fe0: 626a 6563 7473 3d54 7275 652c 206c 6f61  bjects=True, loa
-00002ff0: 643d 4e6f 6e65 2c0a 2020 2020 2020 2020  d=None,.        
-00003000: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003010: 2020 2020 2020 6e65 6564 5f74 7261 6e73        need_trans
-00003020: 706f 7365 3d46 616c 7365 2c20 6c6f 6164  pose=False, load
-00003030: 5f77 6176 6566 6f72 6d73 3d54 7275 6529  _waveforms=True)
-00003040: 3a0a 2020 2020 2222 220a 2020 2020 4c6f  :.    """.    Lo
-00003050: 6164 2067 656e 6572 6174 6564 2072 6563  ad generated rec
-00003060: 6f72 6469 6e67 7320 6672 6f6d 2066 696c  ordings from fil
-00003070: 652e 0a0a 2020 2020 5061 7261 6d65 7465  e...    Paramete
-00003080: 7273 0a20 2020 202d 2d2d 2d2d 2d2d 2d2d  rs.    ---------
-00003090: 2d0a 2020 2020 6669 6c65 6e61 6d65 203a  -.    filename :
-000030a0: 205f 696f 2e54 6578 7449 4f57 7261 7070   _io.TextIOWrapp
-000030b0: 6572 0a20 2020 2020 2020 2046 696c 6520  er.        File 
-000030c0: 6861 6e64 6c65 720a 2020 2020 7061 7468  handler.    path
-000030d0: 3a20 7374 720a 2020 2020 2020 2020 5061  : str.        Pa
-000030e0: 7468 2069 6e73 6964 6520 7468 6520 6835  th inside the h5
-000030f0: 2064 6174 6162 6173 650a 2020 2020 7265   database.    re
-00003100: 7475 726e 5f68 355f 6f62 6a65 6374 7320  turn_h5_objects 
-00003110: 3a20 626f 6f6c 0a20 2020 2020 2020 2049  : bool.        I
-00003120: 6620 5472 7565 206f 7574 7075 7420 6f62  f True output ob
-00003130: 6a65 6374 7320 6172 6520 6835 206f 626a  jects are h5 obj
-00003140: 6563 7473 0a20 2020 206c 6f61 6420 3a20  ects.    load : 
-00003150: 6c69 7374 0a20 2020 2020 2020 204c 6973  list.        Lis
-00003160: 7420 6f66 2066 6965 6c64 7320 746f 2062  t of fields to b
-00003170: 6520 6c6f 6164 6564 2028 2827 7265 636f  e loaded (('reco
-00003180: 7264 696e 6773 272c 2027 6368 616e 6e65  rdings', 'channe
-00003190: 6c5f 706f 7369 7469 6f6e 7327 2c20 2776  l_positions', 'v
-000031a0: 6f6c 7461 6765 5f70 6561 6b73 272c 2027  oltage_peaks', '
-000031b0: 7370 696b 6574 7261 696e 7327 2c0a 2020  spiketrains',.  
-000031c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000031d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000031e0: 2020 2020 2027 7469 6d65 7374 616d 7073       'timestamps
-000031f0: 272c 2027 7370 696b 655f 7472 6163 6573  ', 'spike_traces
-00003200: 272c 2027 7465 6d70 6c61 7465 7327 2929  ', 'templates'))
-00003210: 0a20 2020 206c 6f61 645f 7761 7665 666f  .    load_wavefo
-00003220: 726d 7320 3a20 626f 6f6c 0a20 2020 2020  rms : bool.     
-00003230: 2020 2049 6620 5472 7565 2077 6176 6566     If True wavef
-00003240: 6f72 6d73 2061 7265 206c 6f61 6465 6420  orms are loaded 
-00003250: 746f 2073 7069 6b65 7472 6169 6e73 0a20  to spiketrains. 
-00003260: 2020 2076 6572 626f 7365 203a 2062 6f6f     verbose : boo
-00003270: 6c0a 2020 2020 2020 2020 4966 2054 7275  l.        If Tru
-00003280: 6520 6f75 7470 7574 2069 7320 7665 7262  e output is verb
-00003290: 6f73 650a 2020 2020 6368 6563 6b5f 7375  ose.    check_su
-000032a0: 6666 6978 203a 2062 6f6f 6c0a 2020 2020  ffix : bool.    
-000032b0: 2020 2020 4966 2054 7275 652c 2068 6466      If True, hdf
-000032c0: 3520 7375 6666 6978 2069 7320 6368 6563  5 suffix is chec
-000032d0: 6b65 640a 0a20 2020 2052 6574 7572 6e73  ked..    Returns
-000032e0: 0a20 2020 202d 2d2d 2d2d 2d2d 0a20 2020  .    -------.   
-000032f0: 2072 6563 6765 6e20 3a20 5265 636f 7264   recgen : Record
-00003300: 696e 6747 656e 6572 6174 6f72 0a20 2020  ingGenerator.   
-00003310: 2020 2020 2052 6563 6f72 6469 6e67 4765       RecordingGe
-00003320: 6e65 7261 746f 7220 6f62 6a65 6374 0a0a  nerator object..
-00003330: 2020 2020 2222 220a 0a20 2020 2069 6620      """..    if 
-00003340: 6c6f 6164 2069 7320 4e6f 6e65 3a0a 2020  load is None:.  
-00003350: 2020 2020 2020 6c6f 6164 203d 205b 2772        load = ['r
-00003360: 6563 6f72 6469 6e67 7327 2c20 2763 6861  ecordings', 'cha
-00003370: 6e6e 656c 5f70 6f73 6974 696f 6e73 272c  nnel_positions',
-00003380: 2027 766f 6c74 6167 655f 7065 616b 7327   'voltage_peaks'
-00003390: 2c20 2773 7069 6b65 7472 6169 6e73 272c  , 'spiketrains',
-000033a0: 2027 7469 6d65 7374 616d 7073 272c 0a20   'timestamps',. 
-000033b0: 2020 2020 2020 2020 2020 2020 2020 2027                 '
-000033c0: 7370 696b 655f 7472 6163 6573 272c 2027  spike_traces', '
-000033d0: 7465 6d70 6c61 7465 7327 2c20 2774 656d  templates', 'tem
-000033e0: 706c 6174 655f 6964 7327 2c20 2764 7269  plate_ids', 'dri
-000033f0: 6674 5f64 6963 7427 5d0a 2020 2020 656c  ft_dict'].    el
-00003400: 7365 3a0a 2020 2020 2020 2020 6173 7365  se:.        asse
-00003410: 7274 2069 7369 6e73 7461 6e63 6528 6c6f  rt isinstance(lo
-00003420: 6164 2c20 6c69 7374 292c 2022 276c 6f61  ad, list), "'loa
-00003430: 6427 2073 686f 756c 6420 6265 2061 206c  d' should be a l
-00003440: 6973 7420 7769 7468 2073 7472 696e 6773  ist with strings
-00003450: 206f 6620 7768 6174 2074 6f20 6265 206c   of what to be l
-00003460: 6f61 6465 6420 2220 5c0a 2020 2020 2020  oaded " \.      
-00003470: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003480: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003490: 2022 2827 7265 636f 7264 696e 6773 272c   "('recordings',
-000034a0: 2027 6368 616e 6e65 6c5f 706f 7369 7469   'channel_positi
-000034b0: 6f6e 7327 2c20 2776 6f6c 7461 6765 5f70  ons', 'voltage_p
-000034c0: 6561 6b73 272c 2027 7370 696b 6574 7261  eaks', 'spiketra
-000034d0: 696e 7327 2c20 2220 5c0a 2020 2020 2020  ins', " \.      
-000034e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000034f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003500: 2022 2774 696d 6573 7461 6d70 7327 2c20   "'timestamps', 
-00003510: 2773 7069 6b65 5f74 7261 6365 7327 2c20  'spike_traces', 
-00003520: 2774 656d 706c 6174 6573 2729 220a 2020  'templates')".  
-00003530: 2020 7265 635f 6469 6374 203d 207b 7d0a    rec_dict = {}.
-00003540: 2020 2020 696e 666f 203d 206c 6f61 645f      info = load_
-00003550: 6469 6374 5f66 726f 6d5f 6864 6635 2866  dict_from_hdf5(f
-00003560: 2c20 7061 7468 202b 2027 696e 666f 2f27  , path + 'info/'
-00003570: 290a 2020 2020 6966 2066 2e67 6574 2870  ).    if f.get(p
-00003580: 6174 6820 2b20 2776 6f6c 7461 6765 5f70  ath + 'voltage_p
-00003590: 6561 6b73 2729 2069 7320 6e6f 7420 4e6f  eaks') is not No
-000035a0: 6e65 2061 6e64 2027 766f 6c74 6167 655f  ne and 'voltage_
-000035b0: 7065 616b 7327 2069 6e20 6c6f 6164 3a0a  peaks' in load:.
-000035c0: 2020 2020 2020 2020 6966 2072 6574 7572          if retur
-000035d0: 6e5f 6835 5f6f 626a 6563 7473 3a0a 2020  n_h5_objects:.  
-000035e0: 2020 2020 2020 2020 2020 7265 635f 6469            rec_di
-000035f0: 6374 5b27 766f 6c74 6167 655f 7065 616b  ct['voltage_peak
-00003600: 7327 5d20 3d20 662e 6765 7428 7061 7468  s'] = f.get(path
-00003610: 202b 2027 766f 6c74 6167 655f 7065 616b   + 'voltage_peak
-00003620: 7327 290a 2020 2020 2020 2020 656c 7365  s').        else
-00003630: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
-00003640: 635f 6469 6374 5b27 766f 6c74 6167 655f  c_dict['voltage_
-00003650: 7065 616b 7327 5d20 3d20 6e70 2e61 7272  peaks'] = np.arr
-00003660: 6179 2866 2e67 6574 2870 6174 6820 2b20  ay(f.get(path + 
-00003670: 2776 6f6c 7461 6765 5f70 6561 6b73 2729  'voltage_peaks')
-00003680: 290a 2020 2020 6966 2066 2e67 6574 2870  ).    if f.get(p
-00003690: 6174 6820 2b20 2763 6861 6e6e 656c 5f70  ath + 'channel_p
-000036a0: 6f73 6974 696f 6e73 2729 2069 7320 6e6f  ositions') is no
-000036b0: 7420 4e6f 6e65 2061 6e64 2027 6368 616e  t None and 'chan
-000036c0: 6e65 6c5f 706f 7369 7469 6f6e 7327 2069  nel_positions' i
-000036d0: 6e20 6c6f 6164 3a0a 2020 2020 2020 2020  n load:.        
-000036e0: 6966 2072 6574 7572 6e5f 6835 5f6f 626a  if return_h5_obj
-000036f0: 6563 7473 3a0a 2020 2020 2020 2020 2020  ects:.          
-00003700: 2020 7265 635f 6469 6374 5b27 6368 616e    rec_dict['chan
-00003710: 6e65 6c5f 706f 7369 7469 6f6e 7327 5d20  nel_positions'] 
-00003720: 3d20 662e 6765 7428 7061 7468 202b 2027  = f.get(path + '
-00003730: 6368 616e 6e65 6c5f 706f 7369 7469 6f6e  channel_position
-00003740: 7327 290a 2020 2020 2020 2020 656c 7365  s').        else
-00003750: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
-00003760: 635f 6469 6374 5b27 6368 616e 6e65 6c5f  c_dict['channel_
-00003770: 706f 7369 7469 6f6e 7327 5d20 3d20 6e70  positions'] = np
-00003780: 2e61 7272 6179 2866 2e67 6574 2870 6174  .array(f.get(pat
-00003790: 6820 2b20 2763 6861 6e6e 656c 5f70 6f73  h + 'channel_pos
-000037a0: 6974 696f 6e73 2729 290a 2020 2020 6966  itions')).    if
-000037b0: 2066 2e67 6574 2870 6174 6820 2b20 2772   f.get(path + 'r
-000037c0: 6563 6f72 6469 6e67 7327 2920 6973 206e  ecordings') is n
-000037d0: 6f74 204e 6f6e 6520 616e 6420 2772 6563  ot None and 'rec
-000037e0: 6f72 6469 6e67 7327 2069 6e20 6c6f 6164  ordings' in load
-000037f0: 3a0a 2020 2020 2020 2020 6966 2072 6574  :.        if ret
-00003800: 7572 6e5f 6835 5f6f 626a 6563 7473 3a0a  urn_h5_objects:.
-00003810: 2020 2020 2020 2020 2020 2020 6966 206e              if n
-00003820: 6565 645f 7472 616e 7370 6f73 653a 0a20  eed_transpose:. 
-00003830: 2020 2020 2020 2020 2020 2020 2020 2072                 r
-00003840: 6563 5f64 6963 745b 2772 6563 6f72 6469  ec_dict['recordi
-00003850: 6e67 7327 5d20 3d20 4461 7461 7365 7456  ngs'] = DatasetV
-00003860: 6965 7728 662e 6765 7428 7061 7468 202b  iew(f.get(path +
-00003870: 2027 7265 636f 7264 696e 6773 2729 292e   'recordings')).
-00003880: 6c61 7a79 5f74 7261 6e73 706f 7365 2829  lazy_transpose()
-00003890: 0a20 2020 2020 2020 2020 2020 2065 6c73  .            els
-000038a0: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-000038b0: 2020 2072 6563 5f64 6963 745b 2772 6563     rec_dict['rec
-000038c0: 6f72 6469 6e67 7327 5d20 3d20 662e 6765  ordings'] = f.ge
-000038d0: 7428 7061 7468 202b 2027 7265 636f 7264  t(path + 'record
-000038e0: 696e 6773 2729 0a20 2020 2020 2020 2065  ings').        e
-000038f0: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
-00003900: 2061 7272 203d 206e 702e 6172 7261 7928   arr = np.array(
-00003910: 662e 6765 7428 7061 7468 202b 2027 7265  f.get(path + 're
-00003920: 636f 7264 696e 6773 2729 290a 2020 2020  cordings')).    
-00003930: 2020 2020 2020 2020 6966 206e 6565 645f          if need_
-00003940: 7472 616e 7370 6f73 653a 0a20 2020 2020  transpose:.     
-00003950: 2020 2020 2020 2020 2020 2061 7272 203d             arr =
-00003960: 2061 7272 2e54 0a20 2020 2020 2020 2020   arr.T.         
-00003970: 2020 2072 6563 5f64 6963 745b 2772 6563     rec_dict['rec
-00003980: 6f72 6469 6e67 7327 5d20 3d20 6172 720a  ordings'] = arr.
-00003990: 2020 2020 2020 2020 6966 2022 6761 696e          if "gain
-000039a0: 5f74 6f5f 7556 2220 696e 2066 2e67 6574  _to_uV" in f.get
-000039b0: 2870 6174 6820 2b20 2772 6563 6f72 6469  (path + 'recordi
-000039c0: 6e67 7327 292e 6174 7472 733a 0a20 2020  ngs').attrs:.   
-000039d0: 2020 2020 2020 2020 2072 6563 5f64 6963           rec_dic
-000039e0: 745b 2267 6169 6e5f 746f 5f75 5622 5d20  t["gain_to_uV"] 
-000039f0: 3d20 662e 6765 7428 7061 7468 202b 2027  = f.get(path + '
-00003a00: 7265 636f 7264 696e 6773 2729 2e61 7474  recordings').att
-00003a10: 7273 5b22 6761 696e 5f74 6f5f 7556 225d  rs["gain_to_uV"]
-00003a20: 0a20 2020 2069 6620 662e 6765 7428 7061  .    if f.get(pa
-00003a30: 7468 202b 2027 7370 696b 655f 7472 6163  th + 'spike_trac
-00003a40: 6573 2729 2069 7320 6e6f 7420 4e6f 6e65  es') is not None
-00003a50: 2061 6e64 2027 7370 696b 655f 7472 6163   and 'spike_trac
-00003a60: 6573 2720 696e 206c 6f61 643a 0a20 2020  es' in load:.   
-00003a70: 2020 2020 2069 6620 7265 7475 726e 5f68       if return_h
-00003a80: 355f 6f62 6a65 6374 733a 0a20 2020 2020  5_objects:.     
-00003a90: 2020 2020 2020 2069 6620 6e65 6564 5f74         if need_t
-00003aa0: 7261 6e73 706f 7365 3a0a 2020 2020 2020  ranspose:.      
-00003ab0: 2020 2020 2020 2020 2020 7265 635f 6469            rec_di
-00003ac0: 6374 5b27 7370 696b 655f 7472 6163 6573  ct['spike_traces
-00003ad0: 275d 203d 2044 6174 6173 6574 5669 6577  '] = DatasetView
-00003ae0: 2866 2e67 6574 2870 6174 6820 2b20 2773  (f.get(path + 's
-00003af0: 7069 6b65 5f74 7261 6365 7327 2929 2e6c  pike_traces')).l
-00003b00: 617a 795f 7472 616e 7370 6f73 6528 290a  azy_transpose().
-00003b10: 2020 2020 2020 2020 2020 2020 656c 7365              else
-00003b20: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00003b30: 2020 7265 635f 6469 6374 5b27 7370 696b    rec_dict['spik
-00003b40: 655f 7472 6163 6573 275d 203d 2066 2e67  e_traces'] = f.g
-00003b50: 6574 2870 6174 6820 2b20 2773 7069 6b65  et(path + 'spike
-00003b60: 5f74 7261 6365 7327 290a 2020 2020 2020  _traces').      
-00003b70: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
-00003b80: 2020 2020 6172 7220 3d20 6e70 2e61 7272      arr = np.arr
-00003b90: 6179 2866 2e67 6574 2870 6174 6820 2b20  ay(f.get(path + 
-00003ba0: 2773 7069 6b65 5f74 7261 6365 7327 2929  'spike_traces'))
-00003bb0: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-00003bc0: 6e65 6564 5f74 7261 6e73 706f 7365 3a0a  need_transpose:.
+00001b00: 2073 616d 706c 6573 5f74 6f5f 7265 6164   samples_to_read
+00001b10: 203d 206c 656e 2865 6170 7329 0a20 2020   = len(eaps).   
+00001b20: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
+00001b30: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+00001b40: 616d 706c 6573 5f74 6f5f 7265 6164 203d  amples_to_read =
+00001b50: 2073 616d 706c 6573 5f70 6572 5f63 6174   samples_per_cat
+00001b60: 0a0a 2020 2020 2020 2020 2020 2020 6561  ..            ea
+00001b70: 705f 6c69 7374 2e65 7874 656e 6428 6561  p_list.extend(ea
+00001b80: 7073 5b3a 7361 6d70 6c65 735f 746f 5f72  ps[:samples_to_r
+00001b90: 6561 645d 290a 2020 2020 2020 2020 2020  ead]).          
+00001ba0: 2020 726f 745f 6c69 7374 2e65 7874 656e    rot_list.exten
+00001bb0: 6428 726f 7473 5b3a 7361 6d70 6c65 735f  d(rots[:samples_
+00001bc0: 746f 5f72 6561 645d 290a 2020 2020 2020  to_read]).      
+00001bd0: 2020 2020 2020 6c6f 635f 6c69 7374 2e65        loc_list.e
+00001be0: 7874 656e 6428 6c6f 6373 5b3a 7361 6d70  xtend(locs[:samp
+00001bf0: 6c65 735f 746f 5f72 6561 645d 290a 2020  les_to_read]).  
+00001c00: 2020 2020 2020 2020 2020 6361 745f 6c69            cat_li
+00001c10: 7374 2e65 7874 656e 6428 5b63 656c 6c74  st.extend([cellt
+00001c20: 7970 655d 202a 2073 616d 706c 6573 5f74  ype] * samples_t
+00001c30: 6f5f 7265 6164 290a 2020 2020 2020 2020  o_read).        
+00001c40: 2020 2020 6c6f 6164 6564 5f63 6174 6567      loaded_categ
+00001c50: 6f72 6965 732e 6164 6428 6365 6c6c 7479  ories.add(cellty
+00001c60: 7065 290a 0a20 2020 2069 6620 7665 7262  pe)..    if verb
+00001c70: 6f73 653a 0a20 2020 2020 2020 2070 7269  ose:.        pri
+00001c80: 6e74 2822 446f 6e65 206c 6f61 6469 6e67  nt("Done loading
+00001c90: 2073 7069 6b65 2064 6174 6120 2e2e 2e22   spike data ..."
+00001ca0: 290a 0a20 2020 2072 6574 7572 6e20 6e70  )..    return np
+00001cb0: 2e61 7272 6179 2865 6170 5f6c 6973 7429  .array(eap_list)
+00001cc0: 2c20 6e70 2e61 7272 6179 286c 6f63 5f6c  , np.array(loc_l
+00001cd0: 6973 7429 2c20 6e70 2e61 7272 6179 2872  ist), np.array(r
+00001ce0: 6f74 5f6c 6973 7429 2c20 6e70 2e61 7272  ot_list), np.arr
+00001cf0: 6179 2863 6174 5f6c 6973 742c 2064 7479  ay(cat_list, dty
+00001d00: 7065 3d73 7472 290a 0a0a 6465 6620 6c6f  pe=str)...def lo
+00001d10: 6164 5f74 656d 706c 6174 6573 2874 656d  ad_templates(tem
+00001d20: 706c 6174 6573 2c20 7265 7475 726e 5f68  plates, return_h
+00001d30: 355f 6f62 6a65 6374 733d 5472 7565 2c20  5_objects=True, 
+00001d40: 7665 7262 6f73 653d 4661 6c73 652c 2063  verbose=False, c
+00001d50: 6865 636b 5f73 7566 6669 783d 5472 7565  heck_suffix=True
+00001d60: 293a 0a20 2020 2022 2222 0a20 2020 204c  ):.    """.    L
+00001d70: 6f61 6420 6765 6e65 7261 7465 6420 6561  oad generated ea
+00001d80: 7020 7465 6d70 6c61 7465 732e 0a0a 2020  p templates...  
+00001d90: 2020 5061 7261 6d65 7465 7273 0a20 2020    Parameters.   
+00001da0: 202d 2d2d 2d2d 2d2d 2d2d 2d0a 2020 2020   ----------.    
+00001db0: 7465 6d70 6c61 7465 7320 3a20 7374 7220  templates : str 
+00001dc0: 6f72 2050 6174 6820 6f62 6a65 6374 0a20  or Path object. 
+00001dd0: 2020 2020 2020 2074 656d 706c 6174 6573         templates
+00001de0: 2066 696c 650a 2020 2020 7265 7475 726e   file.    return
+00001df0: 5f68 355f 6f62 6a65 6374 7320 3a20 626f  _h5_objects : bo
+00001e00: 6f6c 0a20 2020 2020 2020 2049 6620 5472  ol.        If Tr
+00001e10: 7565 206f 7574 7075 7420 6f62 6a65 6374  ue output object
+00001e20: 7320 6172 6520 6835 206f 626a 6563 7473  s are h5 objects
+00001e30: 0a20 2020 2076 6572 626f 7365 203a 2062  .    verbose : b
+00001e40: 6f6f 6c0a 2020 2020 2020 2020 4966 2054  ool.        If T
+00001e50: 7275 6520 6f75 7470 7574 2069 7320 7665  rue output is ve
+00001e60: 7262 6f73 650a 2020 2020 6368 6563 6b5f  rbose.    check_
+00001e70: 7375 6666 6978 203a 2062 6f6f 6c0a 2020  suffix : bool.  
+00001e80: 2020 2020 2020 4966 2054 7275 652c 2068        If True, h
+00001e90: 6466 3520 7375 6666 6978 2069 7320 6368  df5 suffix is ch
+00001ea0: 6563 6b65 640a 0a20 2020 2052 6574 7572  ecked..    Retur
+00001eb0: 6e73 0a20 2020 202d 2d2d 2d2d 2d2d 0a20  ns.    -------. 
+00001ec0: 2020 2074 656d 7067 656e 203a 2054 656d     tempgen : Tem
+00001ed0: 706c 6174 6547 656e 6572 6174 6f72 0a20  plateGenerator. 
+00001ee0: 2020 2020 2020 2054 656d 706c 6174 6547         TemplateG
+00001ef0: 656e 6572 6174 6f72 206f 626a 6563 740a  enerator object.
+00001f00: 0a20 2020 2022 2222 0a20 2020 2066 726f  .    """.    fro
+00001f10: 6d20 4d45 4172 6563 2069 6d70 6f72 7420  m MEArec import 
+00001f20: 5465 6d70 6c61 7465 4765 6e65 7261 746f  TemplateGenerato
+00001f30: 720a 0a20 2020 2069 6620 7665 7262 6f73  r..    if verbos
+00001f40: 653a 0a20 2020 2020 2020 2070 7269 6e74  e:.        print
+00001f50: 2822 4c6f 6164 696e 6720 7465 6d70 6c61  ("Loading templa
+00001f60: 7465 732e 2e2e 2229 0a0a 2020 2020 7465  tes...")..    te
+00001f70: 6d70 5f64 6963 7420 3d20 7b7d 0a20 2020  mp_dict = {}.   
+00001f80: 2074 656d 706c 6174 6573 203d 2050 6174   templates = Pat
+00001f90: 6828 7465 6d70 6c61 7465 7329 0a20 2020  h(templates).   
+00001fa0: 2069 6620 2874 656d 706c 6174 6573 2e73   if (templates.s
+00001fb0: 7566 6669 7820 696e 205b 222e 6835 222c  uffix in [".h5",
+00001fc0: 2022 2e68 6466 3522 5d29 206f 7220 286e   ".hdf5"]) or (n
+00001fd0: 6f74 2063 6865 636b 5f73 7566 6669 7829  ot check_suffix)
+00001fe0: 3a0a 2020 2020 2020 2020 6620 3d20 6835  :.        f = h5
+00001ff0: 7079 2e46 696c 6528 7374 7228 7465 6d70  py.File(str(temp
+00002000: 6c61 7465 7329 2c20 2272 2229 0a20 2020  lates), "r").   
+00002010: 2020 2020 2069 6e66 6f20 3d20 6c6f 6164       info = load
+00002020: 5f64 6963 745f 6672 6f6d 5f68 6466 3528  _dict_from_hdf5(
+00002030: 662c 2022 696e 666f 2f22 290a 2020 2020  f, "info/").    
+00002040: 2020 2020 6365 6c6c 7479 7065 7320 3d20      celltypes = 
+00002050: 6e70 2e61 7272 6179 2866 2e67 6574 2822  np.array(f.get("
+00002060: 6365 6c6c 7479 7065 7322 2929 0a20 2020  celltypes")).   
+00002070: 2020 2020 2074 656d 705f 6469 6374 5b22       temp_dict["
+00002080: 6365 6c6c 7479 7065 7322 5d20 3d20 6e70  celltypes"] = np
+00002090: 2e61 7272 6179 285b 632e 6465 636f 6465  .array([c.decode
+000020a0: 2822 7574 662d 3822 2920 666f 7220 6320  ("utf-8") for c 
+000020b0: 696e 2063 656c 6c74 7970 6573 5d29 0a20  in celltypes]). 
+000020c0: 2020 2020 2020 2069 6620 7265 7475 726e         if return
+000020d0: 5f68 355f 6f62 6a65 6374 733a 0a20 2020  _h5_objects:.   
+000020e0: 2020 2020 2020 2020 2074 656d 705f 6469           temp_di
+000020f0: 6374 5b22 6c6f 6361 7469 6f6e 7322 5d20  ct["locations"] 
+00002100: 3d20 662e 6765 7428 226c 6f63 6174 696f  = f.get("locatio
+00002110: 6e73 2229 0a20 2020 2020 2020 2065 6c73  ns").        els
+00002120: 653a 0a20 2020 2020 2020 2020 2020 2074  e:.            t
+00002130: 656d 705f 6469 6374 5b22 6c6f 6361 7469  emp_dict["locati
+00002140: 6f6e 7322 5d20 3d20 6e70 2e61 7272 6179  ons"] = np.array
+00002150: 2866 2e67 6574 2822 6c6f 6361 7469 6f6e  (f.get("location
+00002160: 7322 2929 0a20 2020 2020 2020 2069 6620  s")).        if 
+00002170: 7265 7475 726e 5f68 355f 6f62 6a65 6374  return_h5_object
+00002180: 733a 0a20 2020 2020 2020 2020 2020 2074  s:.            t
+00002190: 656d 705f 6469 6374 5b22 726f 7461 7469  emp_dict["rotati
+000021a0: 6f6e 7322 5d20 3d20 662e 6765 7428 2272  ons"] = f.get("r
+000021b0: 6f74 6174 696f 6e73 2229 0a20 2020 2020  otations").     
+000021c0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+000021d0: 2020 2020 2074 656d 705f 6469 6374 5b22       temp_dict["
+000021e0: 726f 7461 7469 6f6e 7322 5d20 3d20 6e70  rotations"] = np
+000021f0: 2e61 7272 6179 2866 2e67 6574 2822 726f  .array(f.get("ro
+00002200: 7461 7469 6f6e 7322 2929 0a20 2020 2020  tations")).     
+00002210: 2020 2069 6620 7265 7475 726e 5f68 355f     if return_h5_
+00002220: 6f62 6a65 6374 733a 0a20 2020 2020 2020  objects:.       
+00002230: 2020 2020 2074 656d 705f 6469 6374 5b22       temp_dict["
+00002240: 7465 6d70 6c61 7465 7322 5d20 3d20 662e  templates"] = f.
+00002250: 6765 7428 2274 656d 706c 6174 6573 2229  get("templates")
+00002260: 0a20 2020 2020 2020 2065 6c73 653a 0a20  .        else:. 
+00002270: 2020 2020 2020 2020 2020 2074 656d 705f             temp_
+00002280: 6469 6374 5b22 7465 6d70 6c61 7465 7322  dict["templates"
+00002290: 5d20 3d20 6e70 2e61 7272 6179 2866 2e67  ] = np.array(f.g
+000022a0: 6574 2822 7465 6d70 6c61 7465 7322 2929  et("templates"))
+000022b0: 0a20 2020 2065 6c73 653a 0a20 2020 2020  .    else:.     
+000022c0: 2020 2072 6169 7365 2045 7863 6570 7469     raise Excepti
+000022d0: 6f6e 2822 5265 636f 7264 696e 6773 206d  on("Recordings m
+000022e0: 7573 7420 6265 2061 6e20 6864 6635 2066  ust be an hdf5 f
+000022f0: 696c 6520 282e 6835 206f 7220 2e68 6466  ile (.h5 or .hdf
+00002300: 3529 2229 0a0a 2020 2020 6966 2076 6572  5)")..    if ver
+00002310: 626f 7365 3a0a 2020 2020 2020 2020 7072  bose:.        pr
+00002320: 696e 7428 2244 6f6e 6520 6c6f 6164 696e  int("Done loadin
+00002330: 6720 7465 6d70 6c61 7465 732e 2e2e 2229  g templates...")
+00002340: 0a20 2020 2069 6620 6e6f 7420 7265 7475  .    if not retu
+00002350: 726e 5f68 355f 6f62 6a65 6374 733a 0a20  rn_h5_objects:. 
+00002360: 2020 2020 2020 2066 2e63 6c6f 7365 2829         f.close()
+00002370: 0a20 2020 2074 656d 7067 656e 203d 2054  .    tempgen = T
+00002380: 656d 706c 6174 6547 656e 6572 6174 6f72  emplateGenerator
+00002390: 2874 656d 705f 6469 6374 3d74 656d 705f  (temp_dict=temp_
+000023a0: 6469 6374 2c20 696e 666f 3d69 6e66 6f29  dict, info=info)
+000023b0: 0a20 2020 2072 6574 7572 6e20 7465 6d70  .    return temp
+000023c0: 6765 6e0a 0a0a 6465 6620 6c6f 6164 5f72  gen...def load_r
+000023d0: 6563 6f72 6469 6e67 7328 0a20 2020 2072  ecordings(.    r
+000023e0: 6563 6f72 6469 6e67 732c 2072 6574 7572  ecordings, retur
+000023f0: 6e5f 6835 5f6f 626a 6563 7473 3d54 7275  n_h5_objects=Tru
+00002400: 652c 206c 6f61 643d 4e6f 6e65 2c20 6c6f  e, load=None, lo
+00002410: 6164 5f77 6176 6566 6f72 6d73 3d54 7275  ad_waveforms=Tru
+00002420: 652c 2063 6865 636b 5f73 7566 6669 783d  e, check_suffix=
+00002430: 5472 7565 2c20 7665 7262 6f73 653d 4661  True, verbose=Fa
+00002440: 6c73 650a 293a 0a20 2020 2022 2222 0a20  lse.):.    """. 
+00002450: 2020 204c 6f61 6420 6765 6e65 7261 7465     Load generate
+00002460: 6420 7265 636f 7264 696e 6773 2e0a 0a20  d recordings... 
+00002470: 2020 2050 6172 616d 6574 6572 730a 2020     Parameters.  
+00002480: 2020 2d2d 2d2d 2d2d 2d2d 2d2d 0a20 2020    ----------.   
+00002490: 2072 6563 6f72 6469 6e67 7320 3a20 7374   recordings : st
+000024a0: 7220 6f72 2050 6174 6820 6f62 6a65 6374  r or Path object
+000024b0: 0a20 2020 2020 2020 2052 6563 6f72 6469  .        Recordi
+000024c0: 6e67 7320 6669 6c65 0a20 2020 2072 6574  ngs file.    ret
+000024d0: 7572 6e5f 6835 5f6f 626a 6563 7473 203a  urn_h5_objects :
+000024e0: 2062 6f6f 6c0a 2020 2020 2020 2020 4966   bool.        If
+000024f0: 2054 7275 6520 6f75 7470 7574 206f 626a   True output obj
+00002500: 6563 7473 2061 7265 2068 3520 6f62 6a65  ects are h5 obje
+00002510: 6374 730a 2020 2020 6c6f 6164 203a 206c  cts.    load : l
+00002520: 6973 740a 2020 2020 2020 2020 4c69 7374  ist.        List
+00002530: 206f 6620 6669 656c 6473 2074 6f20 6265   of fields to be
+00002540: 206c 6f61 6465 6420 2828 2772 6563 6f72   loaded (('recor
+00002550: 6469 6e67 7327 2c20 2763 6861 6e6e 656c  dings', 'channel
+00002560: 5f70 6f73 6974 696f 6e73 272c 2027 766f  _positions', 'vo
+00002570: 6c74 6167 655f 7065 616b 7327 2c20 2773  ltage_peaks', 's
+00002580: 7069 6b65 7472 6169 6e73 272c 0a20 2020  piketrains',.   
+00002590: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000025a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000025b0: 2020 2020 2774 696d 6573 7461 6d70 7327      'timestamps'
+000025c0: 2c20 2773 7069 6b65 5f74 7261 6365 7327  , 'spike_traces'
+000025d0: 2c20 2774 656d 706c 6174 6573 2729 290a  , 'templates')).
+000025e0: 2020 2020 6c6f 6164 5f77 6176 6566 6f72      load_wavefor
+000025f0: 6d73 203a 2062 6f6f 6c0a 2020 2020 2020  ms : bool.      
+00002600: 2020 4966 2054 7275 6520 7761 7665 666f    If True wavefo
+00002610: 726d 7320 6172 6520 6c6f 6164 6564 2074  rms are loaded t
+00002620: 6f20 7370 696b 6574 7261 696e 730a 2020  o spiketrains.  
+00002630: 2020 7665 7262 6f73 6520 3a20 626f 6f6c    verbose : bool
+00002640: 0a20 2020 2020 2020 2049 6620 5472 7565  .        If True
+00002650: 206f 7574 7075 7420 6973 2076 6572 626f   output is verbo
+00002660: 7365 0a20 2020 2063 6865 636b 5f73 7566  se.    check_suf
+00002670: 6669 7820 3a20 626f 6f6c 0a20 2020 2020  fix : bool.     
+00002680: 2020 2049 6620 5472 7565 2c20 6864 6635     If True, hdf5
+00002690: 2073 7566 6669 7820 6973 2063 6865 636b   suffix is check
+000026a0: 6564 0a0a 2020 2020 5265 7475 726e 730a  ed..    Returns.
+000026b0: 2020 2020 2d2d 2d2d 2d2d 2d0a 2020 2020      -------.    
+000026c0: 7265 6367 656e 203a 2052 6563 6f72 6469  recgen : Recordi
+000026d0: 6e67 4765 6e65 7261 746f 720a 2020 2020  ngGenerator.    
+000026e0: 2020 2020 5265 636f 7264 696e 6747 656e      RecordingGen
+000026f0: 6572 6174 6f72 206f 626a 6563 740a 0a20  erator object.. 
+00002700: 2020 2022 2222 0a20 2020 2066 726f 6d20     """.    from 
+00002710: 4d45 4172 6563 2069 6d70 6f72 7420 5265  MEArec import Re
+00002720: 636f 7264 696e 6747 656e 6572 6174 6f72  cordingGenerator
+00002730: 0a0a 2020 2020 6966 2076 6572 626f 7365  ..    if verbose
+00002740: 3a0a 2020 2020 2020 2020 7072 696e 7428  :.        print(
+00002750: 224c 6f61 6469 6e67 2072 6563 6f72 6469  "Loading recordi
+00002760: 6e67 732e 2e2e 2229 0a0a 2020 2020 7265  ngs...")..    re
+00002770: 635f 6469 6374 203d 207b 7d0a 2020 2020  c_dict = {}.    
+00002780: 7265 636f 7264 696e 6773 203d 2050 6174  recordings = Pat
+00002790: 6828 7265 636f 7264 696e 6773 290a 2020  h(recordings).  
+000027a0: 2020 6966 2028 7265 636f 7264 696e 6773    if (recordings
+000027b0: 2e73 7566 6669 7820 696e 205b 222e 6835  .suffix in [".h5
+000027c0: 222c 2022 2e68 6466 3522 5d29 206f 7220  ", ".hdf5"]) or 
+000027d0: 286e 6f74 2063 6865 636b 5f73 7566 6669  (not check_suffi
+000027e0: 7829 3a0a 2020 2020 2020 2020 6620 3d20  x):.        f = 
+000027f0: 6835 7079 2e46 696c 6528 7374 7228 7265  h5py.File(str(re
+00002800: 636f 7264 696e 6773 292c 2022 7222 290a  cordings), "r").
+00002810: 2020 2020 2020 2020 6d65 6172 6563 5f76          mearec_v
+00002820: 6572 7369 6f6e 203d 2066 2e61 7474 7273  ersion = f.attrs
+00002830: 2e67 6574 2822 6d65 6172 6563 5f76 6572  .get("mearec_ver
+00002840: 7369 6f6e 222c 2022 312e 342e 3022 290a  sion", "1.4.0").
+00002850: 0a20 2020 2020 2020 2069 6620 7061 7273  .        if pars
+00002860: 6528 6d65 6172 6563 5f76 6572 7369 6f6e  e(mearec_version
+00002870: 2920 3e3d 2070 6172 7365 2822 312e 352e  ) >= parse("1.5.
+00002880: 3022 293a 0a20 2020 2020 2020 2020 2020  0"):.           
+00002890: 2023 2076 6572 7369 6f6e 2061 6674 6572   # version after
+000028a0: 2031 2e35 2e30 2069 7320 286e 5f73 616d   1.5.0 is (n_sam
+000028b0: 706c 6573 2c20 6e5f 6368 616e 6e65 6c29  ples, n_channel)
+000028c0: 2069 6e73 6964 6520 7468 6520 6835 2066   inside the h5 f
+000028d0: 696c 650a 2020 2020 2020 2020 2020 2020  ile.            
+000028e0: 6e65 6564 5f74 7261 6e73 706f 7365 203d  need_transpose =
+000028f0: 2046 616c 7365 0a20 2020 2020 2020 2065   False.        e
+00002900: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+00002910: 2023 2076 6572 7369 6f6e 2020 312e 342e   # version  1.4.
+00002920: 3020 616e 6420 6265 666f 7265 2069 7320  0 and before is 
+00002930: 286e 5f63 6861 6e6e 656c 2c20 6e5f 7361  (n_channel, n_sa
+00002940: 6d70 6c65 7329 2069 6e73 6964 6520 7468  mples) inside th
+00002950: 6520 6835 2066 696c 650a 2020 2020 2020  e h5 file.      
+00002960: 2020 2020 2020 7072 696e 7428 0a20 2020        print(.   
+00002970: 2020 2020 2020 2020 2020 2020 2022 5761               "Wa
+00002980: 726e 696e 673a 204d 4541 7265 6320 6669  rning: MEArec fi
+00002990: 6c65 2063 7265 6174 6564 2077 6974 6820  le created with 
+000029a0: 7665 7273 696f 6e20 3c31 2e35 2e20 5468  version <1.5. Th
+000029b0: 6973 2063 6f75 6c64 2072 6573 756c 7420  is could result 
+000029c0: 696e 206c 6f77 6572 2065 6666 6963 6965  in lower efficie
+000029d0: 6e63 792e 2054 6f20 7570 6772 6164 6522  ncy. To upgrade"
+000029e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000029f0: 2022 796f 7572 2066 696c 6520 746f 2074   "your file to t
+00002a00: 6865 206e 6577 2066 6f72 6d61 7420 7573  he new format us
+00002a10: 653a 206d 722e 636f 6e76 6572 745f 7265  e: mr.convert_re
+00002a20: 636f 7264 696e 675f 746f 5f6e 6577 5f76  cording_to_new_v
+00002a30: 6572 7369 6f6e 2866 696c 656e 616d 6529  ersion(filename)
+00002a40: 220a 2020 2020 2020 2020 2020 2020 290a  ".            ).
+00002a50: 2020 2020 2020 2020 2020 2020 6e65 6564              need
+00002a60: 5f74 7261 6e73 706f 7365 203d 2054 7275  _transpose = Tru
+00002a70: 650a 0a20 2020 2020 2020 2072 6563 5f64  e..        rec_d
+00002a80: 6963 742c 2069 6e66 6f20 3d20 6c6f 6164  ict, info = load
+00002a90: 5f72 6563 6f72 6469 6e67 735f 6672 6f6d  _recordings_from
+00002aa0: 5f66 696c 6528 0a20 2020 2020 2020 2020  _file(.         
+00002ab0: 2020 2066 2c0a 2020 2020 2020 2020 2020     f,.          
+00002ac0: 2020 7265 7475 726e 5f68 355f 6f62 6a65    return_h5_obje
+00002ad0: 6374 733d 7265 7475 726e 5f68 355f 6f62  cts=return_h5_ob
+00002ae0: 6a65 6374 732c 0a20 2020 2020 2020 2020  jects,.         
+00002af0: 2020 206c 6f61 643d 6c6f 6164 2c0a 2020     load=load,.  
+00002b00: 2020 2020 2020 2020 2020 6e65 6564 5f74            need_t
+00002b10: 7261 6e73 706f 7365 3d6e 6565 645f 7472  ranspose=need_tr
+00002b20: 616e 7370 6f73 652c 0a20 2020 2020 2020  anspose,.       
+00002b30: 2020 2020 206c 6f61 645f 7761 7665 666f       load_wavefo
+00002b40: 726d 733d 6c6f 6164 5f77 6176 6566 6f72  rms=load_wavefor
+00002b50: 6d73 2c0a 2020 2020 2020 2020 290a 0a20  ms,.        ).. 
+00002b60: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+00002b70: 2072 6169 7365 2045 7863 6570 7469 6f6e   raise Exception
+00002b80: 2822 5265 636f 7264 696e 6773 206d 7573  ("Recordings mus
+00002b90: 7420 6265 2061 6e20 6864 6635 2066 696c  t be an hdf5 fil
+00002ba0: 6520 282e 6835 206f 7220 2e68 6466 3529  e (.h5 or .hdf5)
+00002bb0: 2229 0a0a 2020 2020 6966 2076 6572 626f  ")..    if verbo
+00002bc0: 7365 3a0a 2020 2020 2020 2020 7072 696e  se:.        prin
+00002bd0: 7428 2244 6f6e 6520 6c6f 6164 696e 6720  t("Done loading 
+00002be0: 7265 636f 7264 696e 6773 2e2e 2e22 290a  recordings...").
+00002bf0: 0a20 2020 2069 6620 6e6f 7420 7265 7475  .    if not retu
+00002c00: 726e 5f68 355f 6f62 6a65 6374 733a 0a20  rn_h5_objects:. 
+00002c10: 2020 2020 2020 2066 2e63 6c6f 7365 2829         f.close()
+00002c20: 0a20 2020 2072 6563 6765 6e20 3d20 5265  .    recgen = Re
+00002c30: 636f 7264 696e 6747 656e 6572 6174 6f72  cordingGenerator
+00002c40: 2872 6563 5f64 6963 743d 7265 635f 6469  (rec_dict=rec_di
+00002c50: 6374 2c20 696e 666f 3d69 6e66 6f29 0a20  ct, info=info). 
+00002c60: 2020 2069 6620 2267 6169 6e5f 746f 5f75     if "gain_to_u
+00002c70: 5622 2069 6e20 7265 635f 6469 6374 3a0a  V" in rec_dict:.
+00002c80: 2020 2020 2020 2020 7265 6367 656e 2e67          recgen.g
+00002c90: 6169 6e5f 746f 5f75 5620 3d20 7265 635f  ain_to_uV = rec_
+00002ca0: 6469 6374 5b22 6761 696e 5f74 6f5f 7556  dict["gain_to_uV
+00002cb0: 225d 0a20 2020 2072 6574 7572 6e20 7265  "].    return re
+00002cc0: 6367 656e 0a0a 0a64 6566 206c 6f61 645f  cgen...def load_
+00002cd0: 7265 636f 7264 696e 6773 5f66 726f 6d5f  recordings_from_
+00002ce0: 6669 6c65 2866 2c20 7061 7468 3d22 222c  file(f, path="",
+00002cf0: 2072 6574 7572 6e5f 6835 5f6f 626a 6563   return_h5_objec
+00002d00: 7473 3d54 7275 652c 206c 6f61 643d 4e6f  ts=True, load=No
+00002d10: 6e65 2c20 6e65 6564 5f74 7261 6e73 706f  ne, need_transpo
+00002d20: 7365 3d46 616c 7365 2c20 6c6f 6164 5f77  se=False, load_w
+00002d30: 6176 6566 6f72 6d73 3d54 7275 6529 3a0a  aveforms=True):.
+00002d40: 2020 2020 2222 220a 2020 2020 4c6f 6164      """.    Load
+00002d50: 2067 656e 6572 6174 6564 2072 6563 6f72   generated recor
+00002d60: 6469 6e67 7320 6672 6f6d 2066 696c 652e  dings from file.
+00002d70: 0a0a 2020 2020 5061 7261 6d65 7465 7273  ..    Parameters
+00002d80: 0a20 2020 202d 2d2d 2d2d 2d2d 2d2d 2d0a  .    ----------.
+00002d90: 2020 2020 6669 6c65 6e61 6d65 203a 205f      filename : _
+00002da0: 696f 2e54 6578 7449 4f57 7261 7070 6572  io.TextIOWrapper
+00002db0: 0a20 2020 2020 2020 2046 696c 6520 6861  .        File ha
+00002dc0: 6e64 6c65 720a 2020 2020 7061 7468 3a20  ndler.    path: 
+00002dd0: 7374 720a 2020 2020 2020 2020 5061 7468  str.        Path
+00002de0: 2069 6e73 6964 6520 7468 6520 6835 2064   inside the h5 d
+00002df0: 6174 6162 6173 650a 2020 2020 7265 7475  atabase.    retu
+00002e00: 726e 5f68 355f 6f62 6a65 6374 7320 3a20  rn_h5_objects : 
+00002e10: 626f 6f6c 0a20 2020 2020 2020 2049 6620  bool.        If 
+00002e20: 5472 7565 206f 7574 7075 7420 6f62 6a65  True output obje
+00002e30: 6374 7320 6172 6520 6835 206f 626a 6563  cts are h5 objec
+00002e40: 7473 0a20 2020 206c 6f61 6420 3a20 6c69  ts.    load : li
+00002e50: 7374 0a20 2020 2020 2020 204c 6973 7420  st.        List 
+00002e60: 6f66 2066 6965 6c64 7320 746f 2062 6520  of fields to be 
+00002e70: 6c6f 6164 6564 2028 2827 7265 636f 7264  loaded (('record
+00002e80: 696e 6773 272c 2027 6368 616e 6e65 6c5f  ings', 'channel_
+00002e90: 706f 7369 7469 6f6e 7327 2c20 2776 6f6c  positions', 'vol
+00002ea0: 7461 6765 5f70 6561 6b73 272c 2027 7370  tage_peaks', 'sp
+00002eb0: 696b 6574 7261 696e 7327 2c0a 2020 2020  iketrains',.    
+00002ec0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002ed0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002ee0: 2020 2027 7469 6d65 7374 616d 7073 272c     'timestamps',
+00002ef0: 2027 7370 696b 655f 7472 6163 6573 272c   'spike_traces',
+00002f00: 2027 7465 6d70 6c61 7465 7327 2929 0a20   'templates')). 
+00002f10: 2020 206c 6f61 645f 7761 7665 666f 726d     load_waveform
+00002f20: 7320 3a20 626f 6f6c 0a20 2020 2020 2020  s : bool.       
+00002f30: 2049 6620 5472 7565 2077 6176 6566 6f72   If True wavefor
+00002f40: 6d73 2061 7265 206c 6f61 6465 6420 746f  ms are loaded to
+00002f50: 2073 7069 6b65 7472 6169 6e73 0a20 2020   spiketrains.   
+00002f60: 2076 6572 626f 7365 203a 2062 6f6f 6c0a   verbose : bool.
+00002f70: 2020 2020 2020 2020 4966 2054 7275 6520          If True 
+00002f80: 6f75 7470 7574 2069 7320 7665 7262 6f73  output is verbos
+00002f90: 650a 2020 2020 6368 6563 6b5f 7375 6666  e.    check_suff
+00002fa0: 6978 203a 2062 6f6f 6c0a 2020 2020 2020  ix : bool.      
+00002fb0: 2020 4966 2054 7275 652c 2068 6466 3520    If True, hdf5 
+00002fc0: 7375 6666 6978 2069 7320 6368 6563 6b65  suffix is checke
+00002fd0: 640a 0a20 2020 2052 6574 7572 6e73 0a20  d..    Returns. 
+00002fe0: 2020 202d 2d2d 2d2d 2d2d 0a20 2020 2072     -------.    r
+00002ff0: 6563 6765 6e20 3a20 5265 636f 7264 696e  ecgen : Recordin
+00003000: 6747 656e 6572 6174 6f72 0a20 2020 2020  gGenerator.     
+00003010: 2020 2052 6563 6f72 6469 6e67 4765 6e65     RecordingGene
+00003020: 7261 746f 7220 6f62 6a65 6374 0a0a 2020  rator object..  
+00003030: 2020 2222 220a 0a20 2020 2069 6620 6c6f    """..    if lo
+00003040: 6164 2069 7320 4e6f 6e65 3a0a 2020 2020  ad is None:.    
+00003050: 2020 2020 6c6f 6164 203d 205b 0a20 2020      load = [.   
+00003060: 2020 2020 2020 2020 2022 7265 636f 7264           "record
+00003070: 696e 6773 222c 0a20 2020 2020 2020 2020  ings",.         
+00003080: 2020 2022 6368 616e 6e65 6c5f 706f 7369     "channel_posi
+00003090: 7469 6f6e 7322 2c0a 2020 2020 2020 2020  tions",.        
+000030a0: 2020 2020 2276 6f6c 7461 6765 5f70 6561      "voltage_pea
+000030b0: 6b73 222c 0a20 2020 2020 2020 2020 2020  ks",.           
+000030c0: 2022 7370 696b 6574 7261 696e 7322 2c0a   "spiketrains",.
+000030d0: 2020 2020 2020 2020 2020 2020 2274 696d              "tim
+000030e0: 6573 7461 6d70 7322 2c0a 2020 2020 2020  estamps",.      
+000030f0: 2020 2020 2020 2273 7069 6b65 5f74 7261        "spike_tra
+00003100: 6365 7322 2c0a 2020 2020 2020 2020 2020  ces",.          
+00003110: 2020 2274 656d 706c 6174 6573 222c 0a20    "templates",. 
+00003120: 2020 2020 2020 2020 2020 2022 7465 6d70             "temp
+00003130: 6c61 7465 5f69 6473 222c 0a20 2020 2020  late_ids",.     
+00003140: 2020 2020 2020 2022 6472 6966 745f 6469         "drift_di
+00003150: 6374 222c 0a20 2020 2020 2020 205d 0a20  ct",.        ]. 
+00003160: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+00003170: 2061 7373 6572 7420 6973 696e 7374 616e   assert isinstan
+00003180: 6365 286c 6f61 642c 206c 6973 7429 2c20  ce(load, list), 
+00003190: 280a 2020 2020 2020 2020 2020 2020 2227  (.            "'
+000031a0: 6c6f 6164 2720 7368 6f75 6c64 2062 6520  load' should be 
+000031b0: 6120 6c69 7374 2077 6974 6820 7374 7269  a list with stri
+000031c0: 6e67 7320 6f66 2077 6861 7420 746f 2062  ngs of what to b
+000031d0: 6520 6c6f 6164 6564 2022 0a20 2020 2020  e loaded ".     
+000031e0: 2020 2020 2020 2022 2827 7265 636f 7264         "('record
+000031f0: 696e 6773 272c 2027 6368 616e 6e65 6c5f  ings', 'channel_
+00003200: 706f 7369 7469 6f6e 7327 2c20 2776 6f6c  positions', 'vol
+00003210: 7461 6765 5f70 6561 6b73 272c 2027 7370  tage_peaks', 'sp
+00003220: 696b 6574 7261 696e 7327 2c20 220a 2020  iketrains', ".  
+00003230: 2020 2020 2020 2020 2020 2227 7469 6d65            "'time
+00003240: 7374 616d 7073 272c 2027 7370 696b 655f  stamps', 'spike_
+00003250: 7472 6163 6573 272c 2027 7465 6d70 6c61  traces', 'templa
+00003260: 7465 7327 2922 0a20 2020 2020 2020 2029  tes')".        )
+00003270: 0a20 2020 2072 6563 5f64 6963 7420 3d20  .    rec_dict = 
+00003280: 7b7d 0a20 2020 2069 6e66 6f20 3d20 6c6f  {}.    info = lo
+00003290: 6164 5f64 6963 745f 6672 6f6d 5f68 6466  ad_dict_from_hdf
+000032a0: 3528 662c 2070 6174 6820 2b20 2269 6e66  5(f, path + "inf
+000032b0: 6f2f 2229 0a20 2020 2069 6620 662e 6765  o/").    if f.ge
+000032c0: 7428 7061 7468 202b 2022 766f 6c74 6167  t(path + "voltag
+000032d0: 655f 7065 616b 7322 2920 6973 206e 6f74  e_peaks") is not
+000032e0: 204e 6f6e 6520 616e 6420 2276 6f6c 7461   None and "volta
+000032f0: 6765 5f70 6561 6b73 2220 696e 206c 6f61  ge_peaks" in loa
+00003300: 643a 0a20 2020 2020 2020 2069 6620 7265  d:.        if re
+00003310: 7475 726e 5f68 355f 6f62 6a65 6374 733a  turn_h5_objects:
+00003320: 0a20 2020 2020 2020 2020 2020 2072 6563  .            rec
+00003330: 5f64 6963 745b 2276 6f6c 7461 6765 5f70  _dict["voltage_p
+00003340: 6561 6b73 225d 203d 2066 2e67 6574 2870  eaks"] = f.get(p
+00003350: 6174 6820 2b20 2276 6f6c 7461 6765 5f70  ath + "voltage_p
+00003360: 6561 6b73 2229 0a20 2020 2020 2020 2065  eaks").        e
+00003370: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+00003380: 2072 6563 5f64 6963 745b 2276 6f6c 7461   rec_dict["volta
+00003390: 6765 5f70 6561 6b73 225d 203d 206e 702e  ge_peaks"] = np.
+000033a0: 6172 7261 7928 662e 6765 7428 7061 7468  array(f.get(path
+000033b0: 202b 2022 766f 6c74 6167 655f 7065 616b   + "voltage_peak
+000033c0: 7322 2929 0a20 2020 2069 6620 662e 6765  s")).    if f.ge
+000033d0: 7428 7061 7468 202b 2022 6368 616e 6e65  t(path + "channe
+000033e0: 6c5f 706f 7369 7469 6f6e 7322 2920 6973  l_positions") is
+000033f0: 206e 6f74 204e 6f6e 6520 616e 6420 2263   not None and "c
+00003400: 6861 6e6e 656c 5f70 6f73 6974 696f 6e73  hannel_positions
+00003410: 2220 696e 206c 6f61 643a 0a20 2020 2020  " in load:.     
+00003420: 2020 2069 6620 7265 7475 726e 5f68 355f     if return_h5_
+00003430: 6f62 6a65 6374 733a 0a20 2020 2020 2020  objects:.       
+00003440: 2020 2020 2072 6563 5f64 6963 745b 2263       rec_dict["c
+00003450: 6861 6e6e 656c 5f70 6f73 6974 696f 6e73  hannel_positions
+00003460: 225d 203d 2066 2e67 6574 2870 6174 6820  "] = f.get(path 
+00003470: 2b20 2263 6861 6e6e 656c 5f70 6f73 6974  + "channel_posit
+00003480: 696f 6e73 2229 0a20 2020 2020 2020 2065  ions").        e
+00003490: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+000034a0: 2072 6563 5f64 6963 745b 2263 6861 6e6e   rec_dict["chann
+000034b0: 656c 5f70 6f73 6974 696f 6e73 225d 203d  el_positions"] =
+000034c0: 206e 702e 6172 7261 7928 662e 6765 7428   np.array(f.get(
+000034d0: 7061 7468 202b 2022 6368 616e 6e65 6c5f  path + "channel_
+000034e0: 706f 7369 7469 6f6e 7322 2929 0a20 2020  positions")).   
+000034f0: 2069 6620 662e 6765 7428 7061 7468 202b   if f.get(path +
+00003500: 2022 7265 636f 7264 696e 6773 2229 2069   "recordings") i
+00003510: 7320 6e6f 7420 4e6f 6e65 2061 6e64 2022  s not None and "
+00003520: 7265 636f 7264 696e 6773 2220 696e 206c  recordings" in l
+00003530: 6f61 643a 0a20 2020 2020 2020 2069 6620  oad:.        if 
+00003540: 7265 7475 726e 5f68 355f 6f62 6a65 6374  return_h5_object
+00003550: 733a 0a20 2020 2020 2020 2020 2020 2069  s:.            i
+00003560: 6620 6e65 6564 5f74 7261 6e73 706f 7365  f need_transpose
+00003570: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00003580: 2020 7265 635f 6469 6374 5b22 7265 636f    rec_dict["reco
+00003590: 7264 696e 6773 225d 203d 2044 6174 6173  rdings"] = Datas
+000035a0: 6574 5669 6577 2866 2e67 6574 2870 6174  etView(f.get(pat
+000035b0: 6820 2b20 2272 6563 6f72 6469 6e67 7322  h + "recordings"
+000035c0: 2929 2e6c 617a 795f 7472 616e 7370 6f73  )).lazy_transpos
+000035d0: 6528 290a 2020 2020 2020 2020 2020 2020  e().            
+000035e0: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+000035f0: 2020 2020 2020 7265 635f 6469 6374 5b22        rec_dict["
+00003600: 7265 636f 7264 696e 6773 225d 203d 2066  recordings"] = f
+00003610: 2e67 6574 2870 6174 6820 2b20 2272 6563  .get(path + "rec
+00003620: 6f72 6469 6e67 7322 290a 2020 2020 2020  ordings").      
+00003630: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+00003640: 2020 2020 6172 7220 3d20 6e70 2e61 7272      arr = np.arr
+00003650: 6179 2866 2e67 6574 2870 6174 6820 2b20  ay(f.get(path + 
+00003660: 2272 6563 6f72 6469 6e67 7322 2929 0a20  "recordings")). 
+00003670: 2020 2020 2020 2020 2020 2069 6620 6e65             if ne
+00003680: 6564 5f74 7261 6e73 706f 7365 3a0a 2020  ed_transpose:.  
+00003690: 2020 2020 2020 2020 2020 2020 2020 6172                ar
+000036a0: 7220 3d20 6172 722e 540a 2020 2020 2020  r = arr.T.      
+000036b0: 2020 2020 2020 7265 635f 6469 6374 5b22        rec_dict["
+000036c0: 7265 636f 7264 696e 6773 225d 203d 2061  recordings"] = a
+000036d0: 7272 0a20 2020 2020 2020 2069 6620 2267  rr.        if "g
+000036e0: 6169 6e5f 746f 5f75 5622 2069 6e20 662e  ain_to_uV" in f.
+000036f0: 6765 7428 7061 7468 202b 2022 7265 636f  get(path + "reco
+00003700: 7264 696e 6773 2229 2e61 7474 7273 3a0a  rdings").attrs:.
+00003710: 2020 2020 2020 2020 2020 2020 7265 635f              rec_
+00003720: 6469 6374 5b22 6761 696e 5f74 6f5f 7556  dict["gain_to_uV
+00003730: 225d 203d 2066 2e67 6574 2870 6174 6820  "] = f.get(path 
+00003740: 2b20 2272 6563 6f72 6469 6e67 7322 292e  + "recordings").
+00003750: 6174 7472 735b 2267 6169 6e5f 746f 5f75  attrs["gain_to_u
+00003760: 5622 5d0a 2020 2020 6966 2066 2e67 6574  V"].    if f.get
+00003770: 2870 6174 6820 2b20 2273 7069 6b65 5f74  (path + "spike_t
+00003780: 7261 6365 7322 2920 6973 206e 6f74 204e  races") is not N
+00003790: 6f6e 6520 616e 6420 2273 7069 6b65 5f74  one and "spike_t
+000037a0: 7261 6365 7322 2069 6e20 6c6f 6164 3a0a  races" in load:.
+000037b0: 2020 2020 2020 2020 6966 2072 6574 7572          if retur
+000037c0: 6e5f 6835 5f6f 626a 6563 7473 3a0a 2020  n_h5_objects:.  
+000037d0: 2020 2020 2020 2020 2020 6966 206e 6565            if nee
+000037e0: 645f 7472 616e 7370 6f73 653a 0a20 2020  d_transpose:.   
+000037f0: 2020 2020 2020 2020 2020 2020 2072 6563               rec
+00003800: 5f64 6963 745b 2273 7069 6b65 5f74 7261  _dict["spike_tra
+00003810: 6365 7322 5d20 3d20 4461 7461 7365 7456  ces"] = DatasetV
+00003820: 6965 7728 662e 6765 7428 7061 7468 202b  iew(f.get(path +
+00003830: 2022 7370 696b 655f 7472 6163 6573 2229   "spike_traces")
+00003840: 292e 6c61 7a79 5f74 7261 6e73 706f 7365  ).lazy_transpose
+00003850: 2829 0a20 2020 2020 2020 2020 2020 2065  ().            e
+00003860: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+00003870: 2020 2020 2072 6563 5f64 6963 745b 2273       rec_dict["s
+00003880: 7069 6b65 5f74 7261 6365 7322 5d20 3d20  pike_traces"] = 
+00003890: 662e 6765 7428 7061 7468 202b 2022 7370  f.get(path + "sp
+000038a0: 696b 655f 7472 6163 6573 2229 0a20 2020  ike_traces").   
+000038b0: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+000038c0: 2020 2020 2020 2061 7272 203d 206e 702e         arr = np.
+000038d0: 6172 7261 7928 662e 6765 7428 7061 7468  array(f.get(path
+000038e0: 202b 2022 7370 696b 655f 7472 6163 6573   + "spike_traces
+000038f0: 2229 290a 2020 2020 2020 2020 2020 2020  ")).            
+00003900: 6966 206e 6565 645f 7472 616e 7370 6f73  if need_transpos
+00003910: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+00003920: 2020 2061 7272 203d 2061 7272 2e54 0a20     arr = arr.T. 
+00003930: 2020 2020 2020 2020 2020 2072 6563 5f64             rec_d
+00003940: 6963 745b 2273 7069 6b65 5f74 7261 6365  ict["spike_trace
+00003950: 7322 5d20 3d20 6172 720a 2020 2020 6966  s"] = arr.    if
+00003960: 2066 2e67 6574 2870 6174 6820 2b20 2274   f.get(path + "t
+00003970: 656d 706c 6174 6573 2229 2069 7320 6e6f  emplates") is no
+00003980: 7420 4e6f 6e65 2061 6e64 2022 7465 6d70  t None and "temp
+00003990: 6c61 7465 7322 2069 6e20 6c6f 6164 3a0a  lates" in load:.
+000039a0: 2020 2020 2020 2020 6966 2072 6574 7572          if retur
+000039b0: 6e5f 6835 5f6f 626a 6563 7473 3a0a 2020  n_h5_objects:.  
+000039c0: 2020 2020 2020 2020 2020 7265 635f 6469            rec_di
+000039d0: 6374 5b22 7465 6d70 6c61 7465 7322 5d20  ct["templates"] 
+000039e0: 3d20 662e 6765 7428 7061 7468 202b 2022  = f.get(path + "
+000039f0: 7465 6d70 6c61 7465 7322 290a 2020 2020  templates").    
+00003a00: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+00003a10: 2020 2020 2020 7265 635f 6469 6374 5b22        rec_dict["
+00003a20: 7465 6d70 6c61 7465 7322 5d20 3d20 6e70  templates"] = np
+00003a30: 2e61 7272 6179 2866 2e67 6574 2870 6174  .array(f.get(pat
+00003a40: 6820 2b20 2274 656d 706c 6174 6573 2229  h + "templates")
+00003a50: 290a 2020 2020 2020 2020 6966 2066 2e67  ).        if f.g
+00003a60: 6574 2870 6174 6820 2b20 226f 7269 6769  et(path + "origi
+00003a70: 6e61 6c5f 7465 6d70 6c61 7465 7322 2920  nal_templates") 
+00003a80: 6973 206e 6f74 204e 6f6e 653a 0a20 2020  is not None:.   
+00003a90: 2020 2020 2020 2020 2069 6620 7265 7475           if retu
+00003aa0: 726e 5f68 355f 6f62 6a65 6374 733a 0a20  rn_h5_objects:. 
+00003ab0: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+00003ac0: 6563 5f64 6963 745b 226f 7269 6769 6e61  ec_dict["origina
+00003ad0: 6c5f 7465 6d70 6c61 7465 7322 5d20 3d20  l_templates"] = 
+00003ae0: 662e 6765 7428 7061 7468 202b 2022 6f72  f.get(path + "or
+00003af0: 6967 696e 616c 5f74 656d 706c 6174 6573  iginal_templates
+00003b00: 2229 0a20 2020 2020 2020 2020 2020 2065  ").            e
+00003b10: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+00003b20: 2020 2020 2072 6563 5f64 6963 745b 226f       rec_dict["o
+00003b30: 7269 6769 6e61 6c5f 7465 6d70 6c61 7465  riginal_template
+00003b40: 7322 5d20 3d20 6e70 2e61 7272 6179 2866  s"] = np.array(f
+00003b50: 2e67 6574 2870 6174 6820 2b20 226f 7269  .get(path + "ori
+00003b60: 6769 6e61 6c5f 7465 6d70 6c61 7465 7322  ginal_templates"
+00003b70: 2929 0a20 2020 2020 2020 2069 6620 662e  )).        if f.
+00003b80: 6765 7428 7061 7468 202b 2022 7465 6d70  get(path + "temp
+00003b90: 6c61 7465 5f6c 6f63 6174 696f 6e73 2229  late_locations")
+00003ba0: 2069 7320 6e6f 7420 4e6f 6e65 3a0a 2020   is not None:.  
+00003bb0: 2020 2020 2020 2020 2020 6966 2072 6574            if ret
+00003bc0: 7572 6e5f 6835 5f6f 626a 6563 7473 3a0a  urn_h5_objects:.
 00003bd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003be0: 6172 7220 3d20 6172 722e 540a 2020 2020  arr = arr.T.    
-00003bf0: 2020 2020 2020 2020 7265 635f 6469 6374          rec_dict
-00003c00: 5b27 7370 696b 655f 7472 6163 6573 275d  ['spike_traces']
-00003c10: 203d 2061 7272 0a20 2020 2069 6620 662e   = arr.    if f.
-00003c20: 6765 7428 7061 7468 202b 2027 7465 6d70  get(path + 'temp
-00003c30: 6c61 7465 7327 2920 6973 206e 6f74 204e  lates') is not N
-00003c40: 6f6e 6520 616e 6420 2774 656d 706c 6174  one and 'templat
-00003c50: 6573 2720 696e 206c 6f61 643a 0a20 2020  es' in load:.   
-00003c60: 2020 2020 2069 6620 7265 7475 726e 5f68       if return_h
-00003c70: 355f 6f62 6a65 6374 733a 0a20 2020 2020  5_objects:.     
-00003c80: 2020 2020 2020 2072 6563 5f64 6963 745b         rec_dict[
-00003c90: 2774 656d 706c 6174 6573 275d 203d 2066  'templates'] = f
-00003ca0: 2e67 6574 2870 6174 6820 2b20 2774 656d  .get(path + 'tem
-00003cb0: 706c 6174 6573 2729 0a20 2020 2020 2020  plates').       
-00003cc0: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
-00003cd0: 2020 2072 6563 5f64 6963 745b 2774 656d     rec_dict['tem
-00003ce0: 706c 6174 6573 275d 203d 206e 702e 6172  plates'] = np.ar
-00003cf0: 7261 7928 662e 6765 7428 7061 7468 202b  ray(f.get(path +
-00003d00: 2027 7465 6d70 6c61 7465 7327 2929 0a20   'templates')). 
-00003d10: 2020 2020 2020 2069 6620 662e 6765 7428         if f.get(
-00003d20: 7061 7468 202b 2027 6f72 6967 696e 616c  path + 'original
-00003d30: 5f74 656d 706c 6174 6573 2729 2069 7320  _templates') is 
-00003d40: 6e6f 7420 4e6f 6e65 3a0a 2020 2020 2020  not None:.      
-00003d50: 2020 2020 2020 6966 2072 6574 7572 6e5f        if return_
-00003d60: 6835 5f6f 626a 6563 7473 3a0a 2020 2020  h5_objects:.    
-00003d70: 2020 2020 2020 2020 2020 2020 7265 635f              rec_
-00003d80: 6469 6374 5b27 6f72 6967 696e 616c 5f74  dict['original_t
-00003d90: 656d 706c 6174 6573 275d 203d 2066 2e67  emplates'] = f.g
-00003da0: 6574 2870 6174 6820 2b20 276f 7269 6769  et(path + 'origi
-00003db0: 6e61 6c5f 7465 6d70 6c61 7465 7327 290a  nal_templates').
-00003dc0: 2020 2020 2020 2020 2020 2020 656c 7365              else
-00003dd0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00003de0: 2020 7265 635f 6469 6374 5b27 6f72 6967    rec_dict['orig
-00003df0: 696e 616c 5f74 656d 706c 6174 6573 275d  inal_templates']
-00003e00: 203d 206e 702e 6172 7261 7928 662e 6765   = np.array(f.ge
-00003e10: 7428 7061 7468 202b 2027 6f72 6967 696e  t(path + 'origin
-00003e20: 616c 5f74 656d 706c 6174 6573 2729 290a  al_templates')).
-00003e30: 2020 2020 2020 2020 6966 2066 2e67 6574          if f.get
-00003e40: 2870 6174 6820 2b20 2774 656d 706c 6174  (path + 'templat
-00003e50: 655f 6c6f 6361 7469 6f6e 7327 2920 6973  e_locations') is
-00003e60: 206e 6f74 204e 6f6e 653a 0a20 2020 2020   not None:.     
-00003e70: 2020 2020 2020 2069 6620 7265 7475 726e         if return
-00003e80: 5f68 355f 6f62 6a65 6374 733a 0a20 2020  _h5_objects:.   
-00003e90: 2020 2020 2020 2020 2020 2020 2072 6563               rec
-00003ea0: 5f64 6963 745b 2774 656d 706c 6174 655f  _dict['template_
-00003eb0: 6c6f 6361 7469 6f6e 7327 5d20 3d20 662e  locations'] = f.
-00003ec0: 6765 7428 7061 7468 202b 2027 7465 6d70  get(path + 'temp
-00003ed0: 6c61 7465 5f6c 6f63 6174 696f 6e73 2729  late_locations')
-00003ee0: 0a20 2020 2020 2020 2020 2020 2065 6c73  .            els
-00003ef0: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-00003f00: 2020 2072 6563 5f64 6963 745b 2774 656d     rec_dict['tem
-00003f10: 706c 6174 655f 6c6f 6361 7469 6f6e 7327  plate_locations'
-00003f20: 5d20 3d20 6e70 2e61 7272 6179 2866 2e67  ] = np.array(f.g
-00003f30: 6574 2870 6174 6820 2b20 2774 656d 706c  et(path + 'templ
-00003f40: 6174 655f 6c6f 6361 7469 6f6e 7327 2929  ate_locations'))
-00003f50: 0a20 2020 2020 2020 2069 6620 662e 6765  .        if f.ge
-00003f60: 7428 7061 7468 202b 2027 7465 6d70 6c61  t(path + 'templa
-00003f70: 7465 5f72 6f74 6174 696f 6e73 2729 2069  te_rotations') i
-00003f80: 7320 6e6f 7420 4e6f 6e65 3a0a 2020 2020  s not None:.    
-00003f90: 2020 2020 2020 2020 6966 2072 6574 7572          if retur
-00003fa0: 6e5f 6835 5f6f 626a 6563 7473 3a0a 2020  n_h5_objects:.  
-00003fb0: 2020 2020 2020 2020 2020 2020 2020 7265                re
-00003fc0: 635f 6469 6374 5b27 7465 6d70 6c61 7465  c_dict['template
-00003fd0: 5f72 6f74 6174 696f 6e73 275d 203d 2066  _rotations'] = f
-00003fe0: 2e67 6574 2870 6174 6820 2b20 2774 656d  .get(path + 'tem
-00003ff0: 706c 6174 655f 726f 7461 7469 6f6e 7327  plate_rotations'
-00004000: 290a 2020 2020 2020 2020 2020 2020 656c  ).            el
-00004010: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-00004020: 2020 2020 7265 635f 6469 6374 5b27 7465      rec_dict['te
-00004030: 6d70 6c61 7465 5f72 6f74 6174 696f 6e73  mplate_rotations
-00004040: 275d 203d 206e 702e 6172 7261 7928 662e  '] = np.array(f.
-00004050: 6765 7428 7061 7468 202b 2027 7465 6d70  get(path + 'temp
-00004060: 6c61 7465 5f72 6f74 6174 696f 6e73 2729  late_rotations')
-00004070: 290a 2020 2020 2020 2020 6966 2066 2e67  ).        if f.g
-00004080: 6574 2870 6174 6820 2b20 2774 656d 706c  et(path + 'templ
-00004090: 6174 655f 6365 6c6c 7479 7065 7327 2920  ate_celltypes') 
-000040a0: 6973 206e 6f74 204e 6f6e 653a 0a20 2020  is not None:.   
-000040b0: 2020 2020 2020 2020 2063 656c 6c74 7970           celltyp
-000040c0: 6573 203d 206e 702e 6172 7261 7928 285b  es = np.array(([
-000040d0: 6e2e 6465 636f 6465 2829 2066 6f72 206e  n.decode() for n
-000040e0: 2069 6e20 662e 6765 7428 7061 7468 202b   in f.get(path +
-000040f0: 2027 7465 6d70 6c61 7465 5f63 656c 6c74   'template_cellt
-00004100: 7970 6573 2729 5d29 290a 2020 2020 2020  ypes')])).      
-00004110: 2020 2020 2020 7265 635f 6469 6374 5b27        rec_dict['
-00004120: 7465 6d70 6c61 7465 5f63 656c 6c74 7970  template_celltyp
-00004130: 6573 275d 203d 206e 702e 6172 7261 7928  es'] = np.array(
-00004140: 6365 6c6c 7479 7065 7329 0a20 2020 2069  celltypes).    i
-00004150: 6620 662e 6765 7428 7061 7468 202b 2027  f f.get(path + '
-00004160: 7469 6d65 7374 616d 7073 2729 2069 7320  timestamps') is 
-00004170: 6e6f 7420 4e6f 6e65 2061 6e64 2027 7469  not None and 'ti
-00004180: 6d65 7374 616d 7073 2720 696e 206c 6f61  mestamps' in loa
-00004190: 643a 0a20 2020 2020 2020 2069 6620 7265  d:.        if re
-000041a0: 7475 726e 5f68 355f 6f62 6a65 6374 733a  turn_h5_objects:
-000041b0: 0a20 2020 2020 2020 2020 2020 2072 6563  .            rec
-000041c0: 5f64 6963 745b 2774 696d 6573 7461 6d70  _dict['timestamp
-000041d0: 7327 5d20 3d20 662e 6765 7428 7061 7468  s'] = f.get(path
-000041e0: 202b 2027 7469 6d65 7374 616d 7073 2729   + 'timestamps')
-000041f0: 0a20 2020 2020 2020 2065 6c73 653a 0a20  .        else:. 
-00004200: 2020 2020 2020 2020 2020 2072 6563 5f64             rec_d
-00004210: 6963 745b 2774 696d 6573 7461 6d70 7327  ict['timestamps'
-00004220: 5d20 3d20 6e70 2e61 7272 6179 2866 2e67  ] = np.array(f.g
-00004230: 6574 2870 6174 6820 2b20 2774 696d 6573  et(path + 'times
-00004240: 7461 6d70 7327 2929 202a 2070 712e 730a  tamps')) * pq.s.
-00004250: 2020 2020 6966 2066 2e67 6574 2870 6174      if f.get(pat
-00004260: 6820 2b20 2774 656d 706c 6174 655f 6964  h + 'template_id
-00004270: 7327 2920 6973 206e 6f74 204e 6f6e 6520  s') is not None 
-00004280: 616e 6420 2774 656d 706c 6174 655f 6964  and 'template_id
-00004290: 7327 2069 6e20 6c6f 6164 3a0a 2020 2020  s' in load:.    
-000042a0: 2020 2020 7265 635f 6469 6374 5b27 7465      rec_dict['te
-000042b0: 6d70 6c61 7465 5f69 6473 275d 203d 2066  mplate_ids'] = f
-000042c0: 2e67 6574 2870 6174 6820 2b20 2774 656d  .get(path + 'tem
-000042d0: 706c 6174 655f 6964 7327 290a 2020 2020  plate_ids').    
-000042e0: 6966 2066 2e67 6574 2870 6174 6820 2b20  if f.get(path + 
-000042f0: 2773 7069 6b65 7472 6169 6e73 2729 2069  'spiketrains') i
-00004300: 7320 6e6f 7420 4e6f 6e65 2061 6e64 2027  s not None and '
-00004310: 7370 696b 6574 7261 696e 7327 2069 6e20  spiketrains' in 
-00004320: 6c6f 6164 3a0a 2020 2020 2020 2020 7370  load:.        sp
-00004330: 696b 6574 7261 696e 7320 3d20 5b5d 0a20  iketrains = []. 
-00004340: 2020 2020 2020 2073 6f72 7465 645f 756e         sorted_un
-00004350: 6974 7320 3d20 736f 7274 6564 285b 696e  its = sorted([in
-00004360: 7428 7529 2066 6f72 2075 2069 6e20 662e  t(u) for u in f.
-00004370: 6765 7428 7061 7468 202b 2027 7370 696b  get(path + 'spik
-00004380: 6574 7261 696e 732f 2729 5d29 0a20 2020  etrains/')]).   
-00004390: 2020 2020 2066 6f72 2075 6e69 7420 696e       for unit in
-000043a0: 2073 6f72 7465 645f 756e 6974 733a 0a20   sorted_units:. 
-000043b0: 2020 2020 2020 2020 2020 2075 6e69 7420             unit 
-000043c0: 3d20 7374 7228 756e 6974 290a 2020 2020  = str(unit).    
-000043d0: 2020 2020 2020 2020 7469 6d65 7320 3d20          times = 
-000043e0: 6e70 2e61 7272 6179 2866 2e67 6574 2870  np.array(f.get(p
-000043f0: 6174 6820 2b20 2773 7069 6b65 7472 6169  ath + 'spiketrai
-00004400: 6e73 2f27 202b 2075 6e69 7420 2b20 272f  ns/' + unit + '/
-00004410: 7469 6d65 7327 2929 0a20 2020 2020 2020  times')).       
-00004420: 2020 2020 2074 5f73 746f 7020 3d20 6e70       t_stop = np
-00004430: 2e61 7272 6179 2866 2e67 6574 2870 6174  .array(f.get(pat
-00004440: 6820 2b20 2773 7069 6b65 7472 6169 6e73  h + 'spiketrains
-00004450: 2f27 202b 2075 6e69 7420 2b20 272f 745f  /' + unit + '/t_
-00004460: 7374 6f70 2729 290a 2020 2020 2020 2020  stop')).        
-00004470: 2020 2020 6966 2066 2e67 6574 2870 6174      if f.get(pat
-00004480: 6820 2b20 2773 7069 6b65 7472 6169 6e73  h + 'spiketrains
-00004490: 2f27 202b 2075 6e69 7420 2b20 272f 7761  /' + unit + '/wa
-000044a0: 7665 666f 726d 7327 2920 6973 206e 6f74  veforms') is not
-000044b0: 204e 6f6e 6520 616e 6420 6c6f 6164 5f77   None and load_w
-000044c0: 6176 6566 6f72 6d73 3a0a 2020 2020 2020  aveforms:.      
-000044d0: 2020 2020 2020 2020 2020 7761 7665 666f            wavefo
-000044e0: 726d 7320 3d20 6e70 2e61 7272 6179 2866  rms = np.array(f
-000044f0: 2e67 6574 2870 6174 6820 2b20 2773 7069  .get(path + 'spi
-00004500: 6b65 7472 6169 6e73 2f27 202b 2075 6e69  ketrains/' + uni
-00004510: 7420 2b20 272f 7761 7665 666f 726d 7327  t + '/waveforms'
-00004520: 2929 0a20 2020 2020 2020 2020 2020 2065  )).            e
-00004530: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
-00004540: 2020 2020 2077 6176 6566 6f72 6d73 203d       waveforms =
-00004550: 204e 6f6e 650a 2020 2020 2020 2020 2020   None.          
-00004560: 2020 616e 6e6f 7461 7469 6f6e 7320 3d20    annotations = 
-00004570: 6c6f 6164 5f64 6963 745f 6672 6f6d 5f68  load_dict_from_h
-00004580: 6466 3528 662c 2070 6174 6820 2b20 2773  df5(f, path + 's
-00004590: 7069 6b65 7472 6169 6e73 2f27 202b 2075  piketrains/' + u
-000045a0: 6e69 7420 2b20 272f 616e 6e6f 7461 7469  nit + '/annotati
-000045b0: 6f6e 732f 2729 0a20 2020 2020 2020 2020  ons/').         
-000045c0: 2020 2073 7420 3d20 6e65 6f2e 636f 7265     st = neo.core
-000045d0: 2e53 7069 6b65 5472 6169 6e28 0a20 2020  .SpikeTrain(.   
-000045e0: 2020 2020 2020 2020 2020 2020 2074 696d               tim
-000045f0: 6573 2c0a 2020 2020 2020 2020 2020 2020  es,.            
-00004600: 2020 2020 745f 7374 6f70 3d74 5f73 746f      t_stop=t_sto
-00004610: 702c 0a20 2020 2020 2020 2020 2020 2020  p,.             
-00004620: 2020 2077 6176 6566 6f72 6d73 3d77 6176     waveforms=wav
-00004630: 6566 6f72 6d73 2c0a 2020 2020 2020 2020  eforms,.        
-00004640: 2020 2020 2020 2020 756e 6974 733d 7071          units=pq
-00004650: 2e73 0a20 2020 2020 2020 2020 2020 2029  .s.            )
-00004660: 0a20 2020 2020 2020 2020 2020 2073 742e  .            st.
-00004670: 616e 6e6f 7461 7469 6f6e 7320 3d20 616e  annotations = an
-00004680: 6e6f 7461 7469 6f6e 730a 2020 2020 2020  notations.      
-00004690: 2020 2020 2020 7370 696b 6574 7261 696e        spiketrain
-000046a0: 732e 6170 7065 6e64 2873 7429 0a20 2020  s.append(st).   
-000046b0: 2020 2020 2072 6563 5f64 6963 745b 2773       rec_dict['s
-000046c0: 7069 6b65 7472 6169 6e73 275d 203d 2073  piketrains'] = s
-000046d0: 7069 6b65 7472 6169 6e73 0a20 2020 2069  piketrains.    i
-000046e0: 6620 662e 6765 7428 7061 7468 202b 2027  f f.get(path + '
-000046f0: 6472 6966 745f 6c69 7374 2729 2069 7320  drift_list') is 
-00004700: 6e6f 7420 4e6f 6e65 3a0a 2020 2020 2020  not None:.      
-00004710: 2020 6472 6966 745f 6c69 7374 203d 205b    drift_list = [
-00004720: 5d0a 2020 2020 2020 2020 666f 7220 6920  ].        for i 
-00004730: 696e 2066 2e67 6574 2870 6174 6820 2b20  in f.get(path + 
-00004740: 2764 7269 6674 5f6c 6973 7427 292e 6b65  'drift_list').ke
-00004750: 7973 2829 3a0a 2020 2020 2020 2020 2020  ys():.          
-00004760: 2020 6472 6966 745f 6469 6374 203d 206c    drift_dict = l
-00004770: 6f61 645f 6469 6374 5f66 726f 6d5f 6864  oad_dict_from_hd
-00004780: 6635 2866 2c20 7061 7468 202b 2027 6472  f5(f, path + 'dr
-00004790: 6966 745f 6c69 7374 2f27 202b 2073 7472  ift_list/' + str
-000047a0: 2869 2920 2b20 272f 2729 0a20 2020 2020  (i) + '/').     
-000047b0: 2020 2020 2020 2064 7269 6674 5f6c 6973         drift_lis
-000047c0: 742e 6170 7065 6e64 2864 7269 6674 5f64  t.append(drift_d
-000047d0: 6963 7429 0a20 2020 2020 2020 2072 6563  ict).        rec
-000047e0: 5f64 6963 745b 2764 7269 6674 5f6c 6973  _dict['drift_lis
-000047f0: 7427 5d20 3d20 6472 6966 745f 6c69 7374  t'] = drift_list
-00004800: 0a20 2020 2065 6c73 653a 0a20 2020 2020  .    else:.     
-00004810: 2020 2072 6563 5f64 6963 745b 2764 7269     rec_dict['dri
-00004820: 6674 5f6c 6973 7427 5d20 3d20 4e6f 6e65  ft_list'] = None
-00004830: 0a0a 2020 2020 7265 7475 726e 2072 6563  ..    return rec
-00004840: 5f64 6963 742c 2069 6e66 6f0a 0a0a 6465  _dict, info...de
-00004850: 6620 7361 7665 5f74 656d 706c 6174 655f  f save_template_
-00004860: 6765 6e65 7261 746f 7228 7465 6d70 6765  generator(tempge
-00004870: 6e2c 2066 696c 656e 616d 653d 4e6f 6e65  n, filename=None
-00004880: 2c20 7665 7262 6f73 653d 5472 7565 293a  , verbose=True):
-00004890: 0a20 2020 2022 2222 0a20 2020 2053 6176  .    """.    Sav
-000048a0: 6520 7465 6d70 6c61 7465 7320 746f 2064  e templates to d
-000048b0: 6973 6b2e 0a0a 2020 2020 5061 7261 6d65  isk...    Parame
-000048c0: 7465 7273 0a20 2020 202d 2d2d 2d2d 2d2d  ters.    -------
-000048d0: 2d2d 2d0a 2020 2020 7465 6d70 6765 6e20  ---.    tempgen 
-000048e0: 3a20 5465 6d70 6c61 7465 4765 6e65 7261  : TemplateGenera
-000048f0: 746f 720a 2020 2020 2020 2020 5465 6d70  tor.        Temp
-00004900: 6c61 7465 4765 6e65 7261 746f 7220 6f62  lateGenerator ob
-00004910: 6a65 6374 2074 6f20 6265 2073 6176 6564  ject to be saved
-00004920: 0a20 2020 2066 696c 656e 616d 6520 3a20  .    filename : 
-00004930: 7374 720a 2020 2020 2020 2020 5061 7468  str.        Path
-00004940: 2074 6f20 2e68 3520 6669 6c65 0a20 2020   to .h5 file.   
-00004950: 2076 6572 626f 7365 203a 2062 6f6f 6c0a   verbose : bool.
-00004960: 2020 2020 2020 2020 4966 2054 7275 6520          If True 
-00004970: 6f75 7470 7574 2069 7320 7665 7262 6f73  output is verbos
-00004980: 650a 2020 2020 2222 220a 2020 2020 6669  e.    """.    fi
-00004990: 6c65 6e61 6d65 203d 2050 6174 6828 6669  lename = Path(fi
-000049a0: 6c65 6e61 6d65 290a 2020 2020 6966 206e  lename).    if n
-000049b0: 6f74 2066 696c 656e 616d 652e 7061 7265  ot filename.pare
-000049c0: 6e74 2e69 735f 6469 7228 293a 0a20 2020  nt.is_dir():.   
-000049d0: 2020 2020 206f 732e 6d61 6b65 6469 7273       os.makedirs
-000049e0: 2873 7472 2866 696c 656e 616d 652e 7061  (str(filename.pa
-000049f0: 7265 6e74 2929 0a20 2020 2061 7373 6572  rent)).    asser
-00004a00: 7420 6669 6c65 6e61 6d65 2e73 7566 6669  t filename.suffi
-00004a10: 7820 696e 205b 272e 6835 272c 2027 2e68  x in ['.h5', '.h
-00004a20: 6466 3527 5d2c 2027 5072 6f76 6964 6520  df5'], 'Provide 
-00004a30: 616e 202e 6835 206f 7220 2e68 6466 3520  an .h5 or .hdf5 
-00004a40: 6669 6c65 206e 616d 6527 0a20 2020 2077  file name'.    w
-00004a50: 6974 6820 6835 7079 2e46 696c 6528 6669  ith h5py.File(fi
-00004a60: 6c65 6e61 6d65 2c20 2777 2729 2061 7320  lename, 'w') as 
-00004a70: 663a 0a20 2020 2020 2020 2073 6176 655f  f:.        save_
-00004a80: 6469 6374 5f74 6f5f 6864 6635 2874 656d  dict_to_hdf5(tem
-00004a90: 7067 656e 2e69 6e66 6f2c 2066 2c20 2769  pgen.info, f, 'i
-00004aa0: 6e66 6f2f 2729 0a20 2020 2020 2020 2066  nfo/').        f
-00004ab0: 2e61 7474 7273 5b27 6461 7465 275d 203d  .attrs['date'] =
-00004ac0: 2064 6174 6574 696d 652e 6e6f 7728 292e   datetime.now().
-00004ad0: 7374 7266 7469 6d65 2822 2579 2d25 6d2d  strftime("%y-%m-
-00004ae0: 2564 2025 483a 254d 3a25 5322 290a 2020  %d %H:%M:%S").  
-00004af0: 2020 2020 2020 6966 206c 656e 2874 656d        if len(tem
-00004b00: 7067 656e 2e63 656c 6c74 7970 6573 2920  pgen.celltypes) 
-00004b10: 3e20 303a 0a20 2020 2020 2020 2020 2020  > 0:.           
-00004b20: 2063 656c 6c74 7970 6573 203d 205b 7374   celltypes = [st
-00004b30: 7228 7829 2e65 6e63 6f64 6528 2775 7466  r(x).encode('utf
-00004b40: 2d38 2729 2066 6f72 2078 2069 6e20 7465  -8') for x in te
-00004b50: 6d70 6765 6e2e 6365 6c6c 7479 7065 735d  mpgen.celltypes]
-00004b60: 0a20 2020 2020 2020 2020 2020 2066 2e63  .            f.c
-00004b70: 7265 6174 655f 6461 7461 7365 7428 2763  reate_dataset('c
-00004b80: 656c 6c74 7970 6573 272c 2064 6174 613d  elltypes', data=
-00004b90: 6365 6c6c 7479 7065 7329 0a20 2020 2020  celltypes).     
-00004ba0: 2020 2069 6620 6c65 6e28 7465 6d70 6765     if len(tempge
-00004bb0: 6e2e 6c6f 6361 7469 6f6e 7329 203e 2030  n.locations) > 0
-00004bc0: 3a0a 2020 2020 2020 2020 2020 2020 662e  :.            f.
-00004bd0: 6372 6561 7465 5f64 6174 6173 6574 2827  create_dataset('
-00004be0: 6c6f 6361 7469 6f6e 7327 2c20 6461 7461  locations', data
-00004bf0: 3d74 656d 7067 656e 2e6c 6f63 6174 696f  =tempgen.locatio
-00004c00: 6e73 290a 2020 2020 2020 2020 6966 206c  ns).        if l
-00004c10: 656e 2874 656d 7067 656e 2e72 6f74 6174  en(tempgen.rotat
-00004c20: 696f 6e73 2920 3e20 303a 0a20 2020 2020  ions) > 0:.     
-00004c30: 2020 2020 2020 2066 2e63 7265 6174 655f         f.create_
-00004c40: 6461 7461 7365 7428 2772 6f74 6174 696f  dataset('rotatio
-00004c50: 6e73 272c 2064 6174 613d 7465 6d70 6765  ns', data=tempge
-00004c60: 6e2e 726f 7461 7469 6f6e 7329 0a20 2020  n.rotations).   
-00004c70: 2020 2020 2069 6620 6c65 6e28 7465 6d70       if len(temp
-00004c80: 6765 6e2e 7465 6d70 6c61 7465 7329 203e  gen.templates) >
-00004c90: 2030 3a0a 2020 2020 2020 2020 2020 2020   0:.            
-00004ca0: 662e 6372 6561 7465 5f64 6174 6173 6574  f.create_dataset
-00004cb0: 2827 7465 6d70 6c61 7465 7327 2c20 6461  ('templates', da
-00004cc0: 7461 3d74 656d 7067 656e 2e74 656d 706c  ta=tempgen.templ
-00004cd0: 6174 6573 290a 2020 2020 6966 2076 6572  ates).    if ver
-00004ce0: 626f 7365 3a0a 2020 2020 2020 2020 7072  bose:.        pr
-00004cf0: 696e 7428 275c 6e53 6176 6564 2020 7465  int('\nSaved  te
-00004d00: 6d70 6c61 7465 7320 696e 272c 2066 696c  mplates in', fil
-00004d10: 656e 616d 652c 2027 5c6e 2729 0a0a 0a64  ename, '\n')...d
-00004d20: 6566 2073 6176 655f 7265 636f 7264 696e  ef save_recordin
-00004d30: 675f 6765 6e65 7261 746f 7228 7265 6367  g_generator(recg
-00004d40: 656e 2c20 6669 6c65 6e61 6d65 3d4e 6f6e  en, filename=Non
-00004d50: 652c 2076 6572 626f 7365 3d46 616c 7365  e, verbose=False
-00004d60: 293a 0a20 2020 2022 2222 0a20 2020 2053  ):.    """.    S
-00004d70: 6176 6520 7265 636f 7264 696e 6773 2074  ave recordings t
-00004d80: 6f20 6469 736b 2e0a 0a20 2020 2050 6172  o disk...    Par
-00004d90: 616d 6574 6572 730a 2020 2020 2d2d 2d2d  ameters.    ----
-00004da0: 2d2d 2d2d 2d2d 0a20 2020 2072 6563 6765  ------.    recge
-00004db0: 6e20 3a20 5265 636f 7264 696e 6747 656e  n : RecordingGen
-00004dc0: 6572 6174 6f72 0a20 2020 2020 2020 2052  erator.        R
-00004dd0: 6563 6f72 6469 6e67 4765 6e65 7261 746f  ecordingGenerato
-00004de0: 7220 6f62 6a65 6374 2074 6f20 6265 2073  r object to be s
-00004df0: 6176 6564 0a20 2020 2066 696c 656e 616d  aved.    filenam
-00004e00: 6520 3a20 7374 720a 2020 2020 2020 2020  e : str.        
-00004e10: 5061 7468 2074 6f20 2e68 3520 6669 6c65  Path to .h5 file
-00004e20: 0a20 2020 2076 6572 626f 7365 203a 2062  .    verbose : b
-00004e30: 6f6f 6c0a 2020 2020 2020 2020 4966 2054  ool.        If T
-00004e40: 7275 6520 6f75 7470 7574 2069 7320 7665  rue output is ve
-00004e50: 7262 6f73 650a 2020 2020 2222 220a 2020  rbose.    """.  
-00004e60: 2020 6669 6c65 6e61 6d65 203d 2050 6174    filename = Pat
-00004e70: 6828 6669 6c65 6e61 6d65 290a 2020 2020  h(filename).    
-00004e80: 6966 206e 6f74 2066 696c 656e 616d 652e  if not filename.
-00004e90: 7061 7265 6e74 2e69 735f 6469 7228 293a  parent.is_dir():
-00004ea0: 0a20 2020 2020 2020 206f 732e 6d61 6b65  .        os.make
-00004eb0: 6469 7273 2873 7472 2866 696c 656e 616d  dirs(str(filenam
-00004ec0: 652e 7061 7265 6e74 2929 0a20 2020 2061  e.parent)).    a
-00004ed0: 7373 6572 7420 6669 6c65 6e61 6d65 2e73  ssert filename.s
-00004ee0: 7566 6669 7820 696e 205b 272e 6835 272c  uffix in ['.h5',
-00004ef0: 2027 2e68 6466 3527 5d2c 2027 5072 6f76   '.hdf5'], 'Prov
-00004f00: 6964 6520 616e 202e 6835 206f 7220 2e68  ide an .h5 or .h
-00004f10: 6466 3520 6669 6c65 206e 616d 6527 0a20  df5 file name'. 
-00004f20: 2020 2077 6974 6820 6835 7079 2e46 696c     with h5py.Fil
-00004f30: 6528 6669 6c65 6e61 6d65 2c20 2777 2729  e(filename, 'w')
-00004f40: 2061 7320 663a 0a20 2020 2020 2020 2066   as f:.        f
-00004f50: 2e61 7474 7273 5b27 6d65 6172 6563 5f76  .attrs['mearec_v
-00004f60: 6572 7369 6f6e 275d 203d 2076 6572 7369  ersion'] = versi
-00004f70: 6f6e 0a20 2020 2020 2020 2066 2e61 7474  on.        f.att
-00004f80: 7273 5b27 6461 7465 275d 203d 2064 6174  rs['date'] = dat
-00004f90: 6574 696d 652e 6e6f 7728 292e 7374 7266  etime.now().strf
-00004fa0: 7469 6d65 2822 2579 2d25 6d2d 2564 2025  time("%y-%m-%d %
-00004fb0: 483a 254d 3a25 5322 290a 2020 2020 2020  H:%M:%S").      
-00004fc0: 2020 7361 7665 5f72 6563 6f72 6469 6e67    save_recording
-00004fd0: 5f74 6f5f 6669 6c65 2872 6563 6765 6e2c  _to_file(recgen,
-00004fe0: 2066 290a 2020 2020 6966 2076 6572 626f   f).    if verbo
-00004ff0: 7365 3a0a 2020 2020 2020 2020 7072 696e  se:.        prin
-00005000: 7428 275c 6e53 6176 6564 2072 6563 6f72  t('\nSaved recor
-00005010: 6469 6e67 7320 696e 272c 2066 696c 656e  dings in', filen
-00005020: 616d 652c 2027 5c6e 2729 0a0a 6465 6620  ame, '\n')..def 
-00005030: 7361 7665 5f72 6563 6f72 6469 6e67 5f74  save_recording_t
-00005040: 6f5f 6669 6c65 2872 6563 6765 6e2c 2066  o_file(recgen, f
-00005050: 2c20 7061 7468 3d22 2229 3a0a 2020 2020  , path=""):.    
-00005060: 2222 220a 2020 2020 5361 7665 2072 6563  """.    Save rec
-00005070: 6f72 6469 6e67 7320 746f 2066 696c 6520  ordings to file 
-00005080: 6861 6e64 6c65 722e 0a0a 2020 2020 5061  handler...    Pa
-00005090: 7261 6d65 7465 7273 0a20 2020 202d 2d2d  rameters.    ---
-000050a0: 2d2d 2d2d 2d2d 2d0a 2020 2020 7265 6367  -------.    recg
-000050b0: 656e 203a 2052 6563 6f72 6469 6e67 4765  en : RecordingGe
-000050c0: 6e65 7261 746f 720a 2020 2020 2020 2020  nerator.        
-000050d0: 5265 636f 7264 696e 6747 656e 6572 6174  RecordingGenerat
-000050e0: 6f72 206f 626a 6563 7420 746f 2062 6520  or object to be 
-000050f0: 7361 7665 640a 2020 2020 6669 6c65 6e61  saved.    filena
-00005100: 6d65 203a 205f 696f 2e54 6578 7449 4f57  me : _io.TextIOW
-00005110: 7261 7070 6572 0a20 2020 2020 2020 2046  rapper.        F
-00005120: 696c 6520 6861 6e64 6c65 720a 2020 2020  ile handler.    
-00005130: 2222 220a 2020 2020 7361 7665 5f64 6963  """.    save_dic
-00005140: 745f 746f 5f68 6466 3528 7265 6367 656e  t_to_hdf5(recgen
-00005150: 2e69 6e66 6f2c 2066 2c20 7061 7468 202b  .info, f, path +
-00005160: 2027 696e 666f 2f27 290a 2020 2020 6966   'info/').    if
-00005170: 206c 656e 2872 6563 6765 6e2e 766f 6c74   len(recgen.volt
-00005180: 6167 655f 7065 616b 7329 203e 2030 3a0a  age_peaks) > 0:.
-00005190: 2020 2020 2020 2020 662e 6372 6561 7465          f.create
-000051a0: 5f64 6174 6173 6574 2870 6174 6820 2b20  _dataset(path + 
-000051b0: 2776 6f6c 7461 6765 5f70 6561 6b73 272c  'voltage_peaks',
-000051c0: 2064 6174 613d 7265 6367 656e 2e76 6f6c   data=recgen.vol
-000051d0: 7461 6765 5f70 6561 6b73 290a 2020 2020  tage_peaks).    
-000051e0: 6966 206c 656e 2872 6563 6765 6e2e 6368  if len(recgen.ch
-000051f0: 616e 6e65 6c5f 706f 7369 7469 6f6e 7329  annel_positions)
-00005200: 203e 2030 3a0a 2020 2020 2020 2020 662e   > 0:.        f.
-00005210: 6372 6561 7465 5f64 6174 6173 6574 2870  create_dataset(p
-00005220: 6174 6820 2b20 2763 6861 6e6e 656c 5f70  ath + 'channel_p
-00005230: 6f73 6974 696f 6e73 272c 2064 6174 613d  ositions', data=
-00005240: 7265 6367 656e 2e63 6861 6e6e 656c 5f70  recgen.channel_p
-00005250: 6f73 6974 696f 6e73 290a 2020 2020 6966  ositions).    if
-00005260: 206c 656e 2872 6563 6765 6e2e 7265 636f   len(recgen.reco
-00005270: 7264 696e 6773 2920 3e20 303a 0a20 2020  rdings) > 0:.   
-00005280: 2020 2020 2066 2e63 7265 6174 655f 6461       f.create_da
-00005290: 7461 7365 7428 7061 7468 202b 2027 7265  taset(path + 're
-000052a0: 636f 7264 696e 6773 272c 2064 6174 613d  cordings', data=
-000052b0: 7265 6367 656e 2e72 6563 6f72 6469 6e67  recgen.recording
-000052c0: 7329 0a20 2020 2020 2020 2069 6620 7265  s).        if re
-000052d0: 6367 656e 2e67 6169 6e5f 746f 5f75 5620  cgen.gain_to_uV 
-000052e0: 6973 206e 6f74 204e 6f6e 653a 0a20 2020  is not None:.   
-000052f0: 2020 2020 2020 2020 2066 5b27 7265 636f           f['reco
-00005300: 7264 696e 6773 275d 2e61 7474 7273 5b22  rdings'].attrs["
-00005310: 6761 696e 5f74 6f5f 7556 225d 203d 2072  gain_to_uV"] = r
-00005320: 6563 6765 6e2e 6761 696e 5f74 6f5f 7556  ecgen.gain_to_uV
-00005330: 0a20 2020 2069 6620 6c65 6e28 7265 6367  .    if len(recg
-00005340: 656e 2e73 7069 6b65 5f74 7261 6365 7329  en.spike_traces)
-00005350: 203e 2030 3a0a 2020 2020 2020 2020 662e   > 0:.        f.
-00005360: 6372 6561 7465 5f64 6174 6173 6574 2870  create_dataset(p
-00005370: 6174 6820 2b20 2773 7069 6b65 5f74 7261  ath + 'spike_tra
-00005380: 6365 7327 2c20 6461 7461 3d72 6563 6765  ces', data=recge
-00005390: 6e2e 7370 696b 655f 7472 6163 6573 290a  n.spike_traces).
-000053a0: 2020 2020 6966 206c 656e 2872 6563 6765      if len(recge
-000053b0: 6e2e 7370 696b 6574 7261 696e 7329 203e  n.spiketrains) >
-000053c0: 2030 3a0a 2020 2020 2020 2020 666f 7220   0:.        for 
-000053d0: 6969 2069 6e20 7261 6e67 6528 6c65 6e28  ii in range(len(
-000053e0: 7265 6367 656e 2e73 7069 6b65 7472 6169  recgen.spiketrai
-000053f0: 6e73 2929 3a0a 2020 2020 2020 2020 2020  ns)):.          
-00005400: 2020 7374 203d 2072 6563 6765 6e2e 7370    st = recgen.sp
-00005410: 696b 6574 7261 696e 735b 6969 5d0a 2020  iketrains[ii].  
-00005420: 2020 2020 2020 2020 2020 662e 6372 6561            f.crea
-00005430: 7465 5f64 6174 6173 6574 2870 6174 6820  te_dataset(path 
-00005440: 2b20 2773 7069 6b65 7472 6169 6e73 2f7b  + 'spiketrains/{
-00005450: 7d2f 7469 6d65 7327 2e66 6f72 6d61 7428  }/times'.format(
-00005460: 6969 292c 2064 6174 613d 7374 2e74 696d  ii), data=st.tim
-00005470: 6573 2e72 6573 6361 6c65 2827 7327 292e  es.rescale('s').
-00005480: 6d61 676e 6974 7564 6529 0a20 2020 2020  magnitude).     
-00005490: 2020 2020 2020 2066 2e63 7265 6174 655f         f.create_
-000054a0: 6461 7461 7365 7428 7061 7468 202b 2027  dataset(path + '
-000054b0: 7370 696b 6574 7261 696e 732f 7b7d 2f74  spiketrains/{}/t
-000054c0: 5f73 746f 7027 2e66 6f72 6d61 7428 6969  _stop'.format(ii
-000054d0: 292c 2064 6174 613d 7374 2e74 5f73 746f  ), data=st.t_sto
-000054e0: 7029 0a20 2020 2020 2020 2020 2020 2069  p).            i
-000054f0: 6620 7374 2e77 6176 6566 6f72 6d73 2069  f st.waveforms i
-00005500: 7320 6e6f 7420 4e6f 6e65 3a0a 2020 2020  s not None:.    
-00005510: 2020 2020 2020 2020 2020 2020 662e 6372              f.cr
-00005520: 6561 7465 5f64 6174 6173 6574 2870 6174  eate_dataset(pat
-00005530: 6820 2b20 2773 7069 6b65 7472 6169 6e73  h + 'spiketrains
-00005540: 2f7b 7d2f 7761 7665 666f 726d 7327 2e66  /{}/waveforms'.f
-00005550: 6f72 6d61 7428 6969 292c 2064 6174 613d  ormat(ii), data=
-00005560: 7374 2e77 6176 6566 6f72 6d73 290a 2020  st.waveforms).  
-00005570: 2020 2020 2020 2020 2020 7361 7665 5f64            save_d
-00005580: 6963 745f 746f 5f68 6466 3528 7374 2e61  ict_to_hdf5(st.a
-00005590: 6e6e 6f74 6174 696f 6e73 2c20 662c 2070  nnotations, f, p
-000055a0: 6174 6820 2b20 2773 7069 6b65 7472 6169  ath + 'spiketrai
-000055b0: 6e73 2f7b 7d2f 616e 6e6f 7461 7469 6f6e  ns/{}/annotation
-000055c0: 732f 272e 666f 726d 6174 2869 6929 290a  s/'.format(ii)).
-000055d0: 2020 2020 6966 206c 656e 2872 6563 6765      if len(recge
-000055e0: 6e2e 7465 6d70 6c61 7465 7329 203e 2030  n.templates) > 0
-000055f0: 3a0a 2020 2020 2020 2020 662e 6372 6561  :.        f.crea
-00005600: 7465 5f64 6174 6173 6574 2870 6174 6820  te_dataset(path 
-00005610: 2b20 2774 656d 706c 6174 6573 272c 2064  + 'templates', d
-00005620: 6174 613d 7265 6367 656e 2e74 656d 706c  ata=recgen.templ
-00005630: 6174 6573 290a 2020 2020 6966 206c 656e  ates).    if len
-00005640: 2872 6563 6765 6e2e 6f72 6967 696e 616c  (recgen.original
-00005650: 5f74 656d 706c 6174 6573 2920 3e20 303a  _templates) > 0:
-00005660: 0a20 2020 2020 2020 2066 2e63 7265 6174  .        f.creat
-00005670: 655f 6461 7461 7365 7428 7061 7468 202b  e_dataset(path +
-00005680: 2027 6f72 6967 696e 616c 5f74 656d 706c   'original_templ
-00005690: 6174 6573 272c 2064 6174 613d 7265 6367  ates', data=recg
-000056a0: 656e 2e6f 7269 6769 6e61 6c5f 7465 6d70  en.original_temp
-000056b0: 6c61 7465 7329 0a20 2020 2069 6620 6c65  lates).    if le
-000056c0: 6e28 7265 6367 656e 2e74 656d 706c 6174  n(recgen.templat
-000056d0: 655f 6c6f 6361 7469 6f6e 7329 203e 2030  e_locations) > 0
-000056e0: 3a0a 2020 2020 2020 2020 662e 6372 6561  :.        f.crea
-000056f0: 7465 5f64 6174 6173 6574 2870 6174 6820  te_dataset(path 
-00005700: 2b20 2774 656d 706c 6174 655f 6c6f 6361  + 'template_loca
-00005710: 7469 6f6e 7327 2c20 6461 7461 3d72 6563  tions', data=rec
-00005720: 6765 6e2e 7465 6d70 6c61 7465 5f6c 6f63  gen.template_loc
-00005730: 6174 696f 6e73 290a 2020 2020 6966 206c  ations).    if l
-00005740: 656e 2872 6563 6765 6e2e 7465 6d70 6c61  en(recgen.templa
-00005750: 7465 5f72 6f74 6174 696f 6e73 2920 3e20  te_rotations) > 
-00005760: 303a 0a20 2020 2020 2020 2066 2e63 7265  0:.        f.cre
-00005770: 6174 655f 6461 7461 7365 7428 7061 7468  ate_dataset(path
-00005780: 202b 2027 7465 6d70 6c61 7465 5f72 6f74   + 'template_rot
-00005790: 6174 696f 6e73 272c 2064 6174 613d 7265  ations', data=re
-000057a0: 6367 656e 2e74 656d 706c 6174 655f 726f  cgen.template_ro
-000057b0: 7461 7469 6f6e 7329 0a20 2020 2069 6620  tations).    if 
-000057c0: 6c65 6e28 7265 6367 656e 2e74 656d 706c  len(recgen.templ
-000057d0: 6174 655f 6365 6c6c 7479 7065 7329 203e  ate_celltypes) >
-000057e0: 2030 3a0a 2020 2020 2020 2020 6365 6c6c   0:.        cell
-000057f0: 7479 7065 7320 3d20 5b6e 2e65 6e63 6f64  types = [n.encod
-00005800: 6528 2261 7363 6969 222c 2022 6967 6e6f  e("ascii", "igno
-00005810: 7265 2229 2066 6f72 206e 2069 6e20 7265  re") for n in re
-00005820: 6367 656e 2e74 656d 706c 6174 655f 6365  cgen.template_ce
-00005830: 6c6c 7479 7065 735d 0a20 2020 2020 2020  lltypes].       
-00005840: 2066 2e63 7265 6174 655f 6461 7461 7365   f.create_datase
-00005850: 7428 7061 7468 202b 2027 7465 6d70 6c61  t(path + 'templa
-00005860: 7465 5f63 656c 6c74 7970 6573 272c 2064  te_celltypes', d
-00005870: 6174 613d 6365 6c6c 7479 7065 7329 0a20  ata=celltypes). 
-00005880: 2020 2069 6620 6c65 6e28 7265 6367 656e     if len(recgen
-00005890: 2e74 696d 6573 7461 6d70 7329 203e 2030  .timestamps) > 0
-000058a0: 3a0a 2020 2020 2020 2020 662e 6372 6561  :.        f.crea
-000058b0: 7465 5f64 6174 6173 6574 2870 6174 6820  te_dataset(path 
-000058c0: 2b20 2774 696d 6573 7461 6d70 7327 2c20  + 'timestamps', 
-000058d0: 6461 7461 3d72 6563 6765 6e2e 7469 6d65  data=recgen.time
-000058e0: 7374 616d 7073 290a 2020 2020 6966 2068  stamps).    if h
-000058f0: 6173 6174 7472 2872 6563 6765 6e2c 2027  asattr(recgen, '
-00005900: 7465 6d70 6c61 7465 5f69 6473 2729 3a0a  template_ids'):.
-00005910: 2020 2020 2020 2020 6966 2072 6563 6765          if recge
-00005920: 6e2e 7465 6d70 6c61 7465 5f69 6473 2069  n.template_ids i
-00005930: 7320 6e6f 7420 4e6f 6e65 3a0a 2020 2020  s not None:.    
-00005940: 2020 2020 2020 2020 662e 6372 6561 7465          f.create
-00005950: 5f64 6174 6173 6574 2870 6174 6820 2b20  _dataset(path + 
-00005960: 2774 656d 706c 6174 655f 6964 7327 2c20  'template_ids', 
-00005970: 6461 7461 3d72 6563 6765 6e2e 7465 6d70  data=recgen.temp
-00005980: 6c61 7465 5f69 6473 290a 2020 2020 6966  late_ids).    if
-00005990: 2072 6563 6765 6e2e 6472 6966 745f 6c69   recgen.drift_li
-000059a0: 7374 2069 7320 6e6f 7420 4e6f 6e65 3a0a  st is not None:.
-000059b0: 2020 2020 2020 2020 666f 7220 692c 2064          for i, d
-000059c0: 7269 6674 5f64 6963 7420 696e 2065 6e75  rift_dict in enu
-000059d0: 6d65 7261 7465 2872 6563 6765 6e2e 6472  merate(recgen.dr
-000059e0: 6966 745f 6c69 7374 293a 0a20 2020 2020  ift_list):.     
-000059f0: 2020 2020 2020 2073 6176 655f 6469 6374         save_dict
-00005a00: 5f74 6f5f 6864 6635 2864 7269 6674 5f64  _to_hdf5(drift_d
-00005a10: 6963 742c 2066 2c20 7061 7468 202b 2027  ict, f, path + '
-00005a20: 6472 6966 745f 6c69 7374 2f27 202b 2073  drift_list/' + s
-00005a30: 7472 2869 2920 2b20 272f 2729 0a0a 0a64  tr(i) + '/')...d
-00005a40: 6566 2073 6176 655f 6469 6374 5f74 6f5f  ef save_dict_to_
-00005a50: 6864 6635 2864 6963 2c20 6835 6669 6c65  hdf5(dic, h5file
-00005a60: 2c20 7061 7468 293a 0a20 2020 2022 2222  , path):.    """
-00005a70: 0a20 2020 2053 6176 6520 6469 6374 696f  .    Save dictio
-00005a80: 6e61 7279 2074 6f20 6835 2066 696c 652e  nary to h5 file.
-00005a90: 0a0a 2020 2020 5061 7261 6d65 7465 7273  ..    Parameters
-00005aa0: 0a20 2020 202d 2d2d 2d2d 2d2d 2d2d 2d0a  .    ----------.
-00005ab0: 2020 2020 6469 6320 3a20 6469 6374 0a20      dic : dict. 
-00005ac0: 2020 2020 2020 2044 6963 7469 6f6e 6172         Dictionar
-00005ad0: 7920 746f 2062 6520 7361 7665 640a 2020  y to be saved.  
-00005ae0: 2020 6835 6669 6c65 203a 2066 696c 650a    h5file : file.
-00005af0: 2020 2020 2020 2020 4864 6635 2066 696c          Hdf5 fil
-00005b00: 6520 6f62 6a65 6374 0a20 2020 2070 6174  e object.    pat
-00005b10: 6820 3a20 7374 720a 2020 2020 2020 2020  h : str.        
-00005b20: 5061 7468 2074 6f20 7468 6520 6835 2066  Path to the h5 f
-00005b30: 6965 6c64 0a20 2020 2022 2222 0a20 2020  ield.    """.   
-00005b40: 2072 6563 7572 7369 7665 6c79 5f73 6176   recursively_sav
-00005b50: 655f 6469 6374 5f63 6f6e 7465 6e74 735f  e_dict_contents_
-00005b60: 746f 5f67 726f 7570 2868 3566 696c 652c  to_group(h5file,
-00005b70: 2070 6174 682c 2064 6963 290a 0a0a 6465   path, dic)...de
-00005b80: 6620 7265 6375 7273 6976 656c 795f 7361  f recursively_sa
-00005b90: 7665 5f64 6963 745f 636f 6e74 656e 7473  ve_dict_contents
-00005ba0: 5f74 6f5f 6772 6f75 7028 6835 6669 6c65  _to_group(h5file
-00005bb0: 2c20 7061 7468 2c20 6469 6329 3a0a 2020  , path, dic):.  
-00005bc0: 2020 2222 220a 2020 2020 5361 7665 2064    """.    Save d
-00005bd0: 6963 7469 6f6e 6172 7920 7265 6375 7273  ictionary recurs
-00005be0: 6976 656c 7920 2074 6f20 6835 2066 696c  ively  to h5 fil
-00005bf0: 6520 2868 656c 7065 7220 6675 6e63 7469  e (helper functi
-00005c00: 6f6e 292e 0a0a 2020 2020 5061 7261 6d65  on)...    Parame
-00005c10: 7465 7273 0a20 2020 202d 2d2d 2d2d 2d2d  ters.    -------
-00005c20: 2d2d 2d0a 2020 2020 6469 6320 3a20 6469  ---.    dic : di
-00005c30: 6374 0a20 2020 2020 2020 2044 6963 7469  ct.        Dicti
-00005c40: 6f6e 6172 7920 746f 2062 6520 7361 7665  onary to be save
-00005c50: 640a 2020 2020 6835 6669 6c65 203a 2066  d.    h5file : f
-00005c60: 696c 650a 2020 2020 2020 2020 4864 6635  ile.        Hdf5
-00005c70: 2066 696c 6520 6f62 6a65 6374 0a20 2020   file object.   
-00005c80: 2070 6174 6820 3a20 7374 720a 2020 2020   path : str.    
-00005c90: 2020 2020 5061 7468 2074 6f20 7468 6520      Path to the 
-00005ca0: 6835 2066 6965 6c64 0a20 2020 2022 2222  h5 field.    """
-00005cb0: 0a20 2020 2066 6f72 206b 6579 2c20 6974  .    for key, it
-00005cc0: 656d 2069 6e20 6469 632e 6974 656d 7328  em in dic.items(
-00005cd0: 293a 0a20 2020 2020 2020 2069 6620 6973  ):.        if is
-00005ce0: 696e 7374 616e 6365 2869 7465 6d2c 2028  instance(item, (
-00005cf0: 696e 742c 2066 6c6f 6174 2c20 6e70 2e69  int, float, np.i
-00005d00: 6e74 6567 6572 2c20 6e70 2e66 6c6f 6174  nteger, np.float
-00005d10: 2c20 7374 722c 2062 7974 6573 2c20 6e70  , str, bytes, np
-00005d20: 2e62 6f6f 6c5f 2929 3a0a 2020 2020 2020  .bool_)):.      
-00005d30: 2020 2020 2020 6966 2069 7369 6e73 7461        if isinsta
-00005d40: 6e63 6528 6974 656d 2c20 6e70 2e73 7472  nce(item, np.str
-00005d50: 5f29 3a0a 2020 2020 2020 2020 2020 2020  _):.            
-00005d60: 2020 2020 6974 656d 203d 2073 7472 2869      item = str(i
-00005d70: 7465 6d29 0a20 2020 2020 2020 2020 2020  tem).           
-00005d80: 2068 3566 696c 655b 7061 7468 202b 206b   h5file[path + k
-00005d90: 6579 5d20 3d20 6974 656d 0a20 2020 2020  ey] = item.     
-00005da0: 2020 2065 6c69 6620 6973 696e 7374 616e     elif isinstan
-00005db0: 6365 2869 7465 6d2c 2070 712e 5175 616e  ce(item, pq.Quan
-00005dc0: 7469 7479 293a 0a20 2020 2020 2020 2020  tity):.         
-00005dd0: 2020 2068 3566 696c 655b 7061 7468 202b     h5file[path +
-00005de0: 206b 6579 5d20 3d20 666c 6f61 7428 6974   key] = float(it
-00005df0: 656d 2e6d 6167 6e69 7475 6465 290a 2020  em.magnitude).  
-00005e00: 2020 2020 2020 656c 6966 2069 7369 6e73        elif isins
-00005e10: 7461 6e63 6528 6974 656d 2c20 286c 6973  tance(item, (lis
-00005e20: 742c 206e 702e 6e64 6172 7261 7929 293a  t, np.ndarray)):
-00005e30: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-00005e40: 6c65 6e28 6974 656d 2920 3e20 303a 0a20  len(item) > 0:. 
-00005e50: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-00005e60: 6620 6973 696e 7374 616e 6365 2869 7465  f isinstance(ite
-00005e70: 6d5b 305d 2c20 2873 7472 2c20 6279 7465  m[0], (str, byte
-00005e80: 7329 293a 0a20 2020 2020 2020 2020 2020  s)):.           
-00005e90: 2020 2020 2020 2020 2069 7465 6d20 3d20           item = 
-00005ea0: 5b6e 2e65 6e63 6f64 6528 2261 7363 6969  [n.encode("ascii
-00005eb0: 222c 2022 6967 6e6f 7265 2229 2066 6f72  ", "ignore") for
-00005ec0: 206e 2069 6e20 6974 656d 5d0a 2020 2020   n in item].    
-00005ed0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005ee0: 6835 6669 6c65 5b70 6174 6820 2b20 6b65  h5file[path + ke
-00005ef0: 795d 203d 206e 702e 6172 7261 7928 6974  y] = np.array(it
-00005f00: 656d 290a 2020 2020 2020 2020 2020 2020  em).            
-00005f10: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-00005f20: 2020 2020 2020 2020 2020 2020 2020 6835                h5
-00005f30: 6669 6c65 5b70 6174 6820 2b20 6b65 795d  file[path + key]
-00005f40: 203d 206e 702e 6172 7261 7928 6974 656d   = np.array(item
-00005f50: 290a 2020 2020 2020 2020 2020 2020 656c  ).            el
-00005f60: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-00005f70: 2020 2020 6974 656d 203d 2027 5b5d 270a      item = '[]'.
-00005f80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005f90: 6835 6669 6c65 5b70 6174 6820 2b20 6b65  h5file[path + ke
-00005fa0: 795d 203d 2069 7465 6d0a 2020 2020 2020  y] = item.      
-00005fb0: 2020 656c 6966 2069 7369 6e73 7461 6e63    elif isinstanc
-00005fc0: 6528 6974 656d 2c20 7475 706c 6529 3a0a  e(item, tuple):.
-00005fd0: 2020 2020 2020 2020 2020 2020 6835 6669              h5fi
-00005fe0: 6c65 5b70 6174 6820 2b20 6b65 795d 203d  le[path + key] =
-00005ff0: 206e 702e 6172 7261 7928 6974 656d 290a   np.array(item).
-00006000: 2020 2020 2020 2020 656c 6966 2069 7465          elif ite
-00006010: 6d20 6973 204e 6f6e 653a 0a20 2020 2020  m is None:.     
-00006020: 2020 2020 2020 2068 3566 696c 655b 7061         h5file[pa
-00006030: 7468 202b 206b 6579 5d20 3d20 276e 756c  th + key] = 'nul
-00006040: 6c27 0a20 2020 2020 2020 2065 6c69 6620  l'.        elif 
-00006050: 6973 696e 7374 616e 6365 2869 7465 6d2c  isinstance(item,
-00006060: 2064 6963 7429 3a0a 2020 2020 2020 2020   dict):.        
-00006070: 2020 2020 7265 6375 7273 6976 656c 795f      recursively_
-00006080: 7361 7665 5f64 6963 745f 636f 6e74 656e  save_dict_conten
-00006090: 7473 5f74 6f5f 6772 6f75 7028 6835 6669  ts_to_group(h5fi
-000060a0: 6c65 2c20 7061 7468 202b 206b 6579 202b  le, path + key +
-000060b0: 2027 2f27 2c20 6974 656d 290a 2020 2020   '/', item).    
-000060c0: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-000060d0: 2020 2020 2020 7072 696e 7428 6b65 792c        print(key,
-000060e0: 2069 7465 6d29 0a20 2020 2020 2020 2020   item).         
-000060f0: 2020 2072 6169 7365 2056 616c 7565 4572     raise ValueEr
-00006100: 726f 7228 2743 616e 6e6f 7420 7361 7665  ror('Cannot save
-00006110: 2025 7320 7479 7065 2720 2520 7479 7065   %s type' % type
-00006120: 2869 7465 6d29 290a 0a0a 6465 6620 6c6f  (item))...def lo
-00006130: 6164 5f64 6963 745f 6672 6f6d 5f68 6466  ad_dict_from_hdf
-00006140: 3528 6835 6669 6c65 2c20 7061 7468 293a  5(h5file, path):
-00006150: 0a20 2020 2022 2222 0a20 2020 204c 6f61  .    """.    Loa
-00006160: 6420 6835 206f 626a 6563 7420 6173 2064  d h5 object as d
-00006170: 6963 742e 0a0a 2020 2020 5061 7261 6d65  ict...    Parame
-00006180: 7465 7273 0a20 2020 202d 2d2d 2d2d 2d2d  ters.    -------
-00006190: 2d2d 2d0a 2020 2020 6835 6669 6c65 203a  ---.    h5file :
-000061a0: 6669 6c65 0a20 2020 2020 2020 2048 6466  file.        Hdf
-000061b0: 3520 6669 6c65 206f 626a 6563 740a 2020  5 file object.  
-000061c0: 2020 7061 7468 203a 2073 7472 0a20 2020    path : str.   
-000061d0: 2020 2020 2050 6174 6820 746f 2074 6865       Path to the
-000061e0: 2068 3520 6669 656c 640a 2020 2020 5265   h5 field.    Re
-000061f0: 7475 726e 730a 2020 2020 2d2d 2d2d 2d2d  turns.    ------
-00006200: 2d0a 2020 2020 6469 6374 696f 6e61 7279  -.    dictionary
-00006210: 203a 2064 6963 740a 2020 2020 2020 2020   : dict.        
-00006220: 4c6f 6164 6564 2064 6963 7469 6f6e 6172  Loaded dictionar
-00006230: 790a 2020 2020 2222 220a 2020 2020 7265  y.    """.    re
-00006240: 7475 726e 2072 6563 7572 7369 7665 6c79  turn recursively
-00006250: 5f6c 6f61 645f 6469 6374 5f63 6f6e 7465  _load_dict_conte
-00006260: 6e74 735f 6672 6f6d 5f67 726f 7570 2868  nts_from_group(h
-00006270: 3566 696c 652c 2070 6174 6829 0a0a 0a64  5file, path)...d
-00006280: 6566 2072 6563 7572 7369 7665 6c79 5f6c  ef recursively_l
-00006290: 6f61 645f 6469 6374 5f63 6f6e 7465 6e74  oad_dict_content
-000062a0: 735f 6672 6f6d 5f67 726f 7570 2868 3566  s_from_group(h5f
-000062b0: 696c 652c 2070 6174 6829 3a0a 2020 2020  ile, path):.    
-000062c0: 2222 220a 2020 2020 4c6f 6164 2068 3520  """.    Load h5 
-000062d0: 6f62 6a65 6374 2061 7320 6469 6374 2072  object as dict r
-000062e0: 6563 7572 7369 7665 6c79 2028 6865 6c70  ecursively (help
-000062f0: 6572 2066 756e 6374 696f 6e29 2e0a 0a20  er function)... 
-00006300: 2020 2050 6172 616d 6574 6572 730a 2020     Parameters.  
-00006310: 2020 2d2d 2d2d 2d2d 2d2d 2d2d 0a20 2020    ----------.   
-00006320: 2068 3566 696c 6520 3a66 696c 650a 2020   h5file :file.  
-00006330: 2020 2020 2020 4864 6635 2066 696c 6520        Hdf5 file 
-00006340: 6f62 6a65 6374 0a20 2020 2070 6174 6820  object.    path 
-00006350: 3a20 7374 720a 2020 2020 2020 2020 5061  : str.        Pa
-00006360: 7468 2074 6f20 7468 6520 6835 2066 6965  th to the h5 fie
-00006370: 6c64 0a20 2020 2052 6574 7572 6e73 0a20  ld.    Returns. 
-00006380: 2020 202d 2d2d 2d2d 2d2d 0a20 2020 2064     -------.    d
-00006390: 6963 7469 6f6e 6172 7920 3a20 6469 6374  ictionary : dict
-000063a0: 0a20 2020 2020 2020 204c 6f61 6465 6420  .        Loaded 
-000063b0: 6469 6374 696f 6e61 7279 0a20 2020 2022  dictionary.    "
-000063c0: 2222 0a20 2020 2061 6e73 203d 207b 7d0a  "".    ans = {}.
-000063d0: 2020 2020 666f 7220 6b65 792c 2069 7465      for key, ite
-000063e0: 6d20 696e 2068 3566 696c 655b 7061 7468  m in h5file[path
-000063f0: 5d2e 6974 656d 7328 293a 0a20 2020 2020  ].items():.     
-00006400: 2020 2069 6620 6973 696e 7374 616e 6365     if isinstance
-00006410: 2869 7465 6d2c 2068 3570 792e 5f68 6c2e  (item, h5py._hl.
-00006420: 6461 7461 7365 742e 4461 7461 7365 7429  dataset.Dataset)
-00006430: 3a0a 2020 2020 2020 2020 2020 2020 2320  :.            # 
-00006440: 6861 6e64 6c65 2062 7974 6573 2073 7472  handle bytes str
-00006450: 696e 6773 0a20 2020 2020 2020 2020 2020  ings.           
-00006460: 2069 6620 6973 696e 7374 616e 6365 2869   if isinstance(i
-00006470: 7465 6d5b 2829 5d2c 2062 7974 6573 293a  tem[()], bytes):
-00006480: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00006490: 2061 6e73 5b6b 6579 5d20 3d20 6974 656d   ans[key] = item
-000064a0: 5b28 295d 2e64 6563 6f64 6528 290a 2020  [()].decode().  
-000064b0: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
-000064c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000064d0: 616e 735b 6b65 795d 203d 2069 7465 6d5b  ans[key] = item[
-000064e0: 2829 5d0a 2020 2020 2020 2020 656c 6966  ()].        elif
-000064f0: 2069 7369 6e73 7461 6e63 6528 6974 656d   isinstance(item
-00006500: 2c20 6835 7079 2e5f 686c 2e67 726f 7570  , h5py._hl.group
-00006510: 2e47 726f 7570 293a 0a20 2020 2020 2020  .Group):.       
-00006520: 2020 2020 2061 6e73 5b6b 6579 5d20 3d20       ans[key] = 
-00006530: 7265 6375 7273 6976 656c 795f 6c6f 6164  recursively_load
-00006540: 5f64 6963 745f 636f 6e74 656e 7473 5f66  _dict_contents_f
-00006550: 726f 6d5f 6772 6f75 7028 6835 6669 6c65  rom_group(h5file
-00006560: 2c20 7061 7468 202b 206b 6579 202b 2027  , path + key + '
-00006570: 2f27 290a 2020 2020 7265 7475 726e 2063  /').    return c
-00006580: 6c65 616e 5f64 6963 7428 616e 7329 0a0a  lean_dict(ans)..
-00006590: 0a64 6566 2063 6c65 616e 5f64 6963 7428  .def clean_dict(
-000065a0: 6429 3a0a 2020 2020 2222 220a 2020 2020  d):.    """.    
-000065b0: 436c 6561 6e20 6469 6374 696f 6e61 7279  Clean dictionary
-000065c0: 206c 6f61 6465 6420 6672 6f6d 2068 3520   loaded from h5 
-000065d0: 6669 6c65 2e0a 0a20 2020 2050 6172 616d  file...    Param
-000065e0: 6574 6572 730a 2020 2020 2d2d 2d2d 2d2d  eters.    ------
-000065f0: 2d2d 2d2d 0a20 2020 2064 203a 2064 6963  ----.    d : dic
-00006600: 740a 2020 2020 2020 2020 4469 6374 696f  t.        Dictio
-00006610: 6e61 7279 2074 6f20 6265 2063 6c65 616e  nary to be clean
-00006620: 6564 2e0a 0a20 2020 2052 6574 7572 6e73  ed...    Returns
-00006630: 0a20 2020 202d 2d2d 2d2d 2d2d 0a20 2020  .    -------.   
-00006640: 2064 203a 2064 6963 740a 2020 2020 2020   d : dict.      
-00006650: 2020 436c 6561 6e65 6420 6469 6374 696f    Cleaned dictio
-00006660: 6e61 7279 0a20 2020 2022 2222 0a20 2020  nary.    """.   
-00006670: 2066 6f72 206b 6579 2c20 6974 656d 2069   for key, item i
-00006680: 6e20 642e 6974 656d 7328 293a 0a20 2020  n d.items():.   
-00006690: 2020 2020 2069 6620 6973 696e 7374 616e       if isinstan
-000066a0: 6365 2869 7465 6d2c 2064 6963 7429 3a0a  ce(item, dict):.
-000066b0: 2020 2020 2020 2020 2020 2020 636c 6561              clea
-000066c0: 6e5f 6469 6374 2869 7465 6d29 0a20 2020  n_dict(item).   
-000066d0: 2020 2020 2065 6c69 6620 6973 696e 7374       elif isinst
-000066e0: 616e 6365 2869 7465 6d2c 2073 7472 293a  ance(item, str):
-000066f0: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-00006700: 6974 656d 203d 3d20 276e 756c 6c27 3a0a  item == 'null':.
-00006710: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006720: 645b 6b65 795d 203d 204e 6f6e 650a 2020  d[key] = None.  
-00006730: 2020 2020 2020 2020 2020 656c 6966 2069            elif i
-00006740: 7465 6d20 3d3d 2027 5b5d 273a 0a20 2020  tem == '[]':.   
-00006750: 2020 2020 2020 2020 2020 2020 2064 5b6b               d[k
-00006760: 6579 5d20 3d20 6e70 2e61 7272 6179 285b  ey] = np.array([
-00006770: 5d29 0a20 2020 2020 2020 2065 6c69 6620  ]).        elif 
-00006780: 6973 696e 7374 616e 6365 2869 7465 6d2c  isinstance(item,
-00006790: 206e 702e 6e64 6172 7261 7929 3a0a 2020   np.ndarray):.  
-000067a0: 2020 2020 2020 2020 2020 6966 206c 656e            if len
-000067b0: 2869 7465 6d29 203e 2030 3a0a 2020 2020  (item) > 0:.    
-000067c0: 2020 2020 2020 2020 2020 2020 6966 2069              if i
-000067d0: 7369 6e73 7461 6e63 6528 6974 656d 5b30  sinstance(item[0
-000067e0: 5d2c 206e 702e 6279 7465 735f 293a 0a20  ], np.bytes_):. 
-000067f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006800: 2020 2064 5b6b 6579 5d20 3d20 6c69 7374     d[key] = list
-00006810: 285b 6e2e 6465 636f 6465 2829 2066 6f72  ([n.decode() for
-00006820: 206e 2069 6e20 6974 656d 5d29 0a20 2020   n in item]).   
-00006830: 2020 2020 2020 2020 2020 2020 2065 6c73               els
-00006840: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-00006850: 2020 2020 2020 2064 5b6b 6579 5d20 3d20         d[key] = 
-00006860: 6c69 7374 2869 7465 6d29 0a20 2020 2072  list(item).    r
-00006870: 6574 7572 6e20 640a 0a0a 6465 6620 5f63  eturn d...def _c
-00006880: 6c65 616e 5f6e 756d 7079 5f73 6361 6c61  lean_numpy_scala
-00006890: 7228 7629 3a0a 2020 2020 6966 2069 7369  r(v):.    if isi
-000068a0: 6e73 7461 6e63 6528 762c 206e 702e 626f  nstance(v, np.bo
-000068b0: 6f6c 5f29 3a0a 2020 2020 2020 2020 7620  ol_):.        v 
-000068c0: 3d20 626f 6f6c 2876 290a 2020 2020 6966  = bool(v).    if
-000068d0: 2069 7369 6e73 7461 6e63 6528 762c 206e   isinstance(v, n
-000068e0: 702e 666c 6f61 745f 293a 0a20 2020 2020  p.float_):.     
-000068f0: 2020 2076 203d 2066 6c6f 6174 2876 290a     v = float(v).
-00006900: 2020 2020 6966 2069 7369 6e73 7461 6e63      if isinstanc
-00006910: 6528 762c 206e 702e 696e 745f 293a 0a20  e(v, np.int_):. 
-00006920: 2020 2020 2020 2076 203d 2069 6e74 2876         v = int(v
-00006930: 290a 2020 2020 7265 7475 726e 2076 0a0a  ).    return v..
-00006940: 6465 6620 636c 6561 6e5f 6469 6374 5f66  def clean_dict_f
-00006950: 6f72 5f79 616d 6c28 6429 3a0a 2020 2020  or_yaml(d):.    
-00006960: 2222 220a 2020 2020 436c 6561 6e20 6469  """.    Clean di
-00006970: 6374 696f 6e61 7279 2062 6566 6f72 6520  ctionary before 
-00006980: 7361 7669 6e67 2074 6f20 7961 6d6c 0a0a  saving to yaml..
-00006990: 2020 2020 5061 7261 6d65 7465 7273 0a20      Parameters. 
-000069a0: 2020 202d 2d2d 2d2d 2d2d 2d2d 2d0a 2020     ----------.  
-000069b0: 2020 6420 3a20 6469 6374 0a20 2020 2020    d : dict.     
-000069c0: 2020 2044 6963 7469 6f6e 6172 7920 746f     Dictionary to
-000069d0: 2062 6520 636c 6561 6e65 642e 0a0a 2020   be cleaned...  
-000069e0: 2020 5265 7475 726e 730a 2020 2020 2d2d    Returns.    --
-000069f0: 2d2d 2d2d 2d0a 2020 2020 6420 3a20 6469  -----.    d : di
-00006a00: 6374 0a20 2020 2020 2020 2043 6c65 616e  ct.        Clean
-00006a10: 6564 2064 6963 7469 6f6e 6172 790a 2020  ed dictionary.  
-00006a20: 2020 2222 220a 0a20 2020 2064 3220 3d20    """..    d2 = 
-00006a30: 642e 636f 7079 2829 0a20 2020 2066 6f72  d.copy().    for
-00006a40: 206b 2c20 7620 696e 2064 322e 6974 656d   k, v in d2.item
-00006a50: 7328 293a 0a20 2020 2020 2020 2064 325b  s():.        d2[
-00006a60: 6b5d 203d 205f 636c 6561 6e5f 6e75 6d70  k] = _clean_nump
-00006a70: 795f 7363 616c 6172 2876 290a 2020 2020  y_scalar(v).    
-00006a80: 2020 2020 6966 2069 7369 6e73 7461 6e63      if isinstanc
-00006a90: 6528 762c 206c 6973 7429 3a0a 2020 2020  e(v, list):.    
-00006aa0: 2020 2020 2020 2020 6432 5b6b 5d20 3d20          d2[k] = 
-00006ab0: 5b5f 636c 6561 6e5f 6e75 6d70 795f 7363  [_clean_numpy_sc
-00006ac0: 616c 6172 2865 2920 666f 7220 6520 696e  alar(e) for e in
-00006ad0: 2076 5d0a 2020 2020 7265 7475 726e 2064   v].    return d
-00006ae0: 320a 0a64 6566 2063 6f6e 7665 7274 5f72  2..def convert_r
-00006af0: 6563 6f72 6469 6e67 5f74 6f5f 6e65 775f  ecording_to_new_
-00006b00: 7665 7273 696f 6e28 6669 6c65 6e61 6d65  version(filename
-00006b10: 2c20 6e65 775f 6669 6c65 6e61 6d65 3d4e  , new_filename=N
-00006b20: 6f6e 6529 3a0a 2020 2020 2222 220a 2020  one):.    """.  
-00006b30: 2020 436f 6e76 6572 7473 204d 4541 7265    Converts MEAre
-00006b40: 6320 6835 2066 696c 6520 6672 6f6d 2061  c h5 file from a
-00006b50: 2076 6572 7369 6f6e 203c 312e 3520 746f   version <1.5 to
-00006b60: 2074 6865 206e 6577 2066 6f72 6d61 7420   the new format 
-00006b70: 3e3d 312e 352e 0a0a 2020 2020 5061 7261  >=1.5...    Para
-00006b80: 6d65 7465 7273 0a20 2020 202d 2d2d 2d2d  meters.    -----
-00006b90: 2d2d 2d2d 2d0a 2020 2020 6669 6c65 6e61  -----.    filena
-00006ba0: 6d65 3a20 7374 720a 2020 2020 2020 2020  me: str.        
-00006bb0: 5061 7468 2074 6f20 6f72 6967 696e 616c  Path to original
-00006bc0: 202e 6835 2066 696c 650a 2020 2020 6e65   .h5 file.    ne
-00006bd0: 775f 6669 6c65 6e61 6d65 3a20 7374 7220  w_filename: str 
-00006be0: 286f 7074 696f 6e61 6c29 0a20 2020 2020  (optional).     
-00006bf0: 2020 2050 6174 6820 746f 206e 6577 202e     Path to new .
-00006c00: 6835 2066 696c 652e 2049 6620 4e6f 6e65  h5 file. If None
-00006c10: 2028 6465 6661 756c 7429 2c20 7468 6520   (default), the 
-00006c20: 6f72 6967 696e 616c 2066 696c 6520 6973  original file is
-00006c30: 206f 7665 7277 7269 7474 656e 0a0a 2020   overwritten..  
-00006c40: 2020 2222 220a 2020 2020 6669 6c65 6e61    """.    filena
-00006c50: 6d65 203d 2050 6174 6828 6669 6c65 6e61  me = Path(filena
-00006c60: 6d65 290a 2020 2020 6173 7365 7274 2066  me).    assert f
-00006c70: 696c 656e 616d 652e 7375 6666 6978 2069  ilename.suffix i
-00006c80: 6e20 5b27 2e68 3527 2c20 272e 6864 6635  n ['.h5', '.hdf5
-00006c90: 275d 2c20 2750 726f 7669 6465 2061 6e20  '], 'Provide an 
-00006ca0: 2e68 3520 6f72 202e 6864 6635 2066 696c  .h5 or .hdf5 fil
-00006cb0: 6520 6e61 6d65 270a 0a20 2020 2069 6620  e name'..    if 
-00006cc0: 6e65 775f 6669 6c65 6e61 6d65 2069 7320  new_filename is 
-00006cd0: 6e6f 7420 4e6f 6e65 3a0a 2020 2020 2020  not None:.      
-00006ce0: 2020 6e65 775f 6669 6c65 6e61 6d65 203d    new_filename =
-00006cf0: 2050 6174 6828 6e65 775f 6669 6c65 6e61   Path(new_filena
-00006d00: 6d65 290a 2020 2020 2020 2020 6173 7365  me).        asse
-00006d10: 7274 206e 6577 5f66 696c 656e 616d 652e  rt new_filename.
-00006d20: 7375 6666 6978 2069 6e20 5b27 2e68 3527  suffix in ['.h5'
-00006d30: 2c20 272e 6864 6635 275d 0a20 2020 2020  , '.hdf5'].     
-00006d40: 2020 2073 6875 7469 6c2e 636f 7079 2866     shutil.copy(f
-00006d50: 696c 656e 616d 652c 206e 6577 5f66 696c  ilename, new_fil
-00006d60: 656e 616d 6529 0a0a 2020 2020 7769 7468  ename)..    with
-00006d70: 2068 3570 792e 4669 6c65 2866 696c 656e   h5py.File(filen
-00006d80: 616d 652c 2027 722b 2729 2061 7320 663a  ame, 'r+') as f:
-00006d90: 0a20 2020 2020 2020 206d 6561 7265 635f  .        mearec_
-00006da0: 7665 7273 696f 6e20 3d20 662e 6174 7472  version = f.attr
-00006db0: 732e 6765 7428 276d 6561 7265 635f 7665  s.get('mearec_ve
-00006dc0: 7273 696f 6e27 2c20 2731 2e34 2e30 2729  rsion', '1.4.0')
-00006dd0: 0a0a 2020 2020 2020 2020 6966 2070 6172  ..        if par
-00006de0: 7365 286d 6561 7265 635f 7665 7273 696f  se(mearec_versio
-00006df0: 6e29 203e 3d20 7061 7273 6528 2731 2e35  n) >= parse('1.5
-00006e00: 2e30 2729 3a0a 2020 2020 2020 2020 2020  .0'):.          
-00006e10: 2020 7072 696e 7428 2254 6865 2070 726f    print("The pro
-00006e20: 7669 6465 6420 6d65 6172 6563 2066 696c  vided mearec fil
-00006e30: 6520 6973 2061 6c72 6561 6479 2075 7020  e is already up 
-00006e40: 746f 2064 6174 6522 290a 2020 2020 2020  to date").      
-00006e50: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
-00006e60: 2020 2020 2320 7665 7273 696f 6e20 2031      # version  1
-00006e70: 2e34 2e30 2061 6e64 2062 6566 6f72 6520  .4.0 and before 
-00006e80: 6973 2028 6e5f 6368 616e 6e65 6c2c 206e  is (n_channel, n
-00006e90: 5f73 616d 706c 6573 2920 696e 7369 6465  _samples) inside
-00006ea0: 2074 6865 2068 3520 6669 6c65 0a20 2020   the h5 file.   
-00006eb0: 2020 2020 2020 2020 2070 7269 6e74 2822           print("
-00006ec0: 5570 6461 7469 6e67 2066 696c 6522 290a  Updating file").
-00006ed0: 2020 2020 2020 2020 2020 2020 7265 636f              reco
-00006ee0: 7264 696e 6773 203d 2066 2e67 6574 2827  rdings = f.get('
-00006ef0: 7265 636f 7264 696e 6773 2729 5b3a 5d0a  recordings')[:].
-00006f00: 2020 2020 2020 2020 2020 2020 7370 696b              spik
-00006f10: 655f 7472 6163 6573 203d 2066 2e67 6574  e_traces = f.get
-00006f20: 2827 7370 696b 655f 7472 6163 6573 2729  ('spike_traces')
-00006f30: 5b3a 5d0a 0a20 2020 2020 2020 2020 2020  [:]..           
-00006f40: 2069 6620 6e65 775f 6669 6c65 6e61 6d65   if new_filename
-00006f50: 2069 7320 6e6f 7420 4e6f 6e65 3a0a 2020   is not None:.  
-00006f60: 2020 2020 2020 2020 2020 2020 2020 7769                wi
-00006f70: 7468 2068 3570 792e 4669 6c65 286e 6577  th h5py.File(new
-00006f80: 5f66 696c 656e 616d 652c 2027 722b 2729  _filename, 'r+')
-00006f90: 2061 7320 666e 6577 3a0a 2020 2020 2020   as fnew:.      
-00006fa0: 2020 2020 2020 2020 2020 2020 2020 6465                de
-00006fb0: 6c20 666e 6577 5b27 7265 636f 7264 696e  l fnew['recordin
-00006fc0: 6773 275d 0a20 2020 2020 2020 2020 2020  gs'].           
-00006fd0: 2020 2020 2020 2020 2064 656c 2066 6e65           del fne
-00006fe0: 775b 2773 7069 6b65 5f74 7261 6365 7327  w['spike_traces'
-00006ff0: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
-00007000: 2020 2020 2020 666e 6577 2e63 7265 6174        fnew.creat
-00007010: 655f 6461 7461 7365 7428 2772 6563 6f72  e_dataset('recor
-00007020: 6469 6e67 7327 2c20 6461 7461 3d72 6563  dings', data=rec
-00007030: 6f72 6469 6e67 732e 5429 0a20 2020 2020  ordings.T).     
-00007040: 2020 2020 2020 2020 2020 2020 2020 2066                 f
-00007050: 6e65 772e 6372 6561 7465 5f64 6174 6173  new.create_datas
-00007060: 6574 2827 7370 696b 655f 7472 6163 6573  et('spike_traces
-00007070: 272c 2064 6174 613d 7370 696b 655f 7472  ', data=spike_tr
-00007080: 6163 6573 2e54 290a 2020 2020 2020 2020  aces.T).        
-00007090: 2020 2020 2020 2020 2020 2020 666e 6577              fnew
-000070a0: 2e61 7474 7273 5b27 6d65 6172 6563 5f76  .attrs['mearec_v
-000070b0: 6572 7369 6f6e 275d 203d 2076 6572 7369  ersion'] = versi
-000070c0: 6f6e 0a20 2020 2020 2020 2020 2020 2065  on.            e
-000070d0: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
-000070e0: 2020 2020 2064 656c 2066 5b27 7265 636f       del f['reco
-000070f0: 7264 696e 6773 275d 0a20 2020 2020 2020  rdings'].       
-00007100: 2020 2020 2020 2020 2064 656c 2066 5b27           del f['
-00007110: 7370 696b 655f 7472 6163 6573 275d 0a20  spike_traces']. 
-00007120: 2020 2020 2020 2020 2020 2020 2020 2066                 f
-00007130: 2e63 7265 6174 655f 6461 7461 7365 7428  .create_dataset(
-00007140: 2772 6563 6f72 6469 6e67 7327 2c20 6461  'recordings', da
-00007150: 7461 3d72 6563 6f72 6469 6e67 732e 5429  ta=recordings.T)
-00007160: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00007170: 2066 2e63 7265 6174 655f 6461 7461 7365   f.create_datase
-00007180: 7428 2773 7069 6b65 5f74 7261 6365 7327  t('spike_traces'
-00007190: 2c20 6461 7461 3d73 7069 6b65 5f74 7261  , data=spike_tra
-000071a0: 6365 732e 5429 0a20 2020 2020 2020 2020  ces.T).         
-000071b0: 2020 2020 2020 2066 2e61 7474 7273 5b27         f.attrs['
-000071c0: 6d65 6172 6563 5f76 6572 7369 6f6e 275d  mearec_version']
-000071d0: 203d 2076 6572 7369 6f6e 0a0a 0a23 2323   = version...###
-000071e0: 2054 454d 504c 4154 4553 2049 4e46 4f20   TEMPLATES INFO 
-000071f0: 2323 230a 6465 6620 6765 745f 6269 6e61  ###.def get_bina
-00007200: 7279 5f63 6174 2863 656c 6c74 7970 6573  ry_cat(celltypes
-00007210: 2c20 6578 6369 742c 2069 6e68 6962 293a  , excit, inhib):
-00007220: 0a20 2020 2022 2222 0a20 2020 2052 6574  .    """.    Ret
-00007230: 7572 6e73 2062 696e 6172 7920 6361 7465  urns binary cate
-00007240: 676f 7279 2064 6570 656e 6469 6e67 206f  gory depending o
-00007250: 6e20 6365 6c6c 2074 7970 652e 0a0a 2020  n cell type...  
-00007260: 2020 5061 7261 6d65 7465 7273 0a20 2020    Parameters.   
-00007270: 202d 2d2d 2d2d 2d2d 2d2d 2d0a 2020 2020   ----------.    
-00007280: 6365 6c6c 7479 7065 7320 3a20 6e70 2e61  celltypes : np.a
-00007290: 7272 6179 0a20 2020 2020 2020 2053 7472  rray.        Str
-000072a0: 696e 6720 6172 7261 7920 7769 7468 2063  ing array with c
-000072b0: 656c 6c20 7479 7065 730a 2020 2020 6578  ell types.    ex
-000072c0: 6369 7420 3a20 6c69 7374 0a20 2020 2020  cit : list.     
-000072d0: 2020 204c 6973 7420 6f66 2073 7562 7374     List of subst
-000072e0: 7269 6e67 7320 666f 7220 6578 6369 7461  rings for excita
-000072f0: 746f 7279 2063 656c 6c20 7479 7065 7320  tory cell types 
-00007300: 2865 2e67 2e20 5b27 5043 272c 2027 5554  (e.g. ['PC', 'UT
-00007310: 5043 275d 290a 2020 2020 696e 6869 6220  PC']).    inhib 
-00007320: 3a20 6c69 7374 0a20 2020 2020 2020 204c  : list.        L
-00007330: 6973 7420 6f66 2073 7562 7374 7269 6e67  ist of substring
-00007340: 7320 666f 7220 696e 6869 6269 746f 7279  s for inhibitory
-00007350: 2063 656c 6c74 7970 6573 2028 652e 672e   celltypes (e.g.
-00007360: 205b 2742 5027 2c20 274d 4327 5d29 0a0a   ['BP', 'MC'])..
-00007370: 2020 2020 5265 7475 726e 730a 2020 2020      Returns.    
-00007380: 2d2d 2d2d 2d2d 2d0a 2020 2020 6269 6e61  -------.    bina
-00007390: 7279 5f63 6174 203a 206e 702e 6172 7261  ry_cat : np.arra
-000073a0: 790a 2020 2020 2020 2020 4172 7261 7920  y.        Array 
-000073b0: 7769 7468 2062 696e 6172 7920 6365 6c6c  with binary cell
-000073c0: 2074 7970 6520 2845 2d49 290a 0a20 2020   type (E-I)..   
-000073d0: 2022 2222 0a20 2020 2062 696e 6172 795f   """.    binary_
-000073e0: 6361 7420 3d20 5b5d 0a20 2020 2073 616d  cat = [].    sam
-000073f0: 706c 655f 7479 7065 203d 2063 656c 6c74  ple_type = cellt
-00007400: 7970 6573 5b30 5d0a 2020 2020 2320 4669  ypes[0].    # Fi
-00007410: 6e64 2069 6620 6262 7020 6f72 2063 7573  nd if bbp or cus
-00007420: 746f 6d20 6d6f 6465 6c73 0a20 2020 2069  tom models.    i
-00007430: 6620 7361 6d70 6c65 5f74 7970 652e 7374  f sample_type.st
-00007440: 6172 7473 7769 7468 2827 4c27 2920 616e  artswith('L') an
-00007450: 6420 6c65 6e28 7361 6d70 6c65 5f74 7970  d len(sample_typ
-00007460: 652e 7370 6c69 7428 275f 2729 2920 3d3d  e.split('_')) ==
-00007470: 2034 3a0a 2020 2020 2020 2020 6d6f 6465   4:.        mode
-00007480: 6c73 203d 2027 6262 7027 0a20 2020 2065  ls = 'bbp'.    e
-00007490: 6c73 653a 0a20 2020 2020 2020 206d 6f64  lse:.        mod
-000074a0: 656c 7320 3d20 2763 7573 746f 6d27 0a20  els = 'custom'. 
-000074b0: 2020 2066 6f72 2069 2c20 6361 7420 696e     for i, cat in
-000074c0: 2065 6e75 6d65 7261 7465 2863 656c 6c74   enumerate(cellt
-000074d0: 7970 6573 293a 0a20 2020 2020 2020 2069  ypes):.        i
-000074e0: 6620 6d6f 6465 6c73 203d 3d20 2762 6270  f models == 'bbp
-000074f0: 273a 0a20 2020 2020 2020 2020 2020 2063  ':.            c
-00007500: 656c 6c5f 7374 7220 3d20 7374 7228 6361  ell_str = str(ca
-00007510: 7429 2e73 706c 6974 2827 5f27 295b 315d  t).split('_')[1]
-00007520: 0a20 2020 2020 2020 2065 6c73 653a 0a20  .        else:. 
-00007530: 2020 2020 2020 2020 2020 2063 656c 6c5f             cell_
-00007540: 7374 7220 3d20 7374 7228 6361 7429 0a20  str = str(cat). 
-00007550: 2020 2020 2020 2069 6620 6e70 2e61 6e79         if np.any
-00007560: 285b 6578 2069 6e20 6365 6c6c 5f73 7472  ([ex in cell_str
-00007570: 2066 6f72 2065 7820 696e 2065 7863 6974   for ex in excit
-00007580: 5d29 3a0a 2020 2020 2020 2020 2020 2020  ]):.            
-00007590: 6269 6e61 7279 5f63 6174 2e61 7070 656e  binary_cat.appen
-000075a0: 6428 2745 2729 0a20 2020 2020 2020 2065  d('E').        e
-000075b0: 6c69 6620 6e70 2e61 6e79 285b 696e 6820  lif np.any([inh 
-000075c0: 696e 2073 7472 2863 6174 2920 666f 7220  in str(cat) for 
-000075d0: 696e 6820 696e 2069 6e68 6962 5d29 3a0a  inh in inhib]):.
-000075e0: 2020 2020 2020 2020 2020 2020 6269 6e61              bina
-000075f0: 7279 5f63 6174 2e61 7070 656e 6428 2749  ry_cat.append('I
-00007600: 2729 0a20 2020 2020 2020 2065 6c73 653a  ').        else:
-00007610: 0a20 2020 2020 2020 2020 2020 2062 696e  .            bin
-00007620: 6172 795f 6361 742e 6170 7065 6e64 2827  ary_cat.append('
-00007630: 5527 290a 2020 2020 7265 7475 726e 206e  U').    return n
-00007640: 702e 6172 7261 7928 6269 6e61 7279 5f63  p.array(binary_c
-00007650: 6174 2c20 6474 7970 653d 7374 7229 0a0a  at, dtype=str)..
-00007660: 0a64 6566 2067 6574 5f74 656d 706c 6174  .def get_templat
-00007670: 6573 5f66 6561 7475 7265 7328 7465 6d70  es_features(temp
-00007680: 6c61 7465 732c 2066 6561 745f 6c69 7374  lates, feat_list
-00007690: 2c20 6474 3d4e 6f6e 652c 2074 656d 706c  , dt=None, templ
-000076a0: 6174 6573 5f74 696d 6573 3d4e 6f6e 652c  ates_times=None,
-000076b0: 2074 6872 6573 686f 6c64 5f64 6574 6563   threshold_detec
-000076c0: 743d 3029 3a0a 2020 2020 2222 220a 2020  t=0):.    """.  
-000076d0: 2020 436f 6d70 7574 6573 2073 6576 6572    Computes sever
-000076e0: 616c 2074 656d 706c 6174 6573 2066 6561  al templates fea
-000076f0: 7475 7265 732e 0a0a 2020 2020 5061 7261  tures...    Para
-00007700: 6d65 7465 7273 0a20 2020 202d 2d2d 2d2d  meters.    -----
-00007710: 2d2d 2d2d 2d0a 2020 2020 7465 6d70 6c61  -----.    templa
-00007720: 7465 7320 3a20 6e70 2e61 7272 6179 0a20  tes : np.array. 
-00007730: 2020 2020 2020 2045 4150 2074 656d 706c         EAP templ
-00007740: 6174 6573 0a20 2020 2066 6561 745f 6c69  ates.    feat_li
-00007750: 7374 203a 206c 6973 740a 2020 2020 2020  st : list.      
-00007760: 2020 4c69 7374 206f 6620 6665 6174 7572    List of featur
-00007770: 6573 2074 6f20 6265 2063 6f6d 7075 7465  es to be compute
-00007780: 6420 2861 6d70 2c20 7769 6474 682c 2066  d (amp, width, f
-00007790: 7768 6d2c 2072 6174 696f 2c20 7370 6565  whm, ratio, spee
-000077a0: 642c 206e 6567 2c20 706f 7329 0a20 2020  d, neg, pos).   
-000077b0: 2064 7420 3a20 666c 6f61 740a 2020 2020   dt : float.    
-000077c0: 2020 2020 5361 6d70 6c69 6e67 2070 6572      Sampling per
-000077d0: 696f 640a 2020 2020 7468 7265 7368 6f6c  iod.    threshol
-000077e0: 645f 6465 7465 6374 203a 2066 6c6f 6174  d_detect : float
-000077f0: 0a20 2020 2020 2020 2054 6872 6573 686f  .        Thresho
-00007800: 6c64 2074 6f20 7a65 726f 206f 7574 2066  ld to zero out f
-00007810: 6561 7475 7265 730a 0a20 2020 2052 6574  eatures..    Ret
-00007820: 7572 6e73 0a20 2020 202d 2d2d 2d2d 2d2d  urns.    -------
-00007830: 0a20 2020 2066 6561 7475 7265 5f64 6963  .    feature_dic
-00007840: 7420 3a20 6469 6374 0a20 2020 2020 2020  t : dict.       
-00007850: 2044 6963 7469 6f6e 6172 7920 7769 7468   Dictionary with
-00007860: 2066 6561 7475 7265 7320 286b 6579 733a   features (keys:
-00007870: 2061 6d70 2c20 7769 6474 682c 2066 7768   amp, width, fwh
-00007880: 6d2c 2072 6174 696f 2c20 7370 6565 642c  m, ratio, speed,
-00007890: 206e 6567 2c20 706f 7329 0a0a 2020 2020   neg, pos)..    
-000078a0: 2222 220a 2020 2020 6966 2064 7420 6973  """.    if dt is
-000078b0: 206e 6f74 204e 6f6e 653a 0a20 2020 2020   not None:.     
-000078c0: 2020 2074 656d 706c 6174 6573 5f74 696d     templates_tim
-000078d0: 6573 203d 206e 702e 6172 616e 6765 2874  es = np.arange(t
-000078e0: 656d 706c 6174 6573 2e73 6861 7065 5b2d  emplates.shape[-
-000078f0: 315d 2920 2a20 6474 0a20 2020 2065 6c73  1]) * dt.    els
-00007900: 653a 0a20 2020 2020 2020 2069 6620 2777  e:.        if 'w
-00007910: 6964 7468 2720 696e 2066 6561 745f 6c69  idth' in feat_li
-00007920: 7374 206f 7220 2766 7768 6d27 2069 6e20  st or 'fwhm' in 
-00007930: 6665 6174 5f6c 6973 7420 6f72 2027 7370  feat_list or 'sp
-00007940: 6565 6427 2069 6e20 6665 6174 5f6c 6973  eed' in feat_lis
-00007950: 743a 0a20 2020 2020 2020 2020 2020 2072  t:.            r
-00007960: 6169 7365 204e 6f74 496d 706c 656d 656e  aise NotImplemen
-00007970: 7465 6445 7272 6f72 2827 506c 6561 7365  tedError('Please
-00007980: 2c20 7370 6563 6966 7920 6569 7468 6572  , specify either
-00007990: 2064 7420 6f72 2074 656d 706c 6174 6573   dt or templates
-000079a0: 5f74 696d 6573 2e27 290a 0a20 2020 2069  _times.')..    i
-000079b0: 6620 6c65 6e28 7465 6d70 6c61 7465 732e  f len(templates.
-000079c0: 7368 6170 6529 203d 3d20 313a 0a20 2020  shape) == 1:.   
-000079d0: 2020 2020 2074 656d 706c 6174 6573 203d       templates =
-000079e0: 206e 702e 7265 7368 6170 6528 7465 6d70   np.reshape(temp
-000079f0: 6c61 7465 732c 205b 312c 2031 2c20 2d31  lates, [1, 1, -1
-00007a00: 5d29 0a20 2020 2065 6c69 6620 6c65 6e28  ]).    elif len(
-00007a10: 7465 6d70 6c61 7465 732e 7368 6170 6529  templates.shape)
-00007a20: 203d 3d20 323a 0a20 2020 2020 2020 2074   == 2:.        t
-00007a30: 656d 706c 6174 6573 203d 206e 702e 7265  emplates = np.re
-00007a40: 7368 6170 6528 7465 6d70 6c61 7465 732c  shape(templates,
-00007a50: 205b 312c 2074 656d 706c 6174 6573 2e73   [1, templates.s
-00007a60: 6861 7065 5b30 5d2c 2074 656d 706c 6174  hape[0], templat
-00007a70: 6573 2e73 6861 7065 5b31 5d5d 290a 2020  es.shape[1]]).  
-00007a80: 2020 6966 206c 656e 2874 656d 706c 6174    if len(templat
-00007a90: 6573 2e73 6861 7065 2920 213d 2033 3a0a  es.shape) != 3:.
-00007aa0: 2020 2020 2020 2020 7261 6973 6520 5661          raise Va
-00007ab0: 6c75 6545 7272 6f72 2827 4361 6e6e 6f74  lueError('Cannot
-00007ac0: 2068 616e 646c 6520 7465 6d70 6c61 7465   handle template
-00007ad0: 7373 2077 6974 6820 7368 6170 6527 2c20  ss with shape', 
-00007ae0: 7465 6d70 6c61 7465 732e 7368 6170 6529  templates.shape)
-00007af0: 0a0a 2020 2020 6665 6174 7572 6573 203d  ..    features =
-00007b00: 207b 7d0a 0a20 2020 2061 6d70 7320 3d20   {}..    amps = 
-00007b10: 6e70 2e7a 6572 6f73 2828 7465 6d70 6c61  np.zeros((templa
-00007b20: 7465 732e 7368 6170 655b 305d 2c20 7465  tes.shape[0], te
-00007b30: 6d70 6c61 7465 732e 7368 6170 655b 315d  mplates.shape[1]
-00007b40: 2929 0a20 2020 206e 615f 7065 616b 203d  )).    na_peak =
-00007b50: 206e 702e 7a65 726f 7328 2874 656d 706c   np.zeros((templ
-00007b60: 6174 6573 2e73 6861 7065 5b30 5d2c 2074  ates.shape[0], t
-00007b70: 656d 706c 6174 6573 2e73 6861 7065 5b31  emplates.shape[1
-00007b80: 5d29 290a 2020 2020 7265 705f 7065 616b  ])).    rep_peak
-00007b90: 203d 206e 702e 7a65 726f 7328 2874 656d   = np.zeros((tem
-00007ba0: 706c 6174 6573 2e73 6861 7065 5b30 5d2c  plates.shape[0],
-00007bb0: 2074 656d 706c 6174 6573 2e73 6861 7065   templates.shape
-00007bc0: 5b31 5d29 290a 2020 2020 6966 2027 7769  [1])).    if 'wi
-00007bd0: 6474 6827 2069 6e20 6665 6174 5f6c 6973  dth' in feat_lis
-00007be0: 743a 0a20 2020 2020 2020 2066 6561 7475  t:.        featu
-00007bf0: 7265 735b 2777 6964 7468 275d 203d 206e  res['width'] = n
-00007c00: 702e 7a65 726f 7328 2874 656d 706c 6174  p.zeros((templat
-00007c10: 6573 2e73 6861 7065 5b30 5d2c 2074 656d  es.shape[0], tem
-00007c20: 706c 6174 6573 2e73 6861 7065 5b31 5d29  plates.shape[1])
-00007c30: 290a 2020 2020 6966 2027 6677 686d 2720  ).    if 'fwhm' 
-00007c40: 696e 2066 6561 745f 6c69 7374 3a0a 2020  in feat_list:.  
-00007c50: 2020 2020 2020 6665 6174 7572 6573 5b27        features['
-00007c60: 6677 686d 275d 203d 206e 702e 7a65 726f  fwhm'] = np.zero
-00007c70: 7328 2874 656d 706c 6174 6573 2e73 6861  s((templates.sha
-00007c80: 7065 5b30 5d2c 2074 656d 706c 6174 6573  pe[0], templates
-00007c90: 2e73 6861 7065 5b31 5d29 290a 2020 2020  .shape[1])).    
-00007ca0: 6966 2027 7261 7469 6f27 2069 6e20 6665  if 'ratio' in fe
-00007cb0: 6174 5f6c 6973 743a 0a20 2020 2020 2020  at_list:.       
-00007cc0: 2066 6561 7475 7265 735b 2772 6174 696f   features['ratio
-00007cd0: 275d 203d 206e 702e 7a65 726f 7328 2874  '] = np.zeros((t
-00007ce0: 656d 706c 6174 6573 2e73 6861 7065 5b30  emplates.shape[0
-00007cf0: 5d2c 2074 656d 706c 6174 6573 2e73 6861  ], templates.sha
-00007d00: 7065 5b31 5d29 290a 2020 2020 6966 2027  pe[1])).    if '
-00007d10: 7370 6565 6427 2069 6e20 6665 6174 5f6c  speed' in feat_l
-00007d20: 6973 743a 0a20 2020 2020 2020 2066 6561  ist:.        fea
-00007d30: 7475 7265 735b 2773 7065 6564 275d 203d  tures['speed'] =
-00007d40: 206e 702e 7a65 726f 7328 2874 656d 706c   np.zeros((templ
-00007d50: 6174 6573 2e73 6861 7065 5b30 5d2c 2074  ates.shape[0], t
-00007d60: 656d 706c 6174 6573 2e73 6861 7065 5b31  emplates.shape[1
-00007d70: 5d29 290a 2020 2020 6966 2027 6e65 6727  ])).    if 'neg'
-00007d80: 2069 6e20 6665 6174 5f6c 6973 743a 0a20   in feat_list:. 
-00007d90: 2020 2020 2020 2066 6561 7475 7265 735b         features[
-00007da0: 276e 6567 275d 203d 206e 702e 7a65 726f  'neg'] = np.zero
-00007db0: 7328 2874 656d 706c 6174 6573 2e73 6861  s((templates.sha
-00007dc0: 7065 5b30 5d2c 2074 656d 706c 6174 6573  pe[0], templates
-00007dd0: 2e73 6861 7065 5b31 5d29 290a 2020 2020  .shape[1])).    
-00007de0: 6966 2027 706f 7327 2069 6e20 6665 6174  if 'pos' in feat
-00007df0: 5f6c 6973 743a 0a20 2020 2020 2020 2066  _list:.        f
-00007e00: 6561 7475 7265 735b 2770 6f73 275d 203d  eatures['pos'] =
-00007e10: 206e 702e 7a65 726f 7328 2874 656d 706c   np.zeros((templ
-00007e20: 6174 6573 2e73 6861 7065 5b30 5d2c 2074  ates.shape[0], t
-00007e30: 656d 706c 6174 6573 2e73 6861 7065 5b31  emplates.shape[1
-00007e40: 5d29 290a 0a20 2020 2066 6f72 2069 2069  ]))..    for i i
-00007e50: 6e20 7261 6e67 6528 7465 6d70 6c61 7465  n range(template
-00007e60: 732e 7368 6170 655b 305d 293a 0a20 2020  s.shape[0]):.   
-00007e70: 2020 2020 2023 2046 6f72 2041 4d50 2066       # For AMP f
-00007e80: 6561 7475 7265 0a20 2020 2020 2020 206d  eature.        m
-00007e90: 696e 5f69 6478 203d 206e 702e 6172 7261  in_idx = np.arra
-00007ea0: 7928 5b6e 702e 756e 7261 7665 6c5f 696e  y([np.unravel_in
-00007eb0: 6465 7828 7465 6d70 6c61 7465 735b 692c  dex(templates[i,
-00007ec0: 2065 5d2e 6172 676d 696e 2829 2c20 7465   e].argmin(), te
-00007ed0: 6d70 6c61 7465 735b 692c 2065 5d2e 7368  mplates[i, e].sh
-00007ee0: 6170 6529 5b30 5d20 666f 7220 6520 696e  ape)[0] for e in
-00007ef0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00007f00: 2020 2020 2020 2020 2020 2020 2072 616e               ran
-00007f10: 6765 2874 656d 706c 6174 6573 2e73 6861  ge(templates.sha
-00007f20: 7065 5b31 5d29 5d29 0a20 2020 2020 2020  pe[1])]).       
-00007f30: 206d 6178 5f69 6478 203d 206e 702e 6172   max_idx = np.ar
-00007f40: 7261 7928 5b6e 702e 756e 7261 7665 6c5f  ray([np.unravel_
-00007f50: 696e 6465 7828 7465 6d70 6c61 7465 735b  index(templates[
-00007f60: 692c 2065 2c20 6d69 6e5f 6964 785b 655d  i, e, min_idx[e]
-00007f70: 3a5d 2e61 7267 6d61 7828 292c 0a20 2020  :].argmax(),.   
-00007f80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007f90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007fa0: 2020 2020 2020 2020 2020 7465 6d70 6c61            templa
-00007fb0: 7465 735b 692c 2065 2c20 6d69 6e5f 6964  tes[i, e, min_id
-00007fc0: 785b 655d 3a5d 2e73 6861 7065 295b 305d  x[e]:].shape)[0]
-00007fd0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00007fe0: 2020 2020 2020 2020 2020 2020 202b 206d               + m
-00007ff0: 696e 5f69 6478 5b65 5d20 666f 7220 6520  in_idx[e] for e 
-00008000: 696e 2072 616e 6765 2874 656d 706c 6174  in range(templat
-00008010: 6573 2e73 6861 7065 5b31 5d29 5d29 0a20  es.shape[1])]). 
-00008020: 2020 2020 2020 2023 2066 6f72 206e 6120         # for na 
-00008030: 616e 6420 7265 700a 2020 2020 2020 2020  and rep.        
-00008040: 6d69 6e5f 656c 6964 2c20 6d69 6e5f 6964  min_elid, min_id
-00008050: 785f 6e61 203d 206e 702e 756e 7261 7665  x_na = np.unrave
-00008060: 6c5f 696e 6465 7828 7465 6d70 6c61 7465  l_index(template
-00008070: 735b 695d 2e61 7267 6d69 6e28 292c 2074  s[i].argmin(), t
-00008080: 656d 706c 6174 6573 5b69 5d2e 7368 6170  emplates[i].shap
-00008090: 6529 0a20 2020 2020 2020 206d 6178 5f69  e).        max_i
-000080a0: 6478 5f72 6570 203d 2074 656d 706c 6174  dx_rep = templat
-000080b0: 6573 5b69 2c20 6d69 6e5f 656c 6964 2c20  es[i, min_elid, 
-000080c0: 6d69 6e5f 6964 785f 6e61 3a5d 2e61 7267  min_idx_na:].arg
-000080d0: 6d61 7828 2920 2b20 6d69 6e5f 6964 785f  max() + min_idx_
-000080e0: 6e61 0a20 2020 2020 2020 206e 615f 7065  na.        na_pe
-000080f0: 616b 5b69 2c20 3a5d 203d 2074 656d 706c  ak[i, :] = templ
-00008100: 6174 6573 5b69 2c20 3a2c 206d 696e 5f69  ates[i, :, min_i
-00008110: 6478 5f6e 615d 0a20 2020 2020 2020 2072  dx_na].        r
-00008120: 6570 5f70 6561 6b5b 692c 203a 5d20 3d20  ep_peak[i, :] = 
-00008130: 7465 6d70 6c61 7465 735b 692c 203a 2c20  templates[i, :, 
-00008140: 6d61 785f 6964 785f 7265 705d 0a0a 2020  max_idx_rep]..  
-00008150: 2020 2020 2020 616d 7073 5b69 2c20 3a5d        amps[i, :]
-00008160: 203d 206e 702e 6172 7261 7928 5b74 656d   = np.array([tem
-00008170: 706c 6174 6573 5b69 2c20 652c 206d 6178  plates[i, e, max
-00008180: 5f69 6478 5b65 5d5d 202d 2074 656d 706c  _idx[e]] - templ
-00008190: 6174 6573 5b69 2c20 652c 206d 696e 5f69  ates[i, e, min_i
-000081a0: 6478 5b65 5d5d 0a20 2020 2020 2020 2020  dx[e]].         
-000081b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000081c0: 2020 2020 2020 666f 7220 6520 696e 2072        for e in r
-000081d0: 616e 6765 2874 656d 706c 6174 6573 2e73  ange(templates.s
-000081e0: 6861 7065 5b31 5d29 5d29 0a0a 2020 2020  hape[1])])..    
-000081f0: 2020 2020 746f 6f5f 6c6f 7720 3d20 6e70      too_low = np
-00008200: 2e77 6865 7265 2861 6d70 735b 692c 203a  .where(amps[i, :
-00008210: 5d20 3c20 7468 7265 7368 6f6c 645f 6465  ] < threshold_de
-00008220: 7465 6374 290a 2020 2020 2020 2020 616d  tect).        am
-00008230: 7073 5b69 2c20 746f 6f5f 6c6f 775d 203d  ps[i, too_low] =
-00008240: 2030 0a0a 2020 2020 2020 2020 6966 2027   0..        if '
-00008250: 7261 7469 6f27 2069 6e20 6665 6174 5f6c  ratio' in feat_l
-00008260: 6973 743a 0a20 2020 2020 2020 2020 2020  ist:.           
-00008270: 206d 696e 5f69 645f 7261 7469 6f20 3d20   min_id_ratio = 
-00008280: 6e70 2e61 7272 6179 285b 6e70 2e75 6e72  np.array([np.unr
-00008290: 6176 656c 5f69 6e64 6578 2874 656d 706c  avel_index(templ
-000082a0: 6174 6573 5b69 2c20 652c 206d 696e 5f69  ates[i, e, min_i
-000082b0: 6478 5f6e 613a 5d2e 6172 676d 696e 2829  dx_na:].argmin()
-000082c0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-000082d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000082e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000082f0: 2020 2020 2020 2020 7465 6d70 6c61 7465          template
-00008300: 735b 692c 2065 2c20 6d69 6e5f 6964 785f  s[i, e, min_idx_
-00008310: 6e61 3a5d 2e73 6861 7065 295b 305d 0a20  na:].shape)[0]. 
-00008320: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008330: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008340: 2020 2020 2b20 6d69 6e5f 6964 785f 6e61      + min_idx_na
-00008350: 2066 6f72 2065 2069 6e20 7261 6e67 6528   for e in range(
-00008360: 7465 6d70 6c61 7465 732e 7368 6170 655b  templates.shape[
-00008370: 315d 295d 290a 2020 2020 2020 2020 2020  1])]).          
-00008380: 2020 6d61 785f 6964 5f72 6174 696f 203d    max_id_ratio =
-00008390: 206e 702e 6172 7261 7928 5b6e 702e 756e   np.array([np.un
-000083a0: 7261 7665 6c5f 696e 6465 7828 7465 6d70  ravel_index(temp
-000083b0: 6c61 7465 735b 692c 2065 2c20 6d69 6e5f  lates[i, e, min_
-000083c0: 6964 785f 6e61 3a5d 2e61 7267 6d61 7828  idx_na:].argmax(
-000083d0: 292c 0a20 2020 2020 2020 2020 2020 2020  ),.             
-000083e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000083f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008400: 2020 2020 2020 2020 2074 656d 706c 6174           templat
-00008410: 6573 5b69 2c20 652c 206d 696e 5f69 6478  es[i, e, min_idx
-00008420: 5f6e 613a 5d2e 7368 6170 6529 5b30 5d0a  _na:].shape)[0].
-00008430: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008440: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008450: 2020 2020 202b 206d 696e 5f69 6478 5f6e       + min_idx_n
-00008460: 6120 666f 7220 6520 696e 2072 616e 6765  a for e in range
-00008470: 2874 656d 706c 6174 6573 2e73 6861 7065  (templates.shape
-00008480: 5b31 5d29 5d29 0a20 2020 2020 2020 2020  [1])]).         
-00008490: 2020 2066 6561 7475 7265 735b 2772 6174     features['rat
-000084a0: 696f 275d 5b69 2c20 3a5d 203d 206e 702e  io'][i, :] = np.
-000084b0: 6172 7261 7928 5b6e 702e 6162 7328 7465  array([np.abs(te
-000084c0: 6d70 6c61 7465 735b 692c 2065 2c20 6d61  mplates[i, e, ma
-000084d0: 785f 6964 5f72 6174 696f 5b65 5d5d 2920  x_id_ratio[e]]) 
-000084e0: 2f0a 2020 2020 2020 2020 2020 2020 2020  /.              
-000084f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008500: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008510: 2020 6e70 2e61 6273 2874 656d 706c 6174    np.abs(templat
-00008520: 6573 5b69 2c20 652c 206d 696e 5f69 645f  es[i, e, min_id_
-00008530: 7261 7469 6f5b 655d 5d29 0a20 2020 2020  ratio[e]]).     
-00008540: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008550: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008560: 2020 2020 2020 2020 2020 2066 6f72 2065             for e
-00008570: 2069 6e20 7261 6e67 6528 7465 6d70 6c61   in range(templa
-00008580: 7465 732e 7368 6170 655b 315d 295d 290a  tes.shape[1])]).
-00008590: 2020 2020 2020 2020 2020 2020 2320 4966              # If
-000085a0: 2062 656c 6f77 2027 6465 7465 6374 6162   below 'detectab
-000085b0: 6c65 2074 6872 6573 686f 6c64 2c20 7365  le threshold, se
-000085c0: 7420 616d 7020 616e 6420 7769 6474 6820  t amp and width 
-000085d0: 746f 2030 0a20 2020 2020 2020 2020 2020  to 0.           
-000085e0: 2074 6f6f 5f6c 6f77 203d 206e 702e 7768   too_low = np.wh
-000085f0: 6572 6528 616d 7073 5b69 2c20 3a5d 203c  ere(amps[i, :] <
-00008600: 2074 6872 6573 686f 6c64 5f64 6574 6563   threshold_detec
-00008610: 7429 0a20 2020 2020 2020 2020 2020 2066  t).            f
-00008620: 6561 7475 7265 735b 2772 6174 696f 275d  eatures['ratio']
-00008630: 5b69 2c20 746f 6f5f 6c6f 775d 203d 2031  [i, too_low] = 1
-00008640: 0a20 2020 2020 2020 2069 6620 2773 7065  .        if 'spe
-00008650: 6564 2720 696e 2066 6561 745f 6c69 7374  ed' in feat_list
-00008660: 3a0a 2020 2020 2020 2020 2020 2020 6665  :.            fe
-00008670: 6174 7572 6573 5b27 7370 6565 6427 5d5b  atures['speed'][
-00008680: 692c 203a 5d20 3d20 6e70 2e61 7272 6179  i, :] = np.array
-00008690: 2828 6d69 6e5f 6964 7820 2d20 6d69 6e5f  ((min_idx - min_
-000086a0: 6964 785f 6e61 2920 2a20 6474 290a 2020  idx_na) * dt).  
-000086b0: 2020 2020 2020 2020 2020 6665 6174 7572            featur
-000086c0: 6573 5b27 7370 6565 6427 5d5b 692c 2074  es['speed'][i, t
-000086d0: 6f6f 5f6c 6f77 5d20 3d20 6d69 6e5f 6964  oo_low] = min_id
-000086e0: 785f 6e61 202a 2064 740a 0a20 2020 2020  x_na * dt..     
-000086f0: 2020 2069 6620 2777 6964 7468 2720 696e     if 'width' in
-00008700: 2066 6561 745f 6c69 7374 3a0a 2020 2020   feat_list:.    
-00008710: 2020 2020 2020 2020 6665 6174 7572 6573          features
-00008720: 5b27 7769 6474 6827 5d5b 692c 203a 5d20  ['width'][i, :] 
-00008730: 3d20 6e70 2e61 6273 2874 656d 706c 6174  = np.abs(templat
-00008740: 6573 5f74 696d 6573 5b6d 6178 5f69 6478  es_times[max_idx
-00008750: 5d20 2d20 7465 6d70 6c61 7465 735f 7469  ] - templates_ti
-00008760: 6d65 735b 6d69 6e5f 6964 785d 290a 2020  mes[min_idx]).  
-00008770: 2020 2020 2020 2020 2020 6665 6174 7572            featur
-00008780: 6573 5b27 7769 6474 6827 5d5b 692c 2074  es['width'][i, t
-00008790: 6f6f 5f6c 6f77 5d20 3d20 7465 6d70 6c61  oo_low] = templa
-000087a0: 7465 732e 7368 6170 655b 325d 202a 2064  tes.shape[2] * d
-000087b0: 7420 2023 2074 656d 706c 6174 6573 5f74  t  # templates_t
-000087c0: 696d 6573 5b2d 315d 2d74 656d 706c 6174  imes[-1]-templat
-000087d0: 6573 5f74 696d 6573 5b30 5d0a 0a20 2020  es_times[0]..   
-000087e0: 2020 2020 2069 6620 2766 7768 6d27 2069       if 'fwhm' i
-000087f0: 6e20 6665 6174 5f6c 6973 743a 0a20 2020  n feat_list:.   
-00008800: 2020 2020 2020 2020 2069 6d70 6f72 7420           import 
-00008810: 7363 6970 792e 7369 676e 616c 2061 7320  scipy.signal as 
-00008820: 7373 0a20 2020 2020 2020 2020 2020 206d  ss.            m
-00008830: 696e 5f70 6561 6b20 3d20 6e70 2e6d 696e  in_peak = np.min
-00008840: 2874 656d 706c 6174 6573 5b69 5d2c 2061  (templates[i], a
-00008850: 7869 733d 3129 0a20 2020 2020 2020 2020  xis=1).         
-00008860: 2020 2066 7768 6d5f 7265 6620 3d20 6e70     fwhm_ref = np
-00008870: 2e61 7272 6179 285b 7465 6d70 6c61 7465  .array([template
-00008880: 735b 692c 2065 2c20 305d 2066 6f72 2065  s[i, e, 0] for e
-00008890: 2069 6e20 7261 6e67 6528 7465 6d70 6c61   in range(templa
-000088a0: 7465 732e 7368 6170 655b 315d 295d 290a  tes.shape[1])]).
-000088b0: 2020 2020 2020 2020 2020 2020 6677 686d              fwhm
-000088c0: 5f56 203d 2028 6677 686d 5f72 6566 202b  _V = (fwhm_ref +
-000088d0: 206d 696e 5f70 6561 6b29 202f 2032 2e0a   min_peak) / 2..
-000088e0: 2020 2020 2020 2020 2020 2020 6964 5f74              id_t
-000088f0: 726f 7567 6820 3d20 5b6e 702e 7768 6572  rough = [np.wher
-00008900: 6528 7465 6d70 6c61 7465 735b 692c 2065  e(templates[i, e
-00008910: 5d20 3c20 6677 686d 5f56 5b65 5d29 5b30  ] < fwhm_V[e])[0
-00008920: 5d20 666f 7220 6520 696e 2072 616e 6765  ] for e in range
-00008930: 2874 656d 706c 6174 6573 2e73 6861 7065  (templates.shape
-00008940: 5b31 5d29 5d0a 0a20 2020 2020 2020 2020  [1])]..         
-00008950: 2020 2023 206e 6f20 6c69 6e65 6172 2069     # no linear i
-00008960: 6e74 6572 706f 6c61 7469 6f6e 0a20 2020  nterpolation.   
-00008970: 2020 2020 2020 2020 2066 6561 7475 7265           feature
-00008980: 735b 2766 7768 6d27 5d5b 692c 203a 5d20  s['fwhm'][i, :] 
-00008990: 3d20 5b28 6964 5f74 726f 7567 685b 655d  = [(id_trough[e]
-000089a0: 5b2d 315d 202d 2069 645f 7472 6f75 6768  [-1] - id_trough
-000089b0: 5b65 5d5b 305d 2920 2a20 6474 2069 6620  [e][0]) * dt if 
-000089c0: 6c65 6e28 6964 5f74 726f 7567 685b 655d  len(id_trough[e]
-000089d0: 2920 3e20 3120 5c0a 2020 2020 2020 2020  ) > 1 \.        
-000089e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000089f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008a00: 2020 656c 7365 2074 656d 706c 6174 6573    else templates
-00008a10: 2e73 6861 7065 5b32 5d20 2a20 6474 2066  .shape[2] * dt f
-00008a20: 6f72 2065 2069 6e20 7261 6e67 6528 7465  or e in range(te
-00008a30: 6d70 6c61 7465 732e 7368 6170 655b 315d  mplates.shape[1]
-00008a40: 295d 0a20 2020 2020 2020 2020 2020 2066  )].            f
-00008a50: 6561 7475 7265 735b 2766 7768 6d27 5d5b  eatures['fwhm'][
-00008a60: 692c 2074 6f6f 5f6c 6f77 5d20 3d20 7465  i, too_low] = te
-00008a70: 6d70 6c61 7465 732e 7368 6170 655b 325d  mplates.shape[2]
-00008a80: 202a 2064 7420 2023 2045 4150 5f74 696d   * dt  # EAP_tim
-00008a90: 6573 5b2d 315d 2d45 4150 5f74 696d 6573  es[-1]-EAP_times
-00008aa0: 5b30 5d0a 0a20 2020 2069 6620 2761 6d70  [0]..    if 'amp
-00008ab0: 2720 696e 2066 6561 745f 6c69 7374 3a0a  ' in feat_list:.
-00008ac0: 2020 2020 2020 2020 6665 6174 7572 6573          features
-00008ad0: 2e75 7064 6174 6528 7b27 616d 7027 3a20  .update({'amp': 
-00008ae0: 616d 7073 7d29 0a20 2020 2069 6620 276e  amps}).    if 'n
-00008af0: 6567 2720 696e 2066 6561 745f 6c69 7374  eg' in feat_list
-00008b00: 3a0a 2020 2020 2020 2020 6665 6174 7572  :.        featur
-00008b10: 6573 2e75 7064 6174 6528 7b27 6e65 6727  es.update({'neg'
-00008b20: 3a20 6e61 5f70 6561 6b7d 290a 2020 2020  : na_peak}).    
-00008b30: 6966 2027 706f 7327 2069 6e20 6665 6174  if 'pos' in feat
-00008b40: 5f6c 6973 743a 0a20 2020 2020 2020 2066  _list:.        f
-00008b50: 6561 7475 7265 732e 7570 6461 7465 287b  eatures.update({
-00008b60: 2770 6f73 273a 2072 6570 5f70 6561 6b7d  'pos': rep_peak}
-00008b70: 290a 0a20 2020 2072 6574 7572 6e20 6665  )..    return fe
-00008b80: 6174 7572 6573 0a0a 0a23 2323 2054 454d  atures...### TEM
-00008b90: 504c 4154 4553 204f 5045 5241 5449 4f4e  PLATES OPERATION
-00008ba0: 5320 2323 230a 6465 6620 6973 5f70 6f73  S ###.def is_pos
-00008bb0: 6974 696f 6e5f 7769 7468 696e 5f62 6f75  ition_within_bou
-00008bc0: 6e64 6172 6965 7328 706f 7369 7469 6f6e  ndaries(position
-00008bd0: 2c20 785f 6c69 6d2c 2079 5f6c 696d 2c20  , x_lim, y_lim, 
-00008be0: 7a5f 6c69 6d29 3a0a 2020 2020 2222 220a  z_lim):.    """.
-00008bf0: 2020 2020 4368 6563 6b20 6966 2070 6f73      Check if pos
-00008c00: 6974 696f 6e20 6973 2077 6974 6869 6e20  ition is within 
-00008c10: 6769 7665 6e20 626f 756e 6461 7269 6573  given boundaries
-00008c20: 2e0a 0a20 2020 2050 6172 616d 6574 6572  ...    Parameter
-00008c30: 730a 2020 2020 2d2d 2d2d 2d2d 2d2d 2d2d  s.    ----------
-00008c40: 0a20 2020 2070 6f73 6974 696f 6e20 3a20  .    position : 
-00008c50: 6e70 2e61 7272 6179 0a20 2020 2020 2020  np.array.       
-00008c60: 2033 4420 706f 7369 7469 6f6e 0a20 2020   3D position.   
-00008c70: 2078 5f6c 696d 203a 206c 6973 740a 2020   x_lim : list.  
-00008c80: 2020 2020 2020 426f 756e 6461 7269 6573        Boundaries
-00008c90: 2069 6e20 7820 6469 6d65 6e73 696f 6e20   in x dimension 
-00008ca0: 286c 6f77 2c20 6869 6768 290a 2020 2020  (low, high).    
-00008cb0: 795f 6c69 6d20 3a20 6c69 7374 0a20 2020  y_lim : list.   
-00008cc0: 2020 2020 2042 6f75 6e64 6172 6965 7320       Boundaries 
-00008cd0: 696e 2079 2064 696d 656e 7369 6f6e 2028  in y dimension (
-00008ce0: 6c6f 772c 2068 6967 6829 0a20 2020 207a  low, high).    z
-00008cf0: 5f6c 696d 203a 206c 6973 740a 2020 2020  _lim : list.    
-00008d00: 2020 2020 426f 756e 6461 7269 6573 2069      Boundaries i
-00008d10: 6e20 7a20 6469 6d65 6e73 696f 6e20 286c  n z dimension (l
-00008d20: 6f77 2c20 6869 6768 290a 0a20 2020 2052  ow, high)..    R
-00008d30: 6574 7572 6e73 0a20 2020 202d 2d2d 2d2d  eturns.    -----
-00008d40: 2d2d 0a20 2020 2076 616c 6964 5f70 6f73  --.    valid_pos
-00008d50: 6974 696f 6e20 3a20 626f 6f6c 0a20 2020  ition : bool.   
-00008d60: 2020 2020 2049 6620 5472 7565 2074 6865       If True the
-00008d70: 2070 6f73 6974 696f 6e20 6973 2077 6974   position is wit
-00008d80: 6869 6e20 626f 756e 6461 7269 6573 0a0a  hin boundaries..
-00008d90: 2020 2020 2222 220a 2020 2020 7661 6c69      """.    vali
-00008da0: 645f 706f 7369 7469 6f6e 203d 2054 7275  d_position = Tru
-00008db0: 650a 2020 2020 6966 2078 5f6c 696d 2069  e.    if x_lim i
-00008dc0: 7320 6e6f 7420 4e6f 6e65 3a0a 2020 2020  s not None:.    
-00008dd0: 2020 2020 6966 2070 6f73 6974 696f 6e5b      if position[
-00008de0: 305d 203c 2078 5f6c 696d 5b30 5d20 6f72  0] < x_lim[0] or
-00008df0: 2070 6f73 6974 696f 6e5b 305d 203e 2078   position[0] > x
-00008e00: 5f6c 696d 5b31 5d3a 0a20 2020 2020 2020  _lim[1]:.       
-00008e10: 2020 2020 2076 616c 6964 5f70 6f73 6974       valid_posit
-00008e20: 696f 6e20 3d20 4661 6c73 650a 2020 2020  ion = False.    
-00008e30: 6966 2079 5f6c 696d 2069 7320 6e6f 7420  if y_lim is not 
-00008e40: 4e6f 6e65 3a0a 2020 2020 2020 2020 6966  None:.        if
-00008e50: 2070 6f73 6974 696f 6e5b 315d 203c 2079   position[1] < y
-00008e60: 5f6c 696d 5b30 5d20 6f72 2070 6f73 6974  _lim[0] or posit
-00008e70: 696f 6e5b 315d 203e 2079 5f6c 696d 5b31  ion[1] > y_lim[1
-00008e80: 5d3a 0a20 2020 2020 2020 2020 2020 2076  ]:.            v
-00008e90: 616c 6964 5f70 6f73 6974 696f 6e20 3d20  alid_position = 
-00008ea0: 4661 6c73 650a 2020 2020 6966 207a 5f6c  False.    if z_l
-00008eb0: 696d 2069 7320 6e6f 7420 4e6f 6e65 3a0a  im is not None:.
-00008ec0: 2020 2020 2020 2020 6966 2070 6f73 6974          if posit
-00008ed0: 696f 6e5b 325d 203c 207a 5f6c 696d 5b30  ion[2] < z_lim[0
-00008ee0: 5d20 6f72 2070 6f73 6974 696f 6e5b 325d  ] or position[2]
-00008ef0: 203e 207a 5f6c 696d 5b31 5d3a 0a20 2020   > z_lim[1]:.   
-00008f00: 2020 2020 2020 2020 2076 616c 6964 5f70           valid_p
-00008f10: 6f73 6974 696f 6e20 3d20 4661 6c73 650a  osition = False.
-00008f20: 2020 2020 7265 7475 726e 2076 616c 6964      return valid
-00008f30: 5f70 6f73 6974 696f 6e0a 0a0a 6465 6620  _position...def 
-00008f40: 7365 6c65 6374 5f74 656d 706c 6174 6573  select_templates
-00008f50: 286c 6f63 2c20 7465 6d70 6c61 7465 732c  (loc, templates,
-00008f60: 2062 696e 5f63 6174 2c20 6e5f 6578 632c   bin_cat, n_exc,
-00008f70: 206e 5f69 6e68 2c20 6d69 6e5f 6469 7374   n_inh, min_dist
-00008f80: 3d32 352c 2078 5f6c 696d 3d4e 6f6e 652c  =25, x_lim=None,
-00008f90: 2079 5f6c 696d 3d4e 6f6e 652c 207a 5f6c   y_lim=None, z_l
-00008fa0: 696d 3d4e 6f6e 652c 0a20 2020 2020 2020  im=None,.       
-00008fb0: 2020 2020 2020 2020 2020 2020 2020 6d69                mi
-00008fc0: 6e5f 616d 703d 4e6f 6e65 2c20 6d61 785f  n_amp=None, max_
-00008fd0: 616d 703d 4e6f 6e65 2c20 6472 6966 7469  amp=None, drifti
-00008fe0: 6e67 3d46 616c 7365 2c20 6472 6966 745f  ng=False, drift_
-00008ff0: 6469 723d 4e6f 6e65 2c20 7072 6566 6572  dir=None, prefer
-00009000: 7265 645f 6469 723d 4e6f 6e65 2c20 616e  red_dir=None, an
-00009010: 676c 655f 746f 6c3d 3135 2c0a 2020 2020  gle_tol=15,.    
-00009020: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009030: 206e 5f6f 7665 726c 6170 5f70 6169 7273   n_overlap_pairs
-00009040: 3d4e 6f6e 652c 206f 7665 726c 6170 5f74  =None, overlap_t
-00009050: 6872 6573 686f 6c64 3d30 2e38 2c20 7665  hreshold=0.8, ve
-00009060: 7262 6f73 653d 4661 6c73 6529 3a0a 2020  rbose=False):.  
-00009070: 2020 2222 220a 2020 2020 5365 6c65 6374    """.    Select
-00009080: 2074 656d 706c 6174 6573 2067 6976 656e   templates given
-00009090: 2073 7065 6369 6669 6564 2072 756c 6573   specified rules
-000090a0: 2e0a 0a20 2020 2050 6172 616d 6574 6572  ...    Parameter
-000090b0: 730a 2020 2020 2d2d 2d2d 2d2d 2d2d 2d2d  s.    ----------
-000090c0: 0a20 2020 206c 6f63 203a 206e 702e 6172  .    loc : np.ar
-000090d0: 7261 790a 2020 2020 2020 2020 4172 7261  ray.        Arra
-000090e0: 7920 7769 7468 2033 4420 736f 6d61 206c  y with 3D soma l
-000090f0: 6f63 6174 696f 6e73 0a20 2020 2074 656d  ocations.    tem
-00009100: 706c 6174 6573 203a 206e 702e 6172 7261  plates : np.arra
-00009110: 790a 2020 2020 2020 2020 4172 7261 7920  y.        Array 
-00009120: 7769 7468 2065 6170 2074 656d 706c 6174  with eap templat
-00009130: 6573 2028 6e5f 6561 702c 206e 5f63 6861  es (n_eap, n_cha
-00009140: 6e6e 656c 732c 206e 5f73 616d 706c 6573  nnels, n_samples
-00009150: 290a 2020 2020 6269 6e5f 6361 7420 3a20  ).    bin_cat : 
-00009160: 6e70 2e61 7272 6179 0a20 2020 2020 2020  np.array.       
-00009170: 2041 7272 6179 2077 6974 6820 6269 6e61   Array with bina
-00009180: 7279 2063 6174 6567 6f72 7920 2845 2d49  ry category (E-I
-00009190: 290a 2020 2020 6e5f 6578 6320 3a20 696e  ).    n_exc : in
-000091a0: 740a 2020 2020 2020 2020 4e75 6d62 6572  t.        Number
-000091b0: 206f 6620 6578 6369 7461 746f 7279 2063   of excitatory c
-000091c0: 656c 6c73 2074 6f20 6265 2073 656c 6563  ells to be selec
-000091d0: 7465 640a 2020 2020 6e5f 696e 6820 3a20  ted.    n_inh : 
-000091e0: 696e 740a 2020 2020 2020 2020 4e75 6d62  int.        Numb
-000091f0: 6572 206f 6620 696e 6869 6269 746f 7279  er of inhibitory
-00009200: 2063 656c 6c73 2074 6f20 6265 2073 656c   cells to be sel
-00009210: 6563 7465 640a 2020 2020 6d69 6e5f 6469  ected.    min_di
-00009220: 7374 203a 2066 6c6f 6174 0a20 2020 2020  st : float.     
-00009230: 2020 204d 696e 696d 756d 2061 6c6c 6f77     Minimum allow
-00009240: 6564 2064 6973 7461 6e63 6520 6265 7477  ed distance betw
-00009250: 6565 6e20 736f 6d61 7461 2028 696e 2075  een somata (in u
-00009260: 6d29 0a20 2020 2078 5f6c 696d 203a 206c  m).    x_lim : l
-00009270: 6973 740a 2020 2020 2020 2020 426f 756e  ist.        Boun
-00009280: 6461 7269 6573 2069 6e20 7820 6469 6d65  daries in x dime
-00009290: 6e73 696f 6e20 286c 6f77 2c20 6869 6768  nsion (low, high
-000092a0: 290a 2020 2020 795f 6c69 6d20 3a20 6c69  ).    y_lim : li
-000092b0: 7374 0a20 2020 2020 2020 2042 6f75 6e64  st.        Bound
-000092c0: 6172 6965 7320 696e 2079 2064 696d 656e  aries in y dimen
-000092d0: 7369 6f6e 2028 6c6f 772c 2068 6967 6829  sion (low, high)
-000092e0: 0a20 2020 207a 5f6c 696d 203a 206c 6973  .    z_lim : lis
-000092f0: 740a 2020 2020 2020 2020 426f 756e 6461  t.        Bounda
-00009300: 7269 6573 2069 6e20 7a20 6469 6d65 6e73  ries in z dimens
-00009310: 696f 6e20 286c 6f77 2c20 6869 6768 290a  ion (low, high).
-00009320: 2020 2020 6d69 6e5f 616d 7020 3a20 666c      min_amp : fl
-00009330: 6f61 740a 2020 2020 2020 2020 4d69 6e69  oat.        Mini
-00009340: 6d75 6d20 616d 706c 6974 7564 6520 696e  mum amplitude in
-00009350: 2075 560a 2020 2020 6d61 785f 616d 7020   uV.    max_amp 
-00009360: 3a20 666c 6f61 740a 2020 2020 2020 2020  : float.        
-00009370: 4d61 7869 6d75 6d20 616d 706c 6974 7564  Maximum amplitud
-00009380: 6520 696e 2075 560a 2020 2020 6472 6966  e in uV.    drif
-00009390: 7469 6e67 203a 2062 6f6f 6c0a 2020 2020  ting : bool.    
-000093a0: 2020 2020 4966 2054 7275 6520 6472 6966      If True drif
-000093b0: 7469 6e67 2074 656d 706c 6174 6573 2061  ting templates a
-000093c0: 7265 2073 656c 6563 7465 640a 2020 2020  re selected.    
-000093d0: 6472 6966 745f 6469 7220 3a20 6e70 2e61  drift_dir : np.a
-000093e0: 7272 6179 0a20 2020 2020 2020 2033 4420  rray.        3D 
-000093f0: 6172 7261 7920 7769 7468 2064 7269 6674  array with drift
-00009400: 2064 6972 6563 7469 6f6e 2066 6f72 2065   direction for e
-00009410: 6163 6820 7465 6d70 6c61 7465 0a20 2020  ach template.   
-00009420: 2070 7265 6665 7272 6564 5f64 6972 203a   preferred_dir :
-00009430: 206e 702e 6172 7261 790a 2020 2020 2020   np.array.      
-00009440: 2020 3344 2061 7272 6179 2077 6974 6820    3D array with 
-00009450: 7072 6566 6572 7265 640a 2020 2020 616e  preferred.    an
-00009460: 676c 655f 746f 6c20 3a20 666c 6f61 740a  gle_tol : float.
-00009470: 2020 2020 2020 2020 546f 6c6c 6572 616e          Tolleran
-00009480: 6365 2069 6e20 6465 6772 6565 7320 666f  ce in degrees fo
-00009490: 7220 7365 6c65 6374 696e 6720 6669 6e61  r selecting fina
-000094a0: 6c20 6472 6966 7420 706f 7369 7469 6f6e  l drift position
-000094b0: 0a20 2020 206e 5f6f 7665 726c 6170 5f70  .    n_overlap_p
-000094c0: 6169 7273 3a20 696e 740a 2020 2020 2020  airs: int.      
-000094d0: 2020 4e75 6d62 6572 206f 6620 7370 6174    Number of spat
-000094e0: 6961 6c6c 7920 6f76 6572 6c61 7070 696e  ially overlappin
-000094f0: 6720 7465 6d70 6c61 7465 7320 746f 2073  g templates to s
-00009500: 656c 6563 740a 2020 2020 6f76 6572 6c61  elect.    overla
-00009510: 705f 7468 7265 7368 6f6c 643a 2066 6c6f  p_threshold: flo
-00009520: 6174 0a20 2020 2020 2020 2054 6872 6573  at.        Thres
-00009530: 686f 6c64 2066 6f72 2063 6f6e 7369 6465  hold for conside
-00009540: 7269 6e67 2073 7061 7469 616c 6c79 206f  ring spatially o
-00009550: 7665 726c 6170 7069 6e67 2070 6169 7273  verlapping pairs
-00009560: 2028 5b30 2d31 5d29 0a20 2020 2076 6572   ([0-1]).    ver
-00009570: 626f 7365 203a 2062 6f6f 6c0a 2020 2020  bose : bool.    
-00009580: 2020 2020 4966 2054 7275 6520 7468 6520      If True the 
-00009590: 6f75 7470 7574 2069 7320 7665 7262 6f73  output is verbos
-000095a0: 650a 0a20 2020 2052 6574 7572 6e73 0a20  e..    Returns. 
-000095b0: 2020 202d 2d2d 2d2d 2d2d 0a20 2020 2073     -------.    s
-000095c0: 656c 6563 7465 645f 6964 7873 203a 206e  elected_idxs : n
-000095d0: 702e 6172 7261 790a 2020 2020 2020 2020  p.array.        
-000095e0: 5365 6c65 6374 6564 2074 656d 706c 6174  Selected templat
-000095f0: 6520 696e 6465 7865 730a 2020 2020 7365  e indexes.    se
-00009600: 6c65 6374 6564 5f63 6174 203a 206c 6973  lected_cat : lis
-00009610: 740a 2020 2020 2020 2020 5365 6c65 6374  t.        Select
-00009620: 6564 2074 656d 706c 6174 6573 2062 696e  ed templates bin
-00009630: 6172 7920 7479 7065 0a0a 0a20 2020 2022  ary type...    "
-00009640: 2222 0a20 2020 2070 6f73 5f73 656c 203d  "".    pos_sel =
-00009650: 205b 5d0a 2020 2020 7365 6c65 6374 6564   [].    selected
-00009660: 5f69 6478 7320 3d20 5b5d 0a20 2020 2063  _idxs = [].    c
-00009670: 6174 6567 6f72 6965 7320 3d20 6e70 2e75  ategories = np.u
-00009680: 6e69 7175 6528 6269 6e5f 6361 7429 0a0a  nique(bin_cat)..
-00009690: 2020 2020 6966 2062 696e 5f63 6174 2069      if bin_cat i
-000096a0: 7320 6e6f 7420 4e6f 6e65 2061 6e64 2027  s not None and '
-000096b0: 4527 2069 6e20 6361 7465 676f 7269 6573  E' in categories
-000096c0: 2061 6e64 2027 4927 2069 6e20 6361 7465   and 'I' in cate
-000096d0: 676f 7269 6573 3a0a 2020 2020 2020 2020  gories:.        
-000096e0: 6966 2076 6572 626f 7365 3a0a 2020 2020  if verbose:.    
-000096f0: 2020 2020 2020 2020 7072 696e 7428 2753          print('S
-00009700: 656c 6563 7469 6e67 2045 7863 6974 6174  electing Excitat
-00009710: 6f72 7920 616e 6420 496e 6869 6269 746f  ory and Inhibito
-00009720: 7279 2063 656c 6c73 2729 0a20 2020 2020  ry cells').     
-00009730: 2020 2065 7863 696e 6820 3d20 5472 7565     excinh = True
-00009740: 0a20 2020 2020 2020 2073 656c 6563 7465  .        selecte
-00009750: 645f 6361 7420 3d20 5b5d 0a20 2020 2065  d_cat = [].    e
-00009760: 6c73 653a 0a20 2020 2020 2020 2069 6620  lse:.        if 
-00009770: 7665 7262 6f73 653a 0a20 2020 2020 2020  verbose:.       
-00009780: 2020 2020 2070 7269 6e74 2827 5365 6c65       print('Sele
-00009790: 6374 696e 6720 7261 6e64 6f6d 2074 656d  cting random tem
-000097a0: 706c 6174 6573 2028 6365 6c6c 2074 7970  plates (cell typ
-000097b0: 6573 206e 6f74 2073 7065 6369 6669 6564  es not specified
-000097c0: 2927 290a 2020 2020 2020 2020 6578 6369  )').        exci
-000097d0: 6e68 203d 2046 616c 7365 0a20 2020 2020  nh = False.     
-000097e0: 2020 2073 656c 6563 7465 645f 6361 7420     selected_cat 
-000097f0: 3d20 5b5d 0a0a 2020 2020 7065 726d 7574  = []..    permut
-00009800: 6564 5f69 6478 7320 3d20 6e70 2e72 616e  ed_idxs = np.ran
-00009810: 646f 6d2e 7065 726d 7574 6174 696f 6e28  dom.permutation(
-00009820: 6c65 6e28 6c6f 6329 290a 2020 2020 6966  len(loc)).    if
-00009830: 2062 696e 5f63 6174 2069 7320 6e6f 7420   bin_cat is not 
-00009840: 4e6f 6e65 3a0a 2020 2020 2020 2020 7065  None:.        pe
-00009850: 726d 7574 6564 5f62 696e 5f63 6174 7320  rmuted_bin_cats 
-00009860: 3d20 6269 6e5f 6361 745b 7065 726d 7574  = bin_cat[permut
-00009870: 6564 5f69 6478 735d 0a20 2020 2065 6c73  ed_idxs].    els
-00009880: 653a 0a20 2020 2020 2020 2070 6572 6d75  e:.        permu
-00009890: 7465 645f 6269 6e5f 6361 7473 203d 205b  ted_bin_cats = [
-000098a0: 2755 275d 202a 206c 656e 286c 6f63 290a  'U'] * len(loc).
-000098b0: 0a20 2020 2069 6620 7665 7262 6f73 653a  .    if verbose:
-000098c0: 0a20 2020 2020 2020 2070 7269 6e74 2827  .        print('
-000098d0: 4d69 6e20 6469 7374 3a20 272c 206d 696e  Min dist: ', min
-000098e0: 5f64 6973 742c 2027 4d69 6e20 616d 703a  _dist, 'Min amp:
-000098f0: 2027 2c20 6d69 6e5f 616d 7029 0a0a 2020   ', min_amp)..  
-00009900: 2020 6966 206d 696e 5f61 6d70 2069 7320    if min_amp is 
-00009910: 4e6f 6e65 3a0a 2020 2020 2020 2020 6d69  None:.        mi
-00009920: 6e5f 616d 7020 3d20 300a 0a20 2020 2069  n_amp = 0..    i
-00009930: 6620 6d61 785f 616d 7020 6973 204e 6f6e  f max_amp is Non
-00009940: 653a 0a20 2020 2020 2020 206d 6178 5f61  e:.        max_a
-00009950: 6d70 203d 206e 702e 696e 660a 0a20 2020  mp = np.inf..   
-00009960: 2069 6620 6472 6966 7469 6e67 3a0a 2020   if drifting:.  
-00009970: 2020 2020 2020 6966 2064 7269 6674 5f64        if drift_d
-00009980: 6972 2069 7320 4e6f 6e65 206f 7220 7072  ir is None or pr
-00009990: 6566 6572 7265 645f 6469 7220 6973 204e  eferred_dir is N
-000099a0: 6f6e 653a 0a20 2020 2020 2020 2020 2020  one:.           
-000099b0: 2072 6169 7365 2045 7863 6570 7469 6f6e   raise Exception
-000099c0: 2827 466f 7220 6472 6966 7420 7365 6c65  ('For drift sele
-000099d0: 6374 696f 6e20 7072 6f76 6964 6520 6472  ction provide dr
-000099e0: 6966 7469 6e67 2061 6e67 6c65 7320 616e  ifting angles an
-000099f0: 6420 7072 6566 6572 7265 6420 6472 6966  d preferred drif
-00009a00: 7420 6469 7265 6374 696f 6e27 290a 0a20  t direction').. 
-00009a10: 2020 206e 5f73 656c 203d 2030 0a20 2020     n_sel = 0.   
-00009a20: 206e 5f73 656c 5f65 7863 203d 2030 0a20   n_sel_exc = 0. 
-00009a30: 2020 206e 5f73 656c 5f69 6e68 203d 2030     n_sel_inh = 0
-00009a40: 0a20 2020 2069 7465 7220 3d20 300a 2020  .    iter = 0.  
-00009a50: 2020 6375 7272 656e 745f 6f76 6572 6c61    current_overla
-00009a60: 7070 696e 675f 7061 6972 7320 3d20 300a  pping_pairs = 0.
-00009a70: 0a20 2020 2066 6f72 2069 2c20 2869 645f  .    for i, (id_
-00009a80: 6365 6c6c 2c20 6263 6174 2920 696e 2065  cell, bcat) in e
-00009a90: 6e75 6d65 7261 7465 287a 6970 2870 6572  numerate(zip(per
-00009aa0: 6d75 7465 645f 6964 7873 2c20 7065 726d  muted_idxs, perm
-00009ab0: 7574 6564 5f62 696e 5f63 6174 7329 293a  uted_bin_cats)):
-00009ac0: 0a20 2020 2020 2020 2070 6c61 6365 6420  .        placed 
-00009ad0: 3d20 4661 6c73 650a 2020 2020 2020 2020  = False.        
-00009ae0: 6974 6572 202b 3d20 310a 2020 2020 2020  iter += 1.      
-00009af0: 2020 6966 206e 5f73 656c 203d 3d20 6e5f    if n_sel == n_
-00009b00: 6578 6320 2b20 6e5f 696e 683a 0a20 2020  exc + n_inh:.   
-00009b10: 2020 2020 2020 2020 2062 7265 616b 0a20           break. 
-00009b20: 2020 2020 2020 2069 6620 6578 6369 6e68         if excinh
-00009b30: 3a0a 2020 2020 2020 2020 2020 2020 6966  :.            if
-00009b40: 2062 6361 7420 3d3d 2027 4527 3a0a 2020   bcat == 'E':.  
-00009b50: 2020 2020 2020 2020 2020 2020 2020 6966                if
-00009b60: 206e 5f73 656c 5f65 7863 203c 206e 5f65   n_sel_exc < n_e
-00009b70: 7863 3a0a 2020 2020 2020 2020 2020 2020  xc:.            
-00009b80: 2020 2020 2020 2020 6469 7374 203d 206e          dist = n
-00009b90: 702e 6172 7261 7928 5b6e 702e 6c69 6e61  p.array([np.lina
-00009ba0: 6c67 2e6e 6f72 6d28 6c6f 635b 6964 5f63  lg.norm(loc[id_c
-00009bb0: 656c 6c5d 202d 2070 2920 666f 7220 7020  ell] - p) for p 
-00009bc0: 696e 2070 6f73 5f73 656c 5d29 0a20 2020  in pos_sel]).   
-00009bd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009be0: 2069 6620 6e70 2e61 6e79 2864 6973 7420   if np.any(dist 
-00009bf0: 3c20 6d69 6e5f 6469 7374 293a 0a20 2020  < min_dist):.   
+00003be0: 7265 635f 6469 6374 5b22 7465 6d70 6c61  rec_dict["templa
+00003bf0: 7465 5f6c 6f63 6174 696f 6e73 225d 203d  te_locations"] =
+00003c00: 2066 2e67 6574 2870 6174 6820 2b20 2274   f.get(path + "t
+00003c10: 656d 706c 6174 655f 6c6f 6361 7469 6f6e  emplate_location
+00003c20: 7322 290a 2020 2020 2020 2020 2020 2020  s").            
+00003c30: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+00003c40: 2020 2020 2020 7265 635f 6469 6374 5b22        rec_dict["
+00003c50: 7465 6d70 6c61 7465 5f6c 6f63 6174 696f  template_locatio
+00003c60: 6e73 225d 203d 206e 702e 6172 7261 7928  ns"] = np.array(
+00003c70: 662e 6765 7428 7061 7468 202b 2022 7465  f.get(path + "te
+00003c80: 6d70 6c61 7465 5f6c 6f63 6174 696f 6e73  mplate_locations
+00003c90: 2229 290a 2020 2020 2020 2020 6966 2066  ")).        if f
+00003ca0: 2e67 6574 2870 6174 6820 2b20 2274 656d  .get(path + "tem
+00003cb0: 706c 6174 655f 726f 7461 7469 6f6e 7322  plate_rotations"
+00003cc0: 2920 6973 206e 6f74 204e 6f6e 653a 0a20  ) is not None:. 
+00003cd0: 2020 2020 2020 2020 2020 2069 6620 7265             if re
+00003ce0: 7475 726e 5f68 355f 6f62 6a65 6374 733a  turn_h5_objects:
+00003cf0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00003d00: 2072 6563 5f64 6963 745b 2274 656d 706c   rec_dict["templ
+00003d10: 6174 655f 726f 7461 7469 6f6e 7322 5d20  ate_rotations"] 
+00003d20: 3d20 662e 6765 7428 7061 7468 202b 2022  = f.get(path + "
+00003d30: 7465 6d70 6c61 7465 5f72 6f74 6174 696f  template_rotatio
+00003d40: 6e73 2229 0a20 2020 2020 2020 2020 2020  ns").           
+00003d50: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+00003d60: 2020 2020 2020 2072 6563 5f64 6963 745b         rec_dict[
+00003d70: 2274 656d 706c 6174 655f 726f 7461 7469  "template_rotati
+00003d80: 6f6e 7322 5d20 3d20 6e70 2e61 7272 6179  ons"] = np.array
+00003d90: 2866 2e67 6574 2870 6174 6820 2b20 2274  (f.get(path + "t
+00003da0: 656d 706c 6174 655f 726f 7461 7469 6f6e  emplate_rotation
+00003db0: 7322 2929 0a20 2020 2020 2020 2069 6620  s")).        if 
+00003dc0: 662e 6765 7428 7061 7468 202b 2022 7465  f.get(path + "te
+00003dd0: 6d70 6c61 7465 5f63 656c 6c74 7970 6573  mplate_celltypes
+00003de0: 2229 2069 7320 6e6f 7420 4e6f 6e65 3a0a  ") is not None:.
+00003df0: 2020 2020 2020 2020 2020 2020 6365 6c6c              cell
+00003e00: 7479 7065 7320 3d20 6e70 2e61 7272 6179  types = np.array
+00003e10: 2828 5b6e 2e64 6563 6f64 6528 2920 666f  (([n.decode() fo
+00003e20: 7220 6e20 696e 2066 2e67 6574 2870 6174  r n in f.get(pat
+00003e30: 6820 2b20 2274 656d 706c 6174 655f 6365  h + "template_ce
+00003e40: 6c6c 7479 7065 7322 295d 2929 0a20 2020  lltypes")])).   
+00003e50: 2020 2020 2020 2020 2072 6563 5f64 6963           rec_dic
+00003e60: 745b 2274 656d 706c 6174 655f 6365 6c6c  t["template_cell
+00003e70: 7479 7065 7322 5d20 3d20 6e70 2e61 7272  types"] = np.arr
+00003e80: 6179 2863 656c 6c74 7970 6573 290a 2020  ay(celltypes).  
+00003e90: 2020 6966 2066 2e67 6574 2870 6174 6820    if f.get(path 
+00003ea0: 2b20 2274 696d 6573 7461 6d70 7322 2920  + "timestamps") 
+00003eb0: 6973 206e 6f74 204e 6f6e 6520 616e 6420  is not None and 
+00003ec0: 2274 696d 6573 7461 6d70 7322 2069 6e20  "timestamps" in 
+00003ed0: 6c6f 6164 3a0a 2020 2020 2020 2020 6966  load:.        if
+00003ee0: 2072 6574 7572 6e5f 6835 5f6f 626a 6563   return_h5_objec
+00003ef0: 7473 3a0a 2020 2020 2020 2020 2020 2020  ts:.            
+00003f00: 7265 635f 6469 6374 5b22 7469 6d65 7374  rec_dict["timest
+00003f10: 616d 7073 225d 203d 2066 2e67 6574 2870  amps"] = f.get(p
+00003f20: 6174 6820 2b20 2274 696d 6573 7461 6d70  ath + "timestamp
+00003f30: 7322 290a 2020 2020 2020 2020 656c 7365  s").        else
+00003f40: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+00003f50: 635f 6469 6374 5b22 7469 6d65 7374 616d  c_dict["timestam
+00003f60: 7073 225d 203d 206e 702e 6172 7261 7928  ps"] = np.array(
+00003f70: 662e 6765 7428 7061 7468 202b 2022 7469  f.get(path + "ti
+00003f80: 6d65 7374 616d 7073 2229 2920 2a20 7071  mestamps")) * pq
+00003f90: 2e73 0a20 2020 2069 6620 662e 6765 7428  .s.    if f.get(
+00003fa0: 7061 7468 202b 2022 7465 6d70 6c61 7465  path + "template
+00003fb0: 5f69 6473 2229 2069 7320 6e6f 7420 4e6f  _ids") is not No
+00003fc0: 6e65 2061 6e64 2022 7465 6d70 6c61 7465  ne and "template
+00003fd0: 5f69 6473 2220 696e 206c 6f61 643a 0a20  _ids" in load:. 
+00003fe0: 2020 2020 2020 2072 6563 5f64 6963 745b         rec_dict[
+00003ff0: 2274 656d 706c 6174 655f 6964 7322 5d20  "template_ids"] 
+00004000: 3d20 662e 6765 7428 7061 7468 202b 2022  = f.get(path + "
+00004010: 7465 6d70 6c61 7465 5f69 6473 2229 0a20  template_ids"). 
+00004020: 2020 2069 6620 662e 6765 7428 7061 7468     if f.get(path
+00004030: 202b 2022 7370 696b 6574 7261 696e 7322   + "spiketrains"
+00004040: 2920 6973 206e 6f74 204e 6f6e 6520 616e  ) is not None an
+00004050: 6420 2273 7069 6b65 7472 6169 6e73 2220  d "spiketrains" 
+00004060: 696e 206c 6f61 643a 0a20 2020 2020 2020  in load:.       
+00004070: 2073 7069 6b65 7472 6169 6e73 203d 205b   spiketrains = [
+00004080: 5d0a 2020 2020 2020 2020 736f 7274 6564  ].        sorted
+00004090: 5f75 6e69 7473 203d 2073 6f72 7465 6428  _units = sorted(
+000040a0: 5b69 6e74 2875 2920 666f 7220 7520 696e  [int(u) for u in
+000040b0: 2066 2e67 6574 2870 6174 6820 2b20 2273   f.get(path + "s
+000040c0: 7069 6b65 7472 6169 6e73 2f22 295d 290a  piketrains/")]).
+000040d0: 2020 2020 2020 2020 666f 7220 756e 6974          for unit
+000040e0: 2069 6e20 736f 7274 6564 5f75 6e69 7473   in sorted_units
+000040f0: 3a0a 2020 2020 2020 2020 2020 2020 756e  :.            un
+00004100: 6974 203d 2073 7472 2875 6e69 7429 0a20  it = str(unit). 
+00004110: 2020 2020 2020 2020 2020 2074 696d 6573             times
+00004120: 203d 206e 702e 6172 7261 7928 662e 6765   = np.array(f.ge
+00004130: 7428 7061 7468 202b 2022 7370 696b 6574  t(path + "spiket
+00004140: 7261 696e 732f 2220 2b20 756e 6974 202b  rains/" + unit +
+00004150: 2022 2f74 696d 6573 2229 290a 2020 2020   "/times")).    
+00004160: 2020 2020 2020 2020 745f 7374 6f70 203d          t_stop =
+00004170: 206e 702e 6172 7261 7928 662e 6765 7428   np.array(f.get(
+00004180: 7061 7468 202b 2022 7370 696b 6574 7261  path + "spiketra
+00004190: 696e 732f 2220 2b20 756e 6974 202b 2022  ins/" + unit + "
+000041a0: 2f74 5f73 746f 7022 2929 0a20 2020 2020  /t_stop")).     
+000041b0: 2020 2020 2020 2069 6620 662e 6765 7428         if f.get(
+000041c0: 7061 7468 202b 2022 7370 696b 6574 7261  path + "spiketra
+000041d0: 696e 732f 2220 2b20 756e 6974 202b 2022  ins/" + unit + "
+000041e0: 2f77 6176 6566 6f72 6d73 2229 2069 7320  /waveforms") is 
+000041f0: 6e6f 7420 4e6f 6e65 2061 6e64 206c 6f61  not None and loa
+00004200: 645f 7761 7665 666f 726d 733a 0a20 2020  d_waveforms:.   
+00004210: 2020 2020 2020 2020 2020 2020 2077 6176               wav
+00004220: 6566 6f72 6d73 203d 206e 702e 6172 7261  eforms = np.arra
+00004230: 7928 662e 6765 7428 7061 7468 202b 2022  y(f.get(path + "
+00004240: 7370 696b 6574 7261 696e 732f 2220 2b20  spiketrains/" + 
+00004250: 756e 6974 202b 2022 2f77 6176 6566 6f72  unit + "/wavefor
+00004260: 6d73 2229 290a 2020 2020 2020 2020 2020  ms")).          
+00004270: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+00004280: 2020 2020 2020 2020 7761 7665 666f 726d          waveform
+00004290: 7320 3d20 4e6f 6e65 0a20 2020 2020 2020  s = None.       
+000042a0: 2020 2020 2061 6e6e 6f74 6174 696f 6e73       annotations
+000042b0: 203d 206c 6f61 645f 6469 6374 5f66 726f   = load_dict_fro
+000042c0: 6d5f 6864 6635 2866 2c20 7061 7468 202b  m_hdf5(f, path +
+000042d0: 2022 7370 696b 6574 7261 696e 732f 2220   "spiketrains/" 
+000042e0: 2b20 756e 6974 202b 2022 2f61 6e6e 6f74  + unit + "/annot
+000042f0: 6174 696f 6e73 2f22 290a 2020 2020 2020  ations/").      
+00004300: 2020 2020 2020 7374 203d 206e 656f 2e63        st = neo.c
+00004310: 6f72 652e 5370 696b 6554 7261 696e 2874  ore.SpikeTrain(t
+00004320: 696d 6573 2c20 745f 7374 6f70 3d74 5f73  imes, t_stop=t_s
+00004330: 746f 702c 2077 6176 6566 6f72 6d73 3d77  top, waveforms=w
+00004340: 6176 6566 6f72 6d73 2c20 756e 6974 733d  aveforms, units=
+00004350: 7071 2e73 290a 2020 2020 2020 2020 2020  pq.s).          
+00004360: 2020 7374 2e61 6e6e 6f74 6174 696f 6e73    st.annotations
+00004370: 203d 2061 6e6e 6f74 6174 696f 6e73 0a20   = annotations. 
+00004380: 2020 2020 2020 2020 2020 2073 7069 6b65             spike
+00004390: 7472 6169 6e73 2e61 7070 656e 6428 7374  trains.append(st
+000043a0: 290a 2020 2020 2020 2020 7265 635f 6469  ).        rec_di
+000043b0: 6374 5b22 7370 696b 6574 7261 696e 7322  ct["spiketrains"
+000043c0: 5d20 3d20 7370 696b 6574 7261 696e 730a  ] = spiketrains.
+000043d0: 2020 2020 6966 2066 2e67 6574 2870 6174      if f.get(pat
+000043e0: 6820 2b20 2264 7269 6674 5f6c 6973 7422  h + "drift_list"
+000043f0: 2920 6973 206e 6f74 204e 6f6e 653a 0a20  ) is not None:. 
+00004400: 2020 2020 2020 2064 7269 6674 5f6c 6973         drift_lis
+00004410: 7420 3d20 5b5d 0a20 2020 2020 2020 2066  t = [].        f
+00004420: 6f72 2069 2069 6e20 662e 6765 7428 7061  or i in f.get(pa
+00004430: 7468 202b 2022 6472 6966 745f 6c69 7374  th + "drift_list
+00004440: 2229 2e6b 6579 7328 293a 0a20 2020 2020  ").keys():.     
+00004450: 2020 2020 2020 2064 7269 6674 5f64 6963         drift_dic
+00004460: 7420 3d20 6c6f 6164 5f64 6963 745f 6672  t = load_dict_fr
+00004470: 6f6d 5f68 6466 3528 662c 2070 6174 6820  om_hdf5(f, path 
+00004480: 2b20 2264 7269 6674 5f6c 6973 742f 2220  + "drift_list/" 
+00004490: 2b20 7374 7228 6929 202b 2022 2f22 290a  + str(i) + "/").
+000044a0: 2020 2020 2020 2020 2020 2020 6472 6966              drif
+000044b0: 745f 6c69 7374 2e61 7070 656e 6428 6472  t_list.append(dr
+000044c0: 6966 745f 6469 6374 290a 2020 2020 2020  ift_dict).      
+000044d0: 2020 7265 635f 6469 6374 5b22 6472 6966    rec_dict["drif
+000044e0: 745f 6c69 7374 225d 203d 2064 7269 6674  t_list"] = drift
+000044f0: 5f6c 6973 740a 2020 2020 656c 7365 3a0a  _list.    else:.
+00004500: 2020 2020 2020 2020 7265 635f 6469 6374          rec_dict
+00004510: 5b22 6472 6966 745f 6c69 7374 225d 203d  ["drift_list"] =
+00004520: 204e 6f6e 650a 0a20 2020 2072 6574 7572   None..    retur
+00004530: 6e20 7265 635f 6469 6374 2c20 696e 666f  n rec_dict, info
+00004540: 0a0a 0a64 6566 2073 6176 655f 7465 6d70  ...def save_temp
+00004550: 6c61 7465 5f67 656e 6572 6174 6f72 2874  late_generator(t
+00004560: 656d 7067 656e 2c20 6669 6c65 6e61 6d65  empgen, filename
+00004570: 3d4e 6f6e 652c 2076 6572 626f 7365 3d54  =None, verbose=T
+00004580: 7275 6529 3a0a 2020 2020 2222 220a 2020  rue):.    """.  
+00004590: 2020 5361 7665 2074 656d 706c 6174 6573    Save templates
+000045a0: 2074 6f20 6469 736b 2e0a 0a20 2020 2050   to disk...    P
+000045b0: 6172 616d 6574 6572 730a 2020 2020 2d2d  arameters.    --
+000045c0: 2d2d 2d2d 2d2d 2d2d 0a20 2020 2074 656d  --------.    tem
+000045d0: 7067 656e 203a 2054 656d 706c 6174 6547  pgen : TemplateG
+000045e0: 656e 6572 6174 6f72 0a20 2020 2020 2020  enerator.       
+000045f0: 2054 656d 706c 6174 6547 656e 6572 6174   TemplateGenerat
+00004600: 6f72 206f 626a 6563 7420 746f 2062 6520  or object to be 
+00004610: 7361 7665 640a 2020 2020 6669 6c65 6e61  saved.    filena
+00004620: 6d65 203a 2073 7472 0a20 2020 2020 2020  me : str.       
+00004630: 2050 6174 6820 746f 202e 6835 2066 696c   Path to .h5 fil
+00004640: 650a 2020 2020 7665 7262 6f73 6520 3a20  e.    verbose : 
+00004650: 626f 6f6c 0a20 2020 2020 2020 2049 6620  bool.        If 
+00004660: 5472 7565 206f 7574 7075 7420 6973 2076  True output is v
+00004670: 6572 626f 7365 0a20 2020 2022 2222 0a20  erbose.    """. 
+00004680: 2020 2066 696c 656e 616d 6520 3d20 5061     filename = Pa
+00004690: 7468 2866 696c 656e 616d 6529 0a20 2020  th(filename).   
+000046a0: 2069 6620 6e6f 7420 6669 6c65 6e61 6d65   if not filename
+000046b0: 2e70 6172 656e 742e 6973 5f64 6972 2829  .parent.is_dir()
+000046c0: 3a0a 2020 2020 2020 2020 6f73 2e6d 616b  :.        os.mak
+000046d0: 6564 6972 7328 7374 7228 6669 6c65 6e61  edirs(str(filena
+000046e0: 6d65 2e70 6172 656e 7429 290a 2020 2020  me.parent)).    
+000046f0: 6173 7365 7274 2066 696c 656e 616d 652e  assert filename.
+00004700: 7375 6666 6978 2069 6e20 5b22 2e68 3522  suffix in [".h5"
+00004710: 2c20 222e 6864 6635 225d 2c20 2250 726f  , ".hdf5"], "Pro
+00004720: 7669 6465 2061 6e20 2e68 3520 6f72 202e  vide an .h5 or .
+00004730: 6864 6635 2066 696c 6520 6e61 6d65 220a  hdf5 file name".
+00004740: 2020 2020 7769 7468 2068 3570 792e 4669      with h5py.Fi
+00004750: 6c65 2866 696c 656e 616d 652c 2022 7722  le(filename, "w"
+00004760: 2920 6173 2066 3a0a 2020 2020 2020 2020  ) as f:.        
+00004770: 7361 7665 5f64 6963 745f 746f 5f68 6466  save_dict_to_hdf
+00004780: 3528 7465 6d70 6765 6e2e 696e 666f 2c20  5(tempgen.info, 
+00004790: 662c 2022 696e 666f 2f22 290a 2020 2020  f, "info/").    
+000047a0: 2020 2020 662e 6174 7472 735b 2264 6174      f.attrs["dat
+000047b0: 6522 5d20 3d20 6461 7465 7469 6d65 2e6e  e"] = datetime.n
+000047c0: 6f77 2829 2e73 7472 6674 696d 6528 2225  ow().strftime("%
+000047d0: 792d 256d 2d25 6420 2548 3a25 4d3a 2553  y-%m-%d %H:%M:%S
+000047e0: 2229 0a20 2020 2020 2020 2069 6620 6c65  ").        if le
+000047f0: 6e28 7465 6d70 6765 6e2e 6365 6c6c 7479  n(tempgen.cellty
+00004800: 7065 7329 203e 2030 3a0a 2020 2020 2020  pes) > 0:.      
+00004810: 2020 2020 2020 6365 6c6c 7479 7065 7320        celltypes 
+00004820: 3d20 5b73 7472 2878 292e 656e 636f 6465  = [str(x).encode
+00004830: 2822 7574 662d 3822 2920 666f 7220 7820  ("utf-8") for x 
+00004840: 696e 2074 656d 7067 656e 2e63 656c 6c74  in tempgen.cellt
+00004850: 7970 6573 5d0a 2020 2020 2020 2020 2020  ypes].          
+00004860: 2020 662e 6372 6561 7465 5f64 6174 6173    f.create_datas
+00004870: 6574 2822 6365 6c6c 7479 7065 7322 2c20  et("celltypes", 
+00004880: 6461 7461 3d63 656c 6c74 7970 6573 290a  data=celltypes).
+00004890: 2020 2020 2020 2020 6966 206c 656e 2874          if len(t
+000048a0: 656d 7067 656e 2e6c 6f63 6174 696f 6e73  empgen.locations
+000048b0: 2920 3e20 303a 0a20 2020 2020 2020 2020  ) > 0:.         
+000048c0: 2020 2066 2e63 7265 6174 655f 6461 7461     f.create_data
+000048d0: 7365 7428 226c 6f63 6174 696f 6e73 222c  set("locations",
+000048e0: 2064 6174 613d 7465 6d70 6765 6e2e 6c6f   data=tempgen.lo
+000048f0: 6361 7469 6f6e 7329 0a20 2020 2020 2020  cations).       
+00004900: 2069 6620 6c65 6e28 7465 6d70 6765 6e2e   if len(tempgen.
+00004910: 726f 7461 7469 6f6e 7329 203e 2030 3a0a  rotations) > 0:.
+00004920: 2020 2020 2020 2020 2020 2020 662e 6372              f.cr
+00004930: 6561 7465 5f64 6174 6173 6574 2822 726f  eate_dataset("ro
+00004940: 7461 7469 6f6e 7322 2c20 6461 7461 3d74  tations", data=t
+00004950: 656d 7067 656e 2e72 6f74 6174 696f 6e73  empgen.rotations
+00004960: 290a 2020 2020 2020 2020 6966 206c 656e  ).        if len
+00004970: 2874 656d 7067 656e 2e74 656d 706c 6174  (tempgen.templat
+00004980: 6573 2920 3e20 303a 0a20 2020 2020 2020  es) > 0:.       
+00004990: 2020 2020 2066 2e63 7265 6174 655f 6461       f.create_da
+000049a0: 7461 7365 7428 2274 656d 706c 6174 6573  taset("templates
+000049b0: 222c 2064 6174 613d 7465 6d70 6765 6e2e  ", data=tempgen.
+000049c0: 7465 6d70 6c61 7465 7329 0a20 2020 2069  templates).    i
+000049d0: 6620 7665 7262 6f73 653a 0a20 2020 2020  f verbose:.     
+000049e0: 2020 2070 7269 6e74 2822 5c6e 5361 7665     print("\nSave
+000049f0: 6420 2074 656d 706c 6174 6573 2069 6e22  d  templates in"
+00004a00: 2c20 6669 6c65 6e61 6d65 2c20 225c 6e22  , filename, "\n"
+00004a10: 290a 0a0a 6465 6620 7361 7665 5f72 6563  )...def save_rec
+00004a20: 6f72 6469 6e67 5f67 656e 6572 6174 6f72  ording_generator
+00004a30: 2872 6563 6765 6e2c 2066 696c 656e 616d  (recgen, filenam
+00004a40: 653d 4e6f 6e65 2c20 7665 7262 6f73 653d  e=None, verbose=
+00004a50: 4661 6c73 6529 3a0a 2020 2020 2222 220a  False):.    """.
+00004a60: 2020 2020 5361 7665 2072 6563 6f72 6469      Save recordi
+00004a70: 6e67 7320 746f 2064 6973 6b2e 0a0a 2020  ngs to disk...  
+00004a80: 2020 5061 7261 6d65 7465 7273 0a20 2020    Parameters.   
+00004a90: 202d 2d2d 2d2d 2d2d 2d2d 2d0a 2020 2020   ----------.    
+00004aa0: 7265 6367 656e 203a 2052 6563 6f72 6469  recgen : Recordi
+00004ab0: 6e67 4765 6e65 7261 746f 720a 2020 2020  ngGenerator.    
+00004ac0: 2020 2020 5265 636f 7264 696e 6747 656e      RecordingGen
+00004ad0: 6572 6174 6f72 206f 626a 6563 7420 746f  erator object to
+00004ae0: 2062 6520 7361 7665 640a 2020 2020 6669   be saved.    fi
+00004af0: 6c65 6e61 6d65 203a 2073 7472 0a20 2020  lename : str.   
+00004b00: 2020 2020 2050 6174 6820 746f 202e 6835       Path to .h5
+00004b10: 2066 696c 650a 2020 2020 7665 7262 6f73   file.    verbos
+00004b20: 6520 3a20 626f 6f6c 0a20 2020 2020 2020  e : bool.       
+00004b30: 2049 6620 5472 7565 206f 7574 7075 7420   If True output 
+00004b40: 6973 2076 6572 626f 7365 0a20 2020 2022  is verbose.    "
+00004b50: 2222 0a20 2020 2066 696c 656e 616d 6520  "".    filename 
+00004b60: 3d20 5061 7468 2866 696c 656e 616d 6529  = Path(filename)
+00004b70: 0a20 2020 2069 6620 6e6f 7420 6669 6c65  .    if not file
+00004b80: 6e61 6d65 2e70 6172 656e 742e 6973 5f64  name.parent.is_d
+00004b90: 6972 2829 3a0a 2020 2020 2020 2020 6f73  ir():.        os
+00004ba0: 2e6d 616b 6564 6972 7328 7374 7228 6669  .makedirs(str(fi
+00004bb0: 6c65 6e61 6d65 2e70 6172 656e 7429 290a  lename.parent)).
+00004bc0: 2020 2020 6173 7365 7274 2066 696c 656e      assert filen
+00004bd0: 616d 652e 7375 6666 6978 2069 6e20 5b22  ame.suffix in ["
+00004be0: 2e68 3522 2c20 222e 6864 6635 225d 2c20  .h5", ".hdf5"], 
+00004bf0: 2250 726f 7669 6465 2061 6e20 2e68 3520  "Provide an .h5 
+00004c00: 6f72 202e 6864 6635 2066 696c 6520 6e61  or .hdf5 file na
+00004c10: 6d65 220a 2020 2020 7769 7468 2068 3570  me".    with h5p
+00004c20: 792e 4669 6c65 2866 696c 656e 616d 652c  y.File(filename,
+00004c30: 2022 7722 2920 6173 2066 3a0a 2020 2020   "w") as f:.    
+00004c40: 2020 2020 662e 6174 7472 735b 226d 6561      f.attrs["mea
+00004c50: 7265 635f 7665 7273 696f 6e22 5d20 3d20  rec_version"] = 
+00004c60: 6d65 6172 6563 5f76 6572 7369 6f6e 0a20  mearec_version. 
+00004c70: 2020 2020 2020 2066 2e61 7474 7273 5b22         f.attrs["
+00004c80: 6461 7465 225d 203d 2064 6174 6574 696d  date"] = datetim
+00004c90: 652e 6e6f 7728 292e 7374 7266 7469 6d65  e.now().strftime
+00004ca0: 2822 2579 2d25 6d2d 2564 2025 483a 254d  ("%y-%m-%d %H:%M
+00004cb0: 3a25 5322 290a 2020 2020 2020 2020 7361  :%S").        sa
+00004cc0: 7665 5f72 6563 6f72 6469 6e67 5f74 6f5f  ve_recording_to_
+00004cd0: 6669 6c65 2872 6563 6765 6e2c 2066 290a  file(recgen, f).
+00004ce0: 2020 2020 6966 2076 6572 626f 7365 3a0a      if verbose:.
+00004cf0: 2020 2020 2020 2020 7072 696e 7428 225c          print("\
+00004d00: 6e53 6176 6564 2072 6563 6f72 6469 6e67  nSaved recording
+00004d10: 7320 696e 222c 2066 696c 656e 616d 652c  s in", filename,
+00004d20: 2022 5c6e 2229 0a0a 0a64 6566 2073 6176   "\n")...def sav
+00004d30: 655f 7265 636f 7264 696e 675f 746f 5f66  e_recording_to_f
+00004d40: 696c 6528 7265 6367 656e 2c20 662c 2070  ile(recgen, f, p
+00004d50: 6174 683d 2222 293a 0a20 2020 2022 2222  ath=""):.    """
+00004d60: 0a20 2020 2053 6176 6520 7265 636f 7264  .    Save record
+00004d70: 696e 6773 2074 6f20 6669 6c65 2068 616e  ings to file han
+00004d80: 646c 6572 2e0a 0a20 2020 2050 6172 616d  dler...    Param
+00004d90: 6574 6572 730a 2020 2020 2d2d 2d2d 2d2d  eters.    ------
+00004da0: 2d2d 2d2d 0a20 2020 2072 6563 6765 6e20  ----.    recgen 
+00004db0: 3a20 5265 636f 7264 696e 6747 656e 6572  : RecordingGener
+00004dc0: 6174 6f72 0a20 2020 2020 2020 2052 6563  ator.        Rec
+00004dd0: 6f72 6469 6e67 4765 6e65 7261 746f 7220  ordingGenerator 
+00004de0: 6f62 6a65 6374 2074 6f20 6265 2073 6176  object to be sav
+00004df0: 6564 0a20 2020 2066 696c 656e 616d 6520  ed.    filename 
+00004e00: 3a20 5f69 6f2e 5465 7874 494f 5772 6170  : _io.TextIOWrap
+00004e10: 7065 720a 2020 2020 2020 2020 4669 6c65  per.        File
+00004e20: 2068 616e 646c 6572 0a20 2020 2022 2222   handler.    """
+00004e30: 0a20 2020 2073 6176 655f 6469 6374 5f74  .    save_dict_t
+00004e40: 6f5f 6864 6635 2872 6563 6765 6e2e 696e  o_hdf5(recgen.in
+00004e50: 666f 2c20 662c 2070 6174 6820 2b20 2269  fo, f, path + "i
+00004e60: 6e66 6f2f 2229 0a20 2020 2069 6620 6c65  nfo/").    if le
+00004e70: 6e28 7265 6367 656e 2e76 6f6c 7461 6765  n(recgen.voltage
+00004e80: 5f70 6561 6b73 2920 3e20 303a 0a20 2020  _peaks) > 0:.   
+00004e90: 2020 2020 2066 2e63 7265 6174 655f 6461       f.create_da
+00004ea0: 7461 7365 7428 7061 7468 202b 2022 766f  taset(path + "vo
+00004eb0: 6c74 6167 655f 7065 616b 7322 2c20 6461  ltage_peaks", da
+00004ec0: 7461 3d72 6563 6765 6e2e 766f 6c74 6167  ta=recgen.voltag
+00004ed0: 655f 7065 616b 7329 0a20 2020 2069 6620  e_peaks).    if 
+00004ee0: 6c65 6e28 7265 6367 656e 2e63 6861 6e6e  len(recgen.chann
+00004ef0: 656c 5f70 6f73 6974 696f 6e73 2920 3e20  el_positions) > 
+00004f00: 303a 0a20 2020 2020 2020 2066 2e63 7265  0:.        f.cre
+00004f10: 6174 655f 6461 7461 7365 7428 7061 7468  ate_dataset(path
+00004f20: 202b 2022 6368 616e 6e65 6c5f 706f 7369   + "channel_posi
+00004f30: 7469 6f6e 7322 2c20 6461 7461 3d72 6563  tions", data=rec
+00004f40: 6765 6e2e 6368 616e 6e65 6c5f 706f 7369  gen.channel_posi
+00004f50: 7469 6f6e 7329 0a20 2020 2069 6620 6c65  tions).    if le
+00004f60: 6e28 7265 6367 656e 2e72 6563 6f72 6469  n(recgen.recordi
+00004f70: 6e67 7329 203e 2030 3a0a 2020 2020 2020  ngs) > 0:.      
+00004f80: 2020 662e 6372 6561 7465 5f64 6174 6173    f.create_datas
+00004f90: 6574 2870 6174 6820 2b20 2272 6563 6f72  et(path + "recor
+00004fa0: 6469 6e67 7322 2c20 6461 7461 3d72 6563  dings", data=rec
+00004fb0: 6765 6e2e 7265 636f 7264 696e 6773 290a  gen.recordings).
+00004fc0: 2020 2020 2020 2020 6966 2072 6563 6765          if recge
+00004fd0: 6e2e 6761 696e 5f74 6f5f 7556 2069 7320  n.gain_to_uV is 
+00004fe0: 6e6f 7420 4e6f 6e65 3a0a 2020 2020 2020  not None:.      
+00004ff0: 2020 2020 2020 665b 2272 6563 6f72 6469        f["recordi
+00005000: 6e67 7322 5d2e 6174 7472 735b 2267 6169  ngs"].attrs["gai
+00005010: 6e5f 746f 5f75 5622 5d20 3d20 7265 6367  n_to_uV"] = recg
+00005020: 656e 2e67 6169 6e5f 746f 5f75 560a 2020  en.gain_to_uV.  
+00005030: 2020 6966 206c 656e 2872 6563 6765 6e2e    if len(recgen.
+00005040: 7370 696b 655f 7472 6163 6573 2920 3e20  spike_traces) > 
+00005050: 303a 0a20 2020 2020 2020 2066 2e63 7265  0:.        f.cre
+00005060: 6174 655f 6461 7461 7365 7428 7061 7468  ate_dataset(path
+00005070: 202b 2022 7370 696b 655f 7472 6163 6573   + "spike_traces
+00005080: 222c 2064 6174 613d 7265 6367 656e 2e73  ", data=recgen.s
+00005090: 7069 6b65 5f74 7261 6365 7329 0a20 2020  pike_traces).   
+000050a0: 2069 6620 6c65 6e28 7265 6367 656e 2e73   if len(recgen.s
+000050b0: 7069 6b65 7472 6169 6e73 2920 3e20 303a  piketrains) > 0:
+000050c0: 0a20 2020 2020 2020 2066 6f72 2069 6920  .        for ii 
+000050d0: 696e 2072 616e 6765 286c 656e 2872 6563  in range(len(rec
+000050e0: 6765 6e2e 7370 696b 6574 7261 696e 7329  gen.spiketrains)
+000050f0: 293a 0a20 2020 2020 2020 2020 2020 2073  ):.            s
+00005100: 7420 3d20 7265 6367 656e 2e73 7069 6b65  t = recgen.spike
+00005110: 7472 6169 6e73 5b69 695d 0a20 2020 2020  trains[ii].     
+00005120: 2020 2020 2020 2066 2e63 7265 6174 655f         f.create_
+00005130: 6461 7461 7365 7428 7061 7468 202b 2022  dataset(path + "
+00005140: 7370 696b 6574 7261 696e 732f 7b7d 2f74  spiketrains/{}/t
+00005150: 696d 6573 222e 666f 726d 6174 2869 6929  imes".format(ii)
+00005160: 2c20 6461 7461 3d73 742e 7469 6d65 732e  , data=st.times.
+00005170: 7265 7363 616c 6528 2273 2229 2e6d 6167  rescale("s").mag
+00005180: 6e69 7475 6465 290a 2020 2020 2020 2020  nitude).        
+00005190: 2020 2020 662e 6372 6561 7465 5f64 6174      f.create_dat
+000051a0: 6173 6574 2870 6174 6820 2b20 2273 7069  aset(path + "spi
+000051b0: 6b65 7472 6169 6e73 2f7b 7d2f 745f 7374  ketrains/{}/t_st
+000051c0: 6f70 222e 666f 726d 6174 2869 6929 2c20  op".format(ii), 
+000051d0: 6461 7461 3d73 742e 745f 7374 6f70 290a  data=st.t_stop).
+000051e0: 2020 2020 2020 2020 2020 2020 6966 2073              if s
+000051f0: 742e 7761 7665 666f 726d 7320 6973 206e  t.waveforms is n
+00005200: 6f74 204e 6f6e 653a 0a20 2020 2020 2020  ot None:.       
+00005210: 2020 2020 2020 2020 2066 2e63 7265 6174           f.creat
+00005220: 655f 6461 7461 7365 7428 7061 7468 202b  e_dataset(path +
+00005230: 2022 7370 696b 6574 7261 696e 732f 7b7d   "spiketrains/{}
+00005240: 2f77 6176 6566 6f72 6d73 222e 666f 726d  /waveforms".form
+00005250: 6174 2869 6929 2c20 6461 7461 3d73 742e  at(ii), data=st.
+00005260: 7761 7665 666f 726d 7329 0a20 2020 2020  waveforms).     
+00005270: 2020 2020 2020 2073 6176 655f 6469 6374         save_dict
+00005280: 5f74 6f5f 6864 6635 2873 742e 616e 6e6f  _to_hdf5(st.anno
+00005290: 7461 7469 6f6e 732c 2066 2c20 7061 7468  tations, f, path
+000052a0: 202b 2022 7370 696b 6574 7261 696e 732f   + "spiketrains/
+000052b0: 7b7d 2f61 6e6e 6f74 6174 696f 6e73 2f22  {}/annotations/"
+000052c0: 2e66 6f72 6d61 7428 6969 2929 0a20 2020  .format(ii)).   
+000052d0: 2069 6620 6c65 6e28 7265 6367 656e 2e74   if len(recgen.t
+000052e0: 656d 706c 6174 6573 2920 3e20 303a 0a20  emplates) > 0:. 
+000052f0: 2020 2020 2020 2066 2e63 7265 6174 655f         f.create_
+00005300: 6461 7461 7365 7428 7061 7468 202b 2022  dataset(path + "
+00005310: 7465 6d70 6c61 7465 7322 2c20 6461 7461  templates", data
+00005320: 3d72 6563 6765 6e2e 7465 6d70 6c61 7465  =recgen.template
+00005330: 7329 0a20 2020 2069 6620 6c65 6e28 7265  s).    if len(re
+00005340: 6367 656e 2e6f 7269 6769 6e61 6c5f 7465  cgen.original_te
+00005350: 6d70 6c61 7465 7329 203e 2030 3a0a 2020  mplates) > 0:.  
+00005360: 2020 2020 2020 662e 6372 6561 7465 5f64        f.create_d
+00005370: 6174 6173 6574 2870 6174 6820 2b20 226f  ataset(path + "o
+00005380: 7269 6769 6e61 6c5f 7465 6d70 6c61 7465  riginal_template
+00005390: 7322 2c20 6461 7461 3d72 6563 6765 6e2e  s", data=recgen.
+000053a0: 6f72 6967 696e 616c 5f74 656d 706c 6174  original_templat
+000053b0: 6573 290a 2020 2020 6966 206c 656e 2872  es).    if len(r
+000053c0: 6563 6765 6e2e 7465 6d70 6c61 7465 5f6c  ecgen.template_l
+000053d0: 6f63 6174 696f 6e73 2920 3e20 303a 0a20  ocations) > 0:. 
+000053e0: 2020 2020 2020 2066 2e63 7265 6174 655f         f.create_
+000053f0: 6461 7461 7365 7428 7061 7468 202b 2022  dataset(path + "
+00005400: 7465 6d70 6c61 7465 5f6c 6f63 6174 696f  template_locatio
+00005410: 6e73 222c 2064 6174 613d 7265 6367 656e  ns", data=recgen
+00005420: 2e74 656d 706c 6174 655f 6c6f 6361 7469  .template_locati
+00005430: 6f6e 7329 0a20 2020 2069 6620 6c65 6e28  ons).    if len(
+00005440: 7265 6367 656e 2e74 656d 706c 6174 655f  recgen.template_
+00005450: 726f 7461 7469 6f6e 7329 203e 2030 3a0a  rotations) > 0:.
+00005460: 2020 2020 2020 2020 662e 6372 6561 7465          f.create
+00005470: 5f64 6174 6173 6574 2870 6174 6820 2b20  _dataset(path + 
+00005480: 2274 656d 706c 6174 655f 726f 7461 7469  "template_rotati
+00005490: 6f6e 7322 2c20 6461 7461 3d72 6563 6765  ons", data=recge
+000054a0: 6e2e 7465 6d70 6c61 7465 5f72 6f74 6174  n.template_rotat
+000054b0: 696f 6e73 290a 2020 2020 6966 206c 656e  ions).    if len
+000054c0: 2872 6563 6765 6e2e 7465 6d70 6c61 7465  (recgen.template
+000054d0: 5f63 656c 6c74 7970 6573 2920 3e20 303a  _celltypes) > 0:
+000054e0: 0a20 2020 2020 2020 2063 656c 6c74 7970  .        celltyp
+000054f0: 6573 203d 205b 6e2e 656e 636f 6465 2822  es = [n.encode("
+00005500: 6173 6369 6922 2c20 2269 676e 6f72 6522  ascii", "ignore"
+00005510: 2920 666f 7220 6e20 696e 2072 6563 6765  ) for n in recge
+00005520: 6e2e 7465 6d70 6c61 7465 5f63 656c 6c74  n.template_cellt
+00005530: 7970 6573 5d0a 2020 2020 2020 2020 662e  ypes].        f.
+00005540: 6372 6561 7465 5f64 6174 6173 6574 2870  create_dataset(p
+00005550: 6174 6820 2b20 2274 656d 706c 6174 655f  ath + "template_
+00005560: 6365 6c6c 7479 7065 7322 2c20 6461 7461  celltypes", data
+00005570: 3d63 656c 6c74 7970 6573 290a 2020 2020  =celltypes).    
+00005580: 6966 206c 656e 2872 6563 6765 6e2e 7469  if len(recgen.ti
+00005590: 6d65 7374 616d 7073 2920 3e20 303a 0a20  mestamps) > 0:. 
+000055a0: 2020 2020 2020 2066 2e63 7265 6174 655f         f.create_
+000055b0: 6461 7461 7365 7428 7061 7468 202b 2022  dataset(path + "
+000055c0: 7469 6d65 7374 616d 7073 222c 2064 6174  timestamps", dat
+000055d0: 613d 7265 6367 656e 2e74 696d 6573 7461  a=recgen.timesta
+000055e0: 6d70 7329 0a20 2020 2069 6620 6861 7361  mps).    if hasa
+000055f0: 7474 7228 7265 6367 656e 2c20 2274 656d  ttr(recgen, "tem
+00005600: 706c 6174 655f 6964 7322 293a 0a20 2020  plate_ids"):.   
+00005610: 2020 2020 2069 6620 7265 6367 656e 2e74       if recgen.t
+00005620: 656d 706c 6174 655f 6964 7320 6973 206e  emplate_ids is n
+00005630: 6f74 204e 6f6e 653a 0a20 2020 2020 2020  ot None:.       
+00005640: 2020 2020 2066 2e63 7265 6174 655f 6461       f.create_da
+00005650: 7461 7365 7428 7061 7468 202b 2022 7465  taset(path + "te
+00005660: 6d70 6c61 7465 5f69 6473 222c 2064 6174  mplate_ids", dat
+00005670: 613d 7265 6367 656e 2e74 656d 706c 6174  a=recgen.templat
+00005680: 655f 6964 7329 0a20 2020 2069 6620 7265  e_ids).    if re
+00005690: 6367 656e 2e64 7269 6674 5f6c 6973 7420  cgen.drift_list 
+000056a0: 6973 206e 6f74 204e 6f6e 653a 0a20 2020  is not None:.   
+000056b0: 2020 2020 2066 6f72 2069 2c20 6472 6966       for i, drif
+000056c0: 745f 6469 6374 2069 6e20 656e 756d 6572  t_dict in enumer
+000056d0: 6174 6528 7265 6367 656e 2e64 7269 6674  ate(recgen.drift
+000056e0: 5f6c 6973 7429 3a0a 2020 2020 2020 2020  _list):.        
+000056f0: 2020 2020 7361 7665 5f64 6963 745f 746f      save_dict_to
+00005700: 5f68 6466 3528 6472 6966 745f 6469 6374  _hdf5(drift_dict
+00005710: 2c20 662c 2070 6174 6820 2b20 2264 7269  , f, path + "dri
+00005720: 6674 5f6c 6973 742f 2220 2b20 7374 7228  ft_list/" + str(
+00005730: 6929 202b 2022 2f22 290a 0a0a 6465 6620  i) + "/")...def 
+00005740: 7361 7665 5f64 6963 745f 746f 5f68 6466  save_dict_to_hdf
+00005750: 3528 6469 632c 2068 3566 696c 652c 2070  5(dic, h5file, p
+00005760: 6174 6829 3a0a 2020 2020 2222 220a 2020  ath):.    """.  
+00005770: 2020 5361 7665 2064 6963 7469 6f6e 6172    Save dictionar
+00005780: 7920 746f 2068 3520 6669 6c65 2e0a 0a20  y to h5 file... 
+00005790: 2020 2050 6172 616d 6574 6572 730a 2020     Parameters.  
+000057a0: 2020 2d2d 2d2d 2d2d 2d2d 2d2d 0a20 2020    ----------.   
+000057b0: 2064 6963 203a 2064 6963 740a 2020 2020   dic : dict.    
+000057c0: 2020 2020 4469 6374 696f 6e61 7279 2074      Dictionary t
+000057d0: 6f20 6265 2073 6176 6564 0a20 2020 2068  o be saved.    h
+000057e0: 3566 696c 6520 3a20 6669 6c65 0a20 2020  5file : file.   
+000057f0: 2020 2020 2048 6466 3520 6669 6c65 206f       Hdf5 file o
+00005800: 626a 6563 740a 2020 2020 7061 7468 203a  bject.    path :
+00005810: 2073 7472 0a20 2020 2020 2020 2050 6174   str.        Pat
+00005820: 6820 746f 2074 6865 2068 3520 6669 656c  h to the h5 fiel
+00005830: 640a 2020 2020 2222 220a 2020 2020 7265  d.    """.    re
+00005840: 6375 7273 6976 656c 795f 7361 7665 5f64  cursively_save_d
+00005850: 6963 745f 636f 6e74 656e 7473 5f74 6f5f  ict_contents_to_
+00005860: 6772 6f75 7028 6835 6669 6c65 2c20 7061  group(h5file, pa
+00005870: 7468 2c20 6469 6329 0a0a 0a64 6566 2072  th, dic)...def r
+00005880: 6563 7572 7369 7665 6c79 5f73 6176 655f  ecursively_save_
+00005890: 6469 6374 5f63 6f6e 7465 6e74 735f 746f  dict_contents_to
+000058a0: 5f67 726f 7570 2868 3566 696c 652c 2070  _group(h5file, p
+000058b0: 6174 682c 2064 6963 293a 0a20 2020 2022  ath, dic):.    "
+000058c0: 2222 0a20 2020 2053 6176 6520 6469 6374  "".    Save dict
+000058d0: 696f 6e61 7279 2072 6563 7572 7369 7665  ionary recursive
+000058e0: 6c79 2020 746f 2068 3520 6669 6c65 2028  ly  to h5 file (
+000058f0: 6865 6c70 6572 2066 756e 6374 696f 6e29  helper function)
+00005900: 2e0a 0a20 2020 2050 6172 616d 6574 6572  ...    Parameter
+00005910: 730a 2020 2020 2d2d 2d2d 2d2d 2d2d 2d2d  s.    ----------
+00005920: 0a20 2020 2064 6963 203a 2064 6963 740a  .    dic : dict.
+00005930: 2020 2020 2020 2020 4469 6374 696f 6e61          Dictiona
+00005940: 7279 2074 6f20 6265 2073 6176 6564 0a20  ry to be saved. 
+00005950: 2020 2068 3566 696c 6520 3a20 6669 6c65     h5file : file
+00005960: 0a20 2020 2020 2020 2048 6466 3520 6669  .        Hdf5 fi
+00005970: 6c65 206f 626a 6563 740a 2020 2020 7061  le object.    pa
+00005980: 7468 203a 2073 7472 0a20 2020 2020 2020  th : str.       
+00005990: 2050 6174 6820 746f 2074 6865 2068 3520   Path to the h5 
+000059a0: 6669 656c 640a 2020 2020 2222 220a 2020  field.    """.  
+000059b0: 2020 666f 7220 6b65 792c 2069 7465 6d20    for key, item 
+000059c0: 696e 2064 6963 2e69 7465 6d73 2829 3a0a  in dic.items():.
+000059d0: 2020 2020 2020 2020 6966 2069 7369 6e73          if isins
+000059e0: 7461 6e63 6528 6974 656d 2c20 2869 6e74  tance(item, (int
+000059f0: 2c20 666c 6f61 742c 206e 702e 696e 7465  , float, np.inte
+00005a00: 6765 722c 2073 7472 2c20 6279 7465 732c  ger, str, bytes,
+00005a10: 206e 702e 626f 6f6c 5f29 293a 0a20 2020   np.bool_)):.   
+00005a20: 2020 2020 2020 2020 2069 6620 6973 696e           if isin
+00005a30: 7374 616e 6365 2869 7465 6d2c 206e 702e  stance(item, np.
+00005a40: 7374 725f 293a 0a20 2020 2020 2020 2020  str_):.         
+00005a50: 2020 2020 2020 2069 7465 6d20 3d20 7374         item = st
+00005a60: 7228 6974 656d 290a 2020 2020 2020 2020  r(item).        
+00005a70: 2020 2020 6835 6669 6c65 5b70 6174 6820      h5file[path 
+00005a80: 2b20 6b65 795d 203d 2069 7465 6d0a 2020  + key] = item.  
+00005a90: 2020 2020 2020 656c 6966 2069 7369 6e73        elif isins
+00005aa0: 7461 6e63 6528 6974 656d 2c20 7071 2e51  tance(item, pq.Q
+00005ab0: 7561 6e74 6974 7929 3a0a 2020 2020 2020  uantity):.      
+00005ac0: 2020 2020 2020 6835 6669 6c65 5b70 6174        h5file[pat
+00005ad0: 6820 2b20 6b65 795d 203d 2066 6c6f 6174  h + key] = float
+00005ae0: 2869 7465 6d2e 6d61 676e 6974 7564 6529  (item.magnitude)
+00005af0: 0a20 2020 2020 2020 2065 6c69 6620 6973  .        elif is
+00005b00: 696e 7374 616e 6365 2869 7465 6d2c 2028  instance(item, (
+00005b10: 6c69 7374 2c20 6e70 2e6e 6461 7272 6179  list, np.ndarray
+00005b20: 2929 3a0a 2020 2020 2020 2020 2020 2020  )):.            
+00005b30: 6966 206c 656e 2869 7465 6d29 203e 2030  if len(item) > 0
+00005b40: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00005b50: 2020 6966 2069 7369 6e73 7461 6e63 6528    if isinstance(
+00005b60: 6974 656d 5b30 5d2c 2028 7374 722c 2062  item[0], (str, b
+00005b70: 7974 6573 2929 3a0a 2020 2020 2020 2020  ytes)):.        
+00005b80: 2020 2020 2020 2020 2020 2020 6974 656d              item
+00005b90: 203d 205b 6e2e 656e 636f 6465 2822 6173   = [n.encode("as
+00005ba0: 6369 6922 2c20 2269 676e 6f72 6522 2920  cii", "ignore") 
+00005bb0: 666f 7220 6e20 696e 2069 7465 6d5d 0a20  for n in item]. 
+00005bc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005bd0: 2020 2068 3566 696c 655b 7061 7468 202b     h5file[path +
+00005be0: 206b 6579 5d20 3d20 6e70 2e61 7272 6179   key] = np.array
+00005bf0: 2869 7465 6d29 0a20 2020 2020 2020 2020  (item).         
+00005c00: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+00005c10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005c20: 2068 3566 696c 655b 7061 7468 202b 206b   h5file[path + k
+00005c30: 6579 5d20 3d20 6e70 2e61 7272 6179 2869  ey] = np.array(i
+00005c40: 7465 6d29 0a20 2020 2020 2020 2020 2020  tem).           
+00005c50: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+00005c60: 2020 2020 2020 2069 7465 6d20 3d20 225b         item = "[
+00005c70: 5d22 0a20 2020 2020 2020 2020 2020 2020  ]".             
+00005c80: 2020 2068 3566 696c 655b 7061 7468 202b     h5file[path +
+00005c90: 206b 6579 5d20 3d20 6974 656d 0a20 2020   key] = item.   
+00005ca0: 2020 2020 2065 6c69 6620 6973 696e 7374       elif isinst
+00005cb0: 616e 6365 2869 7465 6d2c 2074 7570 6c65  ance(item, tuple
+00005cc0: 293a 0a20 2020 2020 2020 2020 2020 2068  ):.            h
+00005cd0: 3566 696c 655b 7061 7468 202b 206b 6579  5file[path + key
+00005ce0: 5d20 3d20 6e70 2e61 7272 6179 2869 7465  ] = np.array(ite
+00005cf0: 6d29 0a20 2020 2020 2020 2065 6c69 6620  m).        elif 
+00005d00: 6974 656d 2069 7320 4e6f 6e65 3a0a 2020  item is None:.  
+00005d10: 2020 2020 2020 2020 2020 6835 6669 6c65            h5file
+00005d20: 5b70 6174 6820 2b20 6b65 795d 203d 2022  [path + key] = "
+00005d30: 6e75 6c6c 220a 2020 2020 2020 2020 656c  null".        el
+00005d40: 6966 2069 7369 6e73 7461 6e63 6528 6974  if isinstance(it
+00005d50: 656d 2c20 6469 6374 293a 0a20 2020 2020  em, dict):.     
+00005d60: 2020 2020 2020 2072 6563 7572 7369 7665         recursive
+00005d70: 6c79 5f73 6176 655f 6469 6374 5f63 6f6e  ly_save_dict_con
+00005d80: 7465 6e74 735f 746f 5f67 726f 7570 2868  tents_to_group(h
+00005d90: 3566 696c 652c 2070 6174 6820 2b20 6b65  5file, path + ke
+00005da0: 7920 2b20 222f 222c 2069 7465 6d29 0a20  y + "/", item). 
+00005db0: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+00005dc0: 2020 2020 2020 2020 2070 7269 6e74 286b           print(k
+00005dd0: 6579 2c20 6974 656d 290a 2020 2020 2020  ey, item).      
+00005de0: 2020 2020 2020 7261 6973 6520 5661 6c75        raise Valu
+00005df0: 6545 7272 6f72 2822 4361 6e6e 6f74 2073  eError("Cannot s
+00005e00: 6176 6520 2573 2074 7970 6522 2025 2074  ave %s type" % t
+00005e10: 7970 6528 6974 656d 2929 0a0a 0a64 6566  ype(item))...def
+00005e20: 206c 6f61 645f 6469 6374 5f66 726f 6d5f   load_dict_from_
+00005e30: 6864 6635 2868 3566 696c 652c 2070 6174  hdf5(h5file, pat
+00005e40: 6829 3a0a 2020 2020 2222 220a 2020 2020  h):.    """.    
+00005e50: 4c6f 6164 2068 3520 6f62 6a65 6374 2061  Load h5 object a
+00005e60: 7320 6469 6374 2e0a 0a20 2020 2050 6172  s dict...    Par
+00005e70: 616d 6574 6572 730a 2020 2020 2d2d 2d2d  ameters.    ----
+00005e80: 2d2d 2d2d 2d2d 0a20 2020 2068 3566 696c  ------.    h5fil
+00005e90: 6520 3a66 696c 650a 2020 2020 2020 2020  e :file.        
+00005ea0: 4864 6635 2066 696c 6520 6f62 6a65 6374  Hdf5 file object
+00005eb0: 0a20 2020 2070 6174 6820 3a20 7374 720a  .    path : str.
+00005ec0: 2020 2020 2020 2020 5061 7468 2074 6f20          Path to 
+00005ed0: 7468 6520 6835 2066 6965 6c64 0a20 2020  the h5 field.   
+00005ee0: 2052 6574 7572 6e73 0a20 2020 202d 2d2d   Returns.    ---
+00005ef0: 2d2d 2d2d 0a20 2020 2064 6963 7469 6f6e  ----.    diction
+00005f00: 6172 7920 3a20 6469 6374 0a20 2020 2020  ary : dict.     
+00005f10: 2020 204c 6f61 6465 6420 6469 6374 696f     Loaded dictio
+00005f20: 6e61 7279 0a20 2020 2022 2222 0a20 2020  nary.    """.   
+00005f30: 2072 6574 7572 6e20 7265 6375 7273 6976   return recursiv
+00005f40: 656c 795f 6c6f 6164 5f64 6963 745f 636f  ely_load_dict_co
+00005f50: 6e74 656e 7473 5f66 726f 6d5f 6772 6f75  ntents_from_grou
+00005f60: 7028 6835 6669 6c65 2c20 7061 7468 290a  p(h5file, path).
+00005f70: 0a0a 6465 6620 7265 6375 7273 6976 656c  ..def recursivel
+00005f80: 795f 6c6f 6164 5f64 6963 745f 636f 6e74  y_load_dict_cont
+00005f90: 656e 7473 5f66 726f 6d5f 6772 6f75 7028  ents_from_group(
+00005fa0: 6835 6669 6c65 2c20 7061 7468 293a 0a20  h5file, path):. 
+00005fb0: 2020 2022 2222 0a20 2020 204c 6f61 6420     """.    Load 
+00005fc0: 6835 206f 626a 6563 7420 6173 2064 6963  h5 object as dic
+00005fd0: 7420 7265 6375 7273 6976 656c 7920 2868  t recursively (h
+00005fe0: 656c 7065 7220 6675 6e63 7469 6f6e 292e  elper function).
+00005ff0: 0a0a 2020 2020 5061 7261 6d65 7465 7273  ..    Parameters
+00006000: 0a20 2020 202d 2d2d 2d2d 2d2d 2d2d 2d0a  .    ----------.
+00006010: 2020 2020 6835 6669 6c65 203a 6669 6c65      h5file :file
+00006020: 0a20 2020 2020 2020 2048 6466 3520 6669  .        Hdf5 fi
+00006030: 6c65 206f 626a 6563 740a 2020 2020 7061  le object.    pa
+00006040: 7468 203a 2073 7472 0a20 2020 2020 2020  th : str.       
+00006050: 2050 6174 6820 746f 2074 6865 2068 3520   Path to the h5 
+00006060: 6669 656c 640a 2020 2020 5265 7475 726e  field.    Return
+00006070: 730a 2020 2020 2d2d 2d2d 2d2d 2d0a 2020  s.    -------.  
+00006080: 2020 6469 6374 696f 6e61 7279 203a 2064    dictionary : d
+00006090: 6963 740a 2020 2020 2020 2020 4c6f 6164  ict.        Load
+000060a0: 6564 2064 6963 7469 6f6e 6172 790a 2020  ed dictionary.  
+000060b0: 2020 2222 220a 2020 2020 616e 7320 3d20    """.    ans = 
+000060c0: 7b7d 0a20 2020 2066 6f72 206b 6579 2c20  {}.    for key, 
+000060d0: 6974 656d 2069 6e20 6835 6669 6c65 5b70  item in h5file[p
+000060e0: 6174 685d 2e69 7465 6d73 2829 3a0a 2020  ath].items():.  
+000060f0: 2020 2020 2020 6966 2069 7369 6e73 7461        if isinsta
+00006100: 6e63 6528 6974 656d 2c20 6835 7079 2e5f  nce(item, h5py._
+00006110: 686c 2e64 6174 6173 6574 2e44 6174 6173  hl.dataset.Datas
+00006120: 6574 293a 0a20 2020 2020 2020 2020 2020  et):.           
+00006130: 2023 2068 616e 646c 6520 6279 7465 7320   # handle bytes 
+00006140: 7374 7269 6e67 730a 2020 2020 2020 2020  strings.        
+00006150: 2020 2020 6966 2069 7369 6e73 7461 6e63      if isinstanc
+00006160: 6528 6974 656d 5b28 295d 2c20 6279 7465  e(item[()], byte
+00006170: 7329 3a0a 2020 2020 2020 2020 2020 2020  s):.            
+00006180: 2020 2020 616e 735b 6b65 795d 203d 2069      ans[key] = i
+00006190: 7465 6d5b 2829 5d2e 6465 636f 6465 2829  tem[()].decode()
+000061a0: 0a20 2020 2020 2020 2020 2020 2065 6c73  .            els
+000061b0: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+000061c0: 2020 2061 6e73 5b6b 6579 5d20 3d20 6974     ans[key] = it
+000061d0: 656d 5b28 295d 0a20 2020 2020 2020 2065  em[()].        e
+000061e0: 6c69 6620 6973 696e 7374 616e 6365 2869  lif isinstance(i
+000061f0: 7465 6d2c 2068 3570 792e 5f68 6c2e 6772  tem, h5py._hl.gr
+00006200: 6f75 702e 4772 6f75 7029 3a0a 2020 2020  oup.Group):.    
+00006210: 2020 2020 2020 2020 616e 735b 6b65 795d          ans[key]
+00006220: 203d 2072 6563 7572 7369 7665 6c79 5f6c   = recursively_l
+00006230: 6f61 645f 6469 6374 5f63 6f6e 7465 6e74  oad_dict_content
+00006240: 735f 6672 6f6d 5f67 726f 7570 2868 3566  s_from_group(h5f
+00006250: 696c 652c 2070 6174 6820 2b20 6b65 7920  ile, path + key 
+00006260: 2b20 222f 2229 0a20 2020 2072 6574 7572  + "/").    retur
+00006270: 6e20 636c 6561 6e5f 6469 6374 2861 6e73  n clean_dict(ans
+00006280: 290a 0a0a 6465 6620 636c 6561 6e5f 6469  )...def clean_di
+00006290: 6374 2864 293a 0a20 2020 2022 2222 0a20  ct(d):.    """. 
+000062a0: 2020 2043 6c65 616e 2064 6963 7469 6f6e     Clean diction
+000062b0: 6172 7920 6c6f 6164 6564 2066 726f 6d20  ary loaded from 
+000062c0: 6835 2066 696c 652e 0a0a 2020 2020 5061  h5 file...    Pa
+000062d0: 7261 6d65 7465 7273 0a20 2020 202d 2d2d  rameters.    ---
+000062e0: 2d2d 2d2d 2d2d 2d0a 2020 2020 6420 3a20  -------.    d : 
+000062f0: 6469 6374 0a20 2020 2020 2020 2044 6963  dict.        Dic
+00006300: 7469 6f6e 6172 7920 746f 2062 6520 636c  tionary to be cl
+00006310: 6561 6e65 642e 0a0a 2020 2020 5265 7475  eaned...    Retu
+00006320: 726e 730a 2020 2020 2d2d 2d2d 2d2d 2d0a  rns.    -------.
+00006330: 2020 2020 6420 3a20 6469 6374 0a20 2020      d : dict.   
+00006340: 2020 2020 2043 6c65 616e 6564 2064 6963       Cleaned dic
+00006350: 7469 6f6e 6172 790a 2020 2020 2222 220a  tionary.    """.
+00006360: 2020 2020 666f 7220 6b65 792c 2069 7465      for key, ite
+00006370: 6d20 696e 2064 2e69 7465 6d73 2829 3a0a  m in d.items():.
+00006380: 2020 2020 2020 2020 6966 2069 7369 6e73          if isins
+00006390: 7461 6e63 6528 6974 656d 2c20 6469 6374  tance(item, dict
+000063a0: 293a 0a20 2020 2020 2020 2020 2020 2063  ):.            c
+000063b0: 6c65 616e 5f64 6963 7428 6974 656d 290a  lean_dict(item).
+000063c0: 2020 2020 2020 2020 656c 6966 2069 7369          elif isi
+000063d0: 6e73 7461 6e63 6528 6974 656d 2c20 7374  nstance(item, st
+000063e0: 7229 3a0a 2020 2020 2020 2020 2020 2020  r):.            
+000063f0: 6966 2069 7465 6d20 3d3d 2022 6e75 6c6c  if item == "null
+00006400: 223a 0a20 2020 2020 2020 2020 2020 2020  ":.             
+00006410: 2020 2064 5b6b 6579 5d20 3d20 4e6f 6e65     d[key] = None
+00006420: 0a20 2020 2020 2020 2020 2020 2065 6c69  .            eli
+00006430: 6620 6974 656d 203d 3d20 225b 5d22 3a0a  f item == "[]":.
+00006440: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006450: 645b 6b65 795d 203d 206e 702e 6172 7261  d[key] = np.arra
+00006460: 7928 5b5d 290a 2020 2020 2020 2020 656c  y([]).        el
+00006470: 6966 2069 7369 6e73 7461 6e63 6528 6974  if isinstance(it
+00006480: 656d 2c20 6e70 2e6e 6461 7272 6179 293a  em, np.ndarray):
+00006490: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+000064a0: 6c65 6e28 6974 656d 2920 3e20 303a 0a20  len(item) > 0:. 
+000064b0: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+000064c0: 6620 6973 696e 7374 616e 6365 2869 7465  f isinstance(ite
+000064d0: 6d5b 305d 2c20 6e70 2e62 7974 6573 5f29  m[0], np.bytes_)
+000064e0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+000064f0: 2020 2020 2020 645b 6b65 795d 203d 206c        d[key] = l
+00006500: 6973 7428 5b6e 2e64 6563 6f64 6528 2920  ist([n.decode() 
+00006510: 666f 7220 6e20 696e 2069 7465 6d5d 290a  for n in item]).
+00006520: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006530: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+00006540: 2020 2020 2020 2020 2020 645b 6b65 795d            d[key]
+00006550: 203d 206c 6973 7428 6974 656d 290a 2020   = list(item).  
+00006560: 2020 7265 7475 726e 2064 0a0a 0a64 6566    return d...def
+00006570: 205f 636c 6561 6e5f 6e75 6d70 795f 7363   _clean_numpy_sc
+00006580: 616c 6172 2876 293a 0a20 2020 2069 6620  alar(v):.    if 
+00006590: 6973 696e 7374 616e 6365 2876 2c20 6e70  isinstance(v, np
+000065a0: 2e62 6f6f 6c5f 293a 0a20 2020 2020 2020  .bool_):.       
+000065b0: 2076 203d 2062 6f6f 6c28 7629 0a20 2020   v = bool(v).   
+000065c0: 2069 6620 6973 696e 7374 616e 6365 2876   if isinstance(v
+000065d0: 2c20 6e70 2e66 6c6f 6174 5f29 3a0a 2020  , np.float_):.  
+000065e0: 2020 2020 2020 7620 3d20 666c 6f61 7428        v = float(
+000065f0: 7629 0a20 2020 2069 6620 6973 696e 7374  v).    if isinst
+00006600: 616e 6365 2876 2c20 6e70 2e69 6e74 5f29  ance(v, np.int_)
+00006610: 3a0a 2020 2020 2020 2020 7620 3d20 696e  :.        v = in
+00006620: 7428 7629 0a20 2020 2072 6574 7572 6e20  t(v).    return 
+00006630: 760a 0a0a 6465 6620 636c 6561 6e5f 6469  v...def clean_di
+00006640: 6374 5f66 6f72 5f79 616d 6c28 6429 3a0a  ct_for_yaml(d):.
+00006650: 2020 2020 2222 220a 2020 2020 436c 6561      """.    Clea
+00006660: 6e20 6469 6374 696f 6e61 7279 2062 6566  n dictionary bef
+00006670: 6f72 6520 7361 7669 6e67 2074 6f20 7961  ore saving to ya
+00006680: 6d6c 0a0a 2020 2020 5061 7261 6d65 7465  ml..    Paramete
+00006690: 7273 0a20 2020 202d 2d2d 2d2d 2d2d 2d2d  rs.    ---------
+000066a0: 2d0a 2020 2020 6420 3a20 6469 6374 0a20  -.    d : dict. 
+000066b0: 2020 2020 2020 2044 6963 7469 6f6e 6172         Dictionar
+000066c0: 7920 746f 2062 6520 636c 6561 6e65 642e  y to be cleaned.
+000066d0: 0a0a 2020 2020 5265 7475 726e 730a 2020  ..    Returns.  
+000066e0: 2020 2d2d 2d2d 2d2d 2d0a 2020 2020 6420    -------.    d 
+000066f0: 3a20 6469 6374 0a20 2020 2020 2020 2043  : dict.        C
+00006700: 6c65 616e 6564 2064 6963 7469 6f6e 6172  leaned dictionar
+00006710: 790a 2020 2020 2222 220a 0a20 2020 2064  y.    """..    d
+00006720: 3220 3d20 642e 636f 7079 2829 0a20 2020  2 = d.copy().   
+00006730: 2066 6f72 206b 2c20 7620 696e 2064 322e   for k, v in d2.
+00006740: 6974 656d 7328 293a 0a20 2020 2020 2020  items():.       
+00006750: 2064 325b 6b5d 203d 205f 636c 6561 6e5f   d2[k] = _clean_
+00006760: 6e75 6d70 795f 7363 616c 6172 2876 290a  numpy_scalar(v).
+00006770: 2020 2020 2020 2020 6966 2069 7369 6e73          if isins
+00006780: 7461 6e63 6528 762c 206c 6973 7429 3a0a  tance(v, list):.
+00006790: 2020 2020 2020 2020 2020 2020 6432 5b6b              d2[k
+000067a0: 5d20 3d20 5b5f 636c 6561 6e5f 6e75 6d70  ] = [_clean_nump
+000067b0: 795f 7363 616c 6172 2865 2920 666f 7220  y_scalar(e) for 
+000067c0: 6520 696e 2076 5d0a 2020 2020 7265 7475  e in v].    retu
+000067d0: 726e 2064 320a 0a0a 6465 6620 636f 6e76  rn d2...def conv
+000067e0: 6572 745f 7265 636f 7264 696e 675f 746f  ert_recording_to
+000067f0: 5f6e 6577 5f76 6572 7369 6f6e 2866 696c  _new_version(fil
+00006800: 656e 616d 652c 206e 6577 5f66 696c 656e  ename, new_filen
+00006810: 616d 653d 4e6f 6e65 293a 0a20 2020 2022  ame=None):.    "
+00006820: 2222 0a20 2020 2043 6f6e 7665 7274 7320  "".    Converts 
+00006830: 4d45 4172 6563 2068 3520 6669 6c65 2066  MEArec h5 file f
+00006840: 726f 6d20 6120 7665 7273 696f 6e20 3c31  rom a version <1
+00006850: 2e35 2074 6f20 7468 6520 6e65 7720 666f  .5 to the new fo
+00006860: 726d 6174 203e 3d31 2e35 2e0a 0a20 2020  rmat >=1.5...   
+00006870: 2050 6172 616d 6574 6572 730a 2020 2020   Parameters.    
+00006880: 2d2d 2d2d 2d2d 2d2d 2d2d 0a20 2020 2066  ----------.    f
+00006890: 696c 656e 616d 653a 2073 7472 0a20 2020  ilename: str.   
+000068a0: 2020 2020 2050 6174 6820 746f 206f 7269       Path to ori
+000068b0: 6769 6e61 6c20 2e68 3520 6669 6c65 0a20  ginal .h5 file. 
+000068c0: 2020 206e 6577 5f66 696c 656e 616d 653a     new_filename:
+000068d0: 2073 7472 2028 6f70 7469 6f6e 616c 290a   str (optional).
+000068e0: 2020 2020 2020 2020 5061 7468 2074 6f20          Path to 
+000068f0: 6e65 7720 2e68 3520 6669 6c65 2e20 4966  new .h5 file. If
+00006900: 204e 6f6e 6520 2864 6566 6175 6c74 292c   None (default),
+00006910: 2074 6865 206f 7269 6769 6e61 6c20 6669   the original fi
+00006920: 6c65 2069 7320 6f76 6572 7772 6974 7465  le is overwritte
+00006930: 6e0a 0a20 2020 2022 2222 0a20 2020 2066  n..    """.    f
+00006940: 696c 656e 616d 6520 3d20 5061 7468 2866  ilename = Path(f
+00006950: 696c 656e 616d 6529 0a20 2020 2061 7373  ilename).    ass
+00006960: 6572 7420 6669 6c65 6e61 6d65 2e73 7566  ert filename.suf
+00006970: 6669 7820 696e 205b 222e 6835 222c 2022  fix in [".h5", "
+00006980: 2e68 6466 3522 5d2c 2022 5072 6f76 6964  .hdf5"], "Provid
+00006990: 6520 616e 202e 6835 206f 7220 2e68 6466  e an .h5 or .hdf
+000069a0: 3520 6669 6c65 206e 616d 6522 0a0a 2020  5 file name"..  
+000069b0: 2020 6966 206e 6577 5f66 696c 656e 616d    if new_filenam
+000069c0: 6520 6973 206e 6f74 204e 6f6e 653a 0a20  e is not None:. 
+000069d0: 2020 2020 2020 206e 6577 5f66 696c 656e         new_filen
+000069e0: 616d 6520 3d20 5061 7468 286e 6577 5f66  ame = Path(new_f
+000069f0: 696c 656e 616d 6529 0a20 2020 2020 2020  ilename).       
+00006a00: 2061 7373 6572 7420 6e65 775f 6669 6c65   assert new_file
+00006a10: 6e61 6d65 2e73 7566 6669 7820 696e 205b  name.suffix in [
+00006a20: 222e 6835 222c 2022 2e68 6466 3522 5d0a  ".h5", ".hdf5"].
+00006a30: 2020 2020 2020 2020 7368 7574 696c 2e63          shutil.c
+00006a40: 6f70 7928 6669 6c65 6e61 6d65 2c20 6e65  opy(filename, ne
+00006a50: 775f 6669 6c65 6e61 6d65 290a 0a20 2020  w_filename)..   
+00006a60: 2077 6974 6820 6835 7079 2e46 696c 6528   with h5py.File(
+00006a70: 6669 6c65 6e61 6d65 2c20 2272 2b22 2920  filename, "r+") 
+00006a80: 6173 2066 3a0a 2020 2020 2020 2020 6d65  as f:.        me
+00006a90: 6172 6563 5f76 6572 7369 6f6e 5f69 6e5f  arec_version_in_
+00006aa0: 6669 6c65 203d 2066 2e61 7474 7273 2e67  file = f.attrs.g
+00006ab0: 6574 2822 6d65 6172 6563 5f76 6572 7369  et("mearec_versi
+00006ac0: 6f6e 222c 2022 312e 342e 3022 290a 0a20  on", "1.4.0").. 
+00006ad0: 2020 2020 2020 2069 6620 7061 7273 6528         if parse(
+00006ae0: 6d65 6172 6563 5f76 6572 7369 6f6e 5f69  mearec_version_i
+00006af0: 6e5f 6669 6c65 2920 3e3d 2070 6172 7365  n_file) >= parse
+00006b00: 2822 312e 352e 3022 293a 0a20 2020 2020  ("1.5.0"):.     
+00006b10: 2020 2020 2020 2070 7269 6e74 2822 5468         print("Th
+00006b20: 6520 7072 6f76 6964 6564 206d 6561 7265  e provided meare
+00006b30: 6320 6669 6c65 2069 7320 616c 7265 6164  c file is alread
+00006b40: 7920 7570 2074 6f20 6461 7465 2229 0a20  y up to date"). 
+00006b50: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+00006b60: 2020 2020 2020 2020 2023 2076 6572 7369           # versi
+00006b70: 6f6e 2020 312e 342e 3020 616e 6420 6265  on  1.4.0 and be
+00006b80: 666f 7265 2069 7320 286e 5f63 6861 6e6e  fore is (n_chann
+00006b90: 656c 2c20 6e5f 7361 6d70 6c65 7329 2069  el, n_samples) i
+00006ba0: 6e73 6964 6520 7468 6520 6835 2066 696c  nside the h5 fil
+00006bb0: 650a 2020 2020 2020 2020 2020 2020 7072  e.            pr
+00006bc0: 696e 7428 2255 7064 6174 696e 6720 6669  int("Updating fi
+00006bd0: 6c65 2229 0a20 2020 2020 2020 2020 2020  le").           
+00006be0: 2072 6563 6f72 6469 6e67 7320 3d20 662e   recordings = f.
+00006bf0: 6765 7428 2272 6563 6f72 6469 6e67 7322  get("recordings"
+00006c00: 295b 3a5d 0a20 2020 2020 2020 2020 2020  )[:].           
+00006c10: 2073 7069 6b65 5f74 7261 6365 7320 3d20   spike_traces = 
+00006c20: 662e 6765 7428 2273 7069 6b65 5f74 7261  f.get("spike_tra
+00006c30: 6365 7322 295b 3a5d 0a0a 2020 2020 2020  ces")[:]..      
+00006c40: 2020 2020 2020 6966 206e 6577 5f66 696c        if new_fil
+00006c50: 656e 616d 6520 6973 206e 6f74 204e 6f6e  ename is not Non
+00006c60: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+00006c70: 2020 2077 6974 6820 6835 7079 2e46 696c     with h5py.Fil
+00006c80: 6528 6e65 775f 6669 6c65 6e61 6d65 2c20  e(new_filename, 
+00006c90: 2272 2b22 2920 6173 2066 6e65 773a 0a20  "r+") as fnew:. 
+00006ca0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006cb0: 2020 2064 656c 2066 6e65 775b 2272 6563     del fnew["rec
+00006cc0: 6f72 6469 6e67 7322 5d0a 2020 2020 2020  ordings"].      
+00006cd0: 2020 2020 2020 2020 2020 2020 2020 6465                de
+00006ce0: 6c20 666e 6577 5b22 7370 696b 655f 7472  l fnew["spike_tr
+00006cf0: 6163 6573 225d 0a20 2020 2020 2020 2020  aces"].         
+00006d00: 2020 2020 2020 2020 2020 2066 6e65 772e             fnew.
+00006d10: 6372 6561 7465 5f64 6174 6173 6574 2822  create_dataset("
+00006d20: 7265 636f 7264 696e 6773 222c 2064 6174  recordings", dat
+00006d30: 613d 7265 636f 7264 696e 6773 2e54 290a  a=recordings.T).
+00006d40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006d50: 2020 2020 666e 6577 2e63 7265 6174 655f      fnew.create_
+00006d60: 6461 7461 7365 7428 2273 7069 6b65 5f74  dataset("spike_t
+00006d70: 7261 6365 7322 2c20 6461 7461 3d73 7069  races", data=spi
+00006d80: 6b65 5f74 7261 6365 732e 5429 0a20 2020  ke_traces.T).   
+00006d90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006da0: 2066 6e65 772e 6174 7472 735b 226d 6561   fnew.attrs["mea
+00006db0: 7265 635f 7665 7273 696f 6e22 5d20 3d20  rec_version"] = 
+00006dc0: 6d65 6172 6563 5f76 6572 7369 6f6e 0a20  mearec_version. 
+00006dd0: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
+00006de0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00006df0: 2064 656c 2066 5b22 7265 636f 7264 696e   del f["recordin
+00006e00: 6773 225d 0a20 2020 2020 2020 2020 2020  gs"].           
+00006e10: 2020 2020 2064 656c 2066 5b22 7370 696b       del f["spik
+00006e20: 655f 7472 6163 6573 225d 0a20 2020 2020  e_traces"].     
+00006e30: 2020 2020 2020 2020 2020 2066 2e63 7265             f.cre
+00006e40: 6174 655f 6461 7461 7365 7428 2272 6563  ate_dataset("rec
+00006e50: 6f72 6469 6e67 7322 2c20 6461 7461 3d72  ordings", data=r
+00006e60: 6563 6f72 6469 6e67 732e 5429 0a20 2020  ecordings.T).   
+00006e70: 2020 2020 2020 2020 2020 2020 2066 2e63               f.c
+00006e80: 7265 6174 655f 6461 7461 7365 7428 2273  reate_dataset("s
+00006e90: 7069 6b65 5f74 7261 6365 7322 2c20 6461  pike_traces", da
+00006ea0: 7461 3d73 7069 6b65 5f74 7261 6365 732e  ta=spike_traces.
+00006eb0: 5429 0a20 2020 2020 2020 2020 2020 2020  T).             
+00006ec0: 2020 2066 2e61 7474 7273 5b22 6d65 6172     f.attrs["mear
+00006ed0: 6563 5f76 6572 7369 6f6e 225d 203d 206d  ec_version"] = m
+00006ee0: 6561 7265 635f 7665 7273 696f 6e0a 0a0a  earec_version...
+00006ef0: 2323 2320 5445 4d50 4c41 5445 5320 494e  ### TEMPLATES IN
+00006f00: 464f 2023 2323 0a64 6566 2067 6574 5f62  FO ###.def get_b
+00006f10: 696e 6172 795f 6361 7428 6365 6c6c 7479  inary_cat(cellty
+00006f20: 7065 732c 2065 7863 6974 2c20 696e 6869  pes, excit, inhi
+00006f30: 6229 3a0a 2020 2020 2222 220a 2020 2020  b):.    """.    
+00006f40: 5265 7475 726e 7320 6269 6e61 7279 2063  Returns binary c
+00006f50: 6174 6567 6f72 7920 6465 7065 6e64 696e  ategory dependin
+00006f60: 6720 6f6e 2063 656c 6c20 7479 7065 2e0a  g on cell type..
+00006f70: 0a20 2020 2050 6172 616d 6574 6572 730a  .    Parameters.
+00006f80: 2020 2020 2d2d 2d2d 2d2d 2d2d 2d2d 0a20      ----------. 
+00006f90: 2020 2063 656c 6c74 7970 6573 203a 206e     celltypes : n
+00006fa0: 702e 6172 7261 790a 2020 2020 2020 2020  p.array.        
+00006fb0: 5374 7269 6e67 2061 7272 6179 2077 6974  String array wit
+00006fc0: 6820 6365 6c6c 2074 7970 6573 0a20 2020  h cell types.   
+00006fd0: 2065 7863 6974 203a 206c 6973 740a 2020   excit : list.  
+00006fe0: 2020 2020 2020 4c69 7374 206f 6620 7375        List of su
+00006ff0: 6273 7472 696e 6773 2066 6f72 2065 7863  bstrings for exc
+00007000: 6974 6174 6f72 7920 6365 6c6c 2074 7970  itatory cell typ
+00007010: 6573 2028 652e 672e 205b 2750 4327 2c20  es (e.g. ['PC', 
+00007020: 2755 5450 4327 5d29 0a20 2020 2069 6e68  'UTPC']).    inh
+00007030: 6962 203a 206c 6973 740a 2020 2020 2020  ib : list.      
+00007040: 2020 4c69 7374 206f 6620 7375 6273 7472    List of substr
+00007050: 696e 6773 2066 6f72 2069 6e68 6962 6974  ings for inhibit
+00007060: 6f72 7920 6365 6c6c 7479 7065 7320 2865  ory celltypes (e
+00007070: 2e67 2e20 5b27 4250 272c 2027 4d43 275d  .g. ['BP', 'MC']
+00007080: 290a 0a20 2020 2052 6574 7572 6e73 0a20  )..    Returns. 
+00007090: 2020 202d 2d2d 2d2d 2d2d 0a20 2020 2062     -------.    b
+000070a0: 696e 6172 795f 6361 7420 3a20 6e70 2e61  inary_cat : np.a
+000070b0: 7272 6179 0a20 2020 2020 2020 2041 7272  rray.        Arr
+000070c0: 6179 2077 6974 6820 6269 6e61 7279 2063  ay with binary c
+000070d0: 656c 6c20 7479 7065 2028 452d 4929 0a0a  ell type (E-I)..
+000070e0: 2020 2020 2222 220a 2020 2020 6269 6e61      """.    bina
+000070f0: 7279 5f63 6174 203d 205b 5d0a 2020 2020  ry_cat = [].    
+00007100: 7361 6d70 6c65 5f74 7970 6520 3d20 6365  sample_type = ce
+00007110: 6c6c 7479 7065 735b 305d 0a20 2020 2023  lltypes[0].    #
+00007120: 2046 696e 6420 6966 2062 6270 206f 7220   Find if bbp or 
+00007130: 6375 7374 6f6d 206d 6f64 656c 730a 2020  custom models.  
+00007140: 2020 6966 2073 616d 706c 655f 7479 7065    if sample_type
+00007150: 2e73 7461 7274 7377 6974 6828 224c 2229  .startswith("L")
+00007160: 2061 6e64 206c 656e 2873 616d 706c 655f   and len(sample_
+00007170: 7479 7065 2e73 706c 6974 2822 5f22 2929  type.split("_"))
+00007180: 203d 3d20 343a 0a20 2020 2020 2020 206d   == 4:.        m
+00007190: 6f64 656c 7320 3d20 2262 6270 220a 2020  odels = "bbp".  
+000071a0: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+000071b0: 6d6f 6465 6c73 203d 2022 6375 7374 6f6d  models = "custom
+000071c0: 220a 2020 2020 666f 7220 692c 2063 6174  ".    for i, cat
+000071d0: 2069 6e20 656e 756d 6572 6174 6528 6365   in enumerate(ce
+000071e0: 6c6c 7479 7065 7329 3a0a 2020 2020 2020  lltypes):.      
+000071f0: 2020 6966 206d 6f64 656c 7320 3d3d 2022    if models == "
+00007200: 6262 7022 3a0a 2020 2020 2020 2020 2020  bbp":.          
+00007210: 2020 6365 6c6c 5f73 7472 203d 2073 7472    cell_str = str
+00007220: 2863 6174 292e 7370 6c69 7428 225f 2229  (cat).split("_")
+00007230: 5b31 5d0a 2020 2020 2020 2020 656c 7365  [1].        else
+00007240: 3a0a 2020 2020 2020 2020 2020 2020 6365  :.            ce
+00007250: 6c6c 5f73 7472 203d 2073 7472 2863 6174  ll_str = str(cat
+00007260: 290a 2020 2020 2020 2020 6966 206e 702e  ).        if np.
+00007270: 616e 7928 5b65 7820 696e 2063 656c 6c5f  any([ex in cell_
+00007280: 7374 7220 666f 7220 6578 2069 6e20 6578  str for ex in ex
+00007290: 6369 745d 293a 0a20 2020 2020 2020 2020  cit]):.         
+000072a0: 2020 2062 696e 6172 795f 6361 742e 6170     binary_cat.ap
+000072b0: 7065 6e64 2822 4522 290a 2020 2020 2020  pend("E").      
+000072c0: 2020 656c 6966 206e 702e 616e 7928 5b69    elif np.any([i
+000072d0: 6e68 2069 6e20 7374 7228 6361 7429 2066  nh in str(cat) f
+000072e0: 6f72 2069 6e68 2069 6e20 696e 6869 625d  or inh in inhib]
+000072f0: 293a 0a20 2020 2020 2020 2020 2020 2062  ):.            b
+00007300: 696e 6172 795f 6361 742e 6170 7065 6e64  inary_cat.append
+00007310: 2822 4922 290a 2020 2020 2020 2020 656c  ("I").        el
+00007320: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+00007330: 6269 6e61 7279 5f63 6174 2e61 7070 656e  binary_cat.appen
+00007340: 6428 2255 2229 0a20 2020 2072 6574 7572  d("U").    retur
+00007350: 6e20 6e70 2e61 7272 6179 2862 696e 6172  n np.array(binar
+00007360: 795f 6361 742c 2064 7479 7065 3d73 7472  y_cat, dtype=str
+00007370: 290a 0a0a 6465 6620 6765 745f 7465 6d70  )...def get_temp
+00007380: 6c61 7465 735f 6665 6174 7572 6573 2874  lates_features(t
+00007390: 656d 706c 6174 6573 2c20 6665 6174 5f6c  emplates, feat_l
+000073a0: 6973 742c 2064 743d 4e6f 6e65 2c20 7465  ist, dt=None, te
+000073b0: 6d70 6c61 7465 735f 7469 6d65 733d 4e6f  mplates_times=No
+000073c0: 6e65 2c20 7468 7265 7368 6f6c 645f 6465  ne, threshold_de
+000073d0: 7465 6374 3d30 293a 0a20 2020 2022 2222  tect=0):.    """
+000073e0: 0a20 2020 2043 6f6d 7075 7465 7320 7365  .    Computes se
+000073f0: 7665 7261 6c20 7465 6d70 6c61 7465 7320  veral templates 
+00007400: 6665 6174 7572 6573 2e0a 0a20 2020 2050  features...    P
+00007410: 6172 616d 6574 6572 730a 2020 2020 2d2d  arameters.    --
+00007420: 2d2d 2d2d 2d2d 2d2d 0a20 2020 2074 656d  --------.    tem
+00007430: 706c 6174 6573 203a 206e 702e 6172 7261  plates : np.arra
+00007440: 790a 2020 2020 2020 2020 4541 5020 7465  y.        EAP te
+00007450: 6d70 6c61 7465 730a 2020 2020 6665 6174  mplates.    feat
+00007460: 5f6c 6973 7420 3a20 6c69 7374 0a20 2020  _list : list.   
+00007470: 2020 2020 204c 6973 7420 6f66 2066 6561       List of fea
+00007480: 7475 7265 7320 746f 2062 6520 636f 6d70  tures to be comp
+00007490: 7574 6564 2028 616d 702c 2077 6964 7468  uted (amp, width
+000074a0: 2c20 6677 686d 2c20 7261 7469 6f2c 2073  , fwhm, ratio, s
+000074b0: 7065 6564 2c20 6e65 672c 2070 6f73 290a  peed, neg, pos).
+000074c0: 2020 2020 6474 203a 2066 6c6f 6174 0a20      dt : float. 
+000074d0: 2020 2020 2020 2053 616d 706c 696e 6720         Sampling 
+000074e0: 7065 7269 6f64 0a20 2020 2074 6872 6573  period.    thres
+000074f0: 686f 6c64 5f64 6574 6563 7420 3a20 666c  hold_detect : fl
+00007500: 6f61 740a 2020 2020 2020 2020 5468 7265  oat.        Thre
+00007510: 7368 6f6c 6420 746f 207a 6572 6f20 6f75  shold to zero ou
+00007520: 7420 6665 6174 7572 6573 0a0a 2020 2020  t features..    
+00007530: 5265 7475 726e 730a 2020 2020 2d2d 2d2d  Returns.    ----
+00007540: 2d2d 2d0a 2020 2020 6665 6174 7572 655f  ---.    feature_
+00007550: 6469 6374 203a 2064 6963 740a 2020 2020  dict : dict.    
+00007560: 2020 2020 4469 6374 696f 6e61 7279 2077      Dictionary w
+00007570: 6974 6820 6665 6174 7572 6573 2028 6b65  ith features (ke
+00007580: 7973 3a20 616d 702c 2077 6964 7468 2c20  ys: amp, width, 
+00007590: 6677 686d 2c20 7261 7469 6f2c 2073 7065  fwhm, ratio, spe
+000075a0: 6564 2c20 6e65 672c 2070 6f73 290a 0a20  ed, neg, pos).. 
+000075b0: 2020 2022 2222 0a20 2020 2069 6620 6474     """.    if dt
+000075c0: 2069 7320 6e6f 7420 4e6f 6e65 3a0a 2020   is not None:.  
+000075d0: 2020 2020 2020 7465 6d70 6c61 7465 735f        templates_
+000075e0: 7469 6d65 7320 3d20 6e70 2e61 7261 6e67  times = np.arang
+000075f0: 6528 7465 6d70 6c61 7465 732e 7368 6170  e(templates.shap
+00007600: 655b 2d31 5d29 202a 2064 740a 2020 2020  e[-1]) * dt.    
+00007610: 656c 7365 3a0a 2020 2020 2020 2020 6966  else:.        if
+00007620: 2022 7769 6474 6822 2069 6e20 6665 6174   "width" in feat
+00007630: 5f6c 6973 7420 6f72 2022 6677 686d 2220  _list or "fwhm" 
+00007640: 696e 2066 6561 745f 6c69 7374 206f 7220  in feat_list or 
+00007650: 2273 7065 6564 2220 696e 2066 6561 745f  "speed" in feat_
+00007660: 6c69 7374 3a0a 2020 2020 2020 2020 2020  list:.          
+00007670: 2020 7261 6973 6520 4e6f 7449 6d70 6c65    raise NotImple
+00007680: 6d65 6e74 6564 4572 726f 7228 2250 6c65  mentedError("Ple
+00007690: 6173 652c 2073 7065 6369 6679 2065 6974  ase, specify eit
+000076a0: 6865 7220 6474 206f 7220 7465 6d70 6c61  her dt or templa
+000076b0: 7465 735f 7469 6d65 732e 2229 0a0a 2020  tes_times.")..  
+000076c0: 2020 6966 206c 656e 2874 656d 706c 6174    if len(templat
+000076d0: 6573 2e73 6861 7065 2920 3d3d 2031 3a0a  es.shape) == 1:.
+000076e0: 2020 2020 2020 2020 7465 6d70 6c61 7465          template
+000076f0: 7320 3d20 6e70 2e72 6573 6861 7065 2874  s = np.reshape(t
+00007700: 656d 706c 6174 6573 2c20 5b31 2c20 312c  emplates, [1, 1,
+00007710: 202d 315d 290a 2020 2020 656c 6966 206c   -1]).    elif l
+00007720: 656e 2874 656d 706c 6174 6573 2e73 6861  en(templates.sha
+00007730: 7065 2920 3d3d 2032 3a0a 2020 2020 2020  pe) == 2:.      
+00007740: 2020 7465 6d70 6c61 7465 7320 3d20 6e70    templates = np
+00007750: 2e72 6573 6861 7065 2874 656d 706c 6174  .reshape(templat
+00007760: 6573 2c20 5b31 2c20 7465 6d70 6c61 7465  es, [1, template
+00007770: 732e 7368 6170 655b 305d 2c20 7465 6d70  s.shape[0], temp
+00007780: 6c61 7465 732e 7368 6170 655b 315d 5d29  lates.shape[1]])
+00007790: 0a20 2020 2069 6620 6c65 6e28 7465 6d70  .    if len(temp
+000077a0: 6c61 7465 732e 7368 6170 6529 2021 3d20  lates.shape) != 
+000077b0: 333a 0a20 2020 2020 2020 2072 6169 7365  3:.        raise
+000077c0: 2056 616c 7565 4572 726f 7228 2243 616e   ValueError("Can
+000077d0: 6e6f 7420 6861 6e64 6c65 2074 656d 706c  not handle templ
+000077e0: 6174 6573 7320 7769 7468 2073 6861 7065  atess with shape
+000077f0: 222c 2074 656d 706c 6174 6573 2e73 6861  ", templates.sha
+00007800: 7065 290a 0a20 2020 2066 6561 7475 7265  pe)..    feature
+00007810: 7320 3d20 7b7d 0a0a 2020 2020 616d 7073  s = {}..    amps
+00007820: 203d 206e 702e 7a65 726f 7328 2874 656d   = np.zeros((tem
+00007830: 706c 6174 6573 2e73 6861 7065 5b30 5d2c  plates.shape[0],
+00007840: 2074 656d 706c 6174 6573 2e73 6861 7065   templates.shape
+00007850: 5b31 5d29 290a 2020 2020 6e61 5f70 6561  [1])).    na_pea
+00007860: 6b20 3d20 6e70 2e7a 6572 6f73 2828 7465  k = np.zeros((te
+00007870: 6d70 6c61 7465 732e 7368 6170 655b 305d  mplates.shape[0]
+00007880: 2c20 7465 6d70 6c61 7465 732e 7368 6170  , templates.shap
+00007890: 655b 315d 2929 0a20 2020 2072 6570 5f70  e[1])).    rep_p
+000078a0: 6561 6b20 3d20 6e70 2e7a 6572 6f73 2828  eak = np.zeros((
+000078b0: 7465 6d70 6c61 7465 732e 7368 6170 655b  templates.shape[
+000078c0: 305d 2c20 7465 6d70 6c61 7465 732e 7368  0], templates.sh
+000078d0: 6170 655b 315d 2929 0a20 2020 2069 6620  ape[1])).    if 
+000078e0: 2277 6964 7468 2220 696e 2066 6561 745f  "width" in feat_
+000078f0: 6c69 7374 3a0a 2020 2020 2020 2020 6665  list:.        fe
+00007900: 6174 7572 6573 5b22 7769 6474 6822 5d20  atures["width"] 
+00007910: 3d20 6e70 2e7a 6572 6f73 2828 7465 6d70  = np.zeros((temp
+00007920: 6c61 7465 732e 7368 6170 655b 305d 2c20  lates.shape[0], 
+00007930: 7465 6d70 6c61 7465 732e 7368 6170 655b  templates.shape[
+00007940: 315d 2929 0a20 2020 2069 6620 2266 7768  1])).    if "fwh
+00007950: 6d22 2069 6e20 6665 6174 5f6c 6973 743a  m" in feat_list:
+00007960: 0a20 2020 2020 2020 2066 6561 7475 7265  .        feature
+00007970: 735b 2266 7768 6d22 5d20 3d20 6e70 2e7a  s["fwhm"] = np.z
+00007980: 6572 6f73 2828 7465 6d70 6c61 7465 732e  eros((templates.
+00007990: 7368 6170 655b 305d 2c20 7465 6d70 6c61  shape[0], templa
+000079a0: 7465 732e 7368 6170 655b 315d 2929 0a20  tes.shape[1])). 
+000079b0: 2020 2069 6620 2272 6174 696f 2220 696e     if "ratio" in
+000079c0: 2066 6561 745f 6c69 7374 3a0a 2020 2020   feat_list:.    
+000079d0: 2020 2020 6665 6174 7572 6573 5b22 7261      features["ra
+000079e0: 7469 6f22 5d20 3d20 6e70 2e7a 6572 6f73  tio"] = np.zeros
+000079f0: 2828 7465 6d70 6c61 7465 732e 7368 6170  ((templates.shap
+00007a00: 655b 305d 2c20 7465 6d70 6c61 7465 732e  e[0], templates.
+00007a10: 7368 6170 655b 315d 2929 0a20 2020 2069  shape[1])).    i
+00007a20: 6620 2273 7065 6564 2220 696e 2066 6561  f "speed" in fea
+00007a30: 745f 6c69 7374 3a0a 2020 2020 2020 2020  t_list:.        
+00007a40: 6665 6174 7572 6573 5b22 7370 6565 6422  features["speed"
+00007a50: 5d20 3d20 6e70 2e7a 6572 6f73 2828 7465  ] = np.zeros((te
+00007a60: 6d70 6c61 7465 732e 7368 6170 655b 305d  mplates.shape[0]
+00007a70: 2c20 7465 6d70 6c61 7465 732e 7368 6170  , templates.shap
+00007a80: 655b 315d 2929 0a20 2020 2069 6620 226e  e[1])).    if "n
+00007a90: 6567 2220 696e 2066 6561 745f 6c69 7374  eg" in feat_list
+00007aa0: 3a0a 2020 2020 2020 2020 6665 6174 7572  :.        featur
+00007ab0: 6573 5b22 6e65 6722 5d20 3d20 6e70 2e7a  es["neg"] = np.z
+00007ac0: 6572 6f73 2828 7465 6d70 6c61 7465 732e  eros((templates.
+00007ad0: 7368 6170 655b 305d 2c20 7465 6d70 6c61  shape[0], templa
+00007ae0: 7465 732e 7368 6170 655b 315d 2929 0a20  tes.shape[1])). 
+00007af0: 2020 2069 6620 2270 6f73 2220 696e 2066     if "pos" in f
+00007b00: 6561 745f 6c69 7374 3a0a 2020 2020 2020  eat_list:.      
+00007b10: 2020 6665 6174 7572 6573 5b22 706f 7322    features["pos"
+00007b20: 5d20 3d20 6e70 2e7a 6572 6f73 2828 7465  ] = np.zeros((te
+00007b30: 6d70 6c61 7465 732e 7368 6170 655b 305d  mplates.shape[0]
+00007b40: 2c20 7465 6d70 6c61 7465 732e 7368 6170  , templates.shap
+00007b50: 655b 315d 2929 0a0a 2020 2020 666f 7220  e[1]))..    for 
+00007b60: 6920 696e 2072 616e 6765 2874 656d 706c  i in range(templ
+00007b70: 6174 6573 2e73 6861 7065 5b30 5d29 3a0a  ates.shape[0]):.
+00007b80: 2020 2020 2020 2020 2320 466f 7220 414d          # For AM
+00007b90: 5020 6665 6174 7572 650a 2020 2020 2020  P feature.      
+00007ba0: 2020 6d69 6e5f 6964 7820 3d20 6e70 2e61    min_idx = np.a
+00007bb0: 7272 6179 280a 2020 2020 2020 2020 2020  rray(.          
+00007bc0: 2020 5b6e 702e 756e 7261 7665 6c5f 696e    [np.unravel_in
+00007bd0: 6465 7828 7465 6d70 6c61 7465 735b 692c  dex(templates[i,
+00007be0: 2065 5d2e 6172 676d 696e 2829 2c20 7465   e].argmin(), te
+00007bf0: 6d70 6c61 7465 735b 692c 2065 5d2e 7368  mplates[i, e].sh
+00007c00: 6170 6529 5b30 5d20 666f 7220 6520 696e  ape)[0] for e in
+00007c10: 2072 616e 6765 2874 656d 706c 6174 6573   range(templates
+00007c20: 2e73 6861 7065 5b31 5d29 5d0a 2020 2020  .shape[1])].    
+00007c30: 2020 2020 290a 2020 2020 2020 2020 6d61      ).        ma
+00007c40: 785f 6964 7820 3d20 6e70 2e61 7272 6179  x_idx = np.array
+00007c50: 280a 2020 2020 2020 2020 2020 2020 5b0a  (.            [.
+00007c60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007c70: 6e70 2e75 6e72 6176 656c 5f69 6e64 6578  np.unravel_index
+00007c80: 2874 656d 706c 6174 6573 5b69 2c20 652c  (templates[i, e,
+00007c90: 206d 696e 5f69 6478 5b65 5d20 3a5d 2e61   min_idx[e] :].a
+00007ca0: 7267 6d61 7828 292c 2074 656d 706c 6174  rgmax(), templat
+00007cb0: 6573 5b69 2c20 652c 206d 696e 5f69 6478  es[i, e, min_idx
+00007cc0: 5b65 5d20 3a5d 2e73 6861 7065 295b 305d  [e] :].shape)[0]
+00007cd0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00007ce0: 202b 206d 696e 5f69 6478 5b65 5d0a 2020   + min_idx[e].  
+00007cf0: 2020 2020 2020 2020 2020 2020 2020 666f                fo
+00007d00: 7220 6520 696e 2072 616e 6765 2874 656d  r e in range(tem
+00007d10: 706c 6174 6573 2e73 6861 7065 5b31 5d29  plates.shape[1])
+00007d20: 0a20 2020 2020 2020 2020 2020 205d 0a20  .            ]. 
+00007d30: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+00007d40: 2023 2066 6f72 206e 6120 616e 6420 7265   # for na and re
+00007d50: 700a 2020 2020 2020 2020 6d69 6e5f 656c  p.        min_el
+00007d60: 6964 2c20 6d69 6e5f 6964 785f 6e61 203d  id, min_idx_na =
+00007d70: 206e 702e 756e 7261 7665 6c5f 696e 6465   np.unravel_inde
+00007d80: 7828 7465 6d70 6c61 7465 735b 695d 2e61  x(templates[i].a
+00007d90: 7267 6d69 6e28 292c 2074 656d 706c 6174  rgmin(), templat
+00007da0: 6573 5b69 5d2e 7368 6170 6529 0a20 2020  es[i].shape).   
+00007db0: 2020 2020 206d 6178 5f69 6478 5f72 6570       max_idx_rep
+00007dc0: 203d 2074 656d 706c 6174 6573 5b69 2c20   = templates[i, 
+00007dd0: 6d69 6e5f 656c 6964 2c20 6d69 6e5f 6964  min_elid, min_id
+00007de0: 785f 6e61 3a5d 2e61 7267 6d61 7828 2920  x_na:].argmax() 
+00007df0: 2b20 6d69 6e5f 6964 785f 6e61 0a20 2020  + min_idx_na.   
+00007e00: 2020 2020 206e 615f 7065 616b 5b69 2c20       na_peak[i, 
+00007e10: 3a5d 203d 2074 656d 706c 6174 6573 5b69  :] = templates[i
+00007e20: 2c20 3a2c 206d 696e 5f69 6478 5f6e 615d  , :, min_idx_na]
+00007e30: 0a20 2020 2020 2020 2072 6570 5f70 6561  .        rep_pea
+00007e40: 6b5b 692c 203a 5d20 3d20 7465 6d70 6c61  k[i, :] = templa
+00007e50: 7465 735b 692c 203a 2c20 6d61 785f 6964  tes[i, :, max_id
+00007e60: 785f 7265 705d 0a0a 2020 2020 2020 2020  x_rep]..        
+00007e70: 616d 7073 5b69 2c20 3a5d 203d 206e 702e  amps[i, :] = np.
+00007e80: 6172 7261 7928 0a20 2020 2020 2020 2020  array(.         
+00007e90: 2020 205b 7465 6d70 6c61 7465 735b 692c     [templates[i,
+00007ea0: 2065 2c20 6d61 785f 6964 785b 655d 5d20   e, max_idx[e]] 
+00007eb0: 2d20 7465 6d70 6c61 7465 735b 692c 2065  - templates[i, e
+00007ec0: 2c20 6d69 6e5f 6964 785b 655d 5d20 666f  , min_idx[e]] fo
+00007ed0: 7220 6520 696e 2072 616e 6765 2874 656d  r e in range(tem
+00007ee0: 706c 6174 6573 2e73 6861 7065 5b31 5d29  plates.shape[1])
+00007ef0: 5d0a 2020 2020 2020 2020 290a 0a20 2020  ].        )..   
+00007f00: 2020 2020 2074 6f6f 5f6c 6f77 203d 206e       too_low = n
+00007f10: 702e 7768 6572 6528 616d 7073 5b69 2c20  p.where(amps[i, 
+00007f20: 3a5d 203c 2074 6872 6573 686f 6c64 5f64  :] < threshold_d
+00007f30: 6574 6563 7429 0a20 2020 2020 2020 2061  etect).        a
+00007f40: 6d70 735b 692c 2074 6f6f 5f6c 6f77 5d20  mps[i, too_low] 
+00007f50: 3d20 300a 0a20 2020 2020 2020 2069 6620  = 0..        if 
+00007f60: 2272 6174 696f 2220 696e 2066 6561 745f  "ratio" in feat_
+00007f70: 6c69 7374 3a0a 2020 2020 2020 2020 2020  list:.          
+00007f80: 2020 6d69 6e5f 6964 5f72 6174 696f 203d    min_id_ratio =
+00007f90: 206e 702e 6172 7261 7928 0a20 2020 2020   np.array(.     
+00007fa0: 2020 2020 2020 2020 2020 205b 0a20 2020             [.   
+00007fb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007fc0: 206e 702e 756e 7261 7665 6c5f 696e 6465   np.unravel_inde
+00007fd0: 7828 7465 6d70 6c61 7465 735b 692c 2065  x(templates[i, e
+00007fe0: 2c20 6d69 6e5f 6964 785f 6e61 3a5d 2e61  , min_idx_na:].a
+00007ff0: 7267 6d69 6e28 292c 2074 656d 706c 6174  rgmin(), templat
+00008000: 6573 5b69 2c20 652c 206d 696e 5f69 6478  es[i, e, min_idx
+00008010: 5f6e 613a 5d2e 7368 6170 6529 5b30 5d0a  _na:].shape)[0].
+00008020: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008030: 2020 2020 2b20 6d69 6e5f 6964 785f 6e61      + min_idx_na
+00008040: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00008050: 2020 2020 2066 6f72 2065 2069 6e20 7261       for e in ra
+00008060: 6e67 6528 7465 6d70 6c61 7465 732e 7368  nge(templates.sh
+00008070: 6170 655b 315d 290a 2020 2020 2020 2020  ape[1]).        
+00008080: 2020 2020 2020 2020 5d0a 2020 2020 2020          ].      
+00008090: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
+000080a0: 2020 2020 6d61 785f 6964 5f72 6174 696f      max_id_ratio
+000080b0: 203d 206e 702e 6172 7261 7928 0a20 2020   = np.array(.   
+000080c0: 2020 2020 2020 2020 2020 2020 205b 0a20               [. 
+000080d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000080e0: 2020 206e 702e 756e 7261 7665 6c5f 696e     np.unravel_in
+000080f0: 6465 7828 7465 6d70 6c61 7465 735b 692c  dex(templates[i,
+00008100: 2065 2c20 6d69 6e5f 6964 785f 6e61 3a5d   e, min_idx_na:]
+00008110: 2e61 7267 6d61 7828 292c 2074 656d 706c  .argmax(), templ
+00008120: 6174 6573 5b69 2c20 652c 206d 696e 5f69  ates[i, e, min_i
+00008130: 6478 5f6e 613a 5d2e 7368 6170 6529 5b30  dx_na:].shape)[0
+00008140: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
+00008150: 2020 2020 2020 2b20 6d69 6e5f 6964 785f        + min_idx_
+00008160: 6e61 0a20 2020 2020 2020 2020 2020 2020  na.             
+00008170: 2020 2020 2020 2066 6f72 2065 2069 6e20         for e in 
+00008180: 7261 6e67 6528 7465 6d70 6c61 7465 732e  range(templates.
+00008190: 7368 6170 655b 315d 290a 2020 2020 2020  shape[1]).      
+000081a0: 2020 2020 2020 2020 2020 5d0a 2020 2020            ].    
+000081b0: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
+000081c0: 2020 2020 2020 6665 6174 7572 6573 5b22        features["
+000081d0: 7261 7469 6f22 5d5b 692c 203a 5d20 3d20  ratio"][i, :] = 
+000081e0: 6e70 2e61 7272 6179 280a 2020 2020 2020  np.array(.      
+000081f0: 2020 2020 2020 2020 2020 5b0a 2020 2020            [.    
+00008200: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008210: 6e70 2e61 6273 2874 656d 706c 6174 6573  np.abs(templates
+00008220: 5b69 2c20 652c 206d 6178 5f69 645f 7261  [i, e, max_id_ra
+00008230: 7469 6f5b 655d 5d29 202f 206e 702e 6162  tio[e]]) / np.ab
+00008240: 7328 7465 6d70 6c61 7465 735b 692c 2065  s(templates[i, e
+00008250: 2c20 6d69 6e5f 6964 5f72 6174 696f 5b65  , min_id_ratio[e
+00008260: 5d5d 290a 2020 2020 2020 2020 2020 2020  ]]).            
+00008270: 2020 2020 2020 2020 666f 7220 6520 696e          for e in
+00008280: 2072 616e 6765 2874 656d 706c 6174 6573   range(templates
+00008290: 2e73 6861 7065 5b31 5d29 0a20 2020 2020  .shape[1]).     
+000082a0: 2020 2020 2020 2020 2020 205d 0a20 2020             ].   
+000082b0: 2020 2020 2020 2020 2029 0a20 2020 2020           ).     
+000082c0: 2020 2020 2020 2023 2049 6620 6265 6c6f         # If belo
+000082d0: 7720 2764 6574 6563 7461 626c 6520 7468  w 'detectable th
+000082e0: 7265 7368 6f6c 642c 2073 6574 2061 6d70  reshold, set amp
+000082f0: 2061 6e64 2077 6964 7468 2074 6f20 300a   and width to 0.
+00008300: 2020 2020 2020 2020 2020 2020 746f 6f5f              too_
+00008310: 6c6f 7720 3d20 6e70 2e77 6865 7265 2861  low = np.where(a
+00008320: 6d70 735b 692c 203a 5d20 3c20 7468 7265  mps[i, :] < thre
+00008330: 7368 6f6c 645f 6465 7465 6374 290a 2020  shold_detect).  
+00008340: 2020 2020 2020 2020 2020 6665 6174 7572            featur
+00008350: 6573 5b22 7261 7469 6f22 5d5b 692c 2074  es["ratio"][i, t
+00008360: 6f6f 5f6c 6f77 5d20 3d20 310a 2020 2020  oo_low] = 1.    
+00008370: 2020 2020 6966 2022 7370 6565 6422 2069      if "speed" i
+00008380: 6e20 6665 6174 5f6c 6973 743a 0a20 2020  n feat_list:.   
+00008390: 2020 2020 2020 2020 2066 6561 7475 7265           feature
+000083a0: 735b 2273 7065 6564 225d 5b69 2c20 3a5d  s["speed"][i, :]
+000083b0: 203d 206e 702e 6172 7261 7928 286d 696e   = np.array((min
+000083c0: 5f69 6478 202d 206d 696e 5f69 6478 5f6e  _idx - min_idx_n
+000083d0: 6129 202a 2064 7429 0a20 2020 2020 2020  a) * dt).       
+000083e0: 2020 2020 2066 6561 7475 7265 735b 2273       features["s
+000083f0: 7065 6564 225d 5b69 2c20 746f 6f5f 6c6f  peed"][i, too_lo
+00008400: 775d 203d 206d 696e 5f69 6478 5f6e 6120  w] = min_idx_na 
+00008410: 2a20 6474 0a0a 2020 2020 2020 2020 6966  * dt..        if
+00008420: 2022 7769 6474 6822 2069 6e20 6665 6174   "width" in feat
+00008430: 5f6c 6973 743a 0a20 2020 2020 2020 2020  _list:.         
+00008440: 2020 2066 6561 7475 7265 735b 2277 6964     features["wid
+00008450: 7468 225d 5b69 2c20 3a5d 203d 206e 702e  th"][i, :] = np.
+00008460: 6162 7328 7465 6d70 6c61 7465 735f 7469  abs(templates_ti
+00008470: 6d65 735b 6d61 785f 6964 785d 202d 2074  mes[max_idx] - t
+00008480: 656d 706c 6174 6573 5f74 696d 6573 5b6d  emplates_times[m
+00008490: 696e 5f69 6478 5d29 0a20 2020 2020 2020  in_idx]).       
+000084a0: 2020 2020 2066 6561 7475 7265 735b 2277       features["w
+000084b0: 6964 7468 225d 5b69 2c20 746f 6f5f 6c6f  idth"][i, too_lo
+000084c0: 775d 203d 2074 656d 706c 6174 6573 2e73  w] = templates.s
+000084d0: 6861 7065 5b32 5d20 2a20 6474 2020 2320  hape[2] * dt  # 
+000084e0: 7465 6d70 6c61 7465 735f 7469 6d65 735b  templates_times[
+000084f0: 2d31 5d2d 7465 6d70 6c61 7465 735f 7469  -1]-templates_ti
+00008500: 6d65 735b 305d 0a0a 2020 2020 2020 2020  mes[0]..        
+00008510: 6966 2022 6677 686d 2220 696e 2066 6561  if "fwhm" in fea
+00008520: 745f 6c69 7374 3a0a 2020 2020 2020 2020  t_list:.        
+00008530: 2020 2020 696d 706f 7274 2073 6369 7079      import scipy
+00008540: 2e73 6967 6e61 6c20 6173 2073 730a 0a20  .signal as ss.. 
+00008550: 2020 2020 2020 2020 2020 206d 696e 5f70             min_p
+00008560: 6561 6b20 3d20 6e70 2e6d 696e 2874 656d  eak = np.min(tem
+00008570: 706c 6174 6573 5b69 5d2c 2061 7869 733d  plates[i], axis=
+00008580: 3129 0a20 2020 2020 2020 2020 2020 2066  1).            f
+00008590: 7768 6d5f 7265 6620 3d20 6e70 2e61 7272  whm_ref = np.arr
+000085a0: 6179 285b 7465 6d70 6c61 7465 735b 692c  ay([templates[i,
+000085b0: 2065 2c20 305d 2066 6f72 2065 2069 6e20   e, 0] for e in 
+000085c0: 7261 6e67 6528 7465 6d70 6c61 7465 732e  range(templates.
+000085d0: 7368 6170 655b 315d 295d 290a 2020 2020  shape[1])]).    
+000085e0: 2020 2020 2020 2020 6677 686d 5f56 203d          fwhm_V =
+000085f0: 2028 6677 686d 5f72 6566 202b 206d 696e   (fwhm_ref + min
+00008600: 5f70 6561 6b29 202f 2032 2e30 0a20 2020  _peak) / 2.0.   
+00008610: 2020 2020 2020 2020 2069 645f 7472 6f75           id_trou
+00008620: 6768 203d 205b 6e70 2e77 6865 7265 2874  gh = [np.where(t
+00008630: 656d 706c 6174 6573 5b69 2c20 655d 203c  emplates[i, e] <
+00008640: 2066 7768 6d5f 565b 655d 295b 305d 2066   fwhm_V[e])[0] f
+00008650: 6f72 2065 2069 6e20 7261 6e67 6528 7465  or e in range(te
+00008660: 6d70 6c61 7465 732e 7368 6170 655b 315d  mplates.shape[1]
+00008670: 295d 0a0a 2020 2020 2020 2020 2020 2020  )]..            
+00008680: 2320 6e6f 206c 696e 6561 7220 696e 7465  # no linear inte
+00008690: 7270 6f6c 6174 696f 6e0a 2020 2020 2020  rpolation.      
+000086a0: 2020 2020 2020 6665 6174 7572 6573 5b22        features["
+000086b0: 6677 686d 225d 5b69 2c20 3a5d 203d 205b  fwhm"][i, :] = [
+000086c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000086d0: 2028 6964 5f74 726f 7567 685b 655d 5b2d   (id_trough[e][-
+000086e0: 315d 202d 2069 645f 7472 6f75 6768 5b65  1] - id_trough[e
+000086f0: 5d5b 305d 2920 2a20 6474 2069 6620 6c65  ][0]) * dt if le
+00008700: 6e28 6964 5f74 726f 7567 685b 655d 2920  n(id_trough[e]) 
+00008710: 3e20 3120 656c 7365 2074 656d 706c 6174  > 1 else templat
+00008720: 6573 2e73 6861 7065 5b32 5d20 2a20 6474  es.shape[2] * dt
+00008730: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00008740: 2066 6f72 2065 2069 6e20 7261 6e67 6528   for e in range(
+00008750: 7465 6d70 6c61 7465 732e 7368 6170 655b  templates.shape[
+00008760: 315d 290a 2020 2020 2020 2020 2020 2020  1]).            
+00008770: 5d0a 2020 2020 2020 2020 2020 2020 6665  ].            fe
+00008780: 6174 7572 6573 5b22 6677 686d 225d 5b69  atures["fwhm"][i
+00008790: 2c20 746f 6f5f 6c6f 775d 203d 2074 656d  , too_low] = tem
+000087a0: 706c 6174 6573 2e73 6861 7065 5b32 5d20  plates.shape[2] 
+000087b0: 2a20 6474 2020 2320 4541 505f 7469 6d65  * dt  # EAP_time
+000087c0: 735b 2d31 5d2d 4541 505f 7469 6d65 735b  s[-1]-EAP_times[
+000087d0: 305d 0a0a 2020 2020 6966 2022 616d 7022  0]..    if "amp"
+000087e0: 2069 6e20 6665 6174 5f6c 6973 743a 0a20   in feat_list:. 
+000087f0: 2020 2020 2020 2066 6561 7475 7265 732e         features.
+00008800: 7570 6461 7465 287b 2261 6d70 223a 2061  update({"amp": a
+00008810: 6d70 737d 290a 2020 2020 6966 2022 6e65  mps}).    if "ne
+00008820: 6722 2069 6e20 6665 6174 5f6c 6973 743a  g" in feat_list:
+00008830: 0a20 2020 2020 2020 2066 6561 7475 7265  .        feature
+00008840: 732e 7570 6461 7465 287b 226e 6567 223a  s.update({"neg":
+00008850: 206e 615f 7065 616b 7d29 0a20 2020 2069   na_peak}).    i
+00008860: 6620 2270 6f73 2220 696e 2066 6561 745f  f "pos" in feat_
+00008870: 6c69 7374 3a0a 2020 2020 2020 2020 6665  list:.        fe
+00008880: 6174 7572 6573 2e75 7064 6174 6528 7b22  atures.update({"
+00008890: 706f 7322 3a20 7265 705f 7065 616b 7d29  pos": rep_peak})
+000088a0: 0a0a 2020 2020 7265 7475 726e 2066 6561  ..    return fea
+000088b0: 7475 7265 730a 0a0a 2323 2320 5445 4d50  tures...### TEMP
+000088c0: 4c41 5445 5320 4f50 4552 4154 494f 4e53  LATES OPERATIONS
+000088d0: 2023 2323 0a64 6566 2069 735f 706f 7369   ###.def is_posi
+000088e0: 7469 6f6e 5f77 6974 6869 6e5f 626f 756e  tion_within_boun
+000088f0: 6461 7269 6573 2870 6f73 6974 696f 6e2c  daries(position,
+00008900: 2078 5f6c 696d 2c20 795f 6c69 6d2c 207a   x_lim, y_lim, z
+00008910: 5f6c 696d 293a 0a20 2020 2022 2222 0a20  _lim):.    """. 
+00008920: 2020 2043 6865 636b 2069 6620 706f 7369     Check if posi
+00008930: 7469 6f6e 2069 7320 7769 7468 696e 2067  tion is within g
+00008940: 6976 656e 2062 6f75 6e64 6172 6965 732e  iven boundaries.
+00008950: 0a0a 2020 2020 5061 7261 6d65 7465 7273  ..    Parameters
+00008960: 0a20 2020 202d 2d2d 2d2d 2d2d 2d2d 2d0a  .    ----------.
+00008970: 2020 2020 706f 7369 7469 6f6e 203a 206e      position : n
+00008980: 702e 6172 7261 790a 2020 2020 2020 2020  p.array.        
+00008990: 3344 2070 6f73 6974 696f 6e0a 2020 2020  3D position.    
+000089a0: 785f 6c69 6d20 3a20 6c69 7374 0a20 2020  x_lim : list.   
+000089b0: 2020 2020 2042 6f75 6e64 6172 6965 7320       Boundaries 
+000089c0: 696e 2078 2064 696d 656e 7369 6f6e 2028  in x dimension (
+000089d0: 6c6f 772c 2068 6967 6829 0a20 2020 2079  low, high).    y
+000089e0: 5f6c 696d 203a 206c 6973 740a 2020 2020  _lim : list.    
+000089f0: 2020 2020 426f 756e 6461 7269 6573 2069      Boundaries i
+00008a00: 6e20 7920 6469 6d65 6e73 696f 6e20 286c  n y dimension (l
+00008a10: 6f77 2c20 6869 6768 290a 2020 2020 7a5f  ow, high).    z_
+00008a20: 6c69 6d20 3a20 6c69 7374 0a20 2020 2020  lim : list.     
+00008a30: 2020 2042 6f75 6e64 6172 6965 7320 696e     Boundaries in
+00008a40: 207a 2064 696d 656e 7369 6f6e 2028 6c6f   z dimension (lo
+00008a50: 772c 2068 6967 6829 0a0a 2020 2020 5265  w, high)..    Re
+00008a60: 7475 726e 730a 2020 2020 2d2d 2d2d 2d2d  turns.    ------
+00008a70: 2d0a 2020 2020 7661 6c69 645f 706f 7369  -.    valid_posi
+00008a80: 7469 6f6e 203a 2062 6f6f 6c0a 2020 2020  tion : bool.    
+00008a90: 2020 2020 4966 2054 7275 6520 7468 6520      If True the 
+00008aa0: 706f 7369 7469 6f6e 2069 7320 7769 7468  position is with
+00008ab0: 696e 2062 6f75 6e64 6172 6965 730a 0a20  in boundaries.. 
+00008ac0: 2020 2022 2222 0a20 2020 2076 616c 6964     """.    valid
+00008ad0: 5f70 6f73 6974 696f 6e20 3d20 5472 7565  _position = True
+00008ae0: 0a20 2020 2069 6620 785f 6c69 6d20 6973  .    if x_lim is
+00008af0: 206e 6f74 204e 6f6e 653a 0a20 2020 2020   not None:.     
+00008b00: 2020 2069 6620 706f 7369 7469 6f6e 5b30     if position[0
+00008b10: 5d20 3c20 785f 6c69 6d5b 305d 206f 7220  ] < x_lim[0] or 
+00008b20: 706f 7369 7469 6f6e 5b30 5d20 3e20 785f  position[0] > x_
+00008b30: 6c69 6d5b 315d 3a0a 2020 2020 2020 2020  lim[1]:.        
+00008b40: 2020 2020 7661 6c69 645f 706f 7369 7469      valid_positi
+00008b50: 6f6e 203d 2046 616c 7365 0a20 2020 2069  on = False.    i
+00008b60: 6620 795f 6c69 6d20 6973 206e 6f74 204e  f y_lim is not N
+00008b70: 6f6e 653a 0a20 2020 2020 2020 2069 6620  one:.        if 
+00008b80: 706f 7369 7469 6f6e 5b31 5d20 3c20 795f  position[1] < y_
+00008b90: 6c69 6d5b 305d 206f 7220 706f 7369 7469  lim[0] or positi
+00008ba0: 6f6e 5b31 5d20 3e20 795f 6c69 6d5b 315d  on[1] > y_lim[1]
+00008bb0: 3a0a 2020 2020 2020 2020 2020 2020 7661  :.            va
+00008bc0: 6c69 645f 706f 7369 7469 6f6e 203d 2046  lid_position = F
+00008bd0: 616c 7365 0a20 2020 2069 6620 7a5f 6c69  alse.    if z_li
+00008be0: 6d20 6973 206e 6f74 204e 6f6e 653a 0a20  m is not None:. 
+00008bf0: 2020 2020 2020 2069 6620 706f 7369 7469         if positi
+00008c00: 6f6e 5b32 5d20 3c20 7a5f 6c69 6d5b 305d  on[2] < z_lim[0]
+00008c10: 206f 7220 706f 7369 7469 6f6e 5b32 5d20   or position[2] 
+00008c20: 3e20 7a5f 6c69 6d5b 315d 3a0a 2020 2020  > z_lim[1]:.    
+00008c30: 2020 2020 2020 2020 7661 6c69 645f 706f          valid_po
+00008c40: 7369 7469 6f6e 203d 2046 616c 7365 0a20  sition = False. 
+00008c50: 2020 2072 6574 7572 6e20 7661 6c69 645f     return valid_
+00008c60: 706f 7369 7469 6f6e 0a0a 0a64 6566 2073  position...def s
+00008c70: 656c 6563 745f 7465 6d70 6c61 7465 7328  elect_templates(
+00008c80: 0a20 2020 206c 6f63 2c0a 2020 2020 7465  .    loc,.    te
+00008c90: 6d70 6c61 7465 732c 0a20 2020 2062 696e  mplates,.    bin
+00008ca0: 5f63 6174 2c0a 2020 2020 6e5f 6578 632c  _cat,.    n_exc,
+00008cb0: 0a20 2020 206e 5f69 6e68 2c0a 2020 2020  .    n_inh,.    
+00008cc0: 6d69 6e5f 6469 7374 3d32 352c 0a20 2020  min_dist=25,.   
+00008cd0: 2078 5f6c 696d 3d4e 6f6e 652c 0a20 2020   x_lim=None,.   
+00008ce0: 2079 5f6c 696d 3d4e 6f6e 652c 0a20 2020   y_lim=None,.   
+00008cf0: 207a 5f6c 696d 3d4e 6f6e 652c 0a20 2020   z_lim=None,.   
+00008d00: 206d 696e 5f61 6d70 3d4e 6f6e 652c 0a20   min_amp=None,. 
+00008d10: 2020 206d 6178 5f61 6d70 3d4e 6f6e 652c     max_amp=None,
+00008d20: 0a20 2020 2064 7269 6674 696e 673d 4661  .    drifting=Fa
+00008d30: 6c73 652c 0a20 2020 2064 7269 6674 5f64  lse,.    drift_d
+00008d40: 6972 3d4e 6f6e 652c 0a20 2020 2070 7265  ir=None,.    pre
+00008d50: 6665 7272 6564 5f64 6972 3d4e 6f6e 652c  ferred_dir=None,
+00008d60: 0a20 2020 2061 6e67 6c65 5f74 6f6c 3d31  .    angle_tol=1
+00008d70: 352c 0a20 2020 206e 5f6f 7665 726c 6170  5,.    n_overlap
+00008d80: 5f70 6169 7273 3d4e 6f6e 652c 0a20 2020  _pairs=None,.   
+00008d90: 206f 7665 726c 6170 5f74 6872 6573 686f   overlap_thresho
+00008da0: 6c64 3d30 2e38 2c0a 2020 2020 7665 7262  ld=0.8,.    verb
+00008db0: 6f73 653d 4661 6c73 652c 0a29 3a0a 2020  ose=False,.):.  
+00008dc0: 2020 2222 220a 2020 2020 5365 6c65 6374    """.    Select
+00008dd0: 2074 656d 706c 6174 6573 2067 6976 656e   templates given
+00008de0: 2073 7065 6369 6669 6564 2072 756c 6573   specified rules
+00008df0: 2e0a 0a20 2020 2050 6172 616d 6574 6572  ...    Parameter
+00008e00: 730a 2020 2020 2d2d 2d2d 2d2d 2d2d 2d2d  s.    ----------
+00008e10: 0a20 2020 206c 6f63 203a 206e 702e 6172  .    loc : np.ar
+00008e20: 7261 790a 2020 2020 2020 2020 4172 7261  ray.        Arra
+00008e30: 7920 7769 7468 2033 4420 736f 6d61 206c  y with 3D soma l
+00008e40: 6f63 6174 696f 6e73 0a20 2020 2074 656d  ocations.    tem
+00008e50: 706c 6174 6573 203a 206e 702e 6172 7261  plates : np.arra
+00008e60: 790a 2020 2020 2020 2020 4172 7261 7920  y.        Array 
+00008e70: 7769 7468 2065 6170 2074 656d 706c 6174  with eap templat
+00008e80: 6573 2028 6e5f 6561 702c 206e 5f63 6861  es (n_eap, n_cha
+00008e90: 6e6e 656c 732c 206e 5f73 616d 706c 6573  nnels, n_samples
+00008ea0: 290a 2020 2020 6269 6e5f 6361 7420 3a20  ).    bin_cat : 
+00008eb0: 6e70 2e61 7272 6179 0a20 2020 2020 2020  np.array.       
+00008ec0: 2041 7272 6179 2077 6974 6820 6269 6e61   Array with bina
+00008ed0: 7279 2063 6174 6567 6f72 7920 2845 2d49  ry category (E-I
+00008ee0: 290a 2020 2020 6e5f 6578 6320 3a20 696e  ).    n_exc : in
+00008ef0: 740a 2020 2020 2020 2020 4e75 6d62 6572  t.        Number
+00008f00: 206f 6620 6578 6369 7461 746f 7279 2063   of excitatory c
+00008f10: 656c 6c73 2074 6f20 6265 2073 656c 6563  ells to be selec
+00008f20: 7465 640a 2020 2020 6e5f 696e 6820 3a20  ted.    n_inh : 
+00008f30: 696e 740a 2020 2020 2020 2020 4e75 6d62  int.        Numb
+00008f40: 6572 206f 6620 696e 6869 6269 746f 7279  er of inhibitory
+00008f50: 2063 656c 6c73 2074 6f20 6265 2073 656c   cells to be sel
+00008f60: 6563 7465 640a 2020 2020 6d69 6e5f 6469  ected.    min_di
+00008f70: 7374 203a 2066 6c6f 6174 0a20 2020 2020  st : float.     
+00008f80: 2020 204d 696e 696d 756d 2061 6c6c 6f77     Minimum allow
+00008f90: 6564 2064 6973 7461 6e63 6520 6265 7477  ed distance betw
+00008fa0: 6565 6e20 736f 6d61 7461 2028 696e 2075  een somata (in u
+00008fb0: 6d29 0a20 2020 2078 5f6c 696d 203a 206c  m).    x_lim : l
+00008fc0: 6973 740a 2020 2020 2020 2020 426f 756e  ist.        Boun
+00008fd0: 6461 7269 6573 2069 6e20 7820 6469 6d65  daries in x dime
+00008fe0: 6e73 696f 6e20 286c 6f77 2c20 6869 6768  nsion (low, high
+00008ff0: 290a 2020 2020 795f 6c69 6d20 3a20 6c69  ).    y_lim : li
+00009000: 7374 0a20 2020 2020 2020 2042 6f75 6e64  st.        Bound
+00009010: 6172 6965 7320 696e 2079 2064 696d 656e  aries in y dimen
+00009020: 7369 6f6e 2028 6c6f 772c 2068 6967 6829  sion (low, high)
+00009030: 0a20 2020 207a 5f6c 696d 203a 206c 6973  .    z_lim : lis
+00009040: 740a 2020 2020 2020 2020 426f 756e 6461  t.        Bounda
+00009050: 7269 6573 2069 6e20 7a20 6469 6d65 6e73  ries in z dimens
+00009060: 696f 6e20 286c 6f77 2c20 6869 6768 290a  ion (low, high).
+00009070: 2020 2020 6d69 6e5f 616d 7020 3a20 666c      min_amp : fl
+00009080: 6f61 740a 2020 2020 2020 2020 4d69 6e69  oat.        Mini
+00009090: 6d75 6d20 616d 706c 6974 7564 6520 696e  mum amplitude in
+000090a0: 2075 560a 2020 2020 6d61 785f 616d 7020   uV.    max_amp 
+000090b0: 3a20 666c 6f61 740a 2020 2020 2020 2020  : float.        
+000090c0: 4d61 7869 6d75 6d20 616d 706c 6974 7564  Maximum amplitud
+000090d0: 6520 696e 2075 560a 2020 2020 6472 6966  e in uV.    drif
+000090e0: 7469 6e67 203a 2062 6f6f 6c0a 2020 2020  ting : bool.    
+000090f0: 2020 2020 4966 2054 7275 6520 6472 6966      If True drif
+00009100: 7469 6e67 2074 656d 706c 6174 6573 2061  ting templates a
+00009110: 7265 2073 656c 6563 7465 640a 2020 2020  re selected.    
+00009120: 6472 6966 745f 6469 7220 3a20 6e70 2e61  drift_dir : np.a
+00009130: 7272 6179 0a20 2020 2020 2020 2033 4420  rray.        3D 
+00009140: 6172 7261 7920 7769 7468 2064 7269 6674  array with drift
+00009150: 2064 6972 6563 7469 6f6e 2066 6f72 2065   direction for e
+00009160: 6163 6820 7465 6d70 6c61 7465 0a20 2020  ach template.   
+00009170: 2070 7265 6665 7272 6564 5f64 6972 203a   preferred_dir :
+00009180: 206e 702e 6172 7261 790a 2020 2020 2020   np.array.      
+00009190: 2020 3344 2061 7272 6179 2077 6974 6820    3D array with 
+000091a0: 7072 6566 6572 7265 640a 2020 2020 616e  preferred.    an
+000091b0: 676c 655f 746f 6c20 3a20 666c 6f61 740a  gle_tol : float.
+000091c0: 2020 2020 2020 2020 546f 6c6c 6572 616e          Tolleran
+000091d0: 6365 2069 6e20 6465 6772 6565 7320 666f  ce in degrees fo
+000091e0: 7220 7365 6c65 6374 696e 6720 6669 6e61  r selecting fina
+000091f0: 6c20 6472 6966 7420 706f 7369 7469 6f6e  l drift position
+00009200: 0a20 2020 206e 5f6f 7665 726c 6170 5f70  .    n_overlap_p
+00009210: 6169 7273 3a20 696e 740a 2020 2020 2020  airs: int.      
+00009220: 2020 4e75 6d62 6572 206f 6620 7370 6174    Number of spat
+00009230: 6961 6c6c 7920 6f76 6572 6c61 7070 696e  ially overlappin
+00009240: 6720 7465 6d70 6c61 7465 7320 746f 2073  g templates to s
+00009250: 656c 6563 740a 2020 2020 6f76 6572 6c61  elect.    overla
+00009260: 705f 7468 7265 7368 6f6c 643a 2066 6c6f  p_threshold: flo
+00009270: 6174 0a20 2020 2020 2020 2054 6872 6573  at.        Thres
+00009280: 686f 6c64 2066 6f72 2063 6f6e 7369 6465  hold for conside
+00009290: 7269 6e67 2073 7061 7469 616c 6c79 206f  ring spatially o
+000092a0: 7665 726c 6170 7069 6e67 2070 6169 7273  verlapping pairs
+000092b0: 2028 5b30 2d31 5d29 0a20 2020 2076 6572   ([0-1]).    ver
+000092c0: 626f 7365 203a 2062 6f6f 6c0a 2020 2020  bose : bool.    
+000092d0: 2020 2020 4966 2054 7275 6520 7468 6520      If True the 
+000092e0: 6f75 7470 7574 2069 7320 7665 7262 6f73  output is verbos
+000092f0: 650a 0a20 2020 2052 6574 7572 6e73 0a20  e..    Returns. 
+00009300: 2020 202d 2d2d 2d2d 2d2d 0a20 2020 2073     -------.    s
+00009310: 656c 6563 7465 645f 6964 7873 203a 206e  elected_idxs : n
+00009320: 702e 6172 7261 790a 2020 2020 2020 2020  p.array.        
+00009330: 5365 6c65 6374 6564 2074 656d 706c 6174  Selected templat
+00009340: 6520 696e 6465 7865 730a 2020 2020 7365  e indexes.    se
+00009350: 6c65 6374 6564 5f63 6174 203a 206c 6973  lected_cat : lis
+00009360: 740a 2020 2020 2020 2020 5365 6c65 6374  t.        Select
+00009370: 6564 2074 656d 706c 6174 6573 2062 696e  ed templates bin
+00009380: 6172 7920 7479 7065 0a0a 0a20 2020 2022  ary type...    "
+00009390: 2222 0a20 2020 2070 6f73 5f73 656c 203d  "".    pos_sel =
+000093a0: 205b 5d0a 2020 2020 7365 6c65 6374 6564   [].    selected
+000093b0: 5f69 6478 7320 3d20 5b5d 0a20 2020 2063  _idxs = [].    c
+000093c0: 6174 6567 6f72 6965 7320 3d20 6e70 2e75  ategories = np.u
+000093d0: 6e69 7175 6528 6269 6e5f 6361 7429 0a0a  nique(bin_cat)..
+000093e0: 2020 2020 6966 2062 696e 5f63 6174 2069      if bin_cat i
+000093f0: 7320 6e6f 7420 4e6f 6e65 2061 6e64 2022  s not None and "
+00009400: 4522 2069 6e20 6361 7465 676f 7269 6573  E" in categories
+00009410: 2061 6e64 2022 4922 2069 6e20 6361 7465   and "I" in cate
+00009420: 676f 7269 6573 3a0a 2020 2020 2020 2020  gories:.        
+00009430: 6966 2076 6572 626f 7365 3a0a 2020 2020  if verbose:.    
+00009440: 2020 2020 2020 2020 7072 696e 7428 2253          print("S
+00009450: 656c 6563 7469 6e67 2045 7863 6974 6174  electing Excitat
+00009460: 6f72 7920 616e 6420 496e 6869 6269 746f  ory and Inhibito
+00009470: 7279 2063 656c 6c73 2229 0a20 2020 2020  ry cells").     
+00009480: 2020 2065 7863 696e 6820 3d20 5472 7565     excinh = True
+00009490: 0a20 2020 2020 2020 2073 656c 6563 7465  .        selecte
+000094a0: 645f 6361 7420 3d20 5b5d 0a20 2020 2065  d_cat = [].    e
+000094b0: 6c73 653a 0a20 2020 2020 2020 2069 6620  lse:.        if 
+000094c0: 7665 7262 6f73 653a 0a20 2020 2020 2020  verbose:.       
+000094d0: 2020 2020 2070 7269 6e74 2822 5365 6c65       print("Sele
+000094e0: 6374 696e 6720 7261 6e64 6f6d 2074 656d  cting random tem
+000094f0: 706c 6174 6573 2028 6365 6c6c 2074 7970  plates (cell typ
+00009500: 6573 206e 6f74 2073 7065 6369 6669 6564  es not specified
+00009510: 2922 290a 2020 2020 2020 2020 6578 6369  )").        exci
+00009520: 6e68 203d 2046 616c 7365 0a20 2020 2020  nh = False.     
+00009530: 2020 2073 656c 6563 7465 645f 6361 7420     selected_cat 
+00009540: 3d20 5b5d 0a0a 2020 2020 7065 726d 7574  = []..    permut
+00009550: 6564 5f69 6478 7320 3d20 6e70 2e72 616e  ed_idxs = np.ran
+00009560: 646f 6d2e 7065 726d 7574 6174 696f 6e28  dom.permutation(
+00009570: 6c65 6e28 6c6f 6329 290a 2020 2020 6966  len(loc)).    if
+00009580: 2062 696e 5f63 6174 2069 7320 6e6f 7420   bin_cat is not 
+00009590: 4e6f 6e65 3a0a 2020 2020 2020 2020 7065  None:.        pe
+000095a0: 726d 7574 6564 5f62 696e 5f63 6174 7320  rmuted_bin_cats 
+000095b0: 3d20 6269 6e5f 6361 745b 7065 726d 7574  = bin_cat[permut
+000095c0: 6564 5f69 6478 735d 0a20 2020 2065 6c73  ed_idxs].    els
+000095d0: 653a 0a20 2020 2020 2020 2070 6572 6d75  e:.        permu
+000095e0: 7465 645f 6269 6e5f 6361 7473 203d 205b  ted_bin_cats = [
+000095f0: 2255 225d 202a 206c 656e 286c 6f63 290a  "U"] * len(loc).
+00009600: 0a20 2020 2069 6620 7665 7262 6f73 653a  .    if verbose:
+00009610: 0a20 2020 2020 2020 2070 7269 6e74 2822  .        print("
+00009620: 4d69 6e20 6469 7374 3a20 222c 206d 696e  Min dist: ", min
+00009630: 5f64 6973 742c 2022 4d69 6e20 616d 703a  _dist, "Min amp:
+00009640: 2022 2c20 6d69 6e5f 616d 7029 0a0a 2020   ", min_amp)..  
+00009650: 2020 6966 206d 696e 5f61 6d70 2069 7320    if min_amp is 
+00009660: 4e6f 6e65 3a0a 2020 2020 2020 2020 6d69  None:.        mi
+00009670: 6e5f 616d 7020 3d20 300a 0a20 2020 2069  n_amp = 0..    i
+00009680: 6620 6d61 785f 616d 7020 6973 204e 6f6e  f max_amp is Non
+00009690: 653a 0a20 2020 2020 2020 206d 6178 5f61  e:.        max_a
+000096a0: 6d70 203d 206e 702e 696e 660a 0a20 2020  mp = np.inf..   
+000096b0: 2069 6620 6472 6966 7469 6e67 3a0a 2020   if drifting:.  
+000096c0: 2020 2020 2020 6966 2064 7269 6674 5f64        if drift_d
+000096d0: 6972 2069 7320 4e6f 6e65 206f 7220 7072  ir is None or pr
+000096e0: 6566 6572 7265 645f 6469 7220 6973 204e  eferred_dir is N
+000096f0: 6f6e 653a 0a20 2020 2020 2020 2020 2020  one:.           
+00009700: 2072 6169 7365 2045 7863 6570 7469 6f6e   raise Exception
+00009710: 2822 466f 7220 6472 6966 7420 7365 6c65  ("For drift sele
+00009720: 6374 696f 6e20 7072 6f76 6964 6520 6472  ction provide dr
+00009730: 6966 7469 6e67 2061 6e67 6c65 7320 616e  ifting angles an
+00009740: 6420 7072 6566 6572 7265 6420 6472 6966  d preferred drif
+00009750: 7420 6469 7265 6374 696f 6e22 290a 0a20  t direction").. 
+00009760: 2020 206e 5f73 656c 203d 2030 0a20 2020     n_sel = 0.   
+00009770: 206e 5f73 656c 5f65 7863 203d 2030 0a20   n_sel_exc = 0. 
+00009780: 2020 206e 5f73 656c 5f69 6e68 203d 2030     n_sel_inh = 0
+00009790: 0a20 2020 2069 7465 7220 3d20 300a 2020  .    iter = 0.  
+000097a0: 2020 6375 7272 656e 745f 6f76 6572 6c61    current_overla
+000097b0: 7070 696e 675f 7061 6972 7320 3d20 300a  pping_pairs = 0.
+000097c0: 0a20 2020 2066 6f72 2069 2c20 2869 645f  .    for i, (id_
+000097d0: 6365 6c6c 2c20 6263 6174 2920 696e 2065  cell, bcat) in e
+000097e0: 6e75 6d65 7261 7465 287a 6970 2870 6572  numerate(zip(per
+000097f0: 6d75 7465 645f 6964 7873 2c20 7065 726d  muted_idxs, perm
+00009800: 7574 6564 5f62 696e 5f63 6174 7329 293a  uted_bin_cats)):
+00009810: 0a20 2020 2020 2020 2070 6c61 6365 6420  .        placed 
+00009820: 3d20 4661 6c73 650a 2020 2020 2020 2020  = False.        
+00009830: 6974 6572 202b 3d20 310a 2020 2020 2020  iter += 1.      
+00009840: 2020 6966 206e 5f73 656c 203d 3d20 6e5f    if n_sel == n_
+00009850: 6578 6320 2b20 6e5f 696e 683a 0a20 2020  exc + n_inh:.   
+00009860: 2020 2020 2020 2020 2062 7265 616b 0a20           break. 
+00009870: 2020 2020 2020 2023 2045 7863 6974 6174         # Excitat
+00009880: 6f72 7920 616e 6420 696e 6869 6269 746f  ory and inhibito
+00009890: 7279 2063 656c 6c73 0a20 2020 2020 2020  ry cells.       
+000098a0: 2069 6620 6578 6369 6e68 3a0a 2020 2020   if excinh:.    
+000098b0: 2020 2020 2020 2020 2320 6578 6369 7461          # excita
+000098c0: 746f 7279 2063 656c 6c0a 2020 2020 2020  tory cell.      
+000098d0: 2020 2020 2020 6966 2062 6361 7420 3d3d        if bcat ==
+000098e0: 2022 4522 3a0a 2020 2020 2020 2020 2020   "E":.          
+000098f0: 2020 2020 2020 6966 206e 5f73 656c 5f65        if n_sel_e
+00009900: 7863 203c 206e 5f65 7863 3a0a 2020 2020  xc < n_exc:.    
+00009910: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009920: 6469 7374 203d 206e 702e 6172 7261 7928  dist = np.array(
+00009930: 5b6e 702e 6c69 6e61 6c67 2e6e 6f72 6d28  [np.linalg.norm(
+00009940: 6c6f 635b 6964 5f63 656c 6c5d 202d 2070  loc[id_cell] - p
+00009950: 2920 666f 7220 7020 696e 2070 6f73 5f73  ) for p in pos_s
+00009960: 656c 5d29 0a20 2020 2020 2020 2020 2020  el]).           
+00009970: 2020 2020 2020 2020 2069 6620 6e70 2e61           if np.a
+00009980: 6e79 2864 6973 7420 3c20 6d69 6e5f 6469  ny(dist < min_di
+00009990: 7374 293a 0a20 2020 2020 2020 2020 2020  st):.           
+000099a0: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+000099b0: 7665 7262 6f73 653a 0a20 2020 2020 2020  verbose:.       
+000099c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000099d0: 2020 2020 2070 7269 6e74 2822 4469 7374       print("Dist
+000099e0: 616e 6365 2076 696f 6c61 7469 6f6e 222c  ance violation",
+000099f0: 206e 702e 6d69 6e28 6469 7374 292c 2069   np.min(dist), i
+00009a00: 7465 7229 0a20 2020 2020 2020 2020 2020  ter).           
+00009a10: 2020 2020 2020 2020 2020 2020 2070 6173               pas
+00009a20: 730a 2020 2020 2020 2020 2020 2020 2020  s.              
+00009a30: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+00009a40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009a50: 2020 2020 616d 7020 3d20 6e70 2e6d 6178      amp = np.max
+00009a60: 286e 702e 6162 7328 6e70 2e6d 696e 2874  (np.abs(np.min(t
+00009a70: 656d 706c 6174 6573 5b69 645f 6365 6c6c  emplates[id_cell
+00009a80: 5d29 2929 0a20 2020 2020 2020 2020 2020  ]))).           
+00009a90: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+00009aa0: 6e6f 7420 6472 6966 7469 6e67 3a0a 2020  not drifting:.  
+00009ab0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009ac0: 2020 2020 2020 2020 2020 6966 2028 0a20            if (. 
+00009ad0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009ae0: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+00009af0: 735f 706f 7369 7469 6f6e 5f77 6974 6869  s_position_withi
+00009b00: 6e5f 626f 756e 6461 7269 6573 286c 6f63  n_boundaries(loc
+00009b10: 5b69 645f 6365 6c6c 5d2c 2078 5f6c 696d  [id_cell], x_lim
+00009b20: 2c20 795f 6c69 6d2c 207a 5f6c 696d 290a  , y_lim, z_lim).
+00009b30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009b40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009b50: 616e 6420 6d69 6e5f 616d 7020 3c20 616d  and min_amp < am
+00009b60: 7020 3c20 6d61 785f 616d 700a 2020 2020  p < max_amp.    
+00009b70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009b80: 2020 2020 2020 2020 293a 0a20 2020 2020          ):.     
+00009b90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009ba0: 2020 2020 2020 2020 2020 2023 2073 6176             # sav
+00009bb0: 6520 6365 6c6c 0a20 2020 2020 2020 2020  e cell.         
+00009bc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009bd0: 2020 2020 2020 2069 6620 6e5f 6f76 6572         if n_over
+00009be0: 6c61 705f 7061 6972 7320 6973 204e 6f6e  lap_pairs is Non
+00009bf0: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
 00009c00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009c10: 2020 2020 2069 6620 7665 7262 6f73 653a       if verbose:
-00009c20: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00009c30: 2020 2020 2020 2020 2020 2020 2070 7269               pri
-00009c40: 6e74 2827 4469 7374 616e 6365 2076 696f  nt('Distance vio
-00009c50: 6c61 7469 6f6e 272c 206e 702e 6d69 6e28  lation', np.min(
-00009c60: 6469 7374 292c 2069 7465 7229 0a20 2020  dist), iter).   
-00009c70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009c80: 2020 2020 2070 6173 730a 2020 2020 2020       pass.      
-00009c90: 2020 2020 2020 2020 2020 2020 2020 656c                el
-00009ca0: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-00009cb0: 2020 2020 2020 2020 2020 2020 616d 7020              amp 
-00009cc0: 3d20 6e70 2e6d 6178 286e 702e 6162 7328  = np.max(np.abs(
-00009cd0: 6e70 2e6d 696e 2874 656d 706c 6174 6573  np.min(templates
-00009ce0: 5b69 645f 6365 6c6c 5d29 2929 0a20 2020  [id_cell]))).   
-00009cf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009d00: 2020 2020 2069 6620 6e6f 7420 6472 6966       if not drif
-00009d10: 7469 6e67 3a0a 2020 2020 2020 2020 2020  ting:.          
-00009d20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009d30: 2020 6966 2069 735f 706f 7369 7469 6f6e    if is_position
-00009d40: 5f77 6974 6869 6e5f 626f 756e 6461 7269  _within_boundari
-00009d50: 6573 286c 6f63 5b69 645f 6365 6c6c 5d2c  es(loc[id_cell],
-00009d60: 2078 5f6c 696d 2c20 795f 6c69 6d2c 207a   x_lim, y_lim, z
-00009d70: 5f6c 696d 2920 5c0a 2020 2020 2020 2020  _lim) \.        
+00009c10: 2020 2020 2020 2070 6f73 5f73 656c 2e61         pos_sel.a
+00009c20: 7070 656e 6428 6c6f 635b 6964 5f63 656c  ppend(loc[id_cel
+00009c30: 6c5d 290a 2020 2020 2020 2020 2020 2020  l]).            
+00009c40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009c50: 2020 2020 2020 2020 7365 6c65 6374 6564          selected
+00009c60: 5f69 6478 732e 6170 7065 6e64 2869 645f  _idxs.append(id_
+00009c70: 6365 6c6c 290a 2020 2020 2020 2020 2020  cell).          
+00009c80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009c90: 2020 2020 2020 2020 2020 6e5f 7365 6c20            n_sel 
+00009ca0: 2b3d 2031 0a20 2020 2020 2020 2020 2020  += 1.           
+00009cb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009cc0: 2020 2020 2020 2020 2070 6c61 6365 6420           placed 
+00009cd0: 3d20 5472 7565 0a20 2020 2020 2020 2020  = True.         
+00009ce0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009cf0: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+00009d00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009d10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009d20: 2069 6620 6c65 6e28 7365 6c65 6374 6564   if len(selected
+00009d30: 5f69 6478 7329 203d 3d20 303a 0a20 2020  _idxs) == 0:.   
+00009d40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009d50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009d60: 2020 2020 2023 2073 6176 6520 6365 6c6c       # save cell
+00009d70: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
 00009d80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009d90: 2020 2020 2020 2020 2020 2020 616e 6420              and 
-00009da0: 6d69 6e5f 616d 7020 3c20 616d 7020 3c20  min_amp < amp < 
-00009db0: 6d61 785f 616d 703a 0a20 2020 2020 2020  max_amp:.       
+00009d90: 2020 2020 2020 2020 2070 6f73 5f73 656c           pos_sel
+00009da0: 2e61 7070 656e 6428 6c6f 635b 6964 5f63  .append(loc[id_c
+00009db0: 656c 6c5d 290a 2020 2020 2020 2020 2020  ell]).          
 00009dc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009dd0: 2020 2020 2020 2020 2023 2073 6176 6520           # save 
-00009de0: 6365 6c6c 0a20 2020 2020 2020 2020 2020  cell.           
-00009df0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009e00: 2020 2020 2069 6620 6e5f 6f76 6572 6c61       if n_overla
-00009e10: 705f 7061 6972 7320 6973 204e 6f6e 653a  p_pairs is None:
-00009e20: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00009dd0: 2020 2020 2020 2020 2020 2020 2020 7365                se
+00009de0: 6c65 6374 6564 5f69 6478 732e 6170 7065  lected_idxs.appe
+00009df0: 6e64 2869 645f 6365 6c6c 290a 2020 2020  nd(id_cell).    
+00009e00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009e10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009e20: 2020 2020 6e5f 7365 6c20 2b3d 2031 0a20      n_sel += 1. 
 00009e30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009e40: 2020 2020 2070 6f73 5f73 656c 2e61 7070       pos_sel.app
-00009e50: 656e 6428 6c6f 635b 6964 5f63 656c 6c5d  end(loc[id_cell]
-00009e60: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+00009e40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009e50: 2020 2020 2020 2070 6c61 6365 6420 3d20         placed = 
+00009e60: 5472 7565 0a20 2020 2020 2020 2020 2020  True.           
 00009e70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009e80: 2020 2020 2020 7365 6c65 6374 6564 5f69        selected_i
-00009e90: 6478 732e 6170 7065 6e64 2869 645f 6365  dxs.append(id_ce
-00009ea0: 6c6c 290a 2020 2020 2020 2020 2020 2020  ll).            
-00009eb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009ec0: 2020 2020 2020 2020 6e5f 7365 6c20 2b3d          n_sel +=
-00009ed0: 2031 0a20 2020 2020 2020 2020 2020 2020   1.             
-00009ee0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009ef0: 2020 2020 2020 2070 6c61 6365 6420 3d20         placed = 
-00009f00: 5472 7565 0a20 2020 2020 2020 2020 2020  True.           
-00009f10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009f20: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+00009e80: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
+00009e90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009ea0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009eb0: 2020 2020 2020 2070 6f73 7369 626c 655f         possible_
+00009ec0: 7365 6c65 6374 6564 203d 2064 6565 7063  selected = deepc
+00009ed0: 6f70 7928 7365 6c65 6374 6564 5f69 6478  opy(selected_idx
+00009ee0: 7329 0a20 2020 2020 2020 2020 2020 2020  s).             
+00009ef0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009f00: 2020 2020 2020 2020 2020 2070 6f73 7369             possi
+00009f10: 626c 655f 7365 6c65 6374 6564 2e61 7070  ble_selected.app
+00009f20: 656e 6428 6964 5f63 656c 6c29 0a20 2020  end(id_cell).   
 00009f30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009f40: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-00009f50: 6620 6c65 6e28 7365 6c65 6374 6564 5f69  f len(selected_i
-00009f60: 6478 7329 203d 3d20 303a 0a20 2020 2020  dxs) == 0:.     
-00009f70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009f40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009f50: 2020 2020 2070 6f73 7369 626c 655f 6f76       possible_ov
+00009f60: 6572 6c61 7070 696e 675f 7061 6972 7320  erlapping_pairs 
+00009f70: 3d20 6c65 6e28 0a20 2020 2020 2020 2020  = len(.         
 00009f80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009f90: 2020 2023 2073 6176 6520 6365 6c6c 0a20     # save cell. 
-00009fa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009fb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009fc0: 2020 2020 2020 2070 6f73 5f73 656c 2e61         pos_sel.a
-00009fd0: 7070 656e 6428 6c6f 635b 6964 5f63 656c  ppend(loc[id_cel
-00009fe0: 6c5d 290a 2020 2020 2020 2020 2020 2020  l]).            
-00009ff0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a000: 2020 2020 2020 2020 2020 2020 7365 6c65              sele
-0000a010: 6374 6564 5f69 6478 732e 6170 7065 6e64  cted_idxs.append
-0000a020: 2869 645f 6365 6c6c 290a 2020 2020 2020  (id_cell).      
+00009f90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009fa0: 2020 2066 696e 645f 6f76 6572 6c61 7070     find_overlapp
+00009fb0: 696e 675f 7465 6d70 6c61 7465 7328 0a20  ing_templates(. 
+00009fc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009fd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009fe0: 2020 2020 2020 2020 2020 2020 2020 2074                 t
+00009ff0: 656d 706c 6174 6573 5b73 6f72 7465 6428  emplates[sorted(
+0000a000: 706f 7373 6962 6c65 5f73 656c 6563 7465  possible_selecte
+0000a010: 6429 5d2c 206f 7665 726c 6170 5f74 6872  d)], overlap_thr
+0000a020: 6573 686f 6c64 0a20 2020 2020 2020 2020  eshold.         
 0000a030: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000a040: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a050: 2020 6e5f 7365 6c20 2b3d 2031 0a20 2020    n_sel += 1.   
+0000a050: 2020 2029 0a20 2020 2020 2020 2020 2020     ).           
 0000a060: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a070: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a080: 2020 2020 2070 6c61 6365 6420 3d20 5472       placed = Tr
-0000a090: 7565 0a20 2020 2020 2020 2020 2020 2020  ue.             
-0000a0a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a0b0: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-0000a0c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a070: 2020 2020 2020 2020 2020 2020 2029 0a20               ). 
+0000a080: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a090: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a0a0: 2020 2020 2020 2063 7572 7265 6e74 5f6f         current_o
+0000a0b0: 7665 726c 6170 7069 6e67 5f70 6169 7273  verlapping_pairs
+0000a0c0: 203d 206c 656e 280a 2020 2020 2020 2020   = len(.        
 0000a0d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a0e0: 2020 2020 2070 6f73 7369 626c 655f 7365       possible_se
-0000a0f0: 6c65 6374 6564 203d 2064 6565 7063 6f70  lected = deepcop
-0000a100: 7928 7365 6c65 6374 6564 5f69 6478 7329  y(selected_idxs)
-0000a110: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000a0e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a0f0: 2020 2020 6669 6e64 5f6f 7665 726c 6170      find_overlap
+0000a100: 7069 6e67 5f74 656d 706c 6174 6573 280a  ping_templates(.
+0000a110: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000a120: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a130: 2020 2020 2020 2020 2070 6f73 7369 626c           possibl
-0000a140: 655f 7365 6c65 6374 6564 2e61 7070 656e  e_selected.appen
-0000a150: 6428 6964 5f63 656c 6c29 0a20 2020 2020  d(id_cell).     
-0000a160: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a170: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a180: 2020 2070 6f73 7369 626c 655f 6f76 6572     possible_over
-0000a190: 6c61 7070 696e 675f 7061 6972 7320 3d20  lapping_pairs = 
-0000a1a0: 6c65 6e28 6669 6e64 5f6f 7665 726c 6170  len(find_overlap
-0000a1b0: 7069 6e67 5f74 656d 706c 6174 6573 280a  ping_templates(.
-0000a1c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a130: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a140: 7465 6d70 6c61 7465 735b 736f 7274 6564  templates[sorted
+0000a150: 2873 656c 6563 7465 645f 6964 7873 295d  (selected_idxs)]
+0000a160: 2c20 6f76 6572 6c61 705f 7468 7265 7368  , overlap_thresh
+0000a170: 6f6c 640a 2020 2020 2020 2020 2020 2020  old.            
+0000a180: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a190: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a1a0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+0000a1b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a1c0: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
 0000a1d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a1e0: 2020 2020 2020 2020 2020 2020 7465 6d70              temp
-0000a1f0: 6c61 7465 735b 736f 7274 6564 2870 6f73  lates[sorted(pos
-0000a200: 7369 626c 655f 7365 6c65 6374 6564 295d  sible_selected)]
-0000a210: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-0000a220: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a230: 2020 2020 2020 2020 2020 2020 2020 6f76                ov
-0000a240: 6572 6c61 705f 7468 7265 7368 6f6c 6429  erlap_threshold)
-0000a250: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+0000a1e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a1f0: 2020 2020 6966 2028 0a20 2020 2020 2020      if (.       
+0000a200: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a210: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a220: 2020 2020 2063 7572 7265 6e74 5f6f 7665       current_ove
+0000a230: 726c 6170 7069 6e67 5f70 6169 7273 203c  rlapping_pairs <
+0000a240: 206e 5f6f 7665 726c 6170 5f70 6169 7273   n_overlap_pairs
+0000a250: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
 0000a260: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a270: 2020 2020 2020 2020 2020 6375 7272 656e            curren
-0000a280: 745f 6f76 6572 6c61 7070 696e 675f 7061  t_overlapping_pa
-0000a290: 6972 7320 3d20 6c65 6e28 6669 6e64 5f6f  irs = len(find_o
-0000a2a0: 7665 726c 6170 7069 6e67 5f74 656d 706c  verlapping_templ
-0000a2b0: 6174 6573 280a 2020 2020 2020 2020 2020  ates(.          
+0000a270: 2020 2020 2020 2020 2020 2020 2061 6e64               and
+0000a280: 2070 6f73 7369 626c 655f 6f76 6572 6c61   possible_overla
+0000a290: 7070 696e 675f 7061 6972 7320 3c3d 206e  pping_pairs <= n
+0000a2a0: 5f6f 7665 726c 6170 5f70 6169 7273 0a20  _overlap_pairs. 
+0000a2b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000a2c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a2d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a2e0: 2020 7465 6d70 6c61 7465 735b 736f 7274    templates[sort
-0000a2f0: 6564 2873 656c 6563 7465 645f 6964 7873  ed(selected_idxs
-0000a300: 295d 2c0a 2020 2020 2020 2020 2020 2020  )],.            
-0000a310: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a320: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a330: 6f76 6572 6c61 705f 7468 7265 7368 6f6c  overlap_threshol
-0000a340: 6429 290a 2020 2020 2020 2020 2020 2020  d)).            
+0000a2d0: 2020 2020 2020 2029 3a0a 2020 2020 2020         ):.      
+0000a2e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a2f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a300: 2020 2020 2020 6966 2070 6f73 7369 626c        if possibl
+0000a310: 655f 6f76 6572 6c61 7070 696e 675f 7061  e_overlapping_pa
+0000a320: 6972 7320 3d3d 2063 7572 7265 6e74 5f6f  irs == current_o
+0000a330: 7665 726c 6170 7069 6e67 5f70 6169 7273  verlapping_pairs
+0000a340: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
 0000a350: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a360: 2020 2020 2020 2020 2020 2020 6966 2063              if c
-0000a370: 7572 7265 6e74 5f6f 7665 726c 6170 7069  urrent_overlappi
-0000a380: 6e67 5f70 6169 7273 203c 206e 5f6f 7665  ng_pairs < n_ove
-0000a390: 726c 6170 5f70 6169 7273 2061 6e64 205c  rlap_pairs and \
-0000a3a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000a360: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a370: 2020 636f 6e74 696e 7565 0a20 2020 2020    continue.     
+0000a380: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a390: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a3a0: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
 0000a3b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000a3c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a3d0: 2070 6f73 7369 626c 655f 6f76 6572 6c61   possible_overla
-0000a3e0: 7070 696e 675f 7061 6972 7320 3c3d 206e  pping_pairs <= n
-0000a3f0: 5f6f 7665 726c 6170 5f70 6169 7273 3a0a  _overlap_pairs:.
+0000a3d0: 2020 2020 2020 2020 2020 2020 2070 6f73               pos
+0000a3e0: 5f73 656c 2e61 7070 656e 6428 6c6f 635b  _sel.append(loc[
+0000a3f0: 6964 5f63 656c 6c5d 290a 2020 2020 2020  id_cell]).      
 0000a400: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000a410: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a420: 2020 2020 2020 2020 2020 2020 6966 2070              if p
-0000a430: 6f73 7369 626c 655f 6f76 6572 6c61 7070  ossible_overlapp
-0000a440: 696e 675f 7061 6972 7320 3d3d 2063 7572  ing_pairs == cur
-0000a450: 7265 6e74 5f6f 7665 726c 6170 7069 6e67  rent_overlapping
-0000a460: 5f70 6169 7273 3a0a 2020 2020 2020 2020  _pairs:.        
-0000a470: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a480: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a490: 2020 2020 2020 2020 636f 6e74 696e 7565          continue
-0000a4a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000a4b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a4c0: 2020 2020 2020 2020 2020 2020 2065 6c73               els
-0000a4d0: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+0000a420: 2020 2020 2020 2020 2020 7365 6c65 6374            select
+0000a430: 6564 5f69 6478 732e 6170 7065 6e64 2869  ed_idxs.append(i
+0000a440: 645f 6365 6c6c 290a 2020 2020 2020 2020  d_cell).        
+0000a450: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a460: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a470: 2020 2020 2020 2020 6e5f 7365 6c20 2b3d          n_sel +=
+0000a480: 2031 0a20 2020 2020 2020 2020 2020 2020   1.             
+0000a490: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a4a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a4b0: 2020 2070 6c61 6365 6420 3d20 5472 7565     placed = True
+0000a4c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000a4d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000a4e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a4f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a500: 2020 2070 6f73 5f73 656c 2e61 7070 656e     pos_sel.appen
-0000a510: 6428 6c6f 635b 6964 5f63 656c 6c5d 290a  d(loc[id_cell]).
+0000a4f0: 2069 6620 7665 7262 6f73 653a 0a20 2020   if verbose:.   
+0000a500: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a510: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000a520: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a530: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a540: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a550: 7365 6c65 6374 6564 5f69 6478 732e 6170  selected_idxs.ap
-0000a560: 7065 6e64 2869 645f 6365 6c6c 290a 2020  pend(id_cell).  
-0000a570: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a530: 2070 7269 6e74 2822 4e75 6d62 6572 206f   print("Number o
+0000a540: 6620 6f76 6572 6c61 7070 696e 6720 7061  f overlapping pa
+0000a550: 6972 733a 222c 2070 6f73 7369 626c 655f  irs:", possible_
+0000a560: 6f76 6572 6c61 7070 696e 675f 7061 6972  overlapping_pair
+0000a570: 7329 0a20 2020 2020 2020 2020 2020 2020  s).             
 0000a580: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a590: 2020 2020 2020 2020 2020 2020 2020 6e5f                n_
-0000a5a0: 7365 6c20 2b3d 2031 0a20 2020 2020 2020  sel += 1.       
+0000a590: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
+0000a5a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
 0000a5b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a5c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a5d0: 2020 2020 2020 2020 2070 6c61 6365 6420           placed 
-0000a5e0: 3d20 5472 7565 0a20 2020 2020 2020 2020  = True.         
-0000a5f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a600: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a610: 2020 2020 2020 2069 6620 7665 7262 6f73         if verbos
-0000a620: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-0000a630: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a640: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a650: 2020 2020 2020 2070 7269 6e74 2827 4e75         print('Nu
-0000a660: 6d62 6572 206f 6620 6f76 6572 6c61 7070  mber of overlapp
-0000a670: 696e 6720 7061 6972 733a 272c 2070 6f73  ing pairs:', pos
-0000a680: 7369 626c 655f 6f76 6572 6c61 7070 696e  sible_overlappin
-0000a690: 675f 7061 6972 7329 0a20 2020 2020 2020  g_pairs).       
-0000a6a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a5c0: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+0000a5d0: 706f 7373 6962 6c65 5f6f 7665 726c 6170  possible_overlap
+0000a5e0: 7069 6e67 5f70 6169 7273 203d 3d20 6375  ping_pairs == cu
+0000a5f0: 7272 656e 745f 6f76 6572 6c61 7070 696e  rrent_overlappin
+0000a600: 675f 7061 6972 733a 0a20 2020 2020 2020  g_pairs:.       
+0000a610: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a620: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a630: 2020 2020 2020 2020 2070 6f73 5f73 656c           pos_sel
+0000a640: 2e61 7070 656e 6428 6c6f 635b 6964 5f63  .append(loc[id_c
+0000a650: 656c 6c5d 290a 2020 2020 2020 2020 2020  ell]).          
+0000a660: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a670: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a680: 2020 2020 2020 7365 6c65 6374 6564 5f69        selected_i
+0000a690: 6478 732e 6170 7065 6e64 2869 645f 6365  dxs.append(id_ce
+0000a6a0: 6c6c 290a 2020 2020 2020 2020 2020 2020  ll).            
 0000a6b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a6c0: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
-0000a6d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a6c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a6d0: 2020 2020 6e5f 7365 6c20 2b3d 2031 0a20      n_sel += 1. 
 0000a6e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a6f0: 2020 2069 6620 706f 7373 6962 6c65 5f6f     if possible_o
-0000a700: 7665 726c 6170 7069 6e67 5f70 6169 7273  verlapping_pairs
-0000a710: 203d 3d20 6375 7272 656e 745f 6f76 6572   == current_over
-0000a720: 6c61 7070 696e 675f 7061 6972 733a 0a20  lapping_pairs:. 
+0000a6f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a700: 2020 2020 2020 2020 2020 2020 2020 2070                 p
+0000a710: 6c61 6365 6420 3d20 5472 7565 0a20 2020  laced = True.   
+0000a720: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000a730: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a740: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a750: 2020 2020 2020 2020 2020 2020 2020 2070                 p
-0000a760: 6f73 5f73 656c 2e61 7070 656e 6428 6c6f  os_sel.append(lo
-0000a770: 635b 6964 5f63 656c 6c5d 290a 2020 2020  c[id_cell]).    
-0000a780: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a740: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
+0000a750: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a760: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a770: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+0000a780: 6620 7665 7262 6f73 653a 0a20 2020 2020  f verbose:.     
 0000a790: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a7a0: 2020 2020 2020 2020 2020 2020 7365 6c65              sele
-0000a7b0: 6374 6564 5f69 6478 732e 6170 7065 6e64  cted_idxs.append
-0000a7c0: 2869 645f 6365 6c6c 290a 2020 2020 2020  (id_cell).      
-0000a7d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a7e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a7f0: 2020 2020 2020 2020 2020 6e5f 7365 6c20            n_sel 
-0000a800: 2b3d 2031 0a20 2020 2020 2020 2020 2020  += 1.           
-0000a810: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a7a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a7b0: 2020 2020 2020 2020 2020 2020 2020 2070                 p
+0000a7c0: 7269 6e74 2822 4f76 6572 6c61 7070 696e  rint("Overlappin
+0000a7d0: 6720 7669 6f6c 6174 696f 6e3a 222c 2070  g violation:", p
+0000a7e0: 6f73 7369 626c 655f 6f76 6572 6c61 7070  ossible_overlapp
+0000a7f0: 696e 675f 7061 6972 7329 0a20 2020 2020  ing_pairs).     
+0000a800: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a810: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
 0000a820: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a830: 2020 2020 2070 6c61 6365 6420 3d20 5472       placed = Tr
-0000a840: 7565 0a20 2020 2020 2020 2020 2020 2020  ue.             
+0000a830: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+0000a840: 7665 7262 6f73 653a 0a20 2020 2020 2020  verbose:.       
 0000a850: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a860: 2020 2020 2020 2020 2020 2020 2020 2065                 e
-0000a870: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
-0000a880: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a890: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a8a0: 2020 2020 2069 6620 7665 7262 6f73 653a       if verbose:
-0000a8b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000a8c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a860: 2020 2020 2020 2020 2020 2020 2070 7269               pri
+0000a870: 6e74 2822 416d 706c 6974 7564 6520 6f72  nt("Amplitude or
+0000a880: 2062 6f75 6e64 6172 7920 7669 6f6c 6174   boundary violat
+0000a890: 696f 6e22 2c20 616d 702c 206c 6f63 5b69  ion", amp, loc[i
+0000a8a0: 645f 6365 6c6c 5d2c 2069 7465 7229 0a20  d_cell], iter). 
+0000a8b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a8c0: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
 0000a8d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a8e0: 2020 2020 2070 7269 6e74 2827 4f76 6572       print('Over
-0000a8f0: 6c61 7070 696e 6720 7669 6f6c 6174 696f  lapping violatio
-0000a900: 6e3a 272c 2070 6f73 7369 626c 655f 6f76  n:', possible_ov
-0000a910: 6572 6c61 7070 696e 675f 7061 6972 7329  erlapping_pairs)
-0000a920: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000a930: 2020 2020 2020 2020 2020 2020 2065 6c73               els
-0000a940: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-0000a950: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a960: 2020 2069 6620 7665 7262 6f73 653a 0a20     if verbose:. 
-0000a970: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a8e0: 2020 2020 2020 2020 2023 2064 7269 6674           # drift
+0000a8f0: 696e 670a 2020 2020 2020 2020 2020 2020  ing.            
+0000a900: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a910: 6966 2028 0a20 2020 2020 2020 2020 2020  if (.           
+0000a920: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a930: 2020 2020 2069 735f 706f 7369 7469 6f6e       is_position
+0000a940: 5f77 6974 6869 6e5f 626f 756e 6461 7269  _within_boundari
+0000a950: 6573 286c 6f63 5b69 645f 6365 6c6c 2c20  es(loc[id_cell, 
+0000a960: 305d 2c20 785f 6c69 6d2c 2079 5f6c 696d  0], x_lim, y_lim
+0000a970: 2c20 7a5f 6c69 6d29 0a20 2020 2020 2020  , z_lim).       
 0000a980: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a990: 2020 2070 7269 6e74 2827 416d 706c 6974     print('Amplit
-0000a9a0: 7564 6520 6f72 2062 6f75 6e64 6172 7920  ude or boundary 
-0000a9b0: 7669 6f6c 6174 696f 6e27 2c20 616d 702c  violation', amp,
-0000a9c0: 206c 6f63 5b69 645f 6365 6c6c 5d2c 2069   loc[id_cell], i
-0000a9d0: 7465 7229 0a20 2020 2020 2020 2020 2020  ter).           
-0000a9e0: 2020 2020 2020 2020 2020 2020 2065 6c73               els
-0000a9f0: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-0000aa00: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-0000aa10: 2064 7269 6674 696e 670a 2020 2020 2020   drifting.      
-0000aa20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000aa30: 2020 2020 2020 6966 2069 735f 706f 7369        if is_posi
-0000aa40: 7469 6f6e 5f77 6974 6869 6e5f 626f 756e  tion_within_boun
-0000aa50: 6461 7269 6573 286c 6f63 5b69 645f 6365  daries(loc[id_ce
-0000aa60: 6c6c 2c20 305d 2c20 785f 6c69 6d2c 2079  ll, 0], x_lim, y
-0000aa70: 5f6c 696d 2c20 7a5f 6c69 6d29 205c 0a20  _lim, z_lim) \. 
-0000aa80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000aa90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000aaa0: 2020 2061 6e64 206d 696e 5f61 6d70 203c     and min_amp <
-0000aab0: 2061 6d70 203c 206d 6178 5f61 6d70 3a0a   amp < max_amp:.
+0000a990: 2020 2020 2020 2020 2061 6e64 206d 696e           and min
+0000a9a0: 5f61 6d70 203c 2061 6d70 203c 206d 6178  _amp < amp < max
+0000a9b0: 5f61 6d70 0a20 2020 2020 2020 2020 2020  _amp.           
+0000a9c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a9d0: 2029 3a0a 2020 2020 2020 2020 2020 2020   ):.            
+0000a9e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a9f0: 2020 2020 2320 7361 7665 2063 656c 6c0a      # save cell.
+0000aa00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000aa10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000aa20: 6472 6966 745f 616e 676c 6520 3d20 6e70  drift_angle = np
+0000aa30: 2e72 6164 3264 6567 286e 702e 6172 6363  .rad2deg(np.arcc
+0000aa40: 6f73 286e 702e 646f 7428 6472 6966 745f  os(np.dot(drift_
+0000aa50: 6469 725b 6964 5f63 656c 6c5d 2c20 7072  dir[id_cell], pr
+0000aa60: 6566 6572 7265 645f 6469 7229 2929 0a20  eferred_dir))). 
+0000aa70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000aa80: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+0000aa90: 6620 6472 6966 745f 616e 676c 6520 2d20  f drift_angle - 
+0000aaa0: 616e 676c 655f 746f 6c20 3c3d 2030 3a0a  angle_tol <= 0:.
+0000aab0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000aac0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000aad0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000aae0: 2320 7361 7665 2063 656c 6c0a 2020 2020  # save cell.    
+0000aad0: 2020 2020 6966 206e 5f6f 7665 726c 6170      if n_overlap
+0000aae0: 5f70 6169 7273 2069 7320 4e6f 6e65 3a0a  _pairs is None:.
 0000aaf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ab00: 2020 2020 2020 2020 2020 2020 6472 6966              drif
-0000ab10: 745f 616e 676c 6520 3d20 6e70 2e72 6164  t_angle = np.rad
-0000ab20: 3264 6567 286e 702e 6172 6363 6f73 286e  2deg(np.arccos(n
-0000ab30: 702e 646f 7428 6472 6966 745f 6469 725b  p.dot(drift_dir[
-0000ab40: 6964 5f63 656c 6c5d 2c20 7072 6566 6572  id_cell], prefer
-0000ab50: 7265 645f 6469 7229 2929 0a20 2020 2020  red_dir))).     
-0000ab60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ab70: 2020 2020 2020 2020 2020 2069 6620 6472             if dr
-0000ab80: 6966 745f 616e 676c 6520 2d20 616e 676c  ift_angle - angl
-0000ab90: 655f 746f 6c20 3c3d 2030 3a0a 2020 2020  e_tol <= 0:.    
-0000aba0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ab00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ab10: 2020 2020 2020 2020 706f 735f 7365 6c2e          pos_sel.
+0000ab20: 6170 7065 6e64 286c 6f63 5b69 645f 6365  append(loc[id_ce
+0000ab30: 6c6c 5d29 0a20 2020 2020 2020 2020 2020  ll]).           
+0000ab40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ab50: 2020 2020 2020 2020 2020 2020 2073 656c               sel
+0000ab60: 6563 7465 645f 6964 7873 2e61 7070 656e  ected_idxs.appen
+0000ab70: 6428 6964 5f63 656c 6c29 0a20 2020 2020  d(id_cell).     
+0000ab80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ab90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000aba0: 2020 206e 5f73 656c 202b 3d20 310a 2020     n_sel += 1.  
 0000abb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000abc0: 6966 206e 5f6f 7665 726c 6170 5f70 6169  if n_overlap_pai
-0000abd0: 7273 2069 7320 4e6f 6e65 3a0a 2020 2020  rs is None:.    
-0000abe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000abc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000abd0: 2020 2020 2020 706c 6163 6564 203d 2054        placed = T
+0000abe0: 7275 650a 2020 2020 2020 2020 2020 2020  rue.            
 0000abf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ac00: 2020 2020 706f 735f 7365 6c2e 6170 7065      pos_sel.appe
-0000ac10: 6e64 286c 6f63 5b69 645f 6365 6c6c 5d29  nd(loc[id_cell])
-0000ac20: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000ac30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ac40: 2020 2020 2020 2020 2073 656c 6563 7465           selecte
-0000ac50: 645f 6964 7873 2e61 7070 656e 6428 6964  d_idxs.append(id
-0000ac60: 5f63 656c 6c29 0a20 2020 2020 2020 2020  _cell).         
-0000ac70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ac80: 2020 2020 2020 2020 2020 2020 2020 206e                 n
-0000ac90: 5f73 656c 202b 3d20 310a 2020 2020 2020  _sel += 1.      
+0000ac00: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+0000ac10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ac20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ac30: 2020 2020 2020 6966 206c 656e 2873 656c        if len(sel
+0000ac40: 6563 7465 645f 6964 7873 2920 3d3d 2030  ected_idxs) == 0
+0000ac50: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0000ac60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ac70: 2020 2020 2020 2020 2020 2020 2020 2320                # 
+0000ac80: 7361 7665 2063 656c 6c0a 2020 2020 2020  save cell.      
+0000ac90: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000aca0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000acb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000acc0: 2020 706c 6163 6564 203d 2054 7275 650a    placed = True.
-0000acd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000acb0: 2020 2020 2020 706f 735f 7365 6c2e 6170        pos_sel.ap
+0000acc0: 7065 6e64 286c 6f63 5b69 645f 6365 6c6c  pend(loc[id_cell
+0000acd0: 5d29 0a20 2020 2020 2020 2020 2020 2020  ]).             
 0000ace0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000acf0: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-0000ad00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ad10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ad20: 2020 6966 206c 656e 2873 656c 6563 7465    if len(selecte
-0000ad30: 645f 6964 7873 2920 3d3d 2030 3a0a 2020  d_idxs) == 0:.  
-0000ad40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ad50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ad60: 2020 2020 2020 2020 2020 2320 7361 7665            # save
-0000ad70: 2063 656c 6c0a 2020 2020 2020 2020 2020   cell.          
-0000ad80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000acf0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+0000ad00: 656c 6563 7465 645f 6964 7873 2e61 7070  elected_idxs.app
+0000ad10: 656e 6428 6964 5f63 656c 6c29 0a20 2020  end(id_cell).   
+0000ad20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ad30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ad40: 2020 2020 2020 2020 206e 5f73 656c 202b           n_sel +
+0000ad50: 3d20 310a 2020 2020 2020 2020 2020 2020  = 1.            
+0000ad60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ad70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ad80: 706c 6163 6564 203d 2054 7275 650a 2020  placed = True.  
 0000ad90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ada0: 2020 706f 735f 7365 6c2e 6170 7065 6e64    pos_sel.append
-0000adb0: 286c 6f63 5b69 645f 6365 6c6c 5d29 0a20  (loc[id_cell]). 
+0000ada0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000adb0: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
 0000adc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000add0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ade0: 2020 2020 2020 2020 2020 2073 656c 6563             selec
-0000adf0: 7465 645f 6964 7873 2e61 7070 656e 6428  ted_idxs.append(
-0000ae00: 6964 5f63 656c 6c29 0a20 2020 2020 2020  id_cell).       
-0000ae10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ade0: 2020 2020 2020 2020 706f 7373 6962 6c65          possible
+0000adf0: 5f73 656c 6563 7465 6420 3d20 6465 6570  _selected = deep
+0000ae00: 636f 7079 2873 656c 6563 7465 645f 6964  copy(selected_id
+0000ae10: 7873 290a 2020 2020 2020 2020 2020 2020  xs).            
 0000ae20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ae30: 2020 2020 206e 5f73 656c 202b 3d20 310a       n_sel += 1.
-0000ae40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ae50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ae60: 2020 2020 2020 2020 2020 2020 706c 6163              plac
-0000ae70: 6564 203d 2054 7275 650a 2020 2020 2020  ed = True.      
-0000ae80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ae90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000aea0: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+0000ae30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ae40: 706f 7373 6962 6c65 5f73 656c 6563 7465  possible_selecte
+0000ae50: 642e 6170 7065 6e64 2869 645f 6365 6c6c  d.append(id_cell
+0000ae60: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+0000ae70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ae80: 2020 2020 2020 2020 2020 2020 2020 706f                po
+0000ae90: 7373 6962 6c65 5f6f 7665 726c 6170 7069  ssible_overlappi
+0000aea0: 6e67 5f70 6169 7273 203d 206c 656e 280a  ng_pairs = len(.
 0000aeb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000aec0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000aed0: 2020 2020 706f 7373 6962 6c65 5f73 656c      possible_sel
-0000aee0: 6563 7465 6420 3d20 6465 6570 636f 7079  ected = deepcopy
-0000aef0: 2873 656c 6563 7465 645f 6964 7873 290a  (selected_idxs).
+0000aed0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000aee0: 6669 6e64 5f6f 7665 726c 6170 7069 6e67  find_overlapping
+0000aef0: 5f74 656d 706c 6174 6573 280a 2020 2020  _templates(.    
 0000af00: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000af10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000af20: 2020 2020 2020 2020 2020 2020 706f 7373              poss
-0000af30: 6962 6c65 5f73 656c 6563 7465 642e 6170  ible_selected.ap
-0000af40: 7065 6e64 2869 645f 6365 6c6c 290a 2020  pend(id_cell).  
-0000af50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000af60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000af70: 2020 2020 2020 2020 2020 706f 7373 6962            possib
-0000af80: 6c65 5f6f 7665 726c 6170 7069 6e67 5f70  le_overlapping_p
-0000af90: 6169 7273 203d 206c 656e 2866 696e 645f  airs = len(find_
-0000afa0: 6f76 6572 6c61 7070 696e 675f 7465 6d70  overlapping_temp
-0000afb0: 6c61 7465 7328 0a20 2020 2020 2020 2020  lates(.         
-0000afc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000af20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000af30: 7465 6d70 6c61 7465 735b 736f 7274 6564  templates[sorted
+0000af40: 2870 6f73 7369 626c 655f 7365 6c65 6374  (possible_select
+0000af50: 6564 292c 2030 5d2c 206f 7665 726c 6170  ed), 0], overlap
+0000af60: 5f74 6872 6573 686f 6c64 0a20 2020 2020  _threshold.     
+0000af70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000af80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000af90: 2020 2020 2020 2020 2020 2029 0a20 2020             ).   
+0000afa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000afb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000afc0: 2020 2020 2020 2020 2029 0a20 2020 2020           ).     
 0000afd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000afe0: 2020 2020 2020 2074 656d 706c 6174 6573         templates
-0000aff0: 5b73 6f72 7465 6428 706f 7373 6962 6c65  [sorted(possible
-0000b000: 5f73 656c 6563 7465 6429 2c20 305d 2c0a  _selected), 0],.
-0000b010: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000afe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000aff0: 2020 2020 2020 2063 7572 7265 6e74 5f6f         current_o
+0000b000: 7665 726c 6170 7069 6e67 5f70 6169 7273  verlapping_pairs
+0000b010: 203d 206c 656e 280a 2020 2020 2020 2020   = len(.        
 0000b020: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000b030: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b040: 6f76 6572 6c61 705f 7468 7265 7368 6f6c  overlap_threshol
-0000b050: 6429 290a 2020 2020 2020 2020 2020 2020  d)).            
-0000b060: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b040: 2020 2020 2020 2020 6669 6e64 5f6f 7665          find_ove
+0000b050: 726c 6170 7069 6e67 5f74 656d 706c 6174  rlapping_templat
+0000b060: 6573 280a 2020 2020 2020 2020 2020 2020  es(.            
 0000b070: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b080: 6375 7272 656e 745f 6f76 6572 6c61 7070  current_overlapp
-0000b090: 696e 675f 7061 6972 7320 3d20 6c65 6e28  ing_pairs = len(
-0000b0a0: 6669 6e64 5f6f 7665 726c 6170 7069 6e67  find_overlapping
-0000b0b0: 5f74 656d 706c 6174 6573 280a 2020 2020  _templates(.    
-0000b0c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b080: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b090: 2020 2020 2020 2020 7465 6d70 6c61 7465          template
+0000b0a0: 735b 736f 7274 6564 2873 656c 6563 7465  s[sorted(selecte
+0000b0b0: 645f 6964 7873 292c 2030 5d2c 206f 7665  d_idxs), 0], ove
+0000b0c0: 726c 6170 5f74 6872 6573 686f 6c64 0a20  rlap_threshold. 
 0000b0d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b0e0: 2020 2020 2020 2020 2020 2020 7465 6d70              temp
-0000b0f0: 6c61 7465 735b 736f 7274 6564 2873 656c  lates[sorted(sel
-0000b100: 6563 7465 645f 6964 7873 292c 2030 5d2c  ected_idxs), 0],
-0000b110: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000b120: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b0e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b0f0: 2020 2020 2020 2020 2020 2020 2020 2029                 )
+0000b100: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000b110: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b120: 2020 2020 2020 2020 2020 2020 2029 0a20               ). 
 0000b130: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b140: 206f 7665 726c 6170 5f74 6872 6573 686f   overlap_thresho
-0000b150: 6c64 2929 0a20 2020 2020 2020 2020 2020  ld)).           
+0000b140: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b150: 2020 2020 2020 2020 2020 2069 6620 280a             if (.
 0000b160: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000b170: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b180: 2069 6620 6375 7272 656e 745f 6f76 6572   if current_over
-0000b190: 6c61 7070 696e 675f 7061 6972 7320 3c20  lapping_pairs < 
-0000b1a0: 6e5f 6f76 6572 6c61 705f 7061 6972 7320  n_overlap_pairs 
-0000b1b0: 616e 6420 5c0a 2020 2020 2020 2020 2020  and \.          
+0000b180: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b190: 6375 7272 656e 745f 6f76 6572 6c61 7070  current_overlapp
+0000b1a0: 696e 675f 7061 6972 7320 3c20 6e5f 6f76  ing_pairs < n_ov
+0000b1b0: 6572 6c61 705f 7061 6972 730a 2020 2020  erlap_pairs.    
 0000b1c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000b1d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b1e0: 2020 2020 2020 2020 2020 706f 7373 6962            possib
-0000b1f0: 6c65 5f6f 7665 726c 6170 7069 6e67 5f70  le_overlapping_p
-0000b200: 6169 7273 203c 3d20 6e5f 6f76 6572 6c61  airs <= n_overla
-0000b210: 705f 7061 6972 733a 0a20 2020 2020 2020  p_pairs:.       
+0000b1e0: 2020 2020 2020 2020 2020 2020 616e 6420              and 
+0000b1f0: 706f 7373 6962 6c65 5f6f 7665 726c 6170  possible_overlap
+0000b200: 7069 6e67 5f70 6169 7273 203c 3d20 6e5f  ping_pairs <= n_
+0000b210: 6f76 6572 6c61 705f 7061 6972 730a 2020  overlap_pairs.  
 0000b220: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000b230: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b240: 2020 2020 2020 2020 2069 6620 706f 7373           if poss
-0000b250: 6962 6c65 5f6f 7665 726c 6170 7069 6e67  ible_overlapping
-0000b260: 5f70 6169 7273 203d 3d20 6375 7272 656e  _pairs == curren
-0000b270: 745f 6f76 6572 6c61 7070 696e 675f 7061  t_overlapping_pa
-0000b280: 6972 733a 0a20 2020 2020 2020 2020 2020  irs:.           
-0000b290: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b2a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b2b0: 2020 2020 2020 2020 2063 6f6e 7469 6e75           continu
-0000b2c0: 650a 2020 2020 2020 2020 2020 2020 2020  e.              
+0000b240: 2020 2020 2020 2020 2020 293a 0a20 2020            ):.   
+0000b250: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b260: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b270: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+0000b280: 706f 7373 6962 6c65 5f6f 7665 726c 6170  possible_overlap
+0000b290: 7069 6e67 5f70 6169 7273 203d 3d20 6375  ping_pairs == cu
+0000b2a0: 7272 656e 745f 6f76 6572 6c61 7070 696e  rrent_overlappin
+0000b2b0: 675f 7061 6972 733a 0a20 2020 2020 2020  g_pairs:.       
+0000b2c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000b2d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b2e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b2f0: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+0000b2e0: 2020 2020 2020 2020 2020 2020 2063 6f6e               con
+0000b2f0: 7469 6e75 650a 2020 2020 2020 2020 2020  tinue.          
 0000b300: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000b310: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b320: 2020 2020 2020 2020 2020 2020 706f 735f              pos_
-0000b330: 7365 6c2e 6170 7065 6e64 286c 6f63 5b69  sel.append(loc[i
-0000b340: 645f 6365 6c6c 5d29 0a20 2020 2020 2020  d_cell]).       
+0000b320: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+0000b330: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b340: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000b350: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b360: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b370: 2020 2020 2020 2020 2020 2020 2073 656c               sel
-0000b380: 6563 7465 645f 6964 7873 2e61 7070 656e  ected_idxs.appen
-0000b390: 6428 6964 5f63 656c 6c29 0a20 2020 2020  d(id_cell).     
+0000b360: 706f 735f 7365 6c2e 6170 7065 6e64 286c  pos_sel.append(l
+0000b370: 6f63 5b69 645f 6365 6c6c 5d29 0a20 2020  oc[id_cell]).   
+0000b380: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b390: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000b3a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b3b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b3c0: 2020 2020 2020 2020 2020 2020 2020 206e                 n
-0000b3d0: 5f73 656c 202b 3d20 310a 2020 2020 2020  _sel += 1.      
+0000b3b0: 2073 656c 6563 7465 645f 6964 7873 2e61   selected_idxs.a
+0000b3c0: 7070 656e 6428 6964 5f63 656c 6c29 0a20  ppend(id_cell). 
+0000b3d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000b3e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000b3f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b400: 2020 2020 2020 2020 2020 2020 2020 706c                pl
-0000b410: 6163 6564 203d 2054 7275 650a 2020 2020  aced = True.    
+0000b400: 2020 206e 5f73 656c 202b 3d20 310a 2020     n_sel += 1.  
+0000b410: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000b420: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000b430: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b440: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b450: 6966 2076 6572 626f 7365 3a0a 2020 2020  if verbose:.    
+0000b440: 2020 706c 6163 6564 203d 2054 7275 650a    placed = True.
+0000b450: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000b460: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000b470: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b480: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b490: 2020 2020 7072 696e 7428 274e 756d 6265      print('Numbe
-0000b4a0: 7220 6f66 206f 7665 726c 6170 7069 6e67  r of overlapping
-0000b4b0: 2070 6169 7273 3a27 2c0a 2020 2020 2020   pairs:',.      
-0000b4c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b480: 2020 2020 6966 2076 6572 626f 7365 3a0a      if verbose:.
+0000b490: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b4a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b4b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b4c0: 2020 2020 2020 2020 7072 696e 7428 0a20          print(. 
 0000b4d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000b4e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b4f0: 2020 2020 2020 2020 706f 7373 6962 6c65          possible
-0000b500: 5f6f 7665 726c 6170 7069 6e67 5f70 6169  _overlapping_pai
-0000b510: 7273 290a 2020 2020 2020 2020 2020 2020  rs).            
-0000b520: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b530: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b540: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+0000b4f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b500: 2020 2020 2020 2020 2020 2022 4e75 6d62             "Numb
+0000b510: 6572 206f 6620 6f76 6572 6c61 7070 696e  er of overlappin
+0000b520: 6720 7061 6972 733a 222c 2070 6f73 7369  g pairs:", possi
+0000b530: 626c 655f 6f76 6572 6c61 7070 696e 675f  ble_overlapping_
+0000b540: 7061 6972 730a 2020 2020 2020 2020 2020  pairs.          
 0000b550: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000b560: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b570: 2020 2020 2020 6966 2070 6f73 7369 626c        if possibl
-0000b580: 655f 6f76 6572 6c61 7070 696e 675f 7061  e_overlapping_pa
-0000b590: 6972 7320 3d3d 2063 7572 7265 6e74 5f6f  irs == current_o
-0000b5a0: 7665 726c 6170 7069 6e67 5f70 6169 7273  verlapping_pairs
+0000b570: 2020 2020 2020 2020 2020 2020 2020 290a                ).
+0000b580: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b590: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b5a0: 2020 2020 2020 2020 2020 2020 656c 7365              else
 0000b5b0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
 0000b5c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000b5d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b5e0: 2020 2020 2020 706f 735f 7365 6c2e 6170        pos_sel.ap
-0000b5f0: 7065 6e64 286c 6f63 5b69 645f 6365 6c6c  pend(loc[id_cell
-0000b600: 5d29 0a20 2020 2020 2020 2020 2020 2020  ]).             
-0000b610: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b5e0: 2020 6966 2070 6f73 7369 626c 655f 6f76    if possible_ov
+0000b5f0: 6572 6c61 7070 696e 675f 7061 6972 7320  erlapping_pairs 
+0000b600: 3d3d 2063 7572 7265 6e74 5f6f 7665 726c  == current_overl
+0000b610: 6170 7069 6e67 5f70 6169 7273 3a0a 2020  apping_pairs:.  
 0000b620: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b630: 2020 2020 2020 2073 656c 6563 7465 645f         selected_
-0000b640: 6964 7873 2e61 7070 656e 6428 6964 5f63  idxs.append(id_c
-0000b650: 656c 6c29 0a20 2020 2020 2020 2020 2020  ell).           
-0000b660: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b630: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b640: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b650: 2020 706f 735f 7365 6c2e 6170 7065 6e64    pos_sel.append
+0000b660: 286c 6f63 5b69 645f 6365 6c6c 5d29 0a20  (loc[id_cell]). 
 0000b670: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b680: 2020 2020 2020 2020 206e 5f73 656c 202b           n_sel +
-0000b690: 3d20 310a 2020 2020 2020 2020 2020 2020  = 1.            
-0000b6a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b6b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b6c0: 2020 2020 2020 2020 706c 6163 6564 203d          placed =
-0000b6d0: 2054 7275 650a 2020 2020 2020 2020 2020   True.          
+0000b680: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b690: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b6a0: 2020 2073 656c 6563 7465 645f 6964 7873     selected_idxs
+0000b6b0: 2e61 7070 656e 6428 6964 5f63 656c 6c29  .append(id_cell)
+0000b6c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000b6d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000b6e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b6f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b700: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+0000b6f0: 2020 2020 206e 5f73 656c 202b 3d20 310a       n_sel += 1.
+0000b700: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000b710: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000b720: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b730: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b740: 6966 2076 6572 626f 7365 3a0a 2020 2020  if verbose:.    
+0000b730: 2020 2020 706c 6163 6564 203d 2054 7275      placed = Tru
+0000b740: 650a 2020 2020 2020 2020 2020 2020 2020  e.              
 0000b750: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000b760: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b770: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b780: 2020 2020 7072 696e 7428 274f 7665 726c      print('Overl
-0000b790: 6170 7069 6e67 2076 696f 6c61 7469 6f6e  apping violation
-0000b7a0: 3a27 2c20 706f 7373 6962 6c65 5f6f 7665  :', possible_ove
-0000b7b0: 726c 6170 7069 6e67 5f70 6169 7273 290a  rlapping_pairs).
+0000b770: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+0000b780: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b790: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b7a0: 2020 2020 2020 2020 2020 2020 6966 2076              if v
+0000b7b0: 6572 626f 7365 3a0a 2020 2020 2020 2020  erbose:.        
 0000b7c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000b7d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b7e0: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
-0000b7f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b800: 2020 2020 2020 2020 2020 6966 2076 6572            if ver
-0000b810: 626f 7365 3a0a 2020 2020 2020 2020 2020  bose:.          
-0000b820: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b830: 2020 2020 2020 2020 2020 2020 2020 7072                pr
-0000b840: 696e 7428 2744 7269 6674 2076 696f 6c61  int('Drift viola
-0000b850: 7469 6f6e 272c 206c 6f63 5b69 645f 6365  tion', loc[id_ce
-0000b860: 6c6c 2c20 305d 2c20 6974 6572 290a 2020  ll, 0], iter).  
-0000b870: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b880: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
+0000b7e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b7f0: 7072 696e 7428 224f 7665 726c 6170 7069  print("Overlappi
+0000b800: 6e67 2076 696f 6c61 7469 6f6e 3a22 2c20  ng violation:", 
+0000b810: 706f 7373 6962 6c65 5f6f 7665 726c 6170  possible_overlap
+0000b820: 7069 6e67 5f70 6169 7273 290a 2020 2020  ping_pairs).    
+0000b830: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b840: 2020 2020 2020 2020 2020 2020 656c 7365              else
+0000b850: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0000b860: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b870: 2020 2020 2020 6966 2076 6572 626f 7365        if verbose
+0000b880: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
 0000b890: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b8a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b8b0: 6966 2076 6572 626f 7365 3a0a 2020 2020  if verbose:.    
-0000b8c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b8d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b8e0: 7072 696e 7428 2741 6d70 6c69 7475 6465  print('Amplitude
-0000b8f0: 206f 7220 626f 756e 6461 7279 2076 696f   or boundary vio
-0000b900: 6c61 7469 6f6e 272c 2061 6d70 2c20 6c6f  lation', amp, lo
-0000b910: 635b 6964 5f63 656c 6c2c 2030 5d2c 2069  c[id_cell, 0], i
-0000b920: 7465 7229 0a20 2020 2020 2020 2020 2020  ter).           
-0000b930: 2020 2020 2020 2020 2069 6620 706c 6163           if plac
-0000b940: 6564 3a0a 2020 2020 2020 2020 2020 2020  ed:.            
-0000b950: 2020 2020 2020 2020 2020 2020 6e5f 7365              n_se
-0000b960: 6c5f 6578 6320 2b3d 2031 0a20 2020 2020  l_exc += 1.     
-0000b970: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b980: 2020 2073 656c 6563 7465 645f 6361 742e     selected_cat.
-0000b990: 6170 7065 6e64 2827 4527 290a 2020 2020  append('E').    
-0000b9a0: 2020 2020 2020 2020 656c 6966 2062 6361          elif bca
-0000b9b0: 7420 3d3d 2027 4927 3a0a 2020 2020 2020  t == 'I':.      
-0000b9c0: 2020 2020 2020 2020 2020 6966 206e 5f73            if n_s
-0000b9d0: 656c 5f69 6e68 203c 206e 5f69 6e68 3a0a  el_inh < n_inh:.
-0000b9e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b9f0: 2020 2020 6469 7374 203d 206e 702e 6172      dist = np.ar
-0000ba00: 7261 7928 5b6e 702e 6c69 6e61 6c67 2e6e  ray([np.linalg.n
-0000ba10: 6f72 6d28 6c6f 635b 6964 5f63 656c 6c5d  orm(loc[id_cell]
-0000ba20: 202d 2070 2920 666f 7220 7020 696e 2070   - p) for p in p
-0000ba30: 6f73 5f73 656c 5d29 0a20 2020 2020 2020  os_sel]).       
-0000ba40: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-0000ba50: 6e70 2e61 6e79 2864 6973 7420 3c20 6d69  np.any(dist < mi
-0000ba60: 6e5f 6469 7374 293a 0a20 2020 2020 2020  n_dist):.       
-0000ba70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ba80: 2069 6620 7665 7262 6f73 653a 0a20 2020   if verbose:.   
-0000ba90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000baa0: 2020 2020 2020 2020 2070 7269 6e74 2827           print('
-0000bab0: 4469 7374 616e 6365 2076 696f 6c61 7469  Distance violati
-0000bac0: 6f6e 272c 206e 702e 6d69 6e28 6469 7374  on', np.min(dist
-0000bad0: 292c 2069 7465 7229 0a20 2020 2020 2020  ), iter).       
-0000bae0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000baf0: 2070 6173 730a 2020 2020 2020 2020 2020   pass.          
-0000bb00: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
-0000bb10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bb20: 2020 2020 2020 2020 616d 7020 3d20 6e70          amp = np
-0000bb30: 2e6d 6178 286e 702e 6162 7328 6e70 2e6d  .max(np.abs(np.m
-0000bb40: 696e 2874 656d 706c 6174 6573 5b69 645f  in(templates[id_
-0000bb50: 6365 6c6c 5d29 2929 0a20 2020 2020 2020  cell]))).       
-0000bb60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bb70: 2069 6620 6e6f 7420 6472 6966 7469 6e67   if not drifting
-0000bb80: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0000bb90: 2020 2020 2020 2020 2020 2020 2020 6966                if
-0000bba0: 2069 735f 706f 7369 7469 6f6e 5f77 6974   is_position_wit
-0000bbb0: 6869 6e5f 626f 756e 6461 7269 6573 286c  hin_boundaries(l
-0000bbc0: 6f63 5b69 645f 6365 6c6c 5d2c 2078 5f6c  oc[id_cell], x_l
-0000bbd0: 696d 2c20 795f 6c69 6d2c 207a 5f6c 696d  im, y_lim, z_lim
-0000bbe0: 2920 5c0a 2020 2020 2020 2020 2020 2020  ) \.            
-0000bbf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bc00: 2020 2020 2020 2020 616e 6420 6d69 6e5f          and min_
-0000bc10: 616d 7020 3c20 616d 7020 3c20 6d61 785f  amp < amp < max_
-0000bc20: 616d 703a 0a20 2020 2020 2020 2020 2020  amp:.           
+0000b8a0: 2020 2020 2020 2020 2020 7072 696e 7428            print(
+0000b8b0: 2244 7269 6674 2076 696f 6c61 7469 6f6e  "Drift violation
+0000b8c0: 222c 206c 6f63 5b69 645f 6365 6c6c 2c20  ", loc[id_cell, 
+0000b8d0: 305d 2c20 6974 6572 290a 2020 2020 2020  0], iter).      
+0000b8e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b8f0: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+0000b900: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b910: 2020 2020 2020 2020 2020 2020 6966 2076              if v
+0000b920: 6572 626f 7365 3a0a 2020 2020 2020 2020  erbose:.        
+0000b930: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b940: 2020 2020 2020 2020 2020 2020 7072 696e              prin
+0000b950: 7428 2241 6d70 6c69 7475 6465 206f 7220  t("Amplitude or 
+0000b960: 626f 756e 6461 7279 2076 696f 6c61 7469  boundary violati
+0000b970: 6f6e 222c 2061 6d70 2c20 6c6f 635b 6964  on", amp, loc[id
+0000b980: 5f63 656c 6c2c 2030 5d2c 2069 7465 7229  _cell, 0], iter)
+0000b990: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000b9a0: 2020 2020 2069 6620 706c 6163 6564 3a0a       if placed:.
+0000b9b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b9c0: 2020 2020 2020 2020 6e5f 7365 6c5f 6578          n_sel_ex
+0000b9d0: 6320 2b3d 2031 0a20 2020 2020 2020 2020  c += 1.         
+0000b9e0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+0000b9f0: 656c 6563 7465 645f 6361 742e 6170 7065  elected_cat.appe
+0000ba00: 6e64 2822 4522 290a 2020 2020 2020 2020  nd("E").        
+0000ba10: 2020 2020 2320 696e 6869 6269 746f 7279      # inhibitory
+0000ba20: 2063 656c 6c0a 2020 2020 2020 2020 2020   cell.          
+0000ba30: 2020 656c 6966 2062 6361 7420 3d3d 2022    elif bcat == "
+0000ba40: 4922 3a0a 2020 2020 2020 2020 2020 2020  I":.            
+0000ba50: 2020 2020 6966 206e 5f73 656c 5f69 6e68      if n_sel_inh
+0000ba60: 203c 206e 5f69 6e68 3a0a 2020 2020 2020   < n_inh:.      
+0000ba70: 2020 2020 2020 2020 2020 2020 2020 6469                di
+0000ba80: 7374 203d 206e 702e 6172 7261 7928 5b6e  st = np.array([n
+0000ba90: 702e 6c69 6e61 6c67 2e6e 6f72 6d28 6c6f  p.linalg.norm(lo
+0000baa0: 635b 6964 5f63 656c 6c5d 202d 2070 2920  c[id_cell] - p) 
+0000bab0: 666f 7220 7020 696e 2070 6f73 5f73 656c  for p in pos_sel
+0000bac0: 5d29 0a20 2020 2020 2020 2020 2020 2020  ]).             
+0000bad0: 2020 2020 2020 2069 6620 6e70 2e61 6e79         if np.any
+0000bae0: 2864 6973 7420 3c20 6d69 6e5f 6469 7374  (dist < min_dist
+0000baf0: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
+0000bb00: 2020 2020 2020 2020 2020 2069 6620 7665             if ve
+0000bb10: 7262 6f73 653a 0a20 2020 2020 2020 2020  rbose:.         
+0000bb20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bb30: 2020 2070 7269 6e74 2822 4469 7374 616e     print("Distan
+0000bb40: 6365 2076 696f 6c61 7469 6f6e 222c 206e  ce violation", n
+0000bb50: 702e 6d69 6e28 6469 7374 292c 2069 7465  p.min(dist), ite
+0000bb60: 7229 0a20 2020 2020 2020 2020 2020 2020  r).             
+0000bb70: 2020 2020 2020 2020 2020 2070 6173 730a             pass.
+0000bb80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bb90: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+0000bba0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bbb0: 2020 616d 7020 3d20 6e70 2e6d 6178 286e    amp = np.max(n
+0000bbc0: 702e 6162 7328 6e70 2e6d 696e 2874 656d  p.abs(np.min(tem
+0000bbd0: 706c 6174 6573 5b69 645f 6365 6c6c 5d29  plates[id_cell])
+0000bbe0: 2929 0a20 2020 2020 2020 2020 2020 2020  )).             
+0000bbf0: 2020 2020 2020 2020 2020 2069 6620 6e6f             if no
+0000bc00: 7420 6472 6966 7469 6e67 3a0a 2020 2020  t drifting:.    
+0000bc10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bc20: 2020 2020 2020 2020 6966 2028 0a20 2020          if (.   
 0000bc30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bc40: 2020 2020 2023 2073 6176 6520 6365 6c6c       # save cell
-0000bc50: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000bc60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bc70: 2069 6620 6e5f 6f76 6572 6c61 705f 7061   if n_overlap_pa
-0000bc80: 6972 7320 6973 204e 6f6e 653a 0a20 2020  irs is None:.   
+0000bc40: 2020 2020 2020 2020 2020 2020 2069 735f               is_
+0000bc50: 706f 7369 7469 6f6e 5f77 6974 6869 6e5f  position_within_
+0000bc60: 626f 756e 6461 7269 6573 286c 6f63 5b69  boundaries(loc[i
+0000bc70: 645f 6365 6c6c 5d2c 2078 5f6c 696d 2c20  d_cell], x_lim, 
+0000bc80: 795f 6c69 6d2c 207a 5f6c 696d 290a 2020  y_lim, z_lim).  
 0000bc90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bca0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bcb0: 2070 6f73 5f73 656c 2e61 7070 656e 6428   pos_sel.append(
-0000bcc0: 6c6f 635b 6964 5f63 656c 6c5d 290a 2020  loc[id_cell]).  
+0000bca0: 2020 2020 2020 2020 2020 2020 2020 616e                an
+0000bcb0: 6420 6d69 6e5f 616d 7020 3c20 616d 7020  d min_amp < amp 
+0000bcc0: 3c20 6d61 785f 616d 700a 2020 2020 2020  < max_amp.      
 0000bcd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bce0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bcf0: 2020 7365 6c65 6374 6564 5f69 6478 732e    selected_idxs.
-0000bd00: 6170 7065 6e64 2869 645f 6365 6c6c 290a  append(id_cell).
-0000bd10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bce0: 2020 2020 2020 293a 0a20 2020 2020 2020        ):.       
+0000bcf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bd00: 2020 2020 2020 2020 2023 2073 6176 6520           # save 
+0000bd10: 6365 6c6c 0a20 2020 2020 2020 2020 2020  cell.           
 0000bd20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bd30: 2020 2020 6e5f 7365 6c20 2b3d 2031 0a20      n_sel += 1. 
-0000bd40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bd50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bd60: 2020 2070 6c61 6365 6420 3d20 5472 7565     placed = True
-0000bd70: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000bd80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bd90: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+0000bd30: 2020 2020 2069 6620 6e5f 6f76 6572 6c61       if n_overla
+0000bd40: 705f 7061 6972 7320 6973 204e 6f6e 653a  p_pairs is None:
+0000bd50: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000bd60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bd70: 2020 2020 2070 6f73 5f73 656c 2e61 7070       pos_sel.app
+0000bd80: 656e 6428 6c6f 635b 6964 5f63 656c 6c5d  end(loc[id_cell]
+0000bd90: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
 0000bda0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bdb0: 2020 2020 2020 2020 2020 2069 6620 6c65             if le
-0000bdc0: 6e28 7365 6c65 6374 6564 5f69 6478 7329  n(selected_idxs)
-0000bdd0: 203d 3d20 303a 0a20 2020 2020 2020 2020   == 0:.         
+0000bdb0: 2020 2020 2020 7365 6c65 6374 6564 5f69        selected_i
+0000bdc0: 6478 732e 6170 7065 6e64 2869 645f 6365  dxs.append(id_ce
+0000bdd0: 6c6c 290a 2020 2020 2020 2020 2020 2020  ll).            
 0000bde0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bdf0: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-0000be00: 2073 6176 6520 6365 6c6c 0a20 2020 2020   save cell.     
+0000bdf0: 2020 2020 2020 2020 6e5f 7365 6c20 2b3d          n_sel +=
+0000be00: 2031 0a20 2020 2020 2020 2020 2020 2020   1.             
 0000be10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000be20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000be30: 2020 2070 6f73 5f73 656c 2e61 7070 656e     pos_sel.appen
-0000be40: 6428 6c6f 635b 6964 5f63 656c 6c5d 290a  d(loc[id_cell]).
-0000be50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000be20: 2020 2020 2020 2070 6c61 6365 6420 3d20         placed = 
+0000be30: 5472 7565 0a20 2020 2020 2020 2020 2020  True.           
+0000be40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000be50: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
 0000be60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000be70: 2020 2020 2020 2020 7365 6c65 6374 6564          selected
-0000be80: 5f69 6478 732e 6170 7065 6e64 2869 645f  _idxs.append(id_
-0000be90: 6365 6c6c 290a 2020 2020 2020 2020 2020  cell).          
+0000be70: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+0000be80: 6620 6c65 6e28 7365 6c65 6374 6564 5f69  f len(selected_i
+0000be90: 6478 7329 203d 3d20 303a 0a20 2020 2020  dxs) == 0:.     
 0000bea0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000beb0: 2020 2020 2020 2020 2020 2020 2020 6e5f                n_
-0000bec0: 7365 6c20 2b3d 2031 0a20 2020 2020 2020  sel += 1.       
+0000beb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bec0: 2020 2023 2073 6176 6520 6365 6c6c 0a20     # save cell. 
 0000bed0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000bee0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bef0: 2070 6c61 6365 6420 3d20 5472 7565 0a20   placed = True. 
-0000bf00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bf10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bf20: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-0000bf30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bf40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bf50: 2070 6f73 7369 626c 655f 7365 6c65 6374   possible_select
-0000bf60: 6564 203d 2064 6565 7063 6f70 7928 7365  ed = deepcopy(se
-0000bf70: 6c65 6374 6564 5f69 6478 7329 0a20 2020  lected_idxs).   
-0000bf80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bef0: 2020 2020 2020 2070 6f73 5f73 656c 2e61         pos_sel.a
+0000bf00: 7070 656e 6428 6c6f 635b 6964 5f63 656c  ppend(loc[id_cel
+0000bf10: 6c5d 290a 2020 2020 2020 2020 2020 2020  l]).            
+0000bf20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bf30: 2020 2020 2020 2020 2020 2020 7365 6c65              sele
+0000bf40: 6374 6564 5f69 6478 732e 6170 7065 6e64  cted_idxs.append
+0000bf50: 2869 645f 6365 6c6c 290a 2020 2020 2020  (id_cell).      
+0000bf60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bf70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bf80: 2020 6e5f 7365 6c20 2b3d 2031 0a20 2020    n_sel += 1.   
 0000bf90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bfa0: 2020 2020 2070 6f73 7369 626c 655f 7365       possible_se
-0000bfb0: 6c65 6374 6564 2e61 7070 656e 6428 6964  lected.append(id
-0000bfc0: 5f63 656c 6c29 0a20 2020 2020 2020 2020  _cell).         
+0000bfa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bfb0: 2020 2020 2070 6c61 6365 6420 3d20 5472       placed = Tr
+0000bfc0: 7565 0a20 2020 2020 2020 2020 2020 2020  ue.             
 0000bfd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bfe0: 2020 2020 2020 2020 2020 2020 2020 2070                 p
-0000bff0: 6f73 7369 626c 655f 6f76 6572 6c61 7070  ossible_overlapp
-0000c000: 696e 675f 7061 6972 7320 3d20 6c65 6e28  ing_pairs = len(
-0000c010: 6669 6e64 5f6f 7665 726c 6170 7069 6e67  find_overlapping
-0000c020: 5f74 656d 706c 6174 6573 280a 2020 2020  _templates(.    
-0000c030: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c040: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c050: 2020 2020 2020 2020 7465 6d70 6c61 7465          template
-0000c060: 735b 736f 7274 6564 2870 6f73 7369 626c  s[sorted(possibl
-0000c070: 655f 7365 6c65 6374 6564 295d 2c0a 2020  e_selected)],.  
-0000c080: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bfe0: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+0000bff0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c000: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c010: 2020 2020 2070 6f73 7369 626c 655f 7365       possible_se
+0000c020: 6c65 6374 6564 203d 2064 6565 7063 6f70  lected = deepcop
+0000c030: 7928 7365 6c65 6374 6564 5f69 6478 7329  y(selected_idxs)
+0000c040: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000c050: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c060: 2020 2020 2020 2020 2070 6f73 7369 626c           possibl
+0000c070: 655f 7365 6c65 6374 6564 2e61 7070 656e  e_selected.appen
+0000c080: 6428 6964 5f63 656c 6c29 0a20 2020 2020  d(id_cell).     
 0000c090: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c0a0: 2020 2020 2020 2020 2020 6f76 6572 6c61            overla
-0000c0b0: 705f 7468 7265 7368 6f6c 6429 290a 2020  p_threshold)).  
-0000c0c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c0d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c0e0: 2020 2020 2020 6375 7272 656e 745f 6f76        current_ov
-0000c0f0: 6572 6c61 7070 696e 675f 7061 6972 7320  erlapping_pairs 
-0000c100: 3d20 6c65 6e28 6669 6e64 5f6f 7665 726c  = len(find_overl
-0000c110: 6170 7069 6e67 5f74 656d 706c 6174 6573  apping_templates
-0000c120: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+0000c0a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c0b0: 2020 2070 6f73 7369 626c 655f 6f76 6572     possible_over
+0000c0c0: 6c61 7070 696e 675f 7061 6972 7320 3d20  lapping_pairs = 
+0000c0d0: 6c65 6e28 0a20 2020 2020 2020 2020 2020  len(.           
+0000c0e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c0f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c100: 2066 696e 645f 6f76 6572 6c61 7070 696e   find_overlappin
+0000c110: 675f 7465 6d70 6c61 7465 7328 0a20 2020  g_templates(.   
+0000c120: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000c130: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c140: 2020 2020 2020 2020 2020 2020 2020 7465                te
-0000c150: 6d70 6c61 7465 735b 736f 7274 6564 2873  mplates[sorted(s
-0000c160: 656c 6563 7465 645f 6964 7873 295d 2c0a  elected_idxs)],.
-0000c170: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c180: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c190: 2020 2020 2020 2020 2020 2020 6f76 6572              over
-0000c1a0: 6c61 705f 7468 7265 7368 6f6c 6429 290a  lap_threshold)).
-0000c1b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c140: 2020 2020 2020 2020 2020 2020 2074 656d               tem
+0000c150: 706c 6174 6573 5b73 6f72 7465 6428 706f  plates[sorted(po
+0000c160: 7373 6962 6c65 5f73 656c 6563 7465 6429  ssible_selected)
+0000c170: 5d2c 206f 7665 726c 6170 5f74 6872 6573  ], overlap_thres
+0000c180: 686f 6c64 0a20 2020 2020 2020 2020 2020  hold.           
+0000c190: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c1a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c1b0: 2029 0a20 2020 2020 2020 2020 2020 2020   ).             
 0000c1c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c1d0: 2020 2020 2020 2020 6966 2063 7572 7265          if curre
-0000c1e0: 6e74 5f6f 7665 726c 6170 7069 6e67 5f70  nt_overlapping_p
-0000c1f0: 6169 7273 203c 206e 5f6f 7665 726c 6170  airs < n_overlap
-0000c200: 5f70 6169 7273 2061 6e64 205c 0a20 2020  _pairs and \.   
-0000c210: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c220: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c230: 2020 2020 2020 2020 2020 2020 2070 6f73               pos
-0000c240: 7369 626c 655f 6f76 6572 6c61 7070 696e  sible_overlappin
-0000c250: 675f 7061 6972 7320 3c3d 206e 5f6f 7665  g_pairs <= n_ove
-0000c260: 726c 6170 5f70 6169 7273 3a0a 2020 2020  rlap_pairs:.    
+0000c1d0: 2020 2020 2020 2020 2020 2029 0a20 2020             ).   
+0000c1e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c1f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c200: 2020 2020 2063 7572 7265 6e74 5f6f 7665       current_ove
+0000c210: 726c 6170 7069 6e67 5f70 6169 7273 203d  rlapping_pairs =
+0000c220: 206c 656e 280a 2020 2020 2020 2020 2020   len(.          
+0000c230: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c240: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c250: 2020 6669 6e64 5f6f 7665 726c 6170 7069    find_overlappi
+0000c260: 6e67 5f74 656d 706c 6174 6573 280a 2020  ng_templates(.  
 0000c270: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000c280: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c290: 2020 2020 2020 2020 6966 2070 6f73 7369          if possi
-0000c2a0: 626c 655f 6f76 6572 6c61 7070 696e 675f  ble_overlapping_
-0000c2b0: 7061 6972 7320 3d3d 2063 7572 7265 6e74  pairs == current
-0000c2c0: 5f6f 7665 726c 6170 7069 6e67 5f70 6169  _overlapping_pai
-0000c2d0: 7273 3a0a 2020 2020 2020 2020 2020 2020  rs:.            
+0000c290: 2020 2020 2020 2020 2020 2020 2020 7465                te
+0000c2a0: 6d70 6c61 7465 735b 736f 7274 6564 2873  mplates[sorted(s
+0000c2b0: 656c 6563 7465 645f 6964 7873 295d 2c20  elected_idxs)], 
+0000c2c0: 6f76 6572 6c61 705f 7468 7265 7368 6f6c  overlap_threshol
+0000c2d0: 640a 2020 2020 2020 2020 2020 2020 2020  d.              
 0000c2e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c2f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c300: 2020 2020 636f 6e74 696e 7565 0a20 2020      continue.   
+0000c2f0: 2020 2020 2020 2020 2020 2020 2020 290a                ).
+0000c300: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000c310: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c320: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c330: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
+0000c320: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
+0000c330: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000c340: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c350: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c360: 2020 2020 2020 2020 2020 2020 2020 2070                 p
-0000c370: 6f73 5f73 656c 2e61 7070 656e 6428 6c6f  os_sel.append(lo
-0000c380: 635b 6964 5f63 656c 6c5d 290a 2020 2020  c[id_cell]).    
-0000c390: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c3a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c3b0: 2020 2020 2020 2020 2020 2020 7365 6c65              sele
-0000c3c0: 6374 6564 5f69 6478 732e 6170 7065 6e64  cted_idxs.append
-0000c3d0: 2869 645f 6365 6c6c 290a 2020 2020 2020  (id_cell).      
-0000c3e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c3f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c400: 2020 2020 2020 2020 2020 6e5f 7365 6c20            n_sel 
-0000c410: 2b3d 2031 0a20 2020 2020 2020 2020 2020  += 1.           
+0000c350: 2020 6966 2028 0a20 2020 2020 2020 2020    if (.         
+0000c360: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c370: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c380: 2020 2063 7572 7265 6e74 5f6f 7665 726c     current_overl
+0000c390: 6170 7069 6e67 5f70 6169 7273 203c 206e  apping_pairs < n
+0000c3a0: 5f6f 7665 726c 6170 5f70 6169 7273 0a20  _overlap_pairs. 
+0000c3b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c3c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c3d0: 2020 2020 2020 2020 2020 2061 6e64 2070             and p
+0000c3e0: 6f73 7369 626c 655f 6f76 6572 6c61 7070  ossible_overlapp
+0000c3f0: 696e 675f 7061 6972 7320 3c3d 206e 5f6f  ing_pairs <= n_o
+0000c400: 7665 726c 6170 5f70 6169 7273 0a20 2020  verlap_pairs.   
+0000c410: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000c420: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c430: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c440: 2020 2020 2070 6c61 6365 6420 3d20 5472       placed = Tr
-0000c450: 7565 0a20 2020 2020 2020 2020 2020 2020  ue.             
-0000c460: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c470: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c480: 2020 2069 6620 7665 7262 6f73 653a 0a20     if verbose:. 
-0000c490: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c430: 2020 2020 2029 3a0a 2020 2020 2020 2020       ):.        
+0000c440: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c450: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c460: 2020 2020 6966 2070 6f73 7369 626c 655f      if possible_
+0000c470: 6f76 6572 6c61 7070 696e 675f 7061 6972  overlapping_pair
+0000c480: 7320 3d3d 2063 7572 7265 6e74 5f6f 7665  s == current_ove
+0000c490: 726c 6170 7069 6e67 5f70 6169 7273 3a0a  rlapping_pairs:.
 0000c4a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000c4b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c4c0: 2020 2070 7269 6e74 2827 4e75 6d62 6572     print('Number
-0000c4d0: 206f 6620 6f76 6572 6c61 7070 696e 6720   of overlapping 
-0000c4e0: 7061 6972 733a 272c 2070 6f73 7369 626c  pairs:', possibl
-0000c4f0: 655f 6f76 6572 6c61 7070 696e 675f 7061  e_overlapping_pa
-0000c500: 6972 7329 0a20 2020 2020 2020 2020 2020  irs).           
+0000c4c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c4d0: 636f 6e74 696e 7565 0a20 2020 2020 2020  continue.       
+0000c4e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c4f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c500: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
 0000c510: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c520: 2020 2020 2020 2020 2020 2020 2065 6c73               els
-0000c530: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-0000c540: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c550: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-0000c560: 6620 706f 7373 6962 6c65 5f6f 7665 726c  f possible_overl
-0000c570: 6170 7069 6e67 5f70 6169 7273 203d 3d20  apping_pairs == 
-0000c580: 6375 7272 656e 745f 6f76 6572 6c61 7070  current_overlapp
-0000c590: 696e 675f 7061 6972 733a 0a20 2020 2020  ing_pairs:.     
-0000c5a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c520: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c530: 2020 2020 2020 2020 2020 2070 6f73 5f73             pos_s
+0000c540: 656c 2e61 7070 656e 6428 6c6f 635b 6964  el.append(loc[id
+0000c550: 5f63 656c 6c5d 290a 2020 2020 2020 2020  _cell]).        
+0000c560: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c570: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c580: 2020 2020 2020 2020 7365 6c65 6374 6564          selected
+0000c590: 5f69 6478 732e 6170 7065 6e64 2869 645f  _idxs.append(id_
+0000c5a0: 6365 6c6c 290a 2020 2020 2020 2020 2020  cell).          
 0000c5b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c5c0: 2020 2020 2020 2020 2020 2070 6f73 5f73             pos_s
-0000c5d0: 656c 2e61 7070 656e 6428 6c6f 635b 6964  el.append(loc[id
-0000c5e0: 5f63 656c 6c5d 290a 2020 2020 2020 2020  _cell]).        
+0000c5c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c5d0: 2020 2020 2020 6e5f 7365 6c20 2b3d 2031        n_sel += 1
+0000c5e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
 0000c5f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000c600: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c610: 2020 2020 2020 2020 7365 6c65 6374 6564          selected
-0000c620: 5f69 6478 732e 6170 7065 6e64 2869 645f  _idxs.append(id_
-0000c630: 6365 6c6c 290a 2020 2020 2020 2020 2020  cell).          
-0000c640: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c650: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c660: 2020 2020 2020 6e5f 7365 6c20 2b3d 2031        n_sel += 1
-0000c670: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000c680: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c690: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c6a0: 2070 6c61 6365 6420 3d20 5472 7565 0a20   placed = True. 
-0000c6b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c6c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c6d0: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
-0000c6e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000c6f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c610: 2070 6c61 6365 6420 3d20 5472 7565 0a20   placed = True. 
+0000c620: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c630: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c640: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+0000c650: 6620 7665 7262 6f73 653a 0a20 2020 2020  f verbose:.     
+0000c660: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c670: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c680: 2020 2020 2020 2020 2020 2020 2020 2070                 p
+0000c690: 7269 6e74 2822 4e75 6d62 6572 206f 6620  rint("Number of 
+0000c6a0: 6f76 6572 6c61 7070 696e 6720 7061 6972  overlapping pair
+0000c6b0: 733a 222c 2070 6f73 7369 626c 655f 6f76  s:", possible_ov
+0000c6c0: 6572 6c61 7070 696e 675f 7061 6972 7329  erlapping_pairs)
+0000c6d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000c6e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c6f0: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
 0000c700: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c710: 2069 6620 7665 7262 6f73 653a 0a20 2020   if verbose:.   
-0000c720: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c730: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c740: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c750: 2070 7269 6e74 2827 4f76 6572 6c61 7070   print('Overlapp
-0000c760: 696e 6720 7669 6f6c 6174 696f 6e3a 272c  ing violation:',
-0000c770: 2070 6f73 7369 626c 655f 6f76 6572 6c61   possible_overla
-0000c780: 7070 696e 675f 7061 6972 7329 0a20 2020  pping_pairs).   
-0000c790: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c7a0: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
-0000c7b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c7c0: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-0000c7d0: 6620 7665 7262 6f73 653a 0a20 2020 2020  f verbose:.     
-0000c7e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c7f0: 2020 2020 2020 2020 2020 2020 2020 2070                 p
-0000c800: 7269 6e74 2827 416d 706c 6974 7564 6520  rint('Amplitude 
-0000c810: 6f72 2062 6f75 6e64 6172 7920 7669 6f6c  or boundary viol
-0000c820: 6174 696f 6e27 2c20 616d 702c 206c 6f63  ation', amp, loc
-0000c830: 5b69 645f 6365 6c6c 5d2c 2069 7465 7229  [id_cell], iter)
-0000c840: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000c850: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
-0000c860: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c870: 2020 2020 2020 2020 2020 2023 2064 7269             # dri
-0000c880: 6674 696e 670a 2020 2020 2020 2020 2020  fting.          
+0000c710: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c720: 2020 2020 2020 2020 2020 2069 6620 706f             if po
+0000c730: 7373 6962 6c65 5f6f 7665 726c 6170 7069  ssible_overlappi
+0000c740: 6e67 5f70 6169 7273 203d 3d20 6375 7272  ng_pairs == curr
+0000c750: 656e 745f 6f76 6572 6c61 7070 696e 675f  ent_overlapping_
+0000c760: 7061 6972 733a 0a20 2020 2020 2020 2020  pairs:.         
+0000c770: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c780: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c790: 2020 2020 2020 2070 6f73 5f73 656c 2e61         pos_sel.a
+0000c7a0: 7070 656e 6428 6c6f 635b 6964 5f63 656c  ppend(loc[id_cel
+0000c7b0: 6c5d 290a 2020 2020 2020 2020 2020 2020  l]).            
+0000c7c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c7d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c7e0: 2020 2020 7365 6c65 6374 6564 5f69 6478      selected_idx
+0000c7f0: 732e 6170 7065 6e64 2869 645f 6365 6c6c  s.append(id_cell
+0000c800: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+0000c810: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c820: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c830: 2020 6e5f 7365 6c20 2b3d 2031 0a20 2020    n_sel += 1.   
+0000c840: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c850: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c860: 2020 2020 2020 2020 2020 2020 2070 6c61               pla
+0000c870: 6365 6420 3d20 5472 7565 0a20 2020 2020  ced = True.     
+0000c880: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000c890: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c8a0: 2020 6966 2069 735f 706f 7369 7469 6f6e    if is_position
-0000c8b0: 5f77 6974 6869 6e5f 626f 756e 6461 7269  _within_boundari
-0000c8c0: 6573 286c 6f63 5b69 645f 6365 6c6c 2c20  es(loc[id_cell, 
-0000c8d0: 305d 2c20 785f 6c69 6d2c 2079 5f6c 696d  0], x_lim, y_lim
-0000c8e0: 2c20 7a5f 6c69 6d29 205c 0a20 2020 2020  , z_lim) \.     
+0000c8a0: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+0000c8b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c8c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c8d0: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+0000c8e0: 7665 7262 6f73 653a 0a20 2020 2020 2020  verbose:.       
 0000c8f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c900: 2020 2020 2020 2020 2020 2020 2020 2061                 a
-0000c910: 6e64 206d 696e 5f61 6d70 203c 2061 6d70  nd min_amp < amp
-0000c920: 203c 206d 6178 5f61 6d70 3a0a 2020 2020   < max_amp:.    
-0000c930: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c940: 2020 2020 2020 2020 2020 2020 2320 7361              # sa
-0000c950: 7665 2063 656c 6c0a 2020 2020 2020 2020  ve cell.        
+0000c900: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c910: 2020 2020 2020 2020 2020 2020 2070 7269               pri
+0000c920: 6e74 2822 4f76 6572 6c61 7070 696e 6720  nt("Overlapping 
+0000c930: 7669 6f6c 6174 696f 6e3a 222c 2070 6f73  violation:", pos
+0000c940: 7369 626c 655f 6f76 6572 6c61 7070 696e  sible_overlappin
+0000c950: 675f 7061 6972 7329 0a20 2020 2020 2020  g_pairs).       
 0000c960: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c970: 2020 2020 2020 2020 6472 6966 745f 616e          drift_an
-0000c980: 676c 6520 3d20 6e70 2e72 6164 3264 6567  gle = np.rad2deg
-0000c990: 286e 702e 6172 6363 6f73 286e 702e 646f  (np.arccos(np.do
-0000c9a0: 7428 6472 6966 745f 6469 725b 6964 5f63  t(drift_dir[id_c
-0000c9b0: 656c 6c5d 2c20 7072 6566 6572 7265 645f  ell], preferred_
-0000c9c0: 6469 7229 2929 0a20 2020 2020 2020 2020  dir))).         
-0000c9d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c9e0: 2020 2020 2020 2069 6620 6472 6966 745f         if drift_
-0000c9f0: 616e 676c 6520 2d20 616e 676c 655f 746f  angle - angle_to
-0000ca00: 6c20 3c3d 2030 3a0a 2020 2020 2020 2020  l <= 0:.        
+0000c970: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+0000c980: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c990: 2020 2020 2020 2020 2020 2069 6620 7665             if ve
+0000c9a0: 7262 6f73 653a 0a20 2020 2020 2020 2020  rbose:.         
+0000c9b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c9c0: 2020 2020 2020 2020 2020 2070 7269 6e74             print
+0000c9d0: 2822 416d 706c 6974 7564 6520 6f72 2062  ("Amplitude or b
+0000c9e0: 6f75 6e64 6172 7920 7669 6f6c 6174 696f  oundary violatio
+0000c9f0: 6e22 2c20 616d 702c 206c 6f63 5b69 645f  n", amp, loc[id_
+0000ca00: 6365 6c6c 5d2c 2069 7465 7229 0a20 2020  cell], iter).   
 0000ca10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ca20: 2020 2020 2020 2020 2020 2020 6966 206e              if n
-0000ca30: 5f6f 7665 726c 6170 5f70 6169 7273 2069  _overlap_pairs i
-0000ca40: 7320 4e6f 6e65 3a0a 2020 2020 2020 2020  s None:.        
-0000ca50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ca60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ca70: 7365 6c65 6374 6564 5f69 6478 732e 6170  selected_idxs.ap
-0000ca80: 7065 6e64 2869 645f 6365 6c6c 290a 2020  pend(id_cell).  
-0000ca90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000caa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cab0: 2020 2020 2020 6e5f 7365 6c20 2b3d 2031        n_sel += 1
-0000cac0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000cad0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cae0: 2020 2020 2020 2020 2070 6c61 6365 6420           placed 
-0000caf0: 3d20 5472 7565 0a20 2020 2020 2020 2020  = True.         
-0000cb00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cb10: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
-0000cb20: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000cb30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cb40: 2020 2020 2020 2020 2069 6620 6c65 6e28           if len(
-0000cb50: 7365 6c65 6374 6564 5f69 6478 7329 203d  selected_idxs) =
-0000cb60: 3d20 303a 0a20 2020 2020 2020 2020 2020  = 0:.           
-0000cb70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cb80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cb90: 2023 2073 6176 6520 6365 6c6c 0a20 2020   # save cell.   
-0000cba0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cbb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cbc0: 2020 2020 2020 2020 2070 6f73 5f73 656c           pos_sel
-0000cbd0: 2e61 7070 656e 6428 6c6f 635b 6964 5f63  .append(loc[id_c
-0000cbe0: 656c 6c5d 290a 2020 2020 2020 2020 2020  ell]).          
-0000cbf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cc00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cc10: 2020 7365 6c65 6374 6564 5f69 6478 732e    selected_idxs.
-0000cc20: 6170 7065 6e64 2869 645f 6365 6c6c 290a  append(id_cell).
-0000cc30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cc40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cc50: 2020 2020 2020 2020 2020 2020 6e5f 7365              n_se
-0000cc60: 6c20 2b3d 2031 0a20 2020 2020 2020 2020  l += 1.         
-0000cc70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cc80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cc90: 2020 2070 6c61 6365 6420 3d20 5472 7565     placed = True
-0000cca0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000ccb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ccc0: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
+0000ca20: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+0000ca30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ca40: 2020 2020 2020 2023 2064 7269 6674 696e         # driftin
+0000ca50: 670a 2020 2020 2020 2020 2020 2020 2020  g.              
+0000ca60: 2020 2020 2020 2020 2020 2020 2020 6966                if
+0000ca70: 2028 0a20 2020 2020 2020 2020 2020 2020   (.             
+0000ca80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ca90: 2020 2069 735f 706f 7369 7469 6f6e 5f77     is_position_w
+0000caa0: 6974 6869 6e5f 626f 756e 6461 7269 6573  ithin_boundaries
+0000cab0: 286c 6f63 5b69 645f 6365 6c6c 2c20 305d  (loc[id_cell, 0]
+0000cac0: 2c20 785f 6c69 6d2c 2079 5f6c 696d 2c20  , x_lim, y_lim, 
+0000cad0: 7a5f 6c69 6d29 0a20 2020 2020 2020 2020  z_lim).         
+0000cae0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000caf0: 2020 2020 2020 2061 6e64 206d 696e 5f61         and min_a
+0000cb00: 6d70 203c 2061 6d70 203c 206d 6178 5f61  mp < amp < max_a
+0000cb10: 6d70 0a20 2020 2020 2020 2020 2020 2020  mp.             
+0000cb20: 2020 2020 2020 2020 2020 2020 2020 2029                 )
+0000cb30: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0000cb40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cb50: 2020 2320 7361 7665 2063 656c 6c0a 2020    # save cell.  
+0000cb60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cb70: 2020 2020 2020 2020 2020 2020 2020 6472                dr
+0000cb80: 6966 745f 616e 676c 6520 3d20 6e70 2e72  ift_angle = np.r
+0000cb90: 6164 3264 6567 286e 702e 6172 6363 6f73  ad2deg(np.arccos
+0000cba0: 286e 702e 646f 7428 6472 6966 745f 6469  (np.dot(drift_di
+0000cbb0: 725b 6964 5f63 656c 6c5d 2c20 7072 6566  r[id_cell], pref
+0000cbc0: 6572 7265 645f 6469 7229 2929 0a20 2020  erred_dir))).   
+0000cbd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cbe0: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+0000cbf0: 6472 6966 745f 616e 676c 6520 2d20 616e  drift_angle - an
+0000cc00: 676c 655f 746f 6c20 3c3d 2030 3a0a 2020  gle_tol <= 0:.  
+0000cc10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cc20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cc30: 2020 6966 206e 5f6f 7665 726c 6170 5f70    if n_overlap_p
+0000cc40: 6169 7273 2069 7320 4e6f 6e65 3a0a 2020  airs is None:.  
+0000cc50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cc60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cc70: 2020 2020 2020 7365 6c65 6374 6564 5f69        selected_i
+0000cc80: 6478 732e 6170 7065 6e64 2869 645f 6365  dxs.append(id_ce
+0000cc90: 6c6c 290a 2020 2020 2020 2020 2020 2020  ll).            
+0000cca0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ccb0: 2020 2020 2020 2020 2020 2020 6e5f 7365              n_se
+0000ccc0: 6c20 2b3d 2031 0a20 2020 2020 2020 2020  l += 1.         
 0000ccd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cce0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ccf0: 2020 2020 2020 2020 2020 2070 6f73 7369             possi
-0000cd00: 626c 655f 7365 6c65 6374 6564 203d 2064  ble_selected = d
-0000cd10: 6565 7063 6f70 7928 7365 6c65 6374 6564  eepcopy(selected
-0000cd20: 5f69 6478 7329 0a20 2020 2020 2020 2020  _idxs).         
+0000cce0: 2020 2020 2020 2020 2020 2020 2020 2070                 p
+0000ccf0: 6c61 6365 6420 3d20 5472 7565 0a20 2020  laced = True.   
+0000cd00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cd10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cd20: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
 0000cd30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cd40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cd50: 2020 2070 6f73 7369 626c 655f 7365 6c65     possible_sele
-0000cd60: 6374 6564 2e61 7070 656e 6428 6964 5f63  cted.append(id_c
-0000cd70: 656c 6c29 0a20 2020 2020 2020 2020 2020  ell).           
+0000cd40: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+0000cd50: 6620 6c65 6e28 7365 6c65 6374 6564 5f69  f len(selected_i
+0000cd60: 6478 7329 203d 3d20 303a 0a20 2020 2020  dxs) == 0:.     
+0000cd70: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000cd80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cd90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cda0: 2070 6f73 7369 626c 655f 6f76 6572 6c61   possible_overla
-0000cdb0: 7070 696e 675f 7061 6972 7320 3d20 6c65  pping_pairs = le
-0000cdc0: 6e28 6669 6e64 5f6f 7665 726c 6170 7069  n(find_overlappi
-0000cdd0: 6e67 5f74 656d 706c 6174 6573 280a 2020  ng_templates(.  
-0000cde0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cd90: 2020 2020 2020 2023 2073 6176 6520 6365         # save ce
+0000cda0: 6c6c 0a20 2020 2020 2020 2020 2020 2020  ll.             
+0000cdb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cdc0: 2020 2020 2020 2020 2020 2020 2020 2070                 p
+0000cdd0: 6f73 5f73 656c 2e61 7070 656e 6428 6c6f  os_sel.append(lo
+0000cde0: 635b 6964 5f63 656c 6c5d 290a 2020 2020  c[id_cell]).    
 0000cdf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ce00: 2020 2020 2020 2020 2020 2020 2020 7465                te
-0000ce10: 6d70 6c61 7465 735b 736f 7274 6564 2870  mplates[sorted(p
-0000ce20: 6f73 7369 626c 655f 7365 6c65 6374 6564  ossible_selected
-0000ce30: 292c 2030 5d2c 0a20 2020 2020 2020 2020  ), 0],.         
+0000ce00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ce10: 2020 2020 2020 2020 7365 6c65 6374 6564          selected
+0000ce20: 5f69 6478 732e 6170 7065 6e64 2869 645f  _idxs.append(id_
+0000ce30: 6365 6c6c 290a 2020 2020 2020 2020 2020  cell).          
 0000ce40: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000ce50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ce60: 2020 2020 2020 206f 7665 726c 6170 5f74         overlap_t
-0000ce70: 6872 6573 686f 6c64 2929 0a20 2020 2020  hreshold)).     
+0000ce60: 2020 6e5f 7365 6c20 2b3d 2031 0a20 2020    n_sel += 1.   
+0000ce70: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000ce80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ce90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cea0: 2020 2020 2020 2063 7572 7265 6e74 5f6f         current_o
-0000ceb0: 7665 726c 6170 7069 6e67 5f70 6169 7273  verlapping_pairs
-0000cec0: 203d 206c 656e 2866 696e 645f 6f76 6572   = len(find_over
-0000ced0: 6c61 7070 696e 675f 7465 6d70 6c61 7465  lapping_template
-0000cee0: 7328 0a20 2020 2020 2020 2020 2020 2020  s(.             
+0000ce90: 2020 2020 2020 2020 2070 6c61 6365 6420           placed 
+0000cea0: 3d20 5472 7565 0a20 2020 2020 2020 2020  = True.         
+0000ceb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cec0: 2020 2020 2020 2020 2020 2020 2020 2065                 e
+0000ced0: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+0000cee0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000cef0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cf00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cf10: 2020 2074 656d 706c 6174 6573 5b73 6f72     templates[sor
-0000cf20: 7465 6428 7365 6c65 6374 6564 5f69 6478  ted(selected_idx
-0000cf30: 7329 2c20 305d 2c0a 2020 2020 2020 2020  s), 0],.        
+0000cf00: 2070 6f73 7369 626c 655f 7365 6c65 6374   possible_select
+0000cf10: 6564 203d 2064 6565 7063 6f70 7928 7365  ed = deepcopy(se
+0000cf20: 6c65 6374 6564 5f69 6478 7329 0a20 2020  lected_idxs).   
+0000cf30: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000cf40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cf50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cf60: 2020 2020 2020 2020 6f76 6572 6c61 705f          overlap_
-0000cf70: 7468 7265 7368 6f6c 6429 290a 2020 2020  threshold)).    
+0000cf50: 2020 2020 2020 2020 2070 6f73 7369 626c           possibl
+0000cf60: 655f 7365 6c65 6374 6564 2e61 7070 656e  e_selected.appen
+0000cf70: 6428 6964 5f63 656c 6c29 0a20 2020 2020  d(id_cell).     
 0000cf80: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000cf90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cfa0: 2020 2020 2020 2020 6966 2063 7572 7265          if curre
-0000cfb0: 6e74 5f6f 7665 726c 6170 7069 6e67 5f70  nt_overlapping_p
-0000cfc0: 6169 7273 203c 206e 5f6f 7665 726c 6170  airs < n_overlap
-0000cfd0: 5f70 6169 7273 2061 6e64 205c 0a20 2020  _pairs and \.   
+0000cfa0: 2020 2020 2020 2070 6f73 7369 626c 655f         possible_
+0000cfb0: 6f76 6572 6c61 7070 696e 675f 7061 6972  overlapping_pair
+0000cfc0: 7320 3d20 6c65 6e28 0a20 2020 2020 2020  s = len(.       
+0000cfd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000cfe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cff0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d000: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d010: 2070 6f73 7369 626c 655f 6f76 6572 6c61   possible_overla
-0000d020: 7070 696e 675f 7061 6972 7320 3c3d 206e  pping_pairs <= n
-0000d030: 5f6f 7665 726c 6170 5f70 6169 7273 3a0a  _overlap_pairs:.
-0000d040: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d050: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d060: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d070: 6966 2070 6f73 7369 626c 655f 6f76 6572  if possible_over
-0000d080: 6c61 7070 696e 675f 7061 6972 7320 3d3d  lapping_pairs ==
-0000d090: 2063 7572 7265 6e74 5f6f 7665 726c 6170   current_overlap
-0000d0a0: 7069 6e67 5f70 6169 7273 3a0a 2020 2020  ping_pairs:.    
-0000d0b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cff0: 2020 2020 2020 2020 2066 696e 645f 6f76           find_ov
+0000d000: 6572 6c61 7070 696e 675f 7465 6d70 6c61  erlapping_templa
+0000d010: 7465 7328 0a20 2020 2020 2020 2020 2020  tes(.           
+0000d020: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d030: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d040: 2020 2020 2020 2020 2074 656d 706c 6174           templat
+0000d050: 6573 5b73 6f72 7465 6428 706f 7373 6962  es[sorted(possib
+0000d060: 6c65 5f73 656c 6563 7465 6429 2c20 305d  le_selected), 0]
+0000d070: 2c20 6f76 6572 6c61 705f 7468 7265 7368  , overlap_thresh
+0000d080: 6f6c 640a 2020 2020 2020 2020 2020 2020  old.            
+0000d090: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d0a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d0b0: 2020 2020 290a 2020 2020 2020 2020 2020      ).          
 0000d0c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000d0d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d0e0: 636f 6e74 696e 7565 0a20 2020 2020 2020  continue.       
+0000d0e0: 2020 290a 2020 2020 2020 2020 2020 2020    ).            
 0000d0f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000d100: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d110: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
-0000d120: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d130: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d110: 6375 7272 656e 745f 6f76 6572 6c61 7070  current_overlapp
+0000d120: 696e 675f 7061 6972 7320 3d20 6c65 6e28  ing_pairs = len(
+0000d130: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
 0000d140: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d150: 2020 2070 6f73 5f73 656c 2e61 7070 656e     pos_sel.appen
-0000d160: 6428 6c6f 635b 6964 5f63 656c 6c5d 290a  d(loc[id_cell]).
-0000d170: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d150: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d160: 2066 696e 645f 6f76 6572 6c61 7070 696e   find_overlappin
+0000d170: 675f 7465 6d70 6c61 7465 7328 0a20 2020  g_templates(.   
 0000d180: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000d190: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d1a0: 2020 2020 7365 6c65 6374 6564 5f69 6478      selected_idx
-0000d1b0: 732e 6170 7065 6e64 2869 645f 6365 6c6c  s.append(id_cell
-0000d1c0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-0000d1d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d1e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d1f0: 2020 2020 2020 6e5f 7365 6c20 2b3d 2031        n_sel += 1
-0000d200: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000d210: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d1a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d1b0: 2074 656d 706c 6174 6573 5b73 6f72 7465   templates[sorte
+0000d1c0: 6428 7365 6c65 6374 6564 5f69 6478 7329  d(selected_idxs)
+0000d1d0: 2c20 305d 2c20 6f76 6572 6c61 705f 7468  , 0], overlap_th
+0000d1e0: 7265 7368 6f6c 640a 2020 2020 2020 2020  reshold.        
+0000d1f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d200: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d210: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
 0000d220: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d230: 2020 2020 2070 6c61 6365 6420 3d20 5472       placed = Tr
-0000d240: 7565 0a20 2020 2020 2020 2020 2020 2020  ue.             
+0000d230: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d240: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
 0000d250: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000d260: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d270: 2020 2020 2020 2069 6620 7665 7262 6f73         if verbos
-0000d280: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+0000d270: 2020 2020 6966 2028 0a20 2020 2020 2020      if (.       
+0000d280: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000d290: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d2a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d2b0: 2020 2020 2020 2020 2020 2070 7269 6e74             print
-0000d2c0: 2827 4e75 6d62 6572 206f 6620 6f76 6572  ('Number of over
-0000d2d0: 6c61 7070 696e 6720 7061 6972 733a 272c  lapping pairs:',
-0000d2e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000d2a0: 2020 2020 2020 2020 2063 7572 7265 6e74           current
+0000d2b0: 5f6f 7665 726c 6170 7069 6e67 5f70 6169  _overlapping_pai
+0000d2c0: 7273 203c 206e 5f6f 7665 726c 6170 5f70  rs < n_overlap_p
+0000d2d0: 6169 7273 0a20 2020 2020 2020 2020 2020  airs.           
+0000d2e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000d2f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d300: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d310: 2020 2020 2020 2020 2020 2020 2020 2070                 p
-0000d320: 6f73 7369 626c 655f 6f76 6572 6c61 7070  ossible_overlapp
-0000d330: 696e 675f 7061 6972 7329 0a20 2020 2020  ing_pairs).     
+0000d300: 2020 2020 2061 6e64 2070 6f73 7369 626c       and possibl
+0000d310: 655f 6f76 6572 6c61 7070 696e 675f 7061  e_overlapping_pa
+0000d320: 6972 7320 3c3d 206e 5f6f 7665 726c 6170  irs <= n_overlap
+0000d330: 5f70 6169 7273 0a20 2020 2020 2020 2020  _pairs.         
 0000d340: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000d350: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d360: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+0000d360: 2020 2029 3a0a 2020 2020 2020 2020 2020     ):.          
 0000d370: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000d380: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d390: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-0000d3a0: 706f 7373 6962 6c65 5f6f 7665 726c 6170  possible_overlap
-0000d3b0: 7069 6e67 5f70 6169 7273 203d 3d20 6375  ping_pairs == cu
-0000d3c0: 7272 656e 745f 6f76 6572 6c61 7070 696e  rrent_overlappin
-0000d3d0: 675f 7061 6972 733a 0a20 2020 2020 2020  g_pairs:.       
+0000d390: 2020 2020 2020 6966 2070 6f73 7369 626c        if possibl
+0000d3a0: 655f 6f76 6572 6c61 7070 696e 675f 7061  e_overlapping_pa
+0000d3b0: 6972 7320 3d3d 2063 7572 7265 6e74 5f6f  irs == current_o
+0000d3c0: 7665 726c 6170 7069 6e67 5f70 6169 7273  verlapping_pairs
+0000d3d0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
 0000d3e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000d3f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d400: 2020 2020 2020 2020 2020 2020 2070 6f73               pos
-0000d410: 5f73 656c 2e61 7070 656e 6428 6c6f 635b  _sel.append(loc[
-0000d420: 6964 5f63 656c 6c5d 290a 2020 2020 2020  id_cell]).      
-0000d430: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d440: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d450: 2020 2020 2020 2020 2020 2020 2020 7365                se
-0000d460: 6c65 6374 6564 5f69 6478 732e 6170 7065  lected_idxs.appe
-0000d470: 6e64 2869 645f 6365 6c6c 290a 2020 2020  nd(id_cell).    
-0000d480: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d490: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d400: 2020 2020 2020 636f 6e74 696e 7565 0a20        continue. 
+0000d410: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d420: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d430: 2020 2020 2020 2020 2020 2020 2020 2065                 e
+0000d440: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+0000d450: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d460: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d470: 2020 2020 2020 2020 2070 6f73 5f73 656c           pos_sel
+0000d480: 2e61 7070 656e 6428 6c6f 635b 6964 5f63  .append(loc[id_c
+0000d490: 656c 6c5d 290a 2020 2020 2020 2020 2020  ell]).          
 0000d4a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d4b0: 6e5f 7365 6c20 2b3d 2031 0a20 2020 2020  n_sel += 1.     
-0000d4c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d4d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d4e0: 2020 2020 2020 2020 2020 2020 2020 2070                 p
-0000d4f0: 6c61 6365 6420 3d20 5472 7565 0a20 2020  laced = True.   
+0000d4b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d4c0: 2020 2020 2020 2020 2020 7365 6c65 6374            select
+0000d4d0: 6564 5f69 6478 732e 6170 7065 6e64 2869  ed_idxs.append(i
+0000d4e0: 645f 6365 6c6c 290a 2020 2020 2020 2020  d_cell).        
+0000d4f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000d500: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d510: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d520: 2020 2020 2020 2020 2020 2020 2065 6c73               els
-0000d530: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+0000d510: 2020 2020 2020 2020 2020 2020 6e5f 7365              n_se
+0000d520: 6c20 2b3d 2031 0a20 2020 2020 2020 2020  l += 1.         
+0000d530: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000d540: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d550: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d560: 2020 2020 2020 2069 6620 7665 7262 6f73         if verbos
-0000d570: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+0000d550: 2020 2020 2020 2020 2020 2070 6c61 6365             place
+0000d560: 6420 3d20 5472 7565 0a20 2020 2020 2020  d = True.       
+0000d570: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000d580: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d590: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d5a0: 2020 2020 2020 2020 2020 2070 7269 6e74             print
-0000d5b0: 2827 4f76 6572 6c61 7070 696e 6720 7669  ('Overlapping vi
-0000d5c0: 6f6c 6174 696f 6e3a 272c 2070 6f73 7369  olation:', possi
-0000d5d0: 626c 655f 6f76 6572 6c61 7070 696e 675f  ble_overlapping_
-0000d5e0: 7061 6972 7329 0a20 2020 2020 2020 2020  pairs).         
+0000d590: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+0000d5a0: 7665 7262 6f73 653a 0a20 2020 2020 2020  verbose:.       
+0000d5b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d5c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d5d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d5e0: 2070 7269 6e74 280a 2020 2020 2020 2020   print(.        
 0000d5f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d600: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+0000d600: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000d610: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d620: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d630: 2069 6620 7665 7262 6f73 653a 0a20 2020   if verbose:.   
-0000d640: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d650: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d660: 2020 2020 2070 7269 6e74 2827 4472 6966       print('Drif
-0000d670: 7420 7669 6f6c 6174 696f 6e27 2c20 6c6f  t violation', lo
-0000d680: 635b 6964 5f63 656c 6c5d 2c20 6974 6572  c[id_cell], iter
-0000d690: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-0000d6a0: 2020 2020 2020 2020 2020 2020 2020 656c                el
-0000d6b0: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-0000d6c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d6d0: 2020 2020 6966 2076 6572 626f 7365 3a0a      if verbose:.
+0000d620: 2020 2020 224e 756d 6265 7220 6f66 206f      "Number of o
+0000d630: 7665 726c 6170 7069 6e67 2070 6169 7273  verlapping pairs
+0000d640: 3a22 2c20 706f 7373 6962 6c65 5f6f 7665  :", possible_ove
+0000d650: 726c 6170 7069 6e67 5f70 6169 7273 0a20  rlapping_pairs. 
+0000d660: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d670: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d680: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d690: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+0000d6a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d6b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d6c0: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+0000d6d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000d6e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d6f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d700: 2020 2020 7072 696e 7428 2741 6d70 6c69      print('Ampli
-0000d710: 7475 6465 206f 7220 626f 756e 6461 7279  tude or boundary
-0000d720: 2076 696f 6c61 7469 6f6e 272c 2061 6d70   violation', amp
-0000d730: 2c20 6c6f 635b 6964 5f63 656c 6c2c 2030  , loc[id_cell, 0
-0000d740: 5d2c 2069 7465 7229 0a20 2020 2020 2020  ], iter).       
-0000d750: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-0000d760: 706c 6163 6564 3a0a 2020 2020 2020 2020  placed:.        
-0000d770: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d780: 6e5f 7365 6c5f 696e 6820 2b3d 2031 0a20  n_sel_inh += 1. 
+0000d6f0: 2020 2020 2020 2020 2020 2069 6620 706f             if po
+0000d700: 7373 6962 6c65 5f6f 7665 726c 6170 7069  ssible_overlappi
+0000d710: 6e67 5f70 6169 7273 203d 3d20 6375 7272  ng_pairs == curr
+0000d720: 656e 745f 6f76 6572 6c61 7070 696e 675f  ent_overlapping_
+0000d730: 7061 6972 733a 0a20 2020 2020 2020 2020  pairs:.         
+0000d740: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d750: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d760: 2020 2020 2020 2020 2020 2070 6f73 5f73             pos_s
+0000d770: 656c 2e61 7070 656e 6428 6c6f 635b 6964  el.append(loc[id
+0000d780: 5f63 656c 6c5d 290a 2020 2020 2020 2020  _cell]).        
 0000d790: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d7a0: 2020 2020 2020 2073 656c 6563 7465 645f         selected_
-0000d7b0: 6361 742e 6170 7065 6e64 2827 4927 290a  cat.append('I').
-0000d7c0: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
-0000d7d0: 2020 2020 2020 2020 2020 6469 7374 203d            dist =
-0000d7e0: 206e 702e 6172 7261 7928 5b6e 702e 6c69   np.array([np.li
-0000d7f0: 6e61 6c67 2e6e 6f72 6d28 6c6f 635b 6964  nalg.norm(loc[id
-0000d800: 5f63 656c 6c5d 202d 2070 2920 666f 7220  _cell] - p) for 
-0000d810: 7020 696e 2070 6f73 5f73 656c 5d29 0a20  p in pos_sel]). 
-0000d820: 2020 2020 2020 2020 2020 2069 6620 6e70             if np
-0000d830: 2e61 6e79 2864 6973 7420 3c20 6d69 6e5f  .any(dist < min_
-0000d840: 6469 7374 293a 0a20 2020 2020 2020 2020  dist):.         
-0000d850: 2020 2020 2020 2069 6620 7665 7262 6f73         if verbos
-0000d860: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-0000d870: 2020 2020 2020 2070 7269 6e74 2827 4469         print('Di
-0000d880: 7374 616e 6365 2076 696f 6c61 7469 6f6e  stance violation
-0000d890: 272c 206e 702e 6d69 6e28 6469 7374 292c  ', np.min(dist),
-0000d8a0: 2069 7465 7229 0a20 2020 2020 2020 2020   iter).         
-0000d8b0: 2020 2020 2020 2070 6173 730a 2020 2020         pass.    
-0000d8c0: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
-0000d8d0: 2020 2020 2020 2020 2020 2020 2020 616d                am
-0000d8e0: 7020 3d20 6e70 2e6d 6178 286e 702e 6162  p = np.max(np.ab
-0000d8f0: 7328 6e70 2e6d 696e 2874 656d 706c 6174  s(np.min(templat
-0000d900: 6573 5b69 645f 6365 6c6c 5d29 2929 0a20  es[id_cell]))). 
-0000d910: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-0000d920: 6620 6e6f 7420 6472 6966 7469 6e67 3a0a  f not drifting:.
-0000d930: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d940: 2020 2020 6966 2069 735f 706f 7369 7469      if is_positi
-0000d950: 6f6e 5f77 6974 6869 6e5f 626f 756e 6461  on_within_bounda
-0000d960: 7269 6573 286c 6f63 5b69 645f 6365 6c6c  ries(loc[id_cell
-0000d970: 5d2c 2078 5f6c 696d 2c20 795f 6c69 6d2c  ], x_lim, y_lim,
-0000d980: 207a 5f6c 696d 2920 616e 6420 6d69 6e5f   z_lim) and min_
-0000d990: 616d 7020 3c20 616d 7020 3c20 6d61 785f  amp < amp < max_
-0000d9a0: 616d 703a 0a20 2020 2020 2020 2020 2020  amp:.           
-0000d9b0: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-0000d9c0: 6e5f 6f76 6572 6c61 705f 7061 6972 7320  n_overlap_pairs 
-0000d9d0: 6973 204e 6f6e 653a 0a20 2020 2020 2020  is None:.       
-0000d9e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d9f0: 2020 2020 2023 2073 6176 6520 6365 6c6c       # save cell
-0000da00: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000da10: 2020 2020 2020 2020 2020 2020 2070 6f73               pos
-0000da20: 5f73 656c 2e61 7070 656e 6428 6c6f 635b  _sel.append(loc[
-0000da30: 6964 5f63 656c 6c5d 290a 2020 2020 2020  id_cell]).      
+0000d7a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d7b0: 2020 2020 2020 2020 2020 2020 7365 6c65              sele
+0000d7c0: 6374 6564 5f69 6478 732e 6170 7065 6e64  cted_idxs.append
+0000d7d0: 2869 645f 6365 6c6c 290a 2020 2020 2020  (id_cell).      
+0000d7e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d7f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d800: 2020 2020 2020 2020 2020 2020 2020 6e5f                n_
+0000d810: 7365 6c20 2b3d 2031 0a20 2020 2020 2020  sel += 1.       
+0000d820: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d830: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d840: 2020 2020 2020 2020 2020 2020 2070 6c61               pla
+0000d850: 6365 6420 3d20 5472 7565 0a20 2020 2020  ced = True.     
+0000d860: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d870: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d880: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
+0000d890: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000d8a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d8b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d8c0: 2020 2020 2069 6620 7665 7262 6f73 653a       if verbose:
+0000d8d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000d8e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d8f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d900: 2020 2020 2020 2020 2070 7269 6e74 2822           print("
+0000d910: 4f76 6572 6c61 7070 696e 6720 7669 6f6c  Overlapping viol
+0000d920: 6174 696f 6e3a 222c 2070 6f73 7369 626c  ation:", possibl
+0000d930: 655f 6f76 6572 6c61 7070 696e 675f 7061  e_overlapping_pa
+0000d940: 6972 7329 0a20 2020 2020 2020 2020 2020  irs).           
+0000d950: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d960: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+0000d970: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d980: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+0000d990: 6620 7665 7262 6f73 653a 0a20 2020 2020  f verbose:.     
+0000d9a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d9b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d9c0: 2020 2070 7269 6e74 2822 4472 6966 7420     print("Drift 
+0000d9d0: 7669 6f6c 6174 696f 6e22 2c20 6c6f 635b  violation", loc[
+0000d9e0: 6964 5f63 656c 6c5d 2c20 6974 6572 290a  id_cell], iter).
+0000d9f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000da00: 2020 2020 2020 2020 2020 2020 656c 7365              else
+0000da10: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0000da20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000da30: 2020 6966 2076 6572 626f 7365 3a0a 2020    if verbose:.  
 0000da40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000da50: 2020 2020 2020 7365 6c65 6374 6564 5f69        selected_i
-0000da60: 6478 732e 6170 7065 6e64 2869 645f 6365  dxs.append(id_ce
-0000da70: 6c6c 290a 2020 2020 2020 2020 2020 2020  ll).            
-0000da80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000da90: 6e5f 7365 6c20 2b3d 2031 0a20 2020 2020  n_sel += 1.     
-0000daa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000dab0: 2020 2020 2020 2070 6c61 6365 6420 3d20         placed = 
-0000dac0: 5472 7565 0a20 2020 2020 2020 2020 2020  True.           
-0000dad0: 2020 2020 2020 2020 2020 2020 2065 6c73               els
-0000dae0: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-0000daf0: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-0000db00: 6620 6c65 6e28 7365 6c65 6374 6564 5f69  f len(selected_i
-0000db10: 6478 7329 203d 3d20 303a 0a20 2020 2020  dxs) == 0:.     
-0000db20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000db30: 2020 2020 2020 2020 2020 2023 2073 6176             # sav
-0000db40: 6520 6365 6c6c 0a20 2020 2020 2020 2020  e cell.         
-0000db50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000db60: 2020 2020 2020 2070 6f73 5f73 656c 2e61         pos_sel.a
-0000db70: 7070 656e 6428 6c6f 635b 6964 5f63 656c  ppend(loc[id_cel
-0000db80: 6c5d 290a 2020 2020 2020 2020 2020 2020  l]).            
-0000db90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000dba0: 2020 2020 7365 6c65 6374 6564 5f69 6478      selected_idx
-0000dbb0: 732e 6170 7065 6e64 2869 645f 6365 6c6c  s.append(id_cell
-0000dbc0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-0000dbd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000dbe0: 2020 6e5f 7365 6c20 2b3d 2031 0a20 2020    n_sel += 1.   
-0000dbf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000dc00: 2020 2020 2020 2020 2020 2020 2070 6c61               pla
-0000dc10: 6365 6420 3d20 5472 7565 0a20 2020 2020  ced = True.     
-0000dc20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000dc30: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-0000dc40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000dc50: 2020 2020 2020 2020 2020 2020 2070 6f73               pos
-0000dc60: 7369 626c 655f 7365 6c65 6374 6564 203d  sible_selected =
-0000dc70: 2064 6565 7063 6f70 7928 7365 6c65 6374   deepcopy(select
-0000dc80: 6564 5f69 6478 7329 0a20 2020 2020 2020  ed_idxs).       
-0000dc90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000dca0: 2020 2020 2020 2020 2070 6f73 7369 626c           possibl
-0000dcb0: 655f 7365 6c65 6374 6564 2e61 7070 656e  e_selected.appen
-0000dcc0: 6428 6964 5f63 656c 6c29 0a20 2020 2020  d(id_cell).     
-0000dcd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000dce0: 2020 2020 2020 2020 2020 2070 6f73 7369             possi
-0000dcf0: 626c 655f 6f76 6572 6c61 7070 696e 675f  ble_overlapping_
-0000dd00: 7061 6972 7320 3d20 6c65 6e28 6669 6e64  pairs = len(find
-0000dd10: 5f6f 7665 726c 6170 7069 6e67 5f74 656d  _overlapping_tem
-0000dd20: 706c 6174 6573 280a 2020 2020 2020 2020  plates(.        
-0000dd30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000dd40: 2020 2020 2020 2020 2020 2020 7465 6d70              temp
-0000dd50: 6c61 7465 735b 6e70 2e61 7272 6179 2870  lates[np.array(p
-0000dd60: 6f73 7369 626c 655f 7365 6c65 6374 6564  ossible_selected
-0000dd70: 295d 2c0a 2020 2020 2020 2020 2020 2020  )],.            
+0000da50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000da60: 2020 7072 696e 7428 2241 6d70 6c69 7475    print("Amplitu
+0000da70: 6465 206f 7220 626f 756e 6461 7279 2076  de or boundary v
+0000da80: 696f 6c61 7469 6f6e 222c 2061 6d70 2c20  iolation", amp, 
+0000da90: 6c6f 635b 6964 5f63 656c 6c2c 2030 5d2c  loc[id_cell, 0],
+0000daa0: 2069 7465 7229 0a20 2020 2020 2020 2020   iter).         
+0000dab0: 2020 2020 2020 2020 2020 2069 6620 706c             if pl
+0000dac0: 6163 6564 3a0a 2020 2020 2020 2020 2020  aced:.          
+0000dad0: 2020 2020 2020 2020 2020 2020 2020 6e5f                n_
+0000dae0: 7365 6c5f 696e 6820 2b3d 2031 0a20 2020  sel_inh += 1.   
+0000daf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000db00: 2020 2020 2073 656c 6563 7465 645f 6361       selected_ca
+0000db10: 742e 6170 7065 6e64 2822 4922 290a 2020  t.append("I").  
+0000db20: 2020 2020 2020 2320 756e 6b6e 6f77 6e20        # unknown 
+0000db30: 6365 6c6c 2074 7970 650a 2020 2020 2020  cell type.      
+0000db40: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+0000db50: 2020 2020 6469 7374 203d 206e 702e 6172      dist = np.ar
+0000db60: 7261 7928 5b6e 702e 6c69 6e61 6c67 2e6e  ray([np.linalg.n
+0000db70: 6f72 6d28 6c6f 635b 6964 5f63 656c 6c5d  orm(loc[id_cell]
+0000db80: 202d 2070 2920 666f 7220 7020 696e 2070   - p) for p in p
+0000db90: 6f73 5f73 656c 5d29 0a20 2020 2020 2020  os_sel]).       
+0000dba0: 2020 2020 2069 6620 6e70 2e61 6e79 2864       if np.any(d
+0000dbb0: 6973 7420 3c20 6d69 6e5f 6469 7374 293a  ist < min_dist):
+0000dbc0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000dbd0: 2069 6620 7665 7262 6f73 653a 0a20 2020   if verbose:.   
+0000dbe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dbf0: 2070 7269 6e74 2822 4469 7374 616e 6365   print("Distance
+0000dc00: 2076 696f 6c61 7469 6f6e 222c 206e 702e   violation", np.
+0000dc10: 6d69 6e28 6469 7374 292c 2069 7465 7229  min(dist), iter)
+0000dc20: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000dc30: 2070 6173 730a 2020 2020 2020 2020 2020   pass.          
+0000dc40: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+0000dc50: 2020 2020 2020 2020 616d 7020 3d20 6e70          amp = np
+0000dc60: 2e6d 6178 286e 702e 6162 7328 6e70 2e6d  .max(np.abs(np.m
+0000dc70: 696e 2874 656d 706c 6174 6573 5b69 645f  in(templates[id_
+0000dc80: 6365 6c6c 5d29 2929 0a20 2020 2020 2020  cell]))).       
+0000dc90: 2020 2020 2020 2020 2069 6620 6e6f 7420           if not 
+0000dca0: 6472 6966 7469 6e67 3a0a 2020 2020 2020  drifting:.      
+0000dcb0: 2020 2020 2020 2020 2020 2020 2020 6966                if
+0000dcc0: 2069 735f 706f 7369 7469 6f6e 5f77 6974   is_position_wit
+0000dcd0: 6869 6e5f 626f 756e 6461 7269 6573 286c  hin_boundaries(l
+0000dce0: 6f63 5b69 645f 6365 6c6c 5d2c 2078 5f6c  oc[id_cell], x_l
+0000dcf0: 696d 2c20 795f 6c69 6d2c 207a 5f6c 696d  im, y_lim, z_lim
+0000dd00: 2920 616e 6420 6d69 6e5f 616d 7020 3c20  ) and min_amp < 
+0000dd10: 616d 7020 3c20 6d61 785f 616d 703a 0a20  amp < max_amp:. 
+0000dd20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dd30: 2020 2020 2020 2069 6620 6e5f 6f76 6572         if n_over
+0000dd40: 6c61 705f 7061 6972 7320 6973 204e 6f6e  lap_pairs is Non
+0000dd50: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+0000dd60: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+0000dd70: 2073 6176 6520 6365 6c6c 0a20 2020 2020   save cell.     
 0000dd80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000dd90: 2020 2020 2020 2020 6f76 6572 6c61 705f          overlap_
-0000dda0: 7468 7265 7368 6f6c 6429 290a 2020 2020  threshold)).    
-0000ddb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ddc0: 2020 2020 2020 2020 2020 2020 6375 7272              curr
-0000ddd0: 656e 745f 6f76 6572 6c61 7070 696e 675f  ent_overlapping_
-0000dde0: 7061 6972 7320 3d20 6c65 6e28 6669 6e64  pairs = len(find
-0000ddf0: 5f6f 7665 726c 6170 7069 6e67 5f74 656d  _overlapping_tem
-0000de00: 706c 6174 6573 280a 2020 2020 2020 2020  plates(.        
-0000de10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000de20: 2020 2020 2020 2020 2020 2020 7465 6d70              temp
-0000de30: 6c61 7465 735b 6e70 2e61 7272 6179 2873  lates[np.array(s
-0000de40: 656c 6563 7465 645f 6964 7873 295d 2c0a  elected_idxs)],.
-0000de50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dd90: 2020 2020 2020 2070 6f73 5f73 656c 2e61         pos_sel.a
+0000dda0: 7070 656e 6428 6c6f 635b 6964 5f63 656c  ppend(loc[id_cel
+0000ddb0: 6c5d 290a 2020 2020 2020 2020 2020 2020  l]).            
+0000ddc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ddd0: 7365 6c65 6374 6564 5f69 6478 732e 6170  selected_idxs.ap
+0000dde0: 7065 6e64 2869 645f 6365 6c6c 290a 2020  pend(id_cell).  
+0000ddf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000de00: 2020 2020 2020 2020 2020 6e5f 7365 6c20            n_sel 
+0000de10: 2b3d 2031 0a20 2020 2020 2020 2020 2020  += 1.           
+0000de20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000de30: 2070 6c61 6365 6420 3d20 5472 7565 0a20   placed = True. 
+0000de40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000de50: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
 0000de60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000de70: 2020 2020 6f76 6572 6c61 705f 7468 7265      overlap_thre
-0000de80: 7368 6f6c 6429 290a 2020 2020 2020 2020  shold)).        
-0000de90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000dea0: 2020 2020 2020 2020 6966 2063 7572 7265          if curre
-0000deb0: 6e74 5f6f 7665 726c 6170 7069 6e67 5f70  nt_overlapping_p
-0000dec0: 6169 7273 203c 206e 5f6f 7665 726c 6170  airs < n_overlap
-0000ded0: 5f70 6169 7273 2061 6e64 205c 0a20 2020  _pairs and \.   
-0000dee0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000def0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000df00: 2020 2020 2070 6f73 7369 626c 655f 6f76       possible_ov
-0000df10: 6572 6c61 7070 696e 675f 7061 6972 7320  erlapping_pairs 
-0000df20: 3c3d 206e 5f6f 7665 726c 6170 5f70 6169  <= n_overlap_pai
-0000df30: 7273 3a0a 2020 2020 2020 2020 2020 2020  rs:.            
+0000de70: 2020 2020 2020 2020 2069 6620 6c65 6e28           if len(
+0000de80: 7365 6c65 6374 6564 5f69 6478 7329 203d  selected_idxs) =
+0000de90: 3d20 303a 0a20 2020 2020 2020 2020 2020  = 0:.           
+0000dea0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000deb0: 2020 2020 2023 2073 6176 6520 6365 6c6c       # save cell
+0000dec0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000ded0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dee0: 2070 6f73 5f73 656c 2e61 7070 656e 6428   pos_sel.append(
+0000def0: 6c6f 635b 6964 5f63 656c 6c5d 290a 2020  loc[id_cell]).  
+0000df00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000df10: 2020 2020 2020 2020 2020 2020 2020 7365                se
+0000df20: 6c65 6374 6564 5f69 6478 732e 6170 7065  lected_idxs.appe
+0000df30: 6e64 2869 645f 6365 6c6c 290a 2020 2020  nd(id_cell).    
 0000df40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000df50: 2020 2020 2020 2020 6966 2070 6f73 7369          if possi
-0000df60: 626c 655f 6f76 6572 6c61 7070 696e 675f  ble_overlapping_
-0000df70: 7061 6972 7320 3d3d 2063 7572 7265 6e74  pairs == current
-0000df80: 5f6f 7665 726c 6170 7069 6e67 5f70 6169  _overlapping_pai
-0000df90: 7273 3a0a 2020 2020 2020 2020 2020 2020  rs:.            
+0000df50: 2020 2020 2020 2020 2020 2020 6e5f 7365              n_se
+0000df60: 6c20 2b3d 2031 0a20 2020 2020 2020 2020  l += 1.         
+0000df70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000df80: 2020 2020 2020 2070 6c61 6365 6420 3d20         placed = 
+0000df90: 5472 7565 0a20 2020 2020 2020 2020 2020  True.           
 0000dfa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000dfb0: 2020 2020 2020 2020 2020 2020 636f 6e74              cont
-0000dfc0: 696e 7565 0a20 2020 2020 2020 2020 2020  inue.           
-0000dfd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000dfe0: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
-0000dff0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e000: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e010: 2020 2020 2020 2070 6f73 5f73 656c 2e61         pos_sel.a
-0000e020: 7070 656e 6428 6c6f 635b 6964 5f63 656c  ppend(loc[id_cel
-0000e030: 6c5d 290a 2020 2020 2020 2020 2020 2020  l]).            
-0000e040: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e050: 2020 2020 2020 2020 2020 2020 7365 6c65              sele
-0000e060: 6374 6564 5f69 6478 732e 6170 7065 6e64  cted_idxs.append
-0000e070: 2869 645f 6365 6c6c 290a 2020 2020 2020  (id_cell).      
-0000e080: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dfb0: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+0000dfc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000dfd0: 2020 2020 2020 2070 6f73 7369 626c 655f         possible_
+0000dfe0: 7365 6c65 6374 6564 203d 2064 6565 7063  selected = deepc
+0000dff0: 6f70 7928 7365 6c65 6374 6564 5f69 6478  opy(selected_idx
+0000e000: 7329 0a20 2020 2020 2020 2020 2020 2020  s).             
+0000e010: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e020: 2020 2070 6f73 7369 626c 655f 7365 6c65     possible_sele
+0000e030: 6374 6564 2e61 7070 656e 6428 6964 5f63  cted.append(id_c
+0000e040: 656c 6c29 0a20 2020 2020 2020 2020 2020  ell).           
+0000e050: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e060: 2020 2020 2070 6f73 7369 626c 655f 6f76       possible_ov
+0000e070: 6572 6c61 7070 696e 675f 7061 6972 7320  erlapping_pairs 
+0000e080: 3d20 6c65 6e28 0a20 2020 2020 2020 2020  = len(.         
 0000e090: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e0a0: 2020 6e5f 7365 6c20 2b3d 2031 0a20 2020    n_sel += 1.   
-0000e0b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e0c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e0d0: 2020 2020 2070 6c61 6365 6420 3d20 5472       placed = Tr
-0000e0e0: 7565 0a20 2020 2020 2020 2020 2020 2020  ue.             
-0000e0f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e100: 2020 2020 2020 2020 2020 2069 6620 7665             if ve
-0000e110: 7262 6f73 653a 0a20 2020 2020 2020 2020  rbose:.         
-0000e120: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e0a0: 2020 2020 2020 2020 2020 2066 696e 645f             find_
+0000e0b0: 6f76 6572 6c61 7070 696e 675f 7465 6d70  overlapping_temp
+0000e0c0: 6c61 7465 7328 0a20 2020 2020 2020 2020  lates(.         
+0000e0d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e0e0: 2020 2020 2020 2020 2020 2020 2020 2074                 t
+0000e0f0: 656d 706c 6174 6573 5b6e 702e 6172 7261  emplates[np.arra
+0000e100: 7928 706f 7373 6962 6c65 5f73 656c 6563  y(possible_selec
+0000e110: 7465 6429 5d2c 206f 7665 726c 6170 5f74  ted)], overlap_t
+0000e120: 6872 6573 686f 6c64 0a20 2020 2020 2020  hreshold.       
 0000e130: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e140: 2020 2070 7269 6e74 2827 4e75 6d62 6572     print('Number
-0000e150: 206f 6620 6f76 6572 6c61 7070 696e 6720   of overlapping 
-0000e160: 7061 6972 733a 272c 2070 6f73 7369 626c  pairs:', possibl
-0000e170: 655f 6f76 6572 6c61 7070 696e 675f 7061  e_overlapping_pa
-0000e180: 6972 7329 0a20 2020 2020 2020 2020 2020  irs).           
-0000e190: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e1a0: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
-0000e1b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e1c0: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-0000e1d0: 6620 706f 7373 6962 6c65 5f6f 7665 726c  f possible_overl
-0000e1e0: 6170 7069 6e67 5f70 6169 7273 203d 3d20  apping_pairs == 
-0000e1f0: 6375 7272 656e 745f 6f76 6572 6c61 7070  current_overlapp
-0000e200: 696e 675f 7061 6972 733a 0a20 2020 2020  ing_pairs:.     
-0000e210: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e220: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e230: 2020 2070 6f73 5f73 656c 2e61 7070 656e     pos_sel.appen
-0000e240: 6428 6c6f 635b 6964 5f63 656c 6c5d 290a  d(loc[id_cell]).
+0000e140: 2020 2020 2020 2020 2020 2020 2029 0a20               ). 
+0000e150: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e160: 2020 2020 2020 2020 2020 2020 2020 2029                 )
+0000e170: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000e180: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e190: 2063 7572 7265 6e74 5f6f 7665 726c 6170   current_overlap
+0000e1a0: 7069 6e67 5f70 6169 7273 203d 206c 656e  ping_pairs = len
+0000e1b0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+0000e1c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e1d0: 2020 2020 2020 6669 6e64 5f6f 7665 726c        find_overl
+0000e1e0: 6170 7069 6e67 5f74 656d 706c 6174 6573  apping_templates
+0000e1f0: 2874 656d 706c 6174 6573 5b6e 702e 6172  (templates[np.ar
+0000e200: 7261 7928 7365 6c65 6374 6564 5f69 6478  ray(selected_idx
+0000e210: 7329 5d2c 206f 7665 726c 6170 5f74 6872  s)], overlap_thr
+0000e220: 6573 686f 6c64 290a 2020 2020 2020 2020  eshold).        
+0000e230: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e240: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
 0000e250: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e260: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e270: 2020 2020 2020 2020 7365 6c65 6374 6564          selected
-0000e280: 5f69 6478 732e 6170 7065 6e64 2869 645f  _idxs.append(id_
-0000e290: 6365 6c6c 290a 2020 2020 2020 2020 2020  cell).          
-0000e2a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e2b0: 2020 2020 2020 2020 2020 2020 2020 6e5f                n_
-0000e2c0: 7365 6c20 2b3d 2031 0a20 2020 2020 2020  sel += 1.       
+0000e260: 2020 2020 2020 2020 2020 6966 2028 0a20            if (. 
+0000e270: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e280: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e290: 2020 2063 7572 7265 6e74 5f6f 7665 726c     current_overl
+0000e2a0: 6170 7069 6e67 5f70 6169 7273 203c 206e  apping_pairs < n
+0000e2b0: 5f6f 7665 726c 6170 5f70 6169 7273 0a20  _overlap_pairs. 
+0000e2c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000e2d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e2e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e2f0: 2070 6c61 6365 6420 3d20 5472 7565 0a20   placed = True. 
-0000e300: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e310: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e320: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-0000e330: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e2e0: 2020 2061 6e64 2070 6f73 7369 626c 655f     and possible_
+0000e2f0: 6f76 6572 6c61 7070 696e 675f 7061 6972  overlapping_pair
+0000e300: 7320 3c3d 206e 5f6f 7665 726c 6170 5f70  s <= n_overlap_p
+0000e310: 6169 7273 0a20 2020 2020 2020 2020 2020  airs.           
+0000e320: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e330: 2020 2020 2029 3a0a 2020 2020 2020 2020       ):.        
 0000e340: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e350: 2069 6620 7665 7262 6f73 653a 0a20 2020   if verbose:.   
-0000e360: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e370: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e380: 2020 2020 2020 2020 2070 7269 6e74 2827           print('
-0000e390: 4f76 6572 6c61 7070 696e 6720 7669 6f6c  Overlapping viol
-0000e3a0: 6174 696f 6e3a 272c 2070 6f73 7369 626c  ation:', possibl
-0000e3b0: 655f 6f76 6572 6c61 7070 696e 675f 7061  e_overlapping_pa
-0000e3c0: 6972 7329 0a20 2020 2020 2020 2020 2020  irs).           
-0000e3d0: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
-0000e3e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e3f0: 2020 2020 2020 2069 6620 7665 7262 6f73         if verbos
-0000e400: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-0000e410: 2020 2020 2020 2020 2020 2020 2020 2070                 p
-0000e420: 7269 6e74 2827 416d 706c 6974 7564 6520  rint('Amplitude 
-0000e430: 6f72 2062 6f75 6e64 6172 7920 7669 6f6c  or boundary viol
-0000e440: 6174 696f 6e27 2c20 616d 702c 206c 6f63  ation', amp, loc
-0000e450: 5b69 645f 6365 6c6c 5d2c 2069 7465 7229  [id_cell], iter)
-0000e460: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000e470: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
-0000e480: 2020 2020 2020 2020 2020 2023 2064 7269             # dri
-0000e490: 6674 696e 670a 2020 2020 2020 2020 2020  fting.          
-0000e4a0: 2020 2020 2020 2020 2020 6966 2069 735f            if is_
-0000e4b0: 706f 7369 7469 6f6e 5f77 6974 6869 6e5f  position_within_
-0000e4c0: 626f 756e 6461 7269 6573 286c 6f63 5b69  boundaries(loc[i
-0000e4d0: 645f 6365 6c6c 2c20 305d 2c20 785f 6c69  d_cell, 0], x_li
-0000e4e0: 6d2c 2079 5f6c 696d 2c20 7a5f 6c69 6d29  m, y_lim, z_lim)
-0000e4f0: 2061 6e64 206d 696e 5f61 6d70 203c 2061   and min_amp < a
-0000e500: 6d70 203c 206d 6178 5f61 6d70 3a0a 2020  mp < max_amp:.  
-0000e510: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e520: 2020 2020 2020 2320 7361 7665 2063 656c        # save cel
-0000e530: 6c0a 2020 2020 2020 2020 2020 2020 2020  l.              
-0000e540: 2020 2020 2020 2020 2020 6472 6966 745f            drift_
-0000e550: 616e 676c 6520 3d20 6e70 2e72 6164 3264  angle = np.rad2d
-0000e560: 6567 286e 702e 6172 6363 6f73 286e 702e  eg(np.arccos(np.
-0000e570: 646f 7428 6472 6966 745f 6469 725b 6964  dot(drift_dir[id
-0000e580: 5f63 656c 6c5d 2c20 7072 6566 6572 7265  _cell], preferre
-0000e590: 645f 6469 7229 2929 0a20 2020 2020 2020  d_dir))).       
-0000e5a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e5b0: 2069 6620 6472 6966 745f 616e 676c 6520   if drift_angle 
-0000e5c0: 2d20 616e 676c 655f 746f 6c20 3c3d 2030  - angle_tol <= 0
-0000e5d0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0000e5e0: 2020 2020 2020 2020 2020 2020 2020 6966                if
-0000e5f0: 206e 5f6f 7665 726c 6170 5f70 6169 7273   n_overlap_pairs
-0000e600: 2069 7320 4e6f 6e65 3a0a 2020 2020 2020   is None:.      
+0000e350: 2020 2020 2020 2020 2020 2020 6966 2070              if p
+0000e360: 6f73 7369 626c 655f 6f76 6572 6c61 7070  ossible_overlapp
+0000e370: 696e 675f 7061 6972 7320 3d3d 2063 7572  ing_pairs == cur
+0000e380: 7265 6e74 5f6f 7665 726c 6170 7069 6e67  rent_overlapping
+0000e390: 5f70 6169 7273 3a0a 2020 2020 2020 2020  _pairs:.        
+0000e3a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e3b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e3c0: 636f 6e74 696e 7565 0a20 2020 2020 2020  continue.       
+0000e3d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e3e0: 2020 2020 2020 2020 2020 2020 2065 6c73               els
+0000e3f0: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+0000e400: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e410: 2020 2020 2020 2020 2020 2070 6f73 5f73             pos_s
+0000e420: 656c 2e61 7070 656e 6428 6c6f 635b 6964  el.append(loc[id
+0000e430: 5f63 656c 6c5d 290a 2020 2020 2020 2020  _cell]).        
+0000e440: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e450: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e460: 7365 6c65 6374 6564 5f69 6478 732e 6170  selected_idxs.ap
+0000e470: 7065 6e64 2869 645f 6365 6c6c 290a 2020  pend(id_cell).  
+0000e480: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e490: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e4a0: 2020 2020 2020 6e5f 7365 6c20 2b3d 2031        n_sel += 1
+0000e4b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000e4c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e4d0: 2020 2020 2020 2020 2070 6c61 6365 6420           placed 
+0000e4e0: 3d20 5472 7565 0a20 2020 2020 2020 2020  = True.         
+0000e4f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e500: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+0000e510: 6620 7665 7262 6f73 653a 0a20 2020 2020  f verbose:.     
+0000e520: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e530: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e540: 2020 2020 2020 2070 7269 6e74 2822 4e75         print("Nu
+0000e550: 6d62 6572 206f 6620 6f76 6572 6c61 7070  mber of overlapp
+0000e560: 696e 6720 7061 6972 733a 222c 2070 6f73  ing pairs:", pos
+0000e570: 7369 626c 655f 6f76 6572 6c61 7070 696e  sible_overlappin
+0000e580: 675f 7061 6972 7329 0a20 2020 2020 2020  g_pairs).       
+0000e590: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e5a0: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
+0000e5b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e5c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e5d0: 2020 2069 6620 706f 7373 6962 6c65 5f6f     if possible_o
+0000e5e0: 7665 726c 6170 7069 6e67 5f70 6169 7273  verlapping_pairs
+0000e5f0: 203d 3d20 6375 7272 656e 745f 6f76 6572   == current_over
+0000e600: 6c61 7070 696e 675f 7061 6972 733a 0a20  lapping_pairs:. 
 0000e610: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e620: 2020 2020 2020 2020 2020 706f 735f 7365            pos_se
-0000e630: 6c2e 6170 7065 6e64 286c 6f63 5b69 645f  l.append(loc[id_
-0000e640: 6365 6c6c 5d29 0a20 2020 2020 2020 2020  cell]).         
-0000e650: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e660: 2020 2020 2020 2073 656c 6563 7465 645f         selected_
-0000e670: 6964 7873 2e61 7070 656e 6428 6964 5f63  idxs.append(id_c
-0000e680: 656c 6c29 0a20 2020 2020 2020 2020 2020  ell).           
-0000e690: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e6a0: 2020 2020 2070 6c61 6365 6420 3d20 5472       placed = Tr
-0000e6b0: 7565 0a20 2020 2020 2020 2020 2020 2020  ue.             
-0000e6c0: 2020 2020 2020 2020 2020 2020 2020 2065                 e
-0000e6d0: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+0000e620: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e630: 2020 2020 2020 2070 6f73 5f73 656c 2e61         pos_sel.a
+0000e640: 7070 656e 6428 6c6f 635b 6964 5f63 656c  ppend(loc[id_cel
+0000e650: 6c5d 290a 2020 2020 2020 2020 2020 2020  l]).            
+0000e660: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e670: 2020 2020 2020 2020 2020 2020 7365 6c65              sele
+0000e680: 6374 6564 5f69 6478 732e 6170 7065 6e64  cted_idxs.append
+0000e690: 2869 645f 6365 6c6c 290a 2020 2020 2020  (id_cell).      
+0000e6a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e6b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e6c0: 2020 6e5f 7365 6c20 2b3d 2031 0a20 2020    n_sel += 1.   
+0000e6d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000e6e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e6f0: 2020 2020 2070 6f73 7369 626c 655f 7365       possible_se
-0000e700: 6c65 6374 6564 203d 2064 6565 7063 6f70  lected = deepcop
-0000e710: 7928 7365 6c65 6374 6564 5f69 6478 7329  y(selected_idxs)
-0000e720: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000e6f0: 2020 2020 2070 6c61 6365 6420 3d20 5472       placed = Tr
+0000e700: 7565 0a20 2020 2020 2020 2020 2020 2020  ue.             
+0000e710: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e720: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
 0000e730: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e740: 2070 6f73 7369 626c 655f 7365 6c65 6374   possible_select
-0000e750: 6564 2e61 7070 656e 6428 6964 5f63 656c  ed.append(id_cel
-0000e760: 6c29 0a20 2020 2020 2020 2020 2020 2020  l).             
+0000e740: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e750: 2020 2020 2069 6620 7665 7262 6f73 653a       if verbose:
+0000e760: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
 0000e770: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e780: 2020 206f 7665 726c 6170 7069 6e67 203d     overlapping =
-0000e790: 2066 696e 645f 6f76 6572 6c61 7070 696e   find_overlappin
-0000e7a0: 675f 7465 6d70 6c61 7465 7328 7465 6d70  g_templates(temp
-0000e7b0: 6c61 7465 735b 6e70 2e61 7272 6179 2870  lates[np.array(p
-0000e7c0: 6f73 7369 626c 655f 7365 6c65 6374 6564  ossible_selected
-0000e7d0: 292c 2030 5d2c 0a20 2020 2020 2020 2020  ), 0],.         
-0000e7e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e7f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e800: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e780: 2020 2020 2020 2020 2020 2020 2070 7269               pri
+0000e790: 6e74 2822 4f76 6572 6c61 7070 696e 6720  nt("Overlapping 
+0000e7a0: 7669 6f6c 6174 696f 6e3a 222c 2070 6f73  violation:", pos
+0000e7b0: 7369 626c 655f 6f76 6572 6c61 7070 696e  sible_overlappin
+0000e7c0: 675f 7061 6972 7329 0a20 2020 2020 2020  g_pairs).       
+0000e7d0: 2020 2020 2020 2020 2020 2020 2065 6c73               els
+0000e7e0: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+0000e7f0: 2020 2020 2020 2020 2020 2069 6620 7665             if ve
+0000e800: 7262 6f73 653a 0a20 2020 2020 2020 2020  rbose:.         
 0000e810: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e820: 6f76 6572 6c61 705f 7468 7265 7368 6f6c  overlap_threshol
-0000e830: 6429 0a20 2020 2020 2020 2020 2020 2020  d).             
-0000e840: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e850: 2020 2070 6f73 7369 626c 655f 6f76 6572     possible_over
-0000e860: 6c61 7070 696e 675f 7061 6972 7320 3d20  lapping_pairs = 
-0000e870: 6c65 6e28 6f76 6572 6c61 7070 696e 6729  len(overlapping)
-0000e880: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000e890: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e8a0: 2069 6620 706f 7373 6962 6c65 5f6f 7665   if possible_ove
-0000e8b0: 726c 6170 7069 6e67 5f70 6169 7273 203c  rlapping_pairs <
-0000e8c0: 3d20 6e5f 6f76 6572 6c61 705f 7061 6972  = n_overlap_pair
-0000e8d0: 733a 0a20 2020 2020 2020 2020 2020 2020  s:.             
-0000e8e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e8f0: 2020 2020 2020 2070 6f73 5f73 656c 2e61         pos_sel.a
-0000e900: 7070 656e 6428 6c6f 635b 6964 5f63 656c  ppend(loc[id_cel
-0000e910: 6c5d 290a 2020 2020 2020 2020 2020 2020  l]).            
-0000e920: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e930: 2020 2020 2020 2020 7365 6c65 6374 6564          selected
-0000e940: 5f69 6478 732e 6170 7065 6e64 2869 645f  _idxs.append(id_
-0000e950: 6365 6c6c 290a 2020 2020 2020 2020 2020  cell).          
-0000e960: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e970: 2020 2020 2020 2020 2020 6e5f 7365 6c20            n_sel 
-0000e980: 2b3d 2031 0a20 2020 2020 2020 2020 2020  += 1.           
-0000e990: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e9a0: 2020 2020 2020 2020 2070 6c61 6365 6420           placed 
-0000e9b0: 3d20 5472 7565 0a20 2020 2020 2020 2020  = True.         
-0000e9c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e9d0: 2020 2020 2020 2020 2020 2063 7572 7265             curre
-0000e9e0: 6e74 5f6f 7665 726c 6170 7069 6e67 5f70  nt_overlapping_p
-0000e9f0: 6169 7273 203d 206c 656e 286f 7665 726c  airs = len(overl
-0000ea00: 6170 7069 6e67 290a 2020 2020 2020 2020  apping).        
+0000e820: 2020 2070 7269 6e74 2822 416d 706c 6974     print("Amplit
+0000e830: 7564 6520 6f72 2062 6f75 6e64 6172 7920  ude or boundary 
+0000e840: 7669 6f6c 6174 696f 6e22 2c20 616d 702c  violation", amp,
+0000e850: 206c 6f63 5b69 645f 6365 6c6c 5d2c 2069   loc[id_cell], i
+0000e860: 7465 7229 0a20 2020 2020 2020 2020 2020  ter).           
+0000e870: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+0000e880: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+0000e890: 2064 7269 6674 696e 670a 2020 2020 2020   drifting.      
+0000e8a0: 2020 2020 2020 2020 2020 2020 2020 6966                if
+0000e8b0: 2069 735f 706f 7369 7469 6f6e 5f77 6974   is_position_wit
+0000e8c0: 6869 6e5f 626f 756e 6461 7269 6573 286c  hin_boundaries(l
+0000e8d0: 6f63 5b69 645f 6365 6c6c 2c20 305d 2c20  oc[id_cell, 0], 
+0000e8e0: 785f 6c69 6d2c 2079 5f6c 696d 2c20 7a5f  x_lim, y_lim, z_
+0000e8f0: 6c69 6d29 2061 6e64 206d 696e 5f61 6d70  lim) and min_amp
+0000e900: 203c 2061 6d70 203c 206d 6178 5f61 6d70   < amp < max_amp
+0000e910: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0000e920: 2020 2020 2020 2020 2020 2320 7361 7665            # save
+0000e930: 2063 656c 6c0a 2020 2020 2020 2020 2020   cell.          
+0000e940: 2020 2020 2020 2020 2020 2020 2020 6472                dr
+0000e950: 6966 745f 616e 676c 6520 3d20 6e70 2e72  ift_angle = np.r
+0000e960: 6164 3264 6567 286e 702e 6172 6363 6f73  ad2deg(np.arccos
+0000e970: 286e 702e 646f 7428 6472 6966 745f 6469  (np.dot(drift_di
+0000e980: 725b 6964 5f63 656c 6c5d 2c20 7072 6566  r[id_cell], pref
+0000e990: 6572 7265 645f 6469 7229 2929 0a20 2020  erred_dir))).   
+0000e9a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e9b0: 2020 2020 2069 6620 6472 6966 745f 616e       if drift_an
+0000e9c0: 676c 6520 2d20 616e 676c 655f 746f 6c20  gle - angle_tol 
+0000e9d0: 3c3d 2030 3a0a 2020 2020 2020 2020 2020  <= 0:.          
+0000e9e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e9f0: 2020 6966 206e 5f6f 7665 726c 6170 5f70    if n_overlap_p
+0000ea00: 6169 7273 2069 7320 4e6f 6e65 3a0a 2020  airs is None:.  
 0000ea10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ea20: 2020 2020 2020 2020 2020 2020 6966 2076              if v
-0000ea30: 6572 626f 7365 3a0a 2020 2020 2020 2020  erbose:.        
-0000ea40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ea20: 2020 2020 2020 2020 2020 2020 2020 706f                po
+0000ea30: 735f 7365 6c2e 6170 7065 6e64 286c 6f63  s_sel.append(loc
+0000ea40: 5b69 645f 6365 6c6c 5d29 0a20 2020 2020  [id_cell]).     
 0000ea50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ea60: 7072 696e 7428 274e 756d 6265 7220 6f66  print('Number of
-0000ea70: 206f 7665 726c 6170 7069 6e67 2070 6169   overlapping pai
-0000ea80: 7273 3a27 2c20 6375 7272 656e 745f 6f76  rs:', current_ov
-0000ea90: 6572 6c61 7070 696e 675f 7061 6972 7329  erlapping_pairs)
-0000eaa0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000eab0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000eac0: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
-0000ead0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000eae0: 2020 2020 2020 2020 2020 2069 6620 7665             if ve
-0000eaf0: 7262 6f73 653a 0a20 2020 2020 2020 2020  rbose:.         
-0000eb00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000eb10: 2020 2020 2020 2020 2020 2020 2020 2070                 p
-0000eb20: 7269 6e74 2827 4f76 6572 6c61 7070 696e  rint('Overlappin
-0000eb30: 6720 7669 6f6c 6174 696f 6e3a 272c 2063  g violation:', c
-0000eb40: 7572 7265 6e74 5f6f 7665 726c 6170 7069  urrent_overlappi
-0000eb50: 6e67 5f70 6169 7273 290a 2020 2020 2020  ng_pairs).      
+0000ea60: 2020 2020 2020 2020 2020 2073 656c 6563             selec
+0000ea70: 7465 645f 6964 7873 2e61 7070 656e 6428  ted_idxs.append(
+0000ea80: 6964 5f63 656c 6c29 0a20 2020 2020 2020  id_cell).       
+0000ea90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000eaa0: 2020 2020 2020 2020 206e 5f73 656c 202b           n_sel +
+0000eab0: 3d20 310a 2020 2020 2020 2020 2020 2020  = 1.            
+0000eac0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ead0: 2020 2020 706c 6163 6564 203d 2054 7275      placed = Tru
+0000eae0: 650a 2020 2020 2020 2020 2020 2020 2020  e.              
+0000eaf0: 2020 2020 2020 2020 2020 2020 2020 656c                el
+0000eb00: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+0000eb10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000eb20: 2020 2020 706f 7373 6962 6c65 5f73 656c      possible_sel
+0000eb30: 6563 7465 6420 3d20 6465 6570 636f 7079  ected = deepcopy
+0000eb40: 2873 656c 6563 7465 645f 6964 7873 290a  (selected_idxs).
+0000eb50: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000eb60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000eb70: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
-0000eb80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000eb90: 2020 2020 6966 2076 6572 626f 7365 3a0a      if verbose:.
+0000eb70: 706f 7373 6962 6c65 5f73 656c 6563 7465  possible_selecte
+0000eb80: 642e 6170 7065 6e64 2869 645f 6365 6c6c  d.append(id_cell
+0000eb90: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
 0000eba0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ebb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ebc0: 7072 696e 7428 2744 7269 6674 2076 696f  print('Drift vio
-0000ebd0: 6c61 7469 6f6e 272c 206c 6f63 5b69 645f  lation', loc[id_
-0000ebe0: 6365 6c6c 2c20 305d 2c20 6974 6572 290a  cell, 0], iter).
+0000ebb0: 2020 6f76 6572 6c61 7070 696e 6720 3d20    overlapping = 
+0000ebc0: 6669 6e64 5f6f 7665 726c 6170 7069 6e67  find_overlapping
+0000ebd0: 5f74 656d 706c 6174 6573 280a 2020 2020  _templates(.    
+0000ebe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000ebf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ec00: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-0000ec10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ec20: 2020 6966 2076 6572 626f 7365 3a0a 2020    if verbose:.  
-0000ec30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ec40: 2020 2020 2020 2020 2020 7072 696e 7428            print(
-0000ec50: 2741 6d70 6c69 7475 6465 206f 7220 626f  'Amplitude or bo
-0000ec60: 756e 6461 7279 2076 696f 6c61 7469 6f6e  undary violation
-0000ec70: 272c 2061 6d70 2c20 6c6f 635b 6964 5f63  ', amp, loc[id_c
-0000ec80: 656c 6c2c 2030 5d2c 2069 7465 7229 0a20  ell, 0], iter). 
-0000ec90: 2020 2020 2020 2020 2020 2069 6620 706c             if pl
-0000eca0: 6163 6564 3a0a 2020 2020 2020 2020 2020  aced:.          
-0000ecb0: 2020 2020 2020 7365 6c65 6374 6564 5f63        selected_c
-0000ecc0: 6174 2e61 7070 656e 6428 2755 2729 0a0a  at.append('U')..
-0000ecd0: 2020 2020 6966 2069 203d 3d20 6c65 6e28      if i == len(
-0000ece0: 7065 726d 7574 6564 5f69 6478 7329 202d  permuted_idxs) -
-0000ecf0: 2031 2061 6e64 206e 5f73 656c 203c 206e   1 and n_sel < n
-0000ed00: 5f65 7863 202b 206e 5f69 6e68 3a0a 2020  _exc + n_inh:.  
-0000ed10: 2020 2020 2020 7261 6973 6520 5275 6e74        raise Runt
-0000ed20: 696d 6545 7272 6f72 2822 5465 6d70 6c61  imeError("Templa
-0000ed30: 7465 7320 636f 756c 6420 6e6f 7420 6265  tes could not be
-0000ed40: 2073 656c 6563 7465 642e 205c 6e22 0a20   selected. \n". 
+0000ec00: 7465 6d70 6c61 7465 735b 6e70 2e61 7272  templates[np.arr
+0000ec10: 6179 2870 6f73 7369 626c 655f 7365 6c65  ay(possible_sele
+0000ec20: 6374 6564 292c 2030 5d2c 206f 7665 726c  cted), 0], overl
+0000ec30: 6170 5f74 6872 6573 686f 6c64 0a20 2020  ap_threshold.   
+0000ec40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ec50: 2020 2020 2020 2020 2020 2020 2029 0a20               ). 
+0000ec60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ec70: 2020 2020 2020 2020 2020 2020 2020 2070                 p
+0000ec80: 6f73 7369 626c 655f 6f76 6572 6c61 7070  ossible_overlapp
+0000ec90: 696e 675f 7061 6972 7320 3d20 6c65 6e28  ing_pairs = len(
+0000eca0: 6f76 6572 6c61 7070 696e 6729 0a20 2020  overlapping).   
+0000ecb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ecc0: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+0000ecd0: 706f 7373 6962 6c65 5f6f 7665 726c 6170  possible_overlap
+0000ece0: 7069 6e67 5f70 6169 7273 203c 3d20 6e5f  ping_pairs <= n_
+0000ecf0: 6f76 6572 6c61 705f 7061 6972 733a 0a20  overlap_pairs:. 
+0000ed00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ed10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ed20: 2020 2070 6f73 5f73 656c 2e61 7070 656e     pos_sel.appen
+0000ed30: 6428 6c6f 635b 6964 5f63 656c 6c5d 290a  d(loc[id_cell]).
+0000ed40: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000ed50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ed60: 2020 2020 2020 2020 2020 2244 6563 7265            "Decre
-0000ed70: 6173 6520 6e75 6d62 6572 206f 6620 7370  ase number of sp
-0000ed80: 696b 6574 7261 696e 732c 2064 6563 7265  iketrains, decre
-0000ed90: 6173 6520 276d 696e 5f64 6973 7427 2c20  ase 'min_dist', 
-0000eda0: 6f72 2075 7365 206d 6f72 6520 7465 6d70  or use more temp
-0000edb0: 6c61 7465 732e 2229 0a20 2020 2072 6574  lates.").    ret
-0000edc0: 7572 6e20 7365 6c65 6374 6564 5f69 6478  urn selected_idx
-0000edd0: 732c 2073 656c 6563 7465 645f 6361 740a  s, selected_cat.
-0000ede0: 0a0a 6465 6620 7265 7361 6d70 6c65 5f74  ..def resample_t
-0000edf0: 656d 706c 6174 6573 2874 656d 706c 6174  emplates(templat
-0000ee00: 6573 2c20 6e5f 7265 7361 6d70 6c65 2c20  es, n_resample, 
-0000ee10: 7570 2c20 646f 776e 2c20 6472 6966 7469  up, down, drifti
-0000ee20: 6e67 2c20 6474 7970 652c 2076 6572 626f  ng, dtype, verbo
-0000ee30: 7365 2c20 6e5f 6a6f 6273 3d4e 6f6e 652c  se, n_jobs=None,
-0000ee40: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000ee50: 2020 2020 2020 2020 746d 705f 6669 6c65          tmp_file
-0000ee60: 3d4e 6f6e 652c 2070 6172 616c 6c65 6c3d  =None, parallel=
-0000ee70: 4661 6c73 6529 3a0a 2020 2020 2222 220a  False):.    """.
-0000ee80: 2020 2020 5265 7361 6d70 6c65 7320 7468      Resamples th
-0000ee90: 6520 7465 6d70 6c61 7465 7320 746f 2061  e templates to a
-0000eea0: 2073 7065 6369 6669 6564 2073 616d 706c   specified sampl
-0000eeb0: 696e 6720 6672 6571 7565 6e63 792e 0a20  ing frequency.. 
-0000eec0: 2020 2050 6172 616d 6574 6572 730a 2020     Parameters.  
-0000eed0: 2020 2d2d 2d2d 2d2d 2d2d 2d2d 0a20 2020    ----------.   
-0000eee0: 2074 656d 706c 6174 6573 203a 206e 702e   templates : np.
-0000eef0: 6172 7261 790a 2020 2020 2020 2020 4172  array.        Ar
-0000ef00: 7261 7920 7769 7468 2074 656d 706c 6174  ray with templat
-0000ef10: 6573 2028 6e5f 6e65 7572 6f6e 732c 206e  es (n_neurons, n
-0000ef20: 5f63 6861 6e6e 656c 732c 206e 5f73 616d  _channels, n_sam
-0000ef30: 706c 6573 290a 2020 2020 2020 2020 6f72  ples).        or
-0000ef40: 2028 6e5f 6e65 7572 6f6e 732c 206e 5f64   (n_neurons, n_d
-0000ef50: 7269 6674 2c20 6e5f 6368 616e 6e65 6c73  rift, n_channels
-0000ef60: 2c20 6e5f 7361 6d70 6c65 7329 2069 6620  , n_samples) if 
-0000ef70: 6472 6966 7469 6e67 0a20 2020 206e 5f72  drifting.    n_r
-0000ef80: 6573 616d 706c 6520 3a20 696e 740a 2020  esample : int.  
-0000ef90: 2020 2020 2020 5361 6d70 6c65 7320 666f        Samples fo
-0000efa0: 7220 7265 7361 6d70 6c65 6420 7465 6d70  r resampled temp
-0000efb0: 6c61 7465 730a 2020 2020 7570 203a 2066  lates.    up : f
-0000efc0: 6c6f 6174 0a20 2020 2020 2020 2054 6865  loat.        The
-0000efd0: 206f 7269 6769 6e61 6c20 7361 6d70 6c69   original sampli
-0000efe0: 6e67 2066 7265 7175 656e 6379 2069 6e20  ng frequency in 
-0000eff0: 487a 0a20 2020 2064 6f77 6e20 3a20 666c  Hz.    down : fl
-0000f000: 6f61 740a 2020 2020 2020 2020 5468 6520  oat.        The 
-0000f010: 6e65 7720 7361 6d70 6c69 6e67 2066 7265  new sampling fre
-0000f020: 7175 656e 6379 2069 6e20 487a 0a20 2020  quency in Hz.   
-0000f030: 2064 7269 6674 696e 6720 3a20 626f 6f6c   drifting : bool
-0000f040: 0a20 2020 2020 2020 2049 6620 5472 7565  .        If True
-0000f050: 2074 656d 706c 6174 6573 2061 7265 2061   templates are a
-0000f060: 7373 756d 6564 2074 6f20 6265 2064 7269  ssumed to be dri
-0000f070: 6674 696e 670a 2020 2020 7665 7262 6f73  fting.    verbos
-0000f080: 6520 3a20 626f 6f6c 0a20 2020 2020 2020  e : bool.       
-0000f090: 2049 6620 5472 7565 206f 7574 7075 7420   If True output 
-0000f0a0: 6973 2076 6572 626f 7365 0a20 2020 206e  is verbose.    n
-0000f0b0: 5f6a 6f62 7320 3a20 696e 740a 2020 2020  _jobs : int.    
-0000f0c0: 2020 2020 4e75 6d62 6572 206f 6620 6a6f      Number of jo
-0000f0d0: 6273 2066 6f72 2070 6172 616c 6c65 6c20  bs for parallel 
-0000f0e0: 7072 6f63 6573 7369 6e67 2e20 4966 204e  processing. If N
-0000f0f0: 6f6e 6520 6861 6c66 2063 7075 7320 6172  one half cpus ar
-0000f100: 6520 7573 6564 0a20 2020 2074 6d70 5f66  e used.    tmp_f
-0000f110: 696c 6520 3a20 7374 720a 2020 2020 2020  ile : str.      
-0000f120: 2020 5061 7468 2074 6f20 746d 7020 6669    Path to tmp fi
-0000f130: 6c65 2074 6f20 6d65 6d6d 6170 2e20 4966  le to memmap. If
-0000f140: 204e 6f6e 652c 2070 726f 6365 7373 696e   None, processin
-0000f150: 6720 6973 2069 6e20 6d65 6d6f 7279 0a20  g is in memory. 
-0000f160: 2020 2070 6172 616c 6c65 6c20 3a20 626f     parallel : bo
-0000f170: 6f6c 0a20 2020 2020 2020 2049 6620 5472  ol.        If Tr
-0000f180: 7565 2065 6163 6820 7465 6d70 6c61 7465  ue each template
-0000f190: 2069 7320 7265 7361 6d70 6c65 6420 696e   is resampled in
-0000f1a0: 2070 6172 656c 6c65 6c0a 2020 2020 5265   parellel.    Re
-0000f1b0: 7475 726e 730a 2020 2020 2d2d 2d2d 2d2d  turns.    ------
-0000f1c0: 2d0a 2020 2020 7465 6d70 6c61 7465 5f72  -.    template_r
-0000f1d0: 7320 3a20 6e70 2e61 7272 6179 0a20 2020  s : np.array.   
-0000f1e0: 2020 2020 2041 7272 6179 2077 6974 6820       Array with 
-0000f1f0: 7265 7361 6d70 6c65 6420 7465 6d70 6c61  resampled templa
-0000f200: 7465 7320 286e 5f6e 6575 726f 6e73 2c20  tes (n_neurons, 
-0000f210: 6e5f 6368 616e 6e65 6c73 2c20 6e5f 7265  n_channels, n_re
-0000f220: 7361 6d70 6c65 290a 2020 2020 2020 2020  sample).        
-0000f230: 6f72 2028 6e5f 6e65 7572 6f6e 732c 206e  or (n_neurons, n
-0000f240: 5f64 7269 6674 2c20 6e5f 6368 616e 6e65  _drift, n_channe
-0000f250: 6c73 2c20 6e5f 7265 7361 6d70 6c65 2920  ls, n_resample) 
-0000f260: 6966 2064 7269 6674 696e 670a 2020 2020  if drifting.    
-0000f270: 2222 220a 2020 2020 2320 6372 6561 7465  """.    # create
-0000f280: 2072 6573 616d 706c 6564 2074 656d 706c   resampled templ
-0000f290: 6174 6573 0a20 2020 2069 6620 6e6f 7420  ates.    if not 
-0000f2a0: 6472 6966 7469 6e67 3a0a 2020 2020 2020  drifting:.      
-0000f2b0: 2020 6966 2074 6d70 5f66 696c 6520 6973    if tmp_file is
-0000f2c0: 206e 6f74 204e 6f6e 653a 0a20 2020 2020   not None:.     
-0000f2d0: 2020 2020 2020 2074 656d 706c 6174 6573         templates
-0000f2e0: 5f72 7320 3d20 6e70 2e6d 656d 6d61 7028  _rs = np.memmap(
-0000f2f0: 746d 705f 6669 6c65 2c20 7368 6170 653d  tmp_file, shape=
-0000f300: 2874 656d 706c 6174 6573 2e73 6861 7065  (templates.shape
-0000f310: 5b30 5d2c 2074 656d 706c 6174 6573 2e73  [0], templates.s
-0000f320: 6861 7065 5b31 5d2c 206e 5f72 6573 616d  hape[1], n_resam
-0000f330: 706c 6529 2c0a 2020 2020 2020 2020 2020  ple),.          
-0000f340: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f350: 2020 2020 2020 2020 2020 2064 7479 7065             dtype
-0000f360: 3d64 7479 7065 2c20 6d6f 6465 3d27 772b  =dtype, mode='w+
-0000f370: 2729 0a20 2020 2020 2020 2065 6c73 653a  ').        else:
-0000f380: 0a20 2020 2020 2020 2020 2020 2074 656d  .            tem
-0000f390: 706c 6174 6573 5f72 7320 3d20 6e70 2e7a  plates_rs = np.z
-0000f3a0: 6572 6f73 2828 7465 6d70 6c61 7465 732e  eros((templates.
-0000f3b0: 7368 6170 655b 305d 2c20 7465 6d70 6c61  shape[0], templa
-0000f3c0: 7465 732e 7368 6170 655b 315d 2c20 6e5f  tes.shape[1], n_
-0000f3d0: 7265 7361 6d70 6c65 2929 0a20 2020 2065  resample)).    e
-0000f3e0: 6c73 653a 0a20 2020 2020 2020 2069 6620  lse:.        if 
-0000f3f0: 746d 705f 6669 6c65 2069 7320 6e6f 7420  tmp_file is not 
-0000f400: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
-0000f410: 2020 7465 6d70 6c61 7465 735f 7273 203d    templates_rs =
-0000f420: 206e 702e 6d65 6d6d 6170 2874 6d70 5f66   np.memmap(tmp_f
-0000f430: 696c 652c 2073 6861 7065 3d28 7465 6d70  ile, shape=(temp
-0000f440: 6c61 7465 732e 7368 6170 655b 305d 2c20  lates.shape[0], 
-0000f450: 7465 6d70 6c61 7465 732e 7368 6170 655b  templates.shape[
-0000f460: 315d 2c0a 2020 2020 2020 2020 2020 2020  1],.            
-0000f470: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f480: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f490: 2020 2020 2020 2020 2020 7465 6d70 6c61            templa
-0000f4a0: 7465 732e 7368 6170 655b 325d 2c20 6e5f  tes.shape[2], n_
-0000f4b0: 7265 7361 6d70 6c65 292c 0a20 2020 2020  resample),.     
-0000f4c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f4d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f4e0: 6474 7970 653d 6474 7970 652c 206d 6f64  dtype=dtype, mod
-0000f4f0: 653d 2777 2b27 290a 2020 2020 2020 2020  e='w+').        
-0000f500: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
-0000f510: 2020 7465 6d70 6c61 7465 735f 7273 203d    templates_rs =
-0000f520: 206e 702e 7a65 726f 7328 0a20 2020 2020   np.zeros(.     
-0000f530: 2020 2020 2020 2020 2020 2028 7465 6d70             (temp
-0000f540: 6c61 7465 732e 7368 6170 655b 305d 2c20  lates.shape[0], 
-0000f550: 7465 6d70 6c61 7465 732e 7368 6170 655b  templates.shape[
-0000f560: 315d 2c20 7465 6d70 6c61 7465 732e 7368  1], templates.sh
-0000f570: 6170 655b 325d 2c20 6e5f 7265 7361 6d70  ape[2], n_resamp
-0000f580: 6c65 2929 0a0a 2020 2020 6966 2070 6172  le))..    if par
-0000f590: 616c 6c65 6c3a 0a20 2020 2020 2020 2069  allel:.        i
-0000f5a0: 6620 6e5f 6a6f 6273 2069 7320 4e6f 6e65  f n_jobs is None
-0000f5b0: 3a0a 2020 2020 2020 2020 2020 2020 6e5f  :.            n_
-0000f5c0: 6a6f 6273 203d 206f 732e 6370 755f 636f  jobs = os.cpu_co
-0000f5d0: 756e 7428 2920 2f2f 2032 0a0a 2020 2020  unt() // 2..    
-0000f5e0: 2020 2020 6966 2076 6572 626f 7365 3a0a      if verbose:.
-0000f5f0: 2020 2020 2020 2020 2020 2020 7072 696e              prin
-0000f600: 7428 2752 6573 616d 706c 696e 6720 7769  t('Resampling wi
-0000f610: 7468 272c 206e 5f6a 6f62 732c 2027 6a6f  th', n_jobs, 'jo
-0000f620: 6273 2729 0a0a 2020 2020 2020 2020 6f75  bs')..        ou
-0000f630: 7470 7574 5f6c 6973 7420 3d20 5061 7261  tput_list = Para
-0000f640: 6c6c 656c 286e 5f6a 6f62 733d 6e5f 6a6f  llel(n_jobs=n_jo
-0000f650: 6273 2928 0a20 2020 2020 2020 2020 2020  bs)(.           
-0000f660: 2064 656c 6179 6564 285f 7265 7361 6d70   delayed(_resamp
-0000f670: 6c65 5f70 6172 616c 6c65 6c29 2869 2c20  le_parallel)(i, 
-0000f680: 7465 6d2c 2075 702c 2064 6f77 6e2c 2064  tem, up, down, d
-0000f690: 7269 6674 696e 672c 2029 2066 6f72 2069  rifting, ) for i
-0000f6a0: 2c20 7465 6d20 696e 2065 6e75 6d65 7261  , tem in enumera
-0000f6b0: 7465 2874 656d 706c 6174 6573 2929 0a0a  te(templates))..
-0000f6c0: 2020 2020 2020 2020 666f 7220 692c 2074          for i, t
-0000f6d0: 656d 2069 6e20 656e 756d 6572 6174 6528  em in enumerate(
-0000f6e0: 7465 6d70 6c61 7465 7329 3a0a 2020 2020  templates):.    
-0000f6f0: 2020 2020 2020 2020 7465 6d70 6c61 7465          template
-0000f700: 5f72 7320 3d20 6f75 7470 7574 5f6c 6973  _rs = output_lis
-0000f710: 745b 695d 0a20 2020 2020 2020 2020 2020  t[i].           
-0000f720: 2069 6620 7465 6d70 6c61 7465 5f72 732e   if template_rs.
-0000f730: 7368 6170 655b 2d31 5d20 3c20 7465 6d70  shape[-1] < temp
-0000f740: 6c61 7465 735f 7273 2e73 6861 7065 5b2d  lates_rs.shape[-
-0000f750: 315d 3a0a 2020 2020 2020 2020 2020 2020  1]:.            
-0000f760: 2020 2020 6966 206e 6f74 2064 7269 6674      if not drift
-0000f770: 696e 673a 0a20 2020 2020 2020 2020 2020  ing:.           
-0000f780: 2020 2020 2020 2020 2074 656d 706c 6174           templat
-0000f790: 6573 5f72 735b 692c 203a 2c20 3a6c 656e  es_rs[i, :, :len
-0000f7a0: 2874 656d 706c 6174 655f 7273 295d 203d  (template_rs)] =
-0000f7b0: 2074 656d 706c 6174 655f 7273 0a20 2020   template_rs.   
-0000f7c0: 2020 2020 2020 2020 2020 2020 2065 6c73               els
-0000f7d0: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-0000f7e0: 2020 2020 2020 2074 656d 706c 6174 6573         templates
-0000f7f0: 5f72 735b 692c 203a 2c20 3a2c 203a 6c65  _rs[i, :, :, :le
-0000f800: 6e28 7465 6d70 6c61 7465 5f72 7329 5d20  n(template_rs)] 
-0000f810: 3d20 7465 6d70 6c61 7465 5f72 730a 2020  = template_rs.  
-0000f820: 2020 2020 2020 2020 2020 656c 6966 2074            elif t
-0000f830: 656d 706c 6174 655f 7273 2e73 6861 7065  emplate_rs.shape
-0000f840: 5b2d 315d 203e 2074 656d 706c 6174 6573  [-1] > templates
-0000f850: 5f72 732e 7368 6170 655b 2d31 5d3a 0a20  _rs.shape[-1]:. 
-0000f860: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-0000f870: 6620 6e6f 7420 6472 6966 7469 6e67 3a0a  f not drifting:.
-0000f880: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f890: 2020 2020 7465 6d70 6c61 7465 735f 7273      templates_rs
-0000f8a0: 5b69 5d20 3d20 7465 6d70 6c61 7465 5f72  [i] = template_r
-0000f8b0: 735b 3a2c 203a 7465 6d70 6c61 7465 735f  s[:, :templates_
-0000f8c0: 7273 2e73 6861 7065 5b2d 315d 5d0a 2020  rs.shape[-1]].  
-0000f8d0: 2020 2020 2020 2020 2020 2020 2020 656c                el
-0000f8e0: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-0000f8f0: 2020 2020 2020 2020 7465 6d70 6c61 7465          template
-0000f900: 735f 7273 5b69 5d20 3d20 7465 6d70 6c61  s_rs[i] = templa
-0000f910: 7465 5f72 735b 3a2c 203a 2c20 3a74 656d  te_rs[:, :, :tem
-0000f920: 706c 6174 6573 5f72 732e 7368 6170 655b  plates_rs.shape[
-0000f930: 2d31 5d5d 0a20 2020 2020 2020 2020 2020  -1]].           
-0000f940: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
-0000f950: 2020 2020 2020 2074 656d 706c 6174 6573         templates
-0000f960: 5f72 735b 695d 203d 2074 656d 706c 6174  _rs[i] = templat
-0000f970: 655f 7273 0a20 2020 2065 6c73 653a 0a20  e_rs.    else:. 
-0000f980: 2020 2020 2020 2066 6f72 2069 2c20 7465         for i, te
-0000f990: 6d20 696e 2065 6e75 6d65 7261 7465 2874  m in enumerate(t
-0000f9a0: 656d 706c 6174 6573 293a 0a20 2020 2020  emplates):.     
-0000f9b0: 2020 2020 2020 2074 656d 706c 6174 655f         template_
-0000f9c0: 7273 203d 205f 7265 7361 6d70 6c65 5f70  rs = _resample_p
-0000f9d0: 6172 616c 6c65 6c28 692c 2074 656d 2c20  arallel(i, tem, 
-0000f9e0: 7570 2c20 646f 776e 2c20 6472 6966 7469  up, down, drifti
-0000f9f0: 6e67 290a 2020 2020 2020 2020 2020 2020  ng).            
-0000fa00: 6966 2074 656d 706c 6174 655f 7273 2e73  if template_rs.s
-0000fa10: 6861 7065 5b2d 315d 203c 2074 656d 706c  hape[-1] < templ
-0000fa20: 6174 6573 5f72 732e 7368 6170 655b 2d31  ates_rs.shape[-1
-0000fa30: 5d3a 0a20 2020 2020 2020 2020 2020 2020  ]:.             
-0000fa40: 2020 2069 6620 6e6f 7420 6472 6966 7469     if not drifti
-0000fa50: 6e67 3a0a 2020 2020 2020 2020 2020 2020  ng:.            
-0000fa60: 2020 2020 2020 2020 7465 6d70 6c61 7465          template
-0000fa70: 735f 7273 5b69 2c20 3a2c 203a 6c65 6e28  s_rs[i, :, :len(
-0000fa80: 7465 6d70 6c61 7465 5f72 7329 5d20 3d20  template_rs)] = 
-0000fa90: 7465 6d70 6c61 7465 5f72 730a 2020 2020  template_rs.    
-0000faa0: 2020 2020 2020 2020 2020 2020 656c 7365              else
-0000fab0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0000fac0: 2020 2020 2020 7465 6d70 6c61 7465 735f        templates_
-0000fad0: 7273 5b69 2c20 3a2c 203a 2c20 3a6c 656e  rs[i, :, :, :len
-0000fae0: 2874 656d 706c 6174 655f 7273 295d 203d  (template_rs)] =
-0000faf0: 2074 656d 706c 6174 655f 7273 0a20 2020   template_rs.   
-0000fb00: 2020 2020 2020 2020 2065 6c69 6620 7465           elif te
-0000fb10: 6d70 6c61 7465 5f72 732e 7368 6170 655b  mplate_rs.shape[
-0000fb20: 2d31 5d20 3e20 7465 6d70 6c61 7465 735f  -1] > templates_
-0000fb30: 7273 2e73 6861 7065 5b2d 315d 3a0a 2020  rs.shape[-1]:.  
-0000fb40: 2020 2020 2020 2020 2020 2020 2020 6966                if
-0000fb50: 206e 6f74 2064 7269 6674 696e 673a 0a20   not drifting:. 
-0000fb60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000fb70: 2020 2074 656d 706c 6174 6573 5f72 735b     templates_rs[
-0000fb80: 695d 203d 2074 656d 706c 6174 655f 7273  i] = template_rs
-0000fb90: 5b3a 2c20 3a74 656d 706c 6174 6573 5f72  [:, :templates_r
-0000fba0: 732e 7368 6170 655b 2d31 5d5d 0a20 2020  s.shape[-1]].   
-0000fbb0: 2020 2020 2020 2020 2020 2020 2065 6c73               els
-0000fbc0: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-0000fbd0: 2020 2020 2020 2074 656d 706c 6174 6573         templates
-0000fbe0: 5f72 735b 695d 203d 2074 656d 706c 6174  _rs[i] = templat
-0000fbf0: 655f 7273 5b3a 2c20 3a2c 203a 7465 6d70  e_rs[:, :, :temp
-0000fc00: 6c61 7465 735f 7273 2e73 6861 7065 5b2d  lates_rs.shape[-
-0000fc10: 315d 5d0a 2020 2020 2020 2020 2020 2020  1]].            
-0000fc20: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
-0000fc30: 2020 2020 2020 7465 6d70 6c61 7465 735f        templates_
-0000fc40: 7273 5b69 5d20 3d20 7465 6d70 6c61 7465  rs[i] = template
-0000fc50: 5f72 730a 0a20 2020 2072 6574 7572 6e20  _rs..    return 
-0000fc60: 7465 6d70 6c61 7465 735f 7273 0a0a 0a64  templates_rs...d
-0000fc70: 6566 2070 6164 5f74 656d 706c 6174 6573  ef pad_templates
-0000fc80: 2874 656d 706c 6174 6573 2c20 7061 645f  (templates, pad_
-0000fc90: 7361 6d70 6c65 732c 2064 7269 6674 696e  samples, driftin
-0000fca0: 672c 2064 7479 7065 2c20 7665 7262 6f73  g, dtype, verbos
-0000fcb0: 652c 206e 5f6a 6f62 733d 4e6f 6e65 2c0a  e, n_jobs=None,.
-0000fcc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000fcd0: 2020 746d 705f 6669 6c65 3d4e 6f6e 652c    tmp_file=None,
-0000fce0: 2070 6172 616c 6c65 6c3d 4661 6c73 6529   parallel=False)
-0000fcf0: 3a0a 2020 2020 2222 220a 2020 2020 5061  :.    """.    Pa
-0000fd00: 6473 2074 6865 2074 656d 706c 6174 6573  ds the templates
-0000fd10: 206f 6e20 626f 7468 2065 6e64 732e 0a20   on both ends.. 
-0000fd20: 2020 2050 6172 616d 6574 6572 730a 2020     Parameters.  
-0000fd30: 2020 2d2d 2d2d 2d2d 2d2d 2d2d 0a20 2020    ----------.   
-0000fd40: 2074 656d 706c 6174 6573 203a 206e 702e   templates : np.
-0000fd50: 6172 7261 790a 2020 2020 2020 2020 4172  array.        Ar
-0000fd60: 7261 7920 7769 7468 2074 656d 706c 6174  ray with templat
-0000fd70: 6573 2028 6e5f 6e65 7572 6f6e 732c 206e  es (n_neurons, n
-0000fd80: 5f63 6861 6e6e 656c 732c 206e 5f73 616d  _channels, n_sam
-0000fd90: 706c 6573 290a 2020 2020 2020 2020 6f72  ples).        or
-0000fda0: 2028 6e5f 6e65 7572 6f6e 732c 206e 5f64   (n_neurons, n_d
-0000fdb0: 7269 6674 2c20 6e5f 6368 616e 6e65 6c73  rift, n_channels
-0000fdc0: 2c20 6e5f 7361 6d70 6c65 7329 2069 6620  , n_samples) if 
-0000fdd0: 6472 6966 7469 6e67 0a20 2020 2070 6164  drifting.    pad
-0000fde0: 5f73 616d 706c 6573 203a 206c 6973 740a  _samples : list.
-0000fdf0: 2020 2020 2020 2020 4c69 7374 206f 6620          List of 
-0000fe00: 3220 696e 7473 2077 6974 6820 6e75 6d62  2 ints with numb
-0000fe10: 6572 206f 6620 7361 6d70 6c65 7320 666f  er of samples fo
-0000fe20: 7220 7061 6464 696e 6720 6265 666f 7265  r padding before
-0000fe30: 2061 6e64 2061 6674 6572 0a20 2020 2064   and after.    d
-0000fe40: 7269 6674 696e 6720 3a20 626f 6f6c 0a20  rifting : bool. 
-0000fe50: 2020 2020 2020 2049 6620 5472 7565 2074         If True t
-0000fe60: 656d 706c 6174 6573 2061 7265 2061 7373  emplates are ass
-0000fe70: 756d 6564 2074 6f20 6265 2064 7269 6674  umed to be drift
-0000fe80: 696e 670a 2020 2020 7665 7262 6f73 6520  ing.    verbose 
-0000fe90: 3a20 626f 6f6c 0a20 2020 2020 2020 2049  : bool.        I
-0000fea0: 6620 5472 7565 206f 7574 7075 7420 6973  f True output is
-0000feb0: 2076 6572 626f 7365 0a20 2020 206e 5f6a   verbose.    n_j
-0000fec0: 6f62 7320 3a20 696e 740a 2020 2020 2020  obs : int.      
-0000fed0: 2020 4e75 6d62 6572 206f 6620 6a6f 6273    Number of jobs
-0000fee0: 2066 6f72 2070 6172 616c 6c65 6c20 7072   for parallel pr
-0000fef0: 6f63 6573 7369 6e67 2e20 4966 204e 6f6e  ocessing. If Non
-0000ff00: 6520 6861 6c66 2063 7075 7320 6172 6520  e half cpus are 
-0000ff10: 7573 6564 0a20 2020 2074 6d70 5f66 696c  used.    tmp_fil
-0000ff20: 6520 3a20 7374 720a 2020 2020 2020 2020  e : str.        
-0000ff30: 5061 7468 2074 6f20 746d 7020 6669 6c65  Path to tmp file
-0000ff40: 2074 6f20 6d65 6d6d 6170 2e20 4966 204e   to memmap. If N
-0000ff50: 6f6e 652c 2070 726f 6365 7373 696e 6720  one, processing 
-0000ff60: 6973 2069 6e20 6d65 6d6f 7279 0a20 2020  is in memory.   
-0000ff70: 2070 6172 616c 6c65 6c20 3a20 626f 6f6c   parallel : bool
-0000ff80: 0a20 2020 2020 2020 2049 6620 5472 7565  .        If True
-0000ff90: 2065 6163 6820 7465 6d70 6c61 7465 2069   each template i
-0000ffa0: 7320 7061 6464 6564 2069 6e20 7061 7265  s padded in pare
-0000ffb0: 6c6c 656c 0a20 2020 2052 6574 7572 6e73  llel.    Returns
-0000ffc0: 0a20 2020 202d 2d2d 2d2d 2d2d 0a20 2020  .    -------.   
-0000ffd0: 2074 656d 706c 6174 655f 7061 6420 3a20   template_pad : 
-0000ffe0: 6e70 2e61 7272 6179 0a20 2020 2020 2020  np.array.       
-0000fff0: 2041 7272 6179 2077 6974 6820 7061 6464   Array with padd
-00010000: 6564 2074 656d 706c 6174 6573 2028 6e5f  ed templates (n_
-00010010: 6e65 7572 6f6e 732c 206e 5f63 6861 6e6e  neurons, n_chann
-00010020: 656c 732c 206e 5f70 6164 6465 645f 7361  els, n_padded_sa
-00010030: 6d70 6c65 290a 2020 2020 2020 2020 6f72  mple).        or
-00010040: 2028 6e5f 6e65 7572 6f6e 732c 206e 5f64   (n_neurons, n_d
-00010050: 7269 6674 2c20 6e5f 6368 616e 6e65 6c73  rift, n_channels
-00010060: 2c20 6e5f 7061 6464 6564 5f73 616d 706c  , n_padded_sampl
-00010070: 6529 2069 6620 6472 6966 7469 6e67 0a20  e) if drifting. 
-00010080: 2020 2022 2222 0a20 2020 2070 6164 6465     """.    padde
-00010090: 645f 7465 6d70 6c61 7465 5f73 616d 706c  d_template_sampl
-000100a0: 6573 203d 2074 656d 706c 6174 6573 2e73  es = templates.s
-000100b0: 6861 7065 5b2d 315d 202b 206e 702e 7375  hape[-1] + np.su
-000100c0: 6d28 7061 645f 7361 6d70 6c65 7329 0a20  m(pad_samples). 
-000100d0: 2020 2023 2063 7265 6174 6520 7061 6464     # create padd
-000100e0: 6564 2074 656d 706c 6174 6573 0a20 2020  ed templates.   
-000100f0: 2069 6620 6e6f 7420 6472 6966 7469 6e67   if not drifting
-00010100: 3a0a 2020 2020 2020 2020 6966 2074 6d70  :.        if tmp
-00010110: 5f66 696c 6520 6973 206e 6f74 204e 6f6e  _file is not Non
-00010120: 653a 0a20 2020 2020 2020 2020 2020 2074  e:.            t
-00010130: 656d 706c 6174 6573 5f70 6164 203d 206e  emplates_pad = n
-00010140: 702e 6d65 6d6d 6170 2874 6d70 5f66 696c  p.memmap(tmp_fil
-00010150: 652c 2073 6861 7065 3d28 7465 6d70 6c61  e, shape=(templa
-00010160: 7465 732e 7368 6170 655b 305d 2c20 7465  tes.shape[0], te
-00010170: 6d70 6c61 7465 732e 7368 6170 655b 315d  mplates.shape[1]
-00010180: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00010190: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000101a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000101b0: 2020 2020 2020 2020 2070 6164 6465 645f           padded_
-000101c0: 7465 6d70 6c61 7465 5f73 616d 706c 6573  template_samples
-000101d0: 292c 0a20 2020 2020 2020 2020 2020 2020  ),.             
-000101e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000101f0: 2020 2020 2020 2020 2064 7479 7065 3d64           dtype=d
-00010200: 7479 7065 2c20 6d6f 6465 3d27 772b 2729  type, mode='w+')
-00010210: 0a20 2020 2020 2020 2065 6c73 653a 0a20  .        else:. 
-00010220: 2020 2020 2020 2020 2020 2074 656d 706c             templ
-00010230: 6174 6573 5f70 6164 203d 206e 702e 7a65  ates_pad = np.ze
-00010240: 726f 7328 2874 656d 706c 6174 6573 2e73  ros((templates.s
-00010250: 6861 7065 5b30 5d2c 2074 656d 706c 6174  hape[0], templat
-00010260: 6573 2e73 6861 7065 5b31 5d2c 2070 6164  es.shape[1], pad
-00010270: 6465 645f 7465 6d70 6c61 7465 5f73 616d  ded_template_sam
-00010280: 706c 6573 2929 0a20 2020 2065 6c73 653a  ples)).    else:
-00010290: 0a20 2020 2020 2020 2069 6620 746d 705f  .        if tmp_
-000102a0: 6669 6c65 2069 7320 6e6f 7420 4e6f 6e65  file is not None
-000102b0: 3a0a 2020 2020 2020 2020 2020 2020 7465  :.            te
-000102c0: 6d70 6c61 7465 735f 7061 6420 3d20 6e70  mplates_pad = np
-000102d0: 2e6d 656d 6d61 7028 746d 705f 6669 6c65  .memmap(tmp_file
-000102e0: 2c20 7368 6170 653d 2874 656d 706c 6174  , shape=(templat
-000102f0: 6573 2e73 6861 7065 5b30 5d2c 2074 656d  es.shape[0], tem
-00010300: 706c 6174 6573 2e73 6861 7065 5b31 5d2c  plates.shape[1],
-00010310: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00010320: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010330: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010340: 2020 2020 2020 2020 7465 6d70 6c61 7465          template
-00010350: 732e 7368 6170 655b 325d 2c20 7061 6464  s.shape[2], padd
-00010360: 6564 5f74 656d 706c 6174 655f 7361 6d70  ed_template_samp
-00010370: 6c65 7329 2c0a 2020 2020 2020 2020 2020  les),.          
-00010380: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010390: 2020 2020 2020 2020 2020 2020 6474 7970              dtyp
-000103a0: 653d 6474 7970 652c 206d 6f64 653d 2777  e=dtype, mode='w
-000103b0: 2b27 290a 2020 2020 2020 2020 656c 7365  +').        else
-000103c0: 3a0a 2020 2020 2020 2020 2020 2020 7465  :.            te
-000103d0: 6d70 6c61 7465 735f 7061 6420 3d20 6e70  mplates_pad = np
-000103e0: 2e7a 6572 6f73 280a 2020 2020 2020 2020  .zeros(.        
-000103f0: 2020 2020 2020 2020 2874 656d 706c 6174          (templat
-00010400: 6573 2e73 6861 7065 5b30 5d2c 2074 656d  es.shape[0], tem
-00010410: 706c 6174 6573 2e73 6861 7065 5b31 5d2c  plates.shape[1],
-00010420: 2074 656d 706c 6174 6573 2e73 6861 7065   templates.shape
-00010430: 5b32 5d2c 2070 6164 6465 645f 7465 6d70  [2], padded_temp
-00010440: 6c61 7465 5f73 616d 706c 6573 2929 0a20  late_samples)). 
-00010450: 2020 2069 6620 7061 7261 6c6c 656c 3a0a     if parallel:.
-00010460: 2020 2020 2020 2020 6966 206e 5f6a 6f62          if n_job
-00010470: 7320 6973 204e 6f6e 653a 0a20 2020 2020  s is None:.     
-00010480: 2020 2020 2020 206e 5f6a 6f62 7320 3d20         n_jobs = 
-00010490: 6f73 2e63 7075 5f63 6f75 6e74 2829 202f  os.cpu_count() /
-000104a0: 2f20 320a 0a20 2020 2020 2020 2069 6620  / 2..        if 
-000104b0: 7665 7262 6f73 653a 0a20 2020 2020 2020  verbose:.       
-000104c0: 2020 2020 2070 7269 6e74 2827 5061 6464       print('Padd
-000104d0: 696e 6720 7769 7468 272c 206e 5f6a 6f62  ing with', n_job
-000104e0: 732c 2027 6a6f 6273 2729 0a20 2020 2020  s, 'jobs').     
-000104f0: 2020 206f 7574 7075 745f 6c69 7374 203d     output_list =
-00010500: 2050 6172 616c 6c65 6c28 6e5f 6a6f 6273   Parallel(n_jobs
-00010510: 3d6e 5f6a 6f62 7329 2864 656c 6179 6564  =n_jobs)(delayed
-00010520: 285f 7061 645f 7061 7261 6c6c 656c 2928  (_pad_parallel)(
-00010530: 692c 2074 656d 2c20 7061 645f 7361 6d70  i, tem, pad_samp
-00010540: 6c65 732c 2064 7269 6674 696e 672c 2076  les, drifting, v
-00010550: 6572 626f 7365 2c20 290a 2020 2020 2020  erbose, ).      
-00010560: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010570: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010580: 2020 2020 2020 2020 666f 7220 692c 2074          for i, t
-00010590: 656d 2069 6e20 656e 756d 6572 6174 6528  em in enumerate(
-000105a0: 7465 6d70 6c61 7465 7329 290a 0a20 2020  templates))..   
-000105b0: 2020 2020 2066 6f72 2069 2c20 7465 6d20       for i, tem 
-000105c0: 696e 2065 6e75 6d65 7261 7465 2874 656d  in enumerate(tem
-000105d0: 706c 6174 6573 5f70 6164 293a 0a20 2020  plates_pad):.   
-000105e0: 2020 2020 2020 2020 2074 656d 706c 6174           templat
-000105f0: 6573 5f70 6164 5b69 5d20 3d20 6f75 7470  es_pad[i] = outp
-00010600: 7574 5f6c 6973 745b 695d 0a20 2020 2065  ut_list[i].    e
-00010610: 6c73 653a 0a20 2020 2020 2020 2066 6f72  lse:.        for
-00010620: 2069 2c20 7465 6d20 696e 2065 6e75 6d65   i, tem in enume
-00010630: 7261 7465 2874 656d 706c 6174 6573 293a  rate(templates):
-00010640: 0a20 2020 2020 2020 2020 2020 2074 656d  .            tem
-00010650: 706c 6174 6573 5f70 6164 5b69 5d20 3d20  plates_pad[i] = 
-00010660: 5f70 6164 5f70 6172 616c 6c65 6c28 692c  _pad_parallel(i,
-00010670: 2074 656d 2c20 7061 645f 7361 6d70 6c65   tem, pad_sample
-00010680: 732c 2064 7269 6674 696e 672c 2076 6572  s, drifting, ver
-00010690: 626f 7365 290a 2020 2020 7265 7475 726e  bose).    return
-000106a0: 2074 656d 706c 6174 6573 5f70 6164 0a0a   templates_pad..
-000106b0: 0a64 6566 206a 6974 7465 725f 7465 6d70  .def jitter_temp
-000106c0: 6c61 7465 7328 7465 6d70 6c61 7465 732c  lates(templates,
-000106d0: 2075 7073 616d 706c 652c 2066 732c 206e   upsample, fs, n
-000106e0: 5f6a 6974 7465 7273 2c20 6a69 7474 6572  _jitters, jitter
-000106f0: 2c20 6472 6966 7469 6e67 2c20 6474 7970  , drifting, dtyp
-00010700: 652c 2076 6572 626f 7365 2c20 6e5f 6a6f  e, verbose, n_jo
-00010710: 6273 3d4e 6f6e 652c 0a20 2020 2020 2020  bs=None,.       
-00010720: 2020 2020 2020 2020 2020 2020 2020 746d                tm
-00010730: 705f 6669 6c65 3d4e 6f6e 652c 2070 6172  p_file=None, par
-00010740: 616c 6c65 6c3d 4661 6c73 6529 3a0a 2020  allel=False):.  
-00010750: 2020 2222 220a 2020 2020 4164 6473 206a    """.    Adds j
-00010760: 6974 7465 7265 6420 7265 706c 6963 6173  ittered replicas
-00010770: 2074 6f20 7468 6520 7465 6d70 6c61 7465   to the template
-00010780: 732e 0a20 2020 2050 6172 616d 6574 6572  s..    Parameter
-00010790: 730a 2020 2020 2d2d 2d2d 2d2d 2d2d 2d2d  s.    ----------
-000107a0: 0a20 2020 2074 656d 706c 6174 6573 203a  .    templates :
-000107b0: 206e 702e 6172 7261 790a 2020 2020 2020   np.array.      
-000107c0: 2020 4172 7261 7920 7769 7468 2074 656d    Array with tem
-000107d0: 706c 6174 6573 2028 6e5f 6e65 7572 6f6e  plates (n_neuron
-000107e0: 732c 206e 5f63 6861 6e6e 656c 732c 206e  s, n_channels, n
-000107f0: 5f73 616d 706c 6573 290a 2020 2020 2020  _samples).      
-00010800: 2020 6f72 2028 6e5f 6e65 7572 6f6e 732c    or (n_neurons,
-00010810: 206e 5f64 7269 6674 2c20 6e5f 6368 616e   n_drift, n_chan
-00010820: 6e65 6c73 2c20 6e5f 7361 6d70 6c65 7329  nels, n_samples)
-00010830: 2069 6620 6472 6966 7469 6e67 0a20 2020   if drifting.   
-00010840: 2075 7073 616d 706c 6520 3a20 696e 740a   upsample : int.
-00010850: 2020 2020 2020 2020 4661 6374 6f72 2066          Factor f
-00010860: 6f72 2075 7073 616d 706c 696e 6720 7468  or upsampling th
-00010870: 6520 7465 6d70 6c61 7465 730a 2020 2020  e templates.    
-00010880: 6e5f 6a69 7474 6572 7320 3a20 696e 740a  n_jitters : int.
-00010890: 2020 2020 2020 2020 4e75 6d62 6572 206f          Number o
-000108a0: 6620 6a69 7474 6572 6564 2063 6f70 6965  f jittered copie
-000108b0: 7320 666f 7220 6561 6368 2074 656d 706c  s for each templ
-000108c0: 6174 650a 2020 2020 6a69 7474 6572 203a  ate.    jitter :
-000108d0: 2071 7561 6e74 6974 790a 2020 2020 2020   quantity.      
-000108e0: 2020 4a69 7474 6572 2069 6e20 7469 6d65    Jitter in time
-000108f0: 2066 6f72 2073 6869 6674 696e 6720 7468   for shifting th
-00010900: 6520 7465 6d70 6c61 7465 0a20 2020 2064  e template.    d
-00010910: 7269 6674 696e 6720 3a20 626f 6f6c 0a20  rifting : bool. 
-00010920: 2020 2020 2020 2049 6620 5472 7565 2074         If True t
-00010930: 656d 706c 6174 6573 2061 7265 2061 7373  emplates are ass
-00010940: 756d 6564 2074 6f20 6265 2064 7269 6674  umed to be drift
-00010950: 696e 670a 2020 2020 7665 7262 6f73 6520  ing.    verbose 
-00010960: 3a20 626f 6f6c 0a20 2020 2020 2020 2049  : bool.        I
-00010970: 6620 5472 7565 206f 7574 7075 7420 6973  f True output is
-00010980: 2076 6572 626f 7365 0a20 2020 206e 5f6a   verbose.    n_j
-00010990: 6f62 7320 3a20 696e 740a 2020 2020 2020  obs : int.      
-000109a0: 2020 4e75 6d62 6572 206f 6620 6a6f 6273    Number of jobs
-000109b0: 2066 6f72 2070 6172 616c 6c65 6c20 7072   for parallel pr
-000109c0: 6f63 6573 7369 6e67 2e20 4966 204e 6f6e  ocessing. If Non
-000109d0: 6520 6861 6c66 2063 7075 7320 6172 6520  e half cpus are 
-000109e0: 7573 6564 0a20 2020 2074 6d70 5f66 696c  used.    tmp_fil
-000109f0: 6520 3a20 7374 720a 2020 2020 2020 2020  e : str.        
-00010a00: 5061 7468 2074 6f20 746d 7020 6669 6c65  Path to tmp file
-00010a10: 2074 6f20 6d65 6d6d 6170 2e20 4966 204e   to memmap. If N
-00010a20: 6f6e 652c 2070 726f 6365 7373 696e 6720  one, processing 
-00010a30: 6973 2069 6e20 6d65 6d6f 7279 0a20 2020  is in memory.   
-00010a40: 2070 6172 616c 6c65 6c20 3a20 626f 6f6c   parallel : bool
-00010a50: 0a20 2020 2020 2020 2049 6620 5472 7565  .        If True
-00010a60: 2065 6163 6820 7465 6d70 6c61 7465 2069   each template i
-00010a70: 7320 6a69 7474 6572 6564 2069 6e20 7061  s jittered in pa
-00010a80: 7265 6c6c 656c 0a20 2020 2052 6574 7572  rellel.    Retur
-00010a90: 6e73 0a20 2020 202d 2d2d 2d2d 2d2d 0a20  ns.    -------. 
-00010aa0: 2020 2074 656d 706c 6174 655f 6a69 7474     template_jitt
-00010ab0: 203a 206e 702e 6172 7261 790a 2020 2020   : np.array.    
-00010ac0: 2020 2020 4172 7261 7920 7769 7468 206a      Array with j
-00010ad0: 6974 7465 7265 6420 7465 6d70 6c61 7465  ittered template
-00010ae0: 7320 286e 5f6e 6575 726f 6e73 2c20 6e5f  s (n_neurons, n_
-00010af0: 6a69 7474 6572 732c 206e 5f63 6861 6e6e  jitters, n_chann
-00010b00: 656c 732c 206e 5f73 616d 706c 6573 290a  els, n_samples).
-00010b10: 2020 2020 2020 2020 6f72 2028 6e5f 6e65          or (n_ne
-00010b20: 7572 6f6e 732c 206e 5f64 7269 6674 2c20  urons, n_drift, 
-00010b30: 6e5f 6a69 7474 6572 732c 206e 5f63 6861  n_jitters, n_cha
-00010b40: 6e6e 656c 732c 206e 5f73 616d 706c 6573  nnels, n_samples
-00010b50: 2920 6966 2064 7269 6674 696e 670a 2020  ) if drifting.  
-00010b60: 2020 2222 220a 2020 2020 2320 6372 6561    """.    # crea
-00010b70: 7465 2070 6164 6465 6420 7465 6d70 6c61  te padded templa
-00010b80: 7465 730a 2020 2020 6966 206e 6f74 2064  tes.    if not d
-00010b90: 7269 6674 696e 673a 0a20 2020 2020 2020  rifting:.       
-00010ba0: 2069 6620 746d 705f 6669 6c65 2069 7320   if tmp_file is 
-00010bb0: 6e6f 7420 4e6f 6e65 3a0a 2020 2020 2020  not None:.      
-00010bc0: 2020 2020 2020 7465 6d70 6c61 7465 735f        templates_
-00010bd0: 6a69 7474 6572 203d 206e 702e 6d65 6d6d  jitter = np.memm
-00010be0: 6170 2874 6d70 5f66 696c 652c 2073 6861  ap(tmp_file, sha
-00010bf0: 7065 3d28 7465 6d70 6c61 7465 732e 7368  pe=(templates.sh
-00010c00: 6170 655b 305d 2c20 6e5f 6a69 7474 6572  ape[0], n_jitter
-00010c10: 732c 2074 656d 706c 6174 6573 2e73 6861  s, templates.sha
-00010c20: 7065 5b31 5d2c 0a20 2020 2020 2020 2020  pe[1],.         
-00010c30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010c40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010c50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010c60: 2074 656d 706c 6174 6573 2e73 6861 7065   templates.shape
-00010c70: 5b32 5d29 2c0a 2020 2020 2020 2020 2020  [2]),.          
-00010c80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010c90: 2020 2020 2020 2020 2020 2020 2020 2064                 d
-00010ca0: 7479 7065 3d64 7479 7065 2c20 6d6f 6465  type=dtype, mode
-00010cb0: 3d27 772b 2729 0a20 2020 2020 2020 2065  ='w+').        e
-00010cc0: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
-00010cd0: 2074 656d 706c 6174 6573 5f6a 6974 7465   templates_jitte
-00010ce0: 7220 3d20 6e70 2e7a 6572 6f73 2828 7465  r = np.zeros((te
-00010cf0: 6d70 6c61 7465 732e 7368 6170 655b 305d  mplates.shape[0]
-00010d00: 2c20 6e5f 6a69 7474 6572 732c 2074 656d  , n_jitters, tem
-00010d10: 706c 6174 6573 2e73 6861 7065 5b31 5d2c  plates.shape[1],
-00010d20: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00010d30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010d40: 2020 2020 2020 2020 2020 7465 6d70 6c61            templa
-00010d50: 7465 732e 7368 6170 655b 325d 2929 0a20  tes.shape[2])). 
-00010d60: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-00010d70: 2069 6620 746d 705f 6669 6c65 2069 7320   if tmp_file is 
-00010d80: 6e6f 7420 4e6f 6e65 3a0a 2020 2020 2020  not None:.      
-00010d90: 2020 2020 2020 7465 6d70 6c61 7465 735f        templates_
-00010da0: 6a69 7474 6572 203d 206e 702e 6d65 6d6d  jitter = np.memm
-00010db0: 6170 2874 6d70 5f66 696c 652c 2073 6861  ap(tmp_file, sha
-00010dc0: 7065 3d28 7465 6d70 6c61 7465 732e 7368  pe=(templates.sh
-00010dd0: 6170 655b 305d 2c20 7465 6d70 6c61 7465  ape[0], template
-00010de0: 732e 7368 6170 655b 315d 2c20 6e5f 6a69  s.shape[1], n_ji
-00010df0: 7474 6572 732c 0a20 2020 2020 2020 2020  tters,.         
-00010e00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010e10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010e20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010e30: 2074 656d 706c 6174 6573 2e73 6861 7065   templates.shape
-00010e40: 5b32 5d2c 2074 656d 706c 6174 6573 2e73  [2], templates.s
-00010e50: 6861 7065 5b33 5d29 2c0a 2020 2020 2020  hape[3]),.      
-00010e60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010e70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010e80: 2020 2064 7479 7065 3d64 7479 7065 2c20     dtype=dtype, 
-00010e90: 6d6f 6465 3d27 772b 2729 0a20 2020 2020  mode='w+').     
-00010ea0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-00010eb0: 2020 2020 2074 656d 706c 6174 6573 5f6a       templates_j
-00010ec0: 6974 7465 7220 3d20 6e70 2e7a 6572 6f73  itter = np.zeros
-00010ed0: 2828 7465 6d70 6c61 7465 732e 7368 6170  ((templates.shap
-00010ee0: 655b 305d 2c20 7465 6d70 6c61 7465 732e  e[0], templates.
-00010ef0: 7368 6170 655b 315d 2c20 6e5f 6a69 7474  shape[1], n_jitt
-00010f00: 6572 732c 0a20 2020 2020 2020 2020 2020  ers,.           
-00010f10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010f20: 2020 2020 2020 2020 2020 2020 2020 7465                te
-00010f30: 6d70 6c61 7465 732e 7368 6170 655b 325d  mplates.shape[2]
-00010f40: 2c20 7465 6d70 6c61 7465 732e 7368 6170  , templates.shap
-00010f50: 655b 335d 2929 0a20 2020 2069 6620 7061  e[3])).    if pa
-00010f60: 7261 6c6c 656c 3a0a 2020 2020 2020 2020  rallel:.        
-00010f70: 6966 206e 5f6a 6f62 7320 6973 204e 6f6e  if n_jobs is Non
-00010f80: 653a 0a20 2020 2020 2020 2020 2020 206e  e:.            n
-00010f90: 5f6a 6f62 7320 3d20 6f73 2e63 7075 5f63  _jobs = os.cpu_c
-00010fa0: 6f75 6e74 2829 202f 2f20 320a 0a20 2020  ount() // 2..   
-00010fb0: 2020 2020 2069 6620 7665 7262 6f73 653a       if verbose:
-00010fc0: 0a20 2020 2020 2020 2020 2020 2070 7269  .            pri
-00010fd0: 6e74 2827 4a69 7474 6572 696e 6720 7769  nt('Jittering wi
-00010fe0: 7468 272c 206e 5f6a 6f62 732c 2027 6a6f  th', n_jobs, 'jo
-00010ff0: 6273 2729 0a0a 2020 2020 2020 2020 6f75  bs')..        ou
-00011000: 7470 7574 5f6c 6973 7420 3d20 5061 7261  tput_list = Para
-00011010: 6c6c 656c 286e 5f6a 6f62 733d 6e5f 6a6f  llel(n_jobs=n_jo
-00011020: 6273 2928 6465 6c61 7965 6428 5f6a 6974  bs)(delayed(_jit
-00011030: 7465 725f 7061 7261 6c6c 656c 2928 692c  ter_parallel)(i,
-00011040: 2074 656d 2c20 7570 7361 6d70 6c65 2c20   tem, upsample, 
-00011050: 6673 2c20 6e5f 6a69 7474 6572 732c 206a  fs, n_jitters, j
-00011060: 6974 7465 722c 0a20 2020 2020 2020 2020  itter,.         
-00011070: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011080: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011090: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000110a0: 2020 2020 2020 2020 2020 2020 2020 2064                 d
-000110b0: 7269 6674 696e 672c 2076 6572 626f 7365  rifting, verbose
-000110c0: 2c20 290a 2020 2020 2020 2020 2020 2020  , ).            
-000110d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000110e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000110f0: 2020 666f 7220 692c 2074 656d 2069 6e20    for i, tem in 
-00011100: 656e 756d 6572 6174 6528 7465 6d70 6c61  enumerate(templa
-00011110: 7465 7329 290a 2020 2020 2020 2020 666f  tes)).        fo
-00011120: 7220 692c 2074 656d 2069 6e20 656e 756d  r i, tem in enum
-00011130: 6572 6174 6528 7465 6d70 6c61 7465 735f  erate(templates_
-00011140: 6a69 7474 6572 293a 0a20 2020 2020 2020  jitter):.       
-00011150: 2020 2020 2074 656d 706c 6174 6573 5f6a       templates_j
-00011160: 6974 7465 725b 695d 203d 206f 7574 7075  itter[i] = outpu
-00011170: 745f 6c69 7374 5b69 5d0a 2020 2020 656c  t_list[i].    el
-00011180: 7365 3a0a 2020 2020 2020 2020 666f 7220  se:.        for 
-00011190: 692c 2074 656d 2069 6e20 656e 756d 6572  i, tem in enumer
-000111a0: 6174 6528 7465 6d70 6c61 7465 7329 3a0a  ate(templates):.
-000111b0: 2020 2020 2020 2020 2020 2020 7465 6d70              temp
-000111c0: 6c61 7465 735f 6a69 7474 6572 5b69 5d20  lates_jitter[i] 
-000111d0: 3d20 5f6a 6974 7465 725f 7061 7261 6c6c  = _jitter_parall
-000111e0: 656c 2869 2c20 7465 6d2c 2075 7073 616d  el(i, tem, upsam
-000111f0: 706c 652c 2066 732c 206e 5f6a 6974 7465  ple, fs, n_jitte
-00011200: 7273 2c20 6a69 7474 6572 2c20 6472 6966  rs, jitter, drif
-00011210: 7469 6e67 2c20 7665 7262 6f73 652c 2029  ting, verbose, )
-00011220: 0a0a 2020 2020 7265 7475 726e 2074 656d  ..    return tem
-00011230: 706c 6174 6573 5f6a 6974 7465 720a 0a0a  plates_jitter...
-00011240: 6465 6620 6375 6269 635f 7061 6464 696e  def cubic_paddin
-00011250: 6728 7465 6d70 6c61 7465 2c20 7061 645f  g(template, pad_
-00011260: 7361 6d70 6c65 7329 3a0a 2020 2020 2222  samples):.    ""
-00011270: 220a 2020 2020 4375 6269 6320 7370 6c69  ".    Cubic spli
-00011280: 6e65 2070 6164 6469 6e67 206f 6e20 6c65  ne padding on le
-00011290: 6674 2061 6e64 2072 6967 6874 2073 6964  ft and right sid
-000112a0: 6520 746f 2030 2e20 5468 6520 696e 6974  e to 0. The init
-000112b0: 6961 6c20 6f66 6673 6574 206f 6620 7468  ial offset of th
-000112c0: 6520 7465 6d70 6c61 7465 7320 6973 2061  e templates is a
-000112d0: 6c73 6f20 7265 6d6f 7665 642e 0a0a 2020  lso removed...  
-000112e0: 2020 5061 7261 6d65 7465 7273 0a20 2020    Parameters.   
-000112f0: 202d 2d2d 2d2d 2d2d 2d2d 2d0a 2020 2020   ----------.    
-00011300: 7465 6d70 6c61 7465 203a 206e 702e 6172  template : np.ar
-00011310: 7261 790a 2020 2020 2020 2020 5465 6d70  ray.        Temp
-00011320: 6c61 7465 7320 746f 2062 6520 7061 6464  lates to be padd
-00011330: 6564 2028 6e5f 656c 6563 2c20 6e5f 7361  ed (n_elec, n_sa
-00011340: 6d70 6c65 7329 0a20 2020 2070 6164 5f73  mples).    pad_s
-00011350: 616d 706c 6573 203a 206c 6973 740a 2020  amples : list.  
-00011360: 2020 2020 2020 5061 6464 696e 6720 7361        Padding sa
-00011370: 6d70 6c65 7320 6265 666f 7265 2061 6e64  mples before and
-00011380: 2061 6674 6572 2074 6865 2074 656d 706c   after the templ
-00011390: 6174 650a 0a20 2020 2052 6574 7572 6e73  ate..    Returns
-000113a0: 0a20 2020 202d 2d2d 2d2d 2d2d 0a20 2020  .    -------.   
-000113b0: 2070 6164 6465 645f 7465 6d70 6c61 7465   padded_template
-000113c0: 203a 206e 702e 6172 7261 790a 2020 2020   : np.array.    
-000113d0: 2020 2020 5061 6464 6564 2074 656d 706c      Padded templ
-000113e0: 6174 650a 0a20 2020 2022 2222 0a20 2020  ate..    """.   
-000113f0: 2069 6d70 6f72 7420 7363 6970 792e 696e   import scipy.in
-00011400: 7465 7270 6f6c 6174 6520 6173 2069 6e74  terpolate as int
-00011410: 6572 700a 2020 2020 6e5f 7072 6520 3d20  erp.    n_pre = 
-00011420: 7061 645f 7361 6d70 6c65 735b 305d 0a20  pad_samples[0]. 
-00011430: 2020 206e 5f70 6f73 7420 3d20 7061 645f     n_post = pad_
-00011440: 7361 6d70 6c65 735b 315d 0a0a 2020 2020  samples[1]..    
-00011450: 7061 6464 6564 5f74 656d 706c 6174 6520  padded_template 
-00011460: 3d20 6e70 2e7a 6572 6f73 2828 7465 6d70  = np.zeros((temp
-00011470: 6c61 7465 2e73 6861 7065 5b30 5d2c 2069  late.shape[0], i
-00011480: 6e74 286e 5f70 7265 2920 2b20 7465 6d70  nt(n_pre) + temp
-00011490: 6c61 7465 2e73 6861 7065 5b31 5d20 2b20  late.shape[1] + 
-000114a0: 6e5f 706f 7374 2929 0a20 2020 2073 706c  n_post)).    spl
-000114b0: 696e 6573 203d 206e 702e 7a65 726f 7328  ines = np.zeros(
-000114c0: 2874 656d 706c 6174 652e 7368 6170 655b  (template.shape[
-000114d0: 305d 2c20 696e 7428 6e5f 7072 6529 202b  0], int(n_pre) +
-000114e0: 2074 656d 706c 6174 652e 7368 6170 655b   template.shape[
-000114f0: 315d 202b 206e 5f70 6f73 7429 290a 0a20  1] + n_post)).. 
-00011500: 2020 2066 6f72 2069 2c20 7370 2069 6e20     for i, sp in 
-00011510: 656e 756d 6572 6174 6528 7465 6d70 6c61  enumerate(templa
-00011520: 7465 293a 0a20 2020 2020 2020 2023 2052  te):.        # R
-00011530: 656d 6f76 6520 696e 6974 616c 206f 6666  emove inital off
-00011540: 7365 740a 2020 2020 2020 2020 7370 5f63  set.        sp_c
-00011550: 6f70 7920 3d20 6465 6570 636f 7079 2873  opy = deepcopy(s
-00011560: 7029 0a20 2020 2020 2020 2070 6164 6465  p).        padde
-00011570: 645f 7370 203d 206e 702e 7a65 726f 7328  d_sp = np.zeros(
-00011580: 6e5f 7072 6520 2b20 6c65 6e28 7370 2920  n_pre + len(sp) 
-00011590: 2b20 6e5f 706f 7374 290a 2020 2020 2020  + n_post).      
-000115a0: 2020 7061 6464 6564 5f74 203d 206e 702e    padded_t = np.
-000115b0: 6172 616e 6765 286c 656e 2870 6164 6465  arange(len(padde
-000115c0: 645f 7370 2929 0a20 2020 2020 2020 2069  d_sp)).        i
-000115d0: 6e69 7469 616c 5f6f 6666 7365 7420 3d20  nitial_offset = 
-000115e0: 6e70 2e6d 6561 6e28 7370 5b30 5d29 0a20  np.mean(sp[0]). 
-000115f0: 2020 2020 2020 2073 705f 636f 7079 202d         sp_copy -
-00011600: 3d20 696e 6974 6961 6c5f 6f66 6673 6574  = initial_offset
-00011610: 0a0a 2020 2020 2020 2020 785f 7072 6520  ..        x_pre 
-00011620: 3d20 666c 6f61 7428 6e5f 7072 6529 0a20  = float(n_pre). 
-00011630: 2020 2020 2020 2078 5f70 7265 5f70 6164         x_pre_pad
-00011640: 203d 206e 702e 6172 616e 6765 286e 5f70   = np.arange(n_p
-00011650: 7265 290a 2020 2020 2020 2020 785f 706f  re).        x_po
-00011660: 7374 203d 2066 6c6f 6174 286e 5f70 6f73  st = float(n_pos
-00011670: 7429 0a20 2020 2020 2020 2078 5f70 6f73  t).        x_pos
-00011680: 745f 7061 6420 3d20 6e70 2e61 7261 6e67  t_pad = np.arang
-00011690: 6528 6e5f 706f 7374 295b 3a3a 2d31 5d0a  e(n_post)[::-1].
-000116a0: 0a20 2020 2020 2020 2023 2066 696c 6c20  .        # fill 
-000116b0: 7072 6520 616e 6420 706f 7374 2069 6e74  pre and post int
-000116c0: 6572 7661 6c73 2077 6974 6820 6c69 6e65  ervals with line
-000116d0: 6172 2076 616c 7565 7320 6672 6f6d 2073  ar values from s
-000116e0: 705b 305d 202d 2073 705b 2d31 5d20 746f  p[0] - sp[-1] to
-000116f0: 2030 2066 6f72 2062 6574 7465 7220 6669   0 for better fi
-00011700: 740a 2020 2020 2020 2020 6d5f 7072 6520  t.        m_pre 
-00011710: 3d20 7370 5f63 6f70 795b 305d 202f 2078  = sp_copy[0] / x
-00011720: 5f70 7265 0a20 2020 2020 2020 206d 5f70  _pre.        m_p
-00011730: 6f73 7420 3d20 7370 5f63 6f70 795b 2d31  ost = sp_copy[-1
-00011740: 5d20 2f20 785f 706f 7374 0a0a 2020 2020  ] / x_post..    
-00011750: 2020 2020 7061 6464 6564 5f73 705b 3a6e      padded_sp[:n
-00011760: 5f70 7265 5d20 3d20 6d5f 7072 6520 2a20  _pre] = m_pre * 
-00011770: 785f 7072 655f 7061 640a 2020 2020 2020  x_pre_pad.      
-00011780: 2020 7061 6464 6564 5f73 705b 6e5f 7072    padded_sp[n_pr
-00011790: 653a 2d6e 5f70 6f73 745d 203d 2073 705f  e:-n_post] = sp_
-000117a0: 636f 7079 0a20 2020 2020 2020 2070 6164  copy.        pad
-000117b0: 6465 645f 7370 5b2d 6e5f 706f 7374 3a5d  ded_sp[-n_post:]
-000117c0: 203d 206d 5f70 6f73 7420 2a20 785f 706f   = m_post * x_po
-000117d0: 7374 5f70 6164 0a0a 2020 2020 2020 2020  st_pad..        
-000117e0: 6620 3d20 696e 7465 7270 2e69 6e74 6572  f = interp.inter
-000117f0: 7031 6428 7061 6464 6564 5f74 2c20 7061  p1d(padded_t, pa
-00011800: 6464 6564 5f73 702c 206b 696e 643d 2763  dded_sp, kind='c
-00011810: 7562 6963 2729 0a20 2020 2020 2020 2073  ubic').        s
-00011820: 706c 696e 6573 5b69 5d20 3d20 6628 6e70  plines[i] = f(np
-00011830: 2e61 7261 6e67 6528 6c65 6e28 7061 6464  .arange(len(padd
-00011840: 6564 5f73 7029 2929 0a0a 2020 2020 2020  ed_sp)))..      
-00011850: 2020 7061 6464 6564 5f74 656d 706c 6174    padded_templat
-00011860: 655b 692c 203a 6e5f 7072 655d 203d 2066  e[i, :n_pre] = f
-00011870: 2878 5f70 7265 5f70 6164 290a 2020 2020  (x_pre_pad).    
-00011880: 2020 2020 7061 6464 6564 5f74 656d 706c      padded_templ
-00011890: 6174 655b 692c 206e 5f70 7265 3a2d 6e5f  ate[i, n_pre:-n_
-000118a0: 706f 7374 5d20 3d20 7370 5f63 6f70 790a  post] = sp_copy.
-000118b0: 2020 2020 2020 2020 7061 6464 6564 5f74          padded_t
-000118c0: 656d 706c 6174 655b 692c 202d 6e5f 706f  emplate[i, -n_po
-000118d0: 7374 3a5d 203d 2066 286e 702e 6172 616e  st:] = f(np.aran
-000118e0: 6765 286e 5f70 7265 202b 206c 656e 2873  ge(n_pre + len(s
-000118f0: 705f 636f 7079 292c 206e 5f70 7265 202b  p_copy), n_pre +
-00011900: 206c 656e 2873 705f 636f 7079 2920 2b20   len(sp_copy) + 
-00011910: 6e5f 706f 7374 2929 0a0a 2020 2020 7265  n_post))..    re
-00011920: 7475 726e 2070 6164 6465 645f 7465 6d70  turn padded_temp
-00011930: 6c61 7465 0a0a 0a64 6566 2066 696e 645f  late...def find_
-00011940: 6f76 6572 6c61 7070 696e 675f 7465 6d70  overlapping_temp
-00011950: 6c61 7465 7328 7465 6d70 6c61 7465 732c  lates(templates,
-00011960: 2074 6872 6573 683d 302e 3829 3a0a 2020   thresh=0.8):.  
-00011970: 2020 2222 220a 2020 2020 4669 6e64 2073    """.    Find s
-00011980: 7061 7469 616c 6c79 206f 7665 726c 6170  patially overlap
-00011990: 7069 6e67 2074 656d 706c 6174 6573 2e0a  ping templates..
-000119a0: 0a20 2020 2050 6172 616d 6574 6572 730a  .    Parameters.
-000119b0: 2020 2020 2d2d 2d2d 2d2d 2d2d 2d2d 0a20      ----------. 
-000119c0: 2020 2074 656d 706c 6174 6573 203a 206e     templates : n
-000119d0: 702e 6172 7261 790a 2020 2020 2020 2020  p.array.        
-000119e0: 4172 7261 7920 7769 7468 2074 656d 706c  Array with templ
-000119f0: 6174 6573 2028 6e5f 7465 6d70 6c61 7465  ates (n_template
-00011a00: 732c 206e 5f65 6c65 632c 206e 5f73 616d  s, n_elec, n_sam
-00011a10: 706c 6573 290a 2020 2020 7468 7265 7368  ples).    thresh
-00011a20: 203a 2066 6c6f 6174 0a20 2020 2020 2020   : float.       
-00011a30: 2050 6572 6365 6e74 2074 6872 6573 686f   Percent thresho
-00011a40: 6c64 2074 6f20 636f 6e73 6964 6572 2074  ld to consider t
-00011a50: 776f 2074 656d 706c 6174 6573 2074 6f20  wo templates to 
-00011a60: 6265 206f 7665 726c 6170 7069 6e67 2e0a  be overlapping..
-00011a70: 0a20 2020 2052 6574 7572 6e73 0a20 2020  .    Returns.   
-00011a80: 202d 2d2d 2d2d 2d2d 0a20 2020 206f 7665   -------.    ove
-00011a90: 726c 6170 7069 6e67 5f70 6169 7273 203a  rlapping_pairs :
-00011aa0: 206e 702e 6172 7261 790a 2020 2020 2020   np.array.      
-00011ab0: 2020 4172 7261 7920 7769 7468 206f 7665    Array with ove
-00011ac0: 726c 6170 7069 6e67 2070 6169 7273 2028  rlapping pairs (
-00011ad0: 6e5f 6f76 6572 6c61 7070 696e 672c 2032  n_overlapping, 2
-00011ae0: 290a 0a20 2020 2022 2222 0a20 2020 206f  )..    """.    o
-00011af0: 7665 726c 6170 7069 6e67 5f70 6169 7273  verlapping_pairs
-00011b00: 203d 205b 5d0a 0a20 2020 2066 6f72 2069   = []..    for i
-00011b10: 2c20 7465 6d70 5f31 2069 6e20 656e 756d  , temp_1 in enum
-00011b20: 6572 6174 6528 7465 6d70 6c61 7465 7329  erate(templates)
-00011b30: 3a0a 2020 2020 2020 2020 6966 206c 656e  :.        if len
-00011b40: 2874 656d 706c 6174 6573 2e73 6861 7065  (templates.shape
-00011b50: 2920 3d3d 2034 3a20 2023 206a 6974 7465  ) == 4:  # jitte
-00011b60: 720a 2020 2020 2020 2020 2020 2020 7465  r.            te
-00011b70: 6d70 5f31 203d 2074 656d 705f 315b 305d  mp_1 = temp_1[0]
-00011b80: 0a0a 2020 2020 2020 2020 7065 616b 5f65  ..        peak_e
-00011b90: 6c65 6374 726f 6465 5f69 6478 203d 206e  lectrode_idx = n
-00011ba0: 702e 756e 7261 7665 6c5f 696e 6465 7828  p.unravel_index(
-00011bb0: 7465 6d70 5f31 2e61 7267 6d69 6e28 292c  temp_1.argmin(),
-00011bc0: 2074 656d 705f 312e 7368 6170 6529 0a0a   temp_1.shape)..
-00011bd0: 2020 2020 2020 2020 666f 7220 6a2c 2074          for j, t
-00011be0: 656d 705f 3220 696e 2065 6e75 6d65 7261  emp_2 in enumera
-00011bf0: 7465 2874 656d 706c 6174 6573 293a 0a20  te(templates):. 
-00011c00: 2020 2020 2020 2020 2020 2069 6620 6c65             if le
-00011c10: 6e28 7465 6d70 6c61 7465 732e 7368 6170  n(templates.shap
-00011c20: 6529 203d 3d20 343a 2020 2320 6a69 7474  e) == 4:  # jitt
-00011c30: 6572 0a20 2020 2020 2020 2020 2020 2020  er.             
-00011c40: 2020 2074 656d 705f 3220 3d20 7465 6d70     temp_2 = temp
-00011c50: 5f32 5b30 5d0a 0a20 2020 2020 2020 2020  _2[0]..         
-00011c60: 2020 2069 6620 6920 213d 206a 3a0a 2020     if i != j:.  
-00011c70: 2020 2020 2020 2020 2020 2020 2020 6966                if
-00011c80: 2061 7265 5f74 656d 706c 6174 6573 5f6f   are_templates_o
-00011c90: 7665 726c 6170 7069 6e67 285b 7465 6d70  verlapping([temp
-00011ca0: 5f31 2c20 7465 6d70 5f32 5d2c 2074 6872  _1, temp_2], thr
-00011cb0: 6573 6829 3a0a 2020 2020 2020 2020 2020  esh):.          
-00011cc0: 2020 2020 2020 2020 2020 6966 205b 692c            if [i,
-00011cd0: 206a 5d20 6e6f 7420 696e 206f 7665 726c   j] not in overl
-00011ce0: 6170 7069 6e67 5f70 6169 7273 2061 6e64  apping_pairs and
-00011cf0: 205b 6a2c 2069 5d20 6e6f 7420 696e 206f   [j, i] not in o
-00011d00: 7665 726c 6170 7069 6e67 5f70 6169 7273  verlapping_pairs
-00011d10: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00011d20: 2020 2020 2020 2020 2020 6f76 6572 6c61            overla
-00011d30: 7070 696e 675f 7061 6972 732e 6170 7065  pping_pairs.appe
-00011d40: 6e64 2873 6f72 7465 6428 5b69 2c20 6a5d  nd(sorted([i, j]
-00011d50: 2929 0a0a 2020 2020 7265 7475 726e 206e  ))..    return n
-00011d60: 702e 6172 7261 7928 6f76 6572 6c61 7070  p.array(overlapp
-00011d70: 696e 675f 7061 6972 7329 0a0a 0a64 6566  ing_pairs)...def
-00011d80: 2061 7265 5f74 656d 706c 6174 6573 5f6f   are_templates_o
-00011d90: 7665 726c 6170 7069 6e67 2874 656d 706c  verlapping(templ
-00011da0: 6174 6573 2c20 7468 7265 7368 293a 0a20  ates, thresh):. 
-00011db0: 2020 2022 2222 0a20 2020 2052 6574 7572     """.    Retur
-00011dc0: 6e73 2074 7275 6520 6966 2074 656d 706c  ns true if templ
-00011dd0: 6174 6573 2061 7265 2073 7061 7469 616c  ates are spatial
-00011de0: 6c79 206f 7665 726c 6170 7069 6e67 0a0a  ly overlapping..
-00011df0: 2020 2020 5061 7261 6d65 7465 7273 0a20      Parameters. 
-00011e00: 2020 202d 2d2d 2d2d 2d2d 2d2d 2d0a 2020     ----------.  
-00011e10: 2020 7465 6d70 6c61 7465 7320 3a20 6e70    templates : np
-00011e20: 2e61 7272 6179 0a20 2020 2020 2020 2041  .array.        A
-00011e30: 7272 6179 2077 6974 6820 3220 7465 6d70  rray with 2 temp
-00011e40: 6c61 7465 7320 2832 2c20 6e5f 656c 6563  lates (2, n_elec
-00011e50: 2c20 6e5f 7361 6d70 6c65 7329 0a20 2020  , n_samples).   
-00011e60: 2074 6872 6573 6820 3a20 666c 6f61 740a   thresh : float.
-00011e70: 2020 2020 2020 2020 4f76 6572 6c61 7070          Overlapp
-00011e80: 696e 6720 7468 7265 7368 6f6c 6420 285b  ing threshold ([
-00011e90: 3020 2d20 315d 290a 0a20 2020 2052 6574  0 - 1])..    Ret
-00011ea0: 7572 6e73 0a20 2020 202d 2d2d 2d2d 2d2d  urns.    -------
-00011eb0: 0a20 2020 206f 7665 726c 6162 203a 2062  .    overlab : b
-00011ec0: 6f6f 6c0a 2020 2020 2020 2020 5768 6574  ool.        Whet
-00011ed0: 6865 7220 7468 6520 7465 6d70 6c61 7465  her the template
-00011ee0: 7320 6172 6520 7370 6174 6961 6c6c 7920  s are spatially 
-00011ef0: 6f76 6572 6c61 7070 696e 6720 6f72 206e  overlapping or n
-00011f00: 6f74 0a20 2020 2022 2222 0a20 2020 2061  ot.    """.    a
-00011f10: 7373 6572 7420 6c65 6e28 7465 6d70 6c61  ssert len(templa
-00011f20: 7465 7329 203d 3d20 320a 2020 2020 7465  tes) == 2.    te
-00011f30: 6d70 5f31 203d 2074 656d 706c 6174 6573  mp_1 = templates
-00011f40: 5b30 5d0a 2020 2020 7465 6d70 5f32 203d  [0].    temp_2 =
-00011f50: 2074 656d 706c 6174 6573 5b31 5d0a 2020   templates[1].  
-00011f60: 2020 7065 616b 5f65 6c65 6374 726f 6465    peak_electrode
-00011f70: 5f69 6478 203d 206e 702e 756e 7261 7665  _idx = np.unrave
-00011f80: 6c5f 696e 6465 7828 7465 6d70 5f31 2e61  l_index(temp_1.a
-00011f90: 7267 6d69 6e28 292c 2074 656d 705f 312e  rgmin(), temp_1.
-00011fa0: 7368 6170 6529 0a20 2020 2070 6561 6b5f  shape).    peak_
-00011fb0: 325f 6f6e 5f6d 6178 203d 206e 702e 6162  2_on_max = np.ab
-00011fc0: 7328 6e70 2e6d 696e 2874 656d 705f 325b  s(np.min(temp_2[
-00011fd0: 7065 616b 5f65 6c65 6374 726f 6465 5f69  peak_electrode_i
-00011fe0: 6478 5d29 290a 2020 2020 7065 616b 5f32  dx])).    peak_2
-00011ff0: 203d 206e 702e 6162 7328 6e70 2e6d 696e   = np.abs(np.min
-00012000: 2874 656d 705f 3229 290a 0a20 2020 2069  (temp_2))..    i
-00012010: 6620 7065 616b 5f32 5f6f 6e5f 6d61 7820  f peak_2_on_max 
-00012020: 3e20 7468 7265 7368 202a 2070 6561 6b5f  > thresh * peak_
-00012030: 323a 0a20 2020 2020 2020 2072 6574 7572  2:.        retur
-00012040: 6e20 5472 7565 0a20 2020 2065 6c73 653a  n True.    else:
-00012050: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00012060: 4661 6c73 650a 0a0a 2323 2320 5350 494b  False...### SPIK
-00012070: 4554 5241 494e 204f 5045 5241 5449 4f4e  ETRAIN OPERATION
-00012080: 5320 2323 230a 6465 6620 616e 6e6f 7461  S ###.def annota
-00012090: 7465 5f6f 7665 726c 6170 7069 6e67 5f73  te_overlapping_s
-000120a0: 7069 6b65 7328 7370 696b 6574 7261 696e  pikes(spiketrain
-000120b0: 732c 2074 5f6a 6974 743d 3120 2a20 7071  s, t_jitt=1 * pq
-000120c0: 2e6d 732c 206f 7665 726c 6170 7069 6e67  .ms, overlapping
-000120d0: 5f70 6169 7273 3d4e 6f6e 652c 2070 6172  _pairs=None, par
-000120e0: 616c 6c65 6c3d 5472 7565 2c20 7665 7262  allel=True, verb
-000120f0: 6f73 653d 5472 7565 293a 0a20 2020 2022  ose=True):.    "
-00012100: 2222 0a20 2020 2041 6e6e 6f74 6174 6520  "".    Annotate 
-00012110: 7370 696b 6520 7472 6169 6e73 2077 6974  spike trains wit
-00012120: 6820 7465 6d70 6f72 616c 2061 6e64 2073  h temporal and s
-00012130: 7061 7469 6f2d 7465 6d70 6f72 616c 206f  patio-temporal o
-00012140: 7665 726c 6170 7069 6e67 206c 6162 656c  verlapping label
-00012150: 732e 0a20 2020 204e 4f20 2d20 4e6f 6e20  s..    NO - Non 
-00012160: 6f76 6572 6c61 700a 2020 2020 544f 202d  overlap.    TO -
-00012170: 2054 656d 706f 7261 6c20 6f76 6572 6c61   Temporal overla
-00012180: 700a 2020 2020 534f 202d 2053 7061 7469  p.    SO - Spati
-00012190: 6f2d 7465 6d70 6f72 616c 206f 7665 726c  o-temporal overl
-000121a0: 6170 0a0a 2020 2020 5061 7261 6d65 7465  ap..    Paramete
-000121b0: 7273 0a20 2020 202d 2d2d 2d2d 2d2d 2d2d  rs.    ---------
-000121c0: 2d0a 2020 2020 7370 696b 6574 7261 696e  -.    spiketrain
-000121d0: 7320 3a20 6c69 7374 0a20 2020 2020 2020  s : list.       
-000121e0: 204c 6973 7420 6f66 206e 656f 2073 7069   List of neo spi
-000121f0: 6b65 2074 7261 696e 7320 746f 2062 6520  ke trains to be 
-00012200: 616e 6e6f 7461 7465 640a 2020 2020 745f  annotated.    t_
-00012210: 6a69 7474 203a 2051 7561 6e74 6974 790a  jitt : Quantity.
-00012220: 2020 2020 2020 2020 5469 6d65 206a 6974          Time jit
-00012230: 7465 7220 746f 2063 6f6e 7369 6465 7220  ter to consider 
-00012240: 6f76 6572 6c61 7070 696e 6720 7370 696b  overlapping spik
-00012250: 6573 2069 6e20 7469 6d65 2028 6465 6661  es in time (defa
-00012260: 756c 7420 3120 6d73 290a 2020 2020 6f76  ult 1 ms).    ov
-00012270: 6572 6c61 7070 696e 675f 7061 6972 7320  erlapping_pairs 
-00012280: 3a20 6e70 2e61 7272 6179 0a20 2020 2020  : np.array.     
-00012290: 2020 2041 7272 6179 2077 6974 6820 6f76     Array with ov
-000122a0: 6572 6c61 7070 696e 6720 696e 666f 726d  erlapping inform
-000122b0: 6174 696f 6e20 6265 7477 6565 6e20 7370  ation between sp
-000122c0: 696b 6520 7472 6169 6e73 2028 6e5f 7370  ike trains (n_sp
-000122d0: 696b 6574 7261 696e 732c 2032 290a 2020  iketrains, 2).  
-000122e0: 2020 7061 7261 6c6c 656c 203a 2062 6f6f    parallel : boo
-000122f0: 6c0a 2020 2020 2020 2020 4966 2054 7275  l.        If Tru
-00012300: 6520 7370 696b 6520 7472 6169 6e73 2061  e spike trains a
-00012310: 7265 2070 726f 6365 7373 6564 2069 6e20  re processed in 
-00012320: 7061 7261 6c6c 656c 2077 6974 6820 6d75  parallel with mu
-00012330: 6c74 6970 726f 6365 7373 696e 670a 2020  ltiprocessing.  
-00012340: 2020 7665 7262 6f73 6520 3a20 626f 6f6c    verbose : bool
-00012350: 0a20 2020 2020 2020 2049 6620 5472 7565  .        If True
-00012360: 206f 7574 7075 7420 6973 2076 6572 626f   output is verbo
-00012370: 7365 0a0a 2020 2020 2222 220a 2020 2020  se..    """.    
-00012380: 6966 2070 6172 616c 6c65 6c3a 0a20 2020  if parallel:.   
-00012390: 2020 2020 2069 6d70 6f72 7420 6d75 6c74       import mult
-000123a0: 6970 726f 6365 7373 696e 670a 2020 2020  iprocessing.    
-000123b0: 2020 2020 7468 7265 6164 7320 3d20 5b5d      threads = []
-000123c0: 0a20 2020 2020 2020 206d 616e 6167 6572  .        manager
-000123d0: 203d 206d 756c 7469 7072 6f63 6573 7369   = multiprocessi
-000123e0: 6e67 2e4d 616e 6167 6572 2829 0a20 2020  ng.Manager().   
-000123f0: 2020 2020 2072 6574 7572 6e5f 7370 696b       return_spik
-00012400: 6574 7261 696e 7320 3d20 6d61 6e61 6765  etrains = manage
-00012410: 722e 6469 6374 2829 0a20 2020 2020 2020  r.dict().       
-00012420: 2066 6f72 2069 2c20 7374 5f69 2069 6e20   for i, st_i in 
-00012430: 656e 756d 6572 6174 6528 7370 696b 6574  enumerate(spiket
-00012440: 7261 696e 7329 3a0a 2020 2020 2020 2020  rains):.        
-00012450: 2020 2020 7020 3d20 6d75 6c74 6970 726f      p = multipro
-00012460: 6365 7373 696e 672e 5072 6f63 6573 7328  cessing.Process(
-00012470: 7461 7267 6574 3d61 6e6e 6f74 6174 655f  target=annotate_
-00012480: 7061 7261 6c6c 656c 2c20 6172 6773 3d28  parallel, args=(
-00012490: 692c 2073 745f 692c 2073 7069 6b65 7472  i, st_i, spiketr
-000124a0: 6169 6e73 2c20 745f 6a69 7474 2c0a 2020  ains, t_jitt,.  
-000124b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000124c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000124d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000124e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000124f0: 2020 2020 2020 6f76 6572 6c61 7070 696e        overlappin
-00012500: 675f 7061 6972 732c 2072 6574 7572 6e5f  g_pairs, return_
-00012510: 7370 696b 6574 7261 696e 732c 0a20 2020  spiketrains,.   
-00012520: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012530: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012540: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012550: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012560: 2020 2020 2076 6572 626f 7365 2c29 290a       verbose,)).
-00012570: 2020 2020 2020 2020 2020 2020 702e 7374              p.st
-00012580: 6172 7428 290a 2020 2020 2020 2020 2020  art().          
-00012590: 2020 7468 7265 6164 732e 6170 7065 6e64    threads.append
-000125a0: 2870 290a 2020 2020 2020 2020 666f 7220  (p).        for 
-000125b0: 7020 696e 2074 6872 6561 6473 3a0a 2020  p in threads:.  
-000125c0: 2020 2020 2020 2020 2020 702e 6a6f 696e            p.join
-000125d0: 2829 0a20 2020 2020 2020 2023 2072 6574  ().        # ret
-000125e0: 7269 6576 6520 616e 6e6f 7461 7465 6420  rieve annotated 
-000125f0: 7370 696b 6574 7261 696e 730a 2020 2020  spiketrains.    
-00012600: 2020 2020 666f 7220 692c 2073 7420 696e      for i, st in
-00012610: 2065 6e75 6d65 7261 7465 2873 7069 6b65   enumerate(spike
-00012620: 7472 6169 6e73 293a 0a20 2020 2020 2020  trains):.       
-00012630: 2020 2020 2073 7069 6b65 7472 6169 6e73       spiketrains
-00012640: 5b69 5d20 3d20 7265 7475 726e 5f73 7069  [i] = return_spi
-00012650: 6b65 7472 6169 6e73 5b69 5d0a 2020 2020  ketrains[i].    
-00012660: 656c 7365 3a0a 2020 2020 2020 2020 2320  else:.        # 
-00012670: 6669 6e64 206f 7665 726c 6170 7069 6e67  find overlapping
-00012680: 2073 7069 6b65 730a 2020 2020 2020 2020   spikes.        
-00012690: 666f 7220 692c 2073 745f 6920 696e 2065  for i, st_i in e
-000126a0: 6e75 6d65 7261 7465 2873 7069 6b65 7472  numerate(spiketr
-000126b0: 6169 6e73 293a 0a20 2020 2020 2020 2020  ains):.         
-000126c0: 2020 2069 6620 7665 7262 6f73 653a 0a20     if verbose:. 
-000126d0: 2020 2020 2020 2020 2020 2020 2020 2070                 p
-000126e0: 7269 6e74 2827 416e 6e6f 7461 7469 6e67  rint('Annotating
-000126f0: 206f 7665 726c 6170 7069 6e67 2073 7069   overlapping spi
-00012700: 6b65 2074 7261 696e 2027 2c20 6929 0a20  ke train ', i). 
-00012710: 2020 2020 2020 2020 2020 206f 7665 7220             over 
-00012720: 3d20 6e70 2e61 7272 6179 285b 274e 4f4e  = np.array(['NON
-00012730: 4527 5d20 2a20 6c65 6e28 7374 5f69 2929  E'] * len(st_i))
-00012740: 0a20 2020 2020 2020 2020 2020 2066 6f72  .            for
-00012750: 2069 5f73 702c 2074 5f69 2069 6e20 656e   i_sp, t_i in en
-00012760: 756d 6572 6174 6528 7374 5f69 293a 0a20  umerate(st_i):. 
-00012770: 2020 2020 2020 2020 2020 2020 2020 2066                 f
-00012780: 6f72 206a 2c20 7374 5f6a 2069 6e20 656e  or j, st_j in en
-00012790: 756d 6572 6174 6528 7370 696b 6574 7261  umerate(spiketra
-000127a0: 696e 7329 3a0a 2020 2020 2020 2020 2020  ins):.          
-000127b0: 2020 2020 2020 2020 2020 6966 2069 2021            if i !
-000127c0: 3d20 6a3a 0a20 2020 2020 2020 2020 2020  = j:.           
-000127d0: 2020 2020 2020 2020 2020 2020 2023 2066               # f
-000127e0: 696e 6420 6f76 6572 6c61 7070 696e 670a  ind overlapping.
+0000ed60: 2020 2020 7365 6c65 6374 6564 5f69 6478      selected_idx
+0000ed70: 732e 6170 7065 6e64 2869 645f 6365 6c6c  s.append(id_cell
+0000ed80: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+0000ed90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000eda0: 2020 2020 2020 6e5f 7365 6c20 2b3d 2031        n_sel += 1
+0000edb0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000edc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000edd0: 2020 2020 2070 6c61 6365 6420 3d20 5472       placed = Tr
+0000ede0: 7565 0a20 2020 2020 2020 2020 2020 2020  ue.             
+0000edf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ee00: 2020 2020 2020 2063 7572 7265 6e74 5f6f         current_o
+0000ee10: 7665 726c 6170 7069 6e67 5f70 6169 7273  verlapping_pairs
+0000ee20: 203d 206c 656e 286f 7665 726c 6170 7069   = len(overlappi
+0000ee30: 6e67 290a 2020 2020 2020 2020 2020 2020  ng).            
+0000ee40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ee50: 2020 2020 2020 2020 6966 2076 6572 626f          if verbo
+0000ee60: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+0000ee70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ee80: 2020 2020 2020 2020 2020 2020 7072 696e              prin
+0000ee90: 7428 224e 756d 6265 7220 6f66 206f 7665  t("Number of ove
+0000eea0: 726c 6170 7069 6e67 2070 6169 7273 3a22  rlapping pairs:"
+0000eeb0: 2c20 6375 7272 656e 745f 6f76 6572 6c61  , current_overla
+0000eec0: 7070 696e 675f 7061 6972 7329 0a20 2020  pping_pairs).   
+0000eed0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000eee0: 2020 2020 2020 2020 2020 2020 2065 6c73               els
+0000eef0: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+0000ef00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ef10: 2020 2020 2020 2069 6620 7665 7262 6f73         if verbos
+0000ef20: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+0000ef30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ef40: 2020 2020 2020 2020 2020 2070 7269 6e74             print
+0000ef50: 2822 4f76 6572 6c61 7070 696e 6720 7669  ("Overlapping vi
+0000ef60: 6f6c 6174 696f 6e3a 222c 2063 7572 7265  olation:", curre
+0000ef70: 6e74 5f6f 7665 726c 6170 7069 6e67 5f70  nt_overlapping_p
+0000ef80: 6169 7273 290a 2020 2020 2020 2020 2020  airs).          
+0000ef90: 2020 2020 2020 2020 2020 2020 2020 656c                el
+0000efa0: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+0000efb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000efc0: 6966 2076 6572 626f 7365 3a0a 2020 2020  if verbose:.    
+0000efd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000efe0: 2020 2020 2020 2020 2020 2020 7072 696e              prin
+0000eff0: 7428 2244 7269 6674 2076 696f 6c61 7469  t("Drift violati
+0000f000: 6f6e 222c 206c 6f63 5b69 645f 6365 6c6c  on", loc[id_cell
+0000f010: 2c20 305d 2c20 6974 6572 290a 2020 2020  , 0], iter).    
+0000f020: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f030: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+0000f040: 2020 2020 2020 2020 2020 2020 2020 6966                if
+0000f050: 2076 6572 626f 7365 3a0a 2020 2020 2020   verbose:.      
+0000f060: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f070: 2020 2020 2020 7072 696e 7428 2241 6d70        print("Amp
+0000f080: 6c69 7475 6465 206f 7220 626f 756e 6461  litude or bounda
+0000f090: 7279 2076 696f 6c61 7469 6f6e 222c 2061  ry violation", a
+0000f0a0: 6d70 2c20 6c6f 635b 6964 5f63 656c 6c2c  mp, loc[id_cell,
+0000f0b0: 2030 5d2c 2069 7465 7229 0a20 2020 2020   0], iter).     
+0000f0c0: 2020 2020 2020 2069 6620 706c 6163 6564         if placed
+0000f0d0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0000f0e0: 2020 7365 6c65 6374 6564 5f63 6174 2e61    selected_cat.a
+0000f0f0: 7070 656e 6428 2255 2229 0a0a 2020 2020  ppend("U")..    
+0000f100: 6966 2069 203d 3d20 6c65 6e28 7065 726d  if i == len(perm
+0000f110: 7574 6564 5f69 6478 7329 202d 2031 2061  uted_idxs) - 1 a
+0000f120: 6e64 206e 5f73 656c 203c 206e 5f65 7863  nd n_sel < n_exc
+0000f130: 202b 206e 5f69 6e68 3a0a 2020 2020 2020   + n_inh:.      
+0000f140: 2020 7261 6973 6520 5275 6e74 696d 6545    raise RuntimeE
+0000f150: 7272 6f72 280a 2020 2020 2020 2020 2020  rror(.          
+0000f160: 2020 2254 656d 706c 6174 6573 2063 6f75    "Templates cou
+0000f170: 6c64 206e 6f74 2062 6520 7365 6c65 6374  ld not be select
+0000f180: 6564 2e20 5c6e 220a 2020 2020 2020 2020  ed. \n".        
+0000f190: 2020 2020 2244 6563 7265 6173 6520 6e75      "Decrease nu
+0000f1a0: 6d62 6572 206f 6620 7370 696b 6574 7261  mber of spiketra
+0000f1b0: 696e 732c 2064 6563 7265 6173 6520 276d  ins, decrease 'm
+0000f1c0: 696e 5f64 6973 7427 2c20 6f72 2075 7365  in_dist', or use
+0000f1d0: 206d 6f72 6520 7465 6d70 6c61 7465 732e   more templates.
+0000f1e0: 220a 2020 2020 2020 2020 290a 2020 2020  ".        ).    
+0000f1f0: 7265 7475 726e 2073 656c 6563 7465 645f  return selected_
+0000f200: 6964 7873 2c20 7365 6c65 6374 6564 5f63  idxs, selected_c
+0000f210: 6174 0a0a 0a64 6566 2072 6573 616d 706c  at...def resampl
+0000f220: 655f 7465 6d70 6c61 7465 7328 0a20 2020  e_templates(.   
+0000f230: 2074 656d 706c 6174 6573 2c20 6e5f 7265   templates, n_re
+0000f240: 7361 6d70 6c65 2c20 7570 2c20 646f 776e  sample, up, down
+0000f250: 2c20 6472 6966 7469 6e67 2c20 6474 7970  , drifting, dtyp
+0000f260: 652c 2076 6572 626f 7365 2c20 6e5f 6a6f  e, verbose, n_jo
+0000f270: 6273 3d4e 6f6e 652c 2074 6d70 5f66 696c  bs=None, tmp_fil
+0000f280: 653d 4e6f 6e65 2c20 7061 7261 6c6c 656c  e=None, parallel
+0000f290: 3d46 616c 7365 0a29 3a0a 2020 2020 2222  =False.):.    ""
+0000f2a0: 220a 2020 2020 5265 7361 6d70 6c65 7320  ".    Resamples 
+0000f2b0: 7468 6520 7465 6d70 6c61 7465 7320 746f  the templates to
+0000f2c0: 2061 2073 7065 6369 6669 6564 2073 616d   a specified sam
+0000f2d0: 706c 696e 6720 6672 6571 7565 6e63 792e  pling frequency.
+0000f2e0: 0a20 2020 2050 6172 616d 6574 6572 730a  .    Parameters.
+0000f2f0: 2020 2020 2d2d 2d2d 2d2d 2d2d 2d2d 0a20      ----------. 
+0000f300: 2020 2074 656d 706c 6174 6573 203a 206e     templates : n
+0000f310: 702e 6172 7261 790a 2020 2020 2020 2020  p.array.        
+0000f320: 4172 7261 7920 7769 7468 2074 656d 706c  Array with templ
+0000f330: 6174 6573 2028 6e5f 6e65 7572 6f6e 732c  ates (n_neurons,
+0000f340: 206e 5f63 6861 6e6e 656c 732c 206e 5f73   n_channels, n_s
+0000f350: 616d 706c 6573 290a 2020 2020 2020 2020  amples).        
+0000f360: 6f72 2028 6e5f 6e65 7572 6f6e 732c 206e  or (n_neurons, n
+0000f370: 5f64 7269 6674 2c20 6e5f 6368 616e 6e65  _drift, n_channe
+0000f380: 6c73 2c20 6e5f 7361 6d70 6c65 7329 2069  ls, n_samples) i
+0000f390: 6620 6472 6966 7469 6e67 0a20 2020 206e  f drifting.    n
+0000f3a0: 5f72 6573 616d 706c 6520 3a20 696e 740a  _resample : int.
+0000f3b0: 2020 2020 2020 2020 5361 6d70 6c65 7320          Samples 
+0000f3c0: 666f 7220 7265 7361 6d70 6c65 6420 7465  for resampled te
+0000f3d0: 6d70 6c61 7465 730a 2020 2020 7570 203a  mplates.    up :
+0000f3e0: 2066 6c6f 6174 0a20 2020 2020 2020 2054   float.        T
+0000f3f0: 6865 206f 7269 6769 6e61 6c20 7361 6d70  he original samp
+0000f400: 6c69 6e67 2066 7265 7175 656e 6379 2069  ling frequency i
+0000f410: 6e20 487a 0a20 2020 2064 6f77 6e20 3a20  n Hz.    down : 
+0000f420: 666c 6f61 740a 2020 2020 2020 2020 5468  float.        Th
+0000f430: 6520 6e65 7720 7361 6d70 6c69 6e67 2066  e new sampling f
+0000f440: 7265 7175 656e 6379 2069 6e20 487a 0a20  requency in Hz. 
+0000f450: 2020 2064 7269 6674 696e 6720 3a20 626f     drifting : bo
+0000f460: 6f6c 0a20 2020 2020 2020 2049 6620 5472  ol.        If Tr
+0000f470: 7565 2074 656d 706c 6174 6573 2061 7265  ue templates are
+0000f480: 2061 7373 756d 6564 2074 6f20 6265 2064   assumed to be d
+0000f490: 7269 6674 696e 670a 2020 2020 7665 7262  rifting.    verb
+0000f4a0: 6f73 6520 3a20 626f 6f6c 0a20 2020 2020  ose : bool.     
+0000f4b0: 2020 2049 6620 5472 7565 206f 7574 7075     If True outpu
+0000f4c0: 7420 6973 2076 6572 626f 7365 0a20 2020  t is verbose.   
+0000f4d0: 206e 5f6a 6f62 7320 3a20 696e 740a 2020   n_jobs : int.  
+0000f4e0: 2020 2020 2020 4e75 6d62 6572 206f 6620        Number of 
+0000f4f0: 6a6f 6273 2066 6f72 2070 6172 616c 6c65  jobs for paralle
+0000f500: 6c20 7072 6f63 6573 7369 6e67 2e20 4966  l processing. If
+0000f510: 204e 6f6e 6520 6861 6c66 2063 7075 7320   None half cpus 
+0000f520: 6172 6520 7573 6564 0a20 2020 2074 6d70  are used.    tmp
+0000f530: 5f66 696c 6520 3a20 7374 720a 2020 2020  _file : str.    
+0000f540: 2020 2020 5061 7468 2074 6f20 746d 7020      Path to tmp 
+0000f550: 6669 6c65 2074 6f20 6d65 6d6d 6170 2e20  file to memmap. 
+0000f560: 4966 204e 6f6e 652c 2070 726f 6365 7373  If None, process
+0000f570: 696e 6720 6973 2069 6e20 6d65 6d6f 7279  ing is in memory
+0000f580: 0a20 2020 2070 6172 616c 6c65 6c20 3a20  .    parallel : 
+0000f590: 626f 6f6c 0a20 2020 2020 2020 2049 6620  bool.        If 
+0000f5a0: 5472 7565 2065 6163 6820 7465 6d70 6c61  True each templa
+0000f5b0: 7465 2069 7320 7265 7361 6d70 6c65 6420  te is resampled 
+0000f5c0: 696e 2070 6172 656c 6c65 6c0a 2020 2020  in parellel.    
+0000f5d0: 5265 7475 726e 730a 2020 2020 2d2d 2d2d  Returns.    ----
+0000f5e0: 2d2d 2d0a 2020 2020 7465 6d70 6c61 7465  ---.    template
+0000f5f0: 5f72 7320 3a20 6e70 2e61 7272 6179 0a20  _rs : np.array. 
+0000f600: 2020 2020 2020 2041 7272 6179 2077 6974         Array wit
+0000f610: 6820 7265 7361 6d70 6c65 6420 7465 6d70  h resampled temp
+0000f620: 6c61 7465 7320 286e 5f6e 6575 726f 6e73  lates (n_neurons
+0000f630: 2c20 6e5f 6368 616e 6e65 6c73 2c20 6e5f  , n_channels, n_
+0000f640: 7265 7361 6d70 6c65 290a 2020 2020 2020  resample).      
+0000f650: 2020 6f72 2028 6e5f 6e65 7572 6f6e 732c    or (n_neurons,
+0000f660: 206e 5f64 7269 6674 2c20 6e5f 6368 616e   n_drift, n_chan
+0000f670: 6e65 6c73 2c20 6e5f 7265 7361 6d70 6c65  nels, n_resample
+0000f680: 2920 6966 2064 7269 6674 696e 670a 2020  ) if drifting.  
+0000f690: 2020 2222 220a 2020 2020 2320 6372 6561    """.    # crea
+0000f6a0: 7465 2072 6573 616d 706c 6564 2074 656d  te resampled tem
+0000f6b0: 706c 6174 6573 0a20 2020 2069 6620 6e6f  plates.    if no
+0000f6c0: 7420 6472 6966 7469 6e67 3a0a 2020 2020  t drifting:.    
+0000f6d0: 2020 2020 6966 2074 6d70 5f66 696c 6520      if tmp_file 
+0000f6e0: 6973 206e 6f74 204e 6f6e 653a 0a20 2020  is not None:.   
+0000f6f0: 2020 2020 2020 2020 2074 656d 706c 6174           templat
+0000f700: 6573 5f72 7320 3d20 6e70 2e6d 656d 6d61  es_rs = np.memma
+0000f710: 7028 0a20 2020 2020 2020 2020 2020 2020  p(.             
+0000f720: 2020 2074 6d70 5f66 696c 652c 2073 6861     tmp_file, sha
+0000f730: 7065 3d28 7465 6d70 6c61 7465 732e 7368  pe=(templates.sh
+0000f740: 6170 655b 305d 2c20 7465 6d70 6c61 7465  ape[0], template
+0000f750: 732e 7368 6170 655b 315d 2c20 6e5f 7265  s.shape[1], n_re
+0000f760: 7361 6d70 6c65 292c 2064 7479 7065 3d64  sample), dtype=d
+0000f770: 7479 7065 2c20 6d6f 6465 3d22 772b 220a  type, mode="w+".
+0000f780: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
+0000f790: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+0000f7a0: 2020 2020 2020 2020 7465 6d70 6c61 7465          template
+0000f7b0: 735f 7273 203d 206e 702e 7a65 726f 7328  s_rs = np.zeros(
+0000f7c0: 2874 656d 706c 6174 6573 2e73 6861 7065  (templates.shape
+0000f7d0: 5b30 5d2c 2074 656d 706c 6174 6573 2e73  [0], templates.s
+0000f7e0: 6861 7065 5b31 5d2c 206e 5f72 6573 616d  hape[1], n_resam
+0000f7f0: 706c 6529 290a 2020 2020 656c 7365 3a0a  ple)).    else:.
+0000f800: 2020 2020 2020 2020 6966 2074 6d70 5f66          if tmp_f
+0000f810: 696c 6520 6973 206e 6f74 204e 6f6e 653a  ile is not None:
+0000f820: 0a20 2020 2020 2020 2020 2020 2074 656d  .            tem
+0000f830: 706c 6174 6573 5f72 7320 3d20 6e70 2e6d  plates_rs = np.m
+0000f840: 656d 6d61 7028 0a20 2020 2020 2020 2020  emmap(.         
+0000f850: 2020 2020 2020 2074 6d70 5f66 696c 652c         tmp_file,
+0000f860: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000f870: 2073 6861 7065 3d28 7465 6d70 6c61 7465   shape=(template
+0000f880: 732e 7368 6170 655b 305d 2c20 7465 6d70  s.shape[0], temp
+0000f890: 6c61 7465 732e 7368 6170 655b 315d 2c20  lates.shape[1], 
+0000f8a0: 7465 6d70 6c61 7465 732e 7368 6170 655b  templates.shape[
+0000f8b0: 325d 2c20 6e5f 7265 7361 6d70 6c65 292c  2], n_resample),
+0000f8c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000f8d0: 2064 7479 7065 3d64 7479 7065 2c0a 2020   dtype=dtype,.  
+0000f8e0: 2020 2020 2020 2020 2020 2020 2020 6d6f                mo
+0000f8f0: 6465 3d22 772b 222c 0a20 2020 2020 2020  de="w+",.       
+0000f900: 2020 2020 2029 0a20 2020 2020 2020 2065       ).        e
+0000f910: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+0000f920: 2074 656d 706c 6174 6573 5f72 7320 3d20   templates_rs = 
+0000f930: 6e70 2e7a 6572 6f73 2828 7465 6d70 6c61  np.zeros((templa
+0000f940: 7465 732e 7368 6170 655b 305d 2c20 7465  tes.shape[0], te
+0000f950: 6d70 6c61 7465 732e 7368 6170 655b 315d  mplates.shape[1]
+0000f960: 2c20 7465 6d70 6c61 7465 732e 7368 6170  , templates.shap
+0000f970: 655b 325d 2c20 6e5f 7265 7361 6d70 6c65  e[2], n_resample
+0000f980: 2929 0a0a 2020 2020 6966 2070 6172 616c  ))..    if paral
+0000f990: 6c65 6c3a 0a20 2020 2020 2020 2069 6620  lel:.        if 
+0000f9a0: 6e5f 6a6f 6273 2069 7320 4e6f 6e65 3a0a  n_jobs is None:.
+0000f9b0: 2020 2020 2020 2020 2020 2020 6e5f 6a6f              n_jo
+0000f9c0: 6273 203d 206f 732e 6370 755f 636f 756e  bs = os.cpu_coun
+0000f9d0: 7428 2920 2f2f 2032 0a0a 2020 2020 2020  t() // 2..      
+0000f9e0: 2020 6966 2076 6572 626f 7365 3a0a 2020    if verbose:.  
+0000f9f0: 2020 2020 2020 2020 2020 7072 696e 7428            print(
+0000fa00: 2252 6573 616d 706c 696e 6720 7769 7468  "Resampling with
+0000fa10: 222c 206e 5f6a 6f62 732c 2022 6a6f 6273  ", n_jobs, "jobs
+0000fa20: 2229 0a0a 2020 2020 2020 2020 6f75 7470  ")..        outp
+0000fa30: 7574 5f6c 6973 7420 3d20 5061 7261 6c6c  ut_list = Parall
+0000fa40: 656c 286e 5f6a 6f62 733d 6e5f 6a6f 6273  el(n_jobs=n_jobs
+0000fa50: 2928 0a20 2020 2020 2020 2020 2020 2064  )(.            d
+0000fa60: 656c 6179 6564 285f 7265 7361 6d70 6c65  elayed(_resample
+0000fa70: 5f70 6172 616c 6c65 6c29 280a 2020 2020  _parallel)(.    
+0000fa80: 2020 2020 2020 2020 2020 2020 692c 0a20              i,. 
+0000fa90: 2020 2020 2020 2020 2020 2020 2020 2074                 t
+0000faa0: 656d 2c0a 2020 2020 2020 2020 2020 2020  em,.            
+0000fab0: 2020 2020 7570 2c0a 2020 2020 2020 2020      up,.        
+0000fac0: 2020 2020 2020 2020 646f 776e 2c0a 2020          down,.  
+0000fad0: 2020 2020 2020 2020 2020 2020 2020 6472                dr
+0000fae0: 6966 7469 6e67 2c0a 2020 2020 2020 2020  ifting,.        
+0000faf0: 2020 2020 290a 2020 2020 2020 2020 2020      ).          
+0000fb00: 2020 666f 7220 692c 2074 656d 2069 6e20    for i, tem in 
+0000fb10: 656e 756d 6572 6174 6528 7465 6d70 6c61  enumerate(templa
+0000fb20: 7465 7329 0a20 2020 2020 2020 2029 0a0a  tes).        )..
+0000fb30: 2020 2020 2020 2020 666f 7220 692c 2074          for i, t
+0000fb40: 656d 2069 6e20 656e 756d 6572 6174 6528  em in enumerate(
+0000fb50: 7465 6d70 6c61 7465 7329 3a0a 2020 2020  templates):.    
+0000fb60: 2020 2020 2020 2020 7465 6d70 6c61 7465          template
+0000fb70: 5f72 7320 3d20 6f75 7470 7574 5f6c 6973  _rs = output_lis
+0000fb80: 745b 695d 0a20 2020 2020 2020 2020 2020  t[i].           
+0000fb90: 2069 6620 7465 6d70 6c61 7465 5f72 732e   if template_rs.
+0000fba0: 7368 6170 655b 2d31 5d20 3c20 7465 6d70  shape[-1] < temp
+0000fbb0: 6c61 7465 735f 7273 2e73 6861 7065 5b2d  lates_rs.shape[-
+0000fbc0: 315d 3a0a 2020 2020 2020 2020 2020 2020  1]:.            
+0000fbd0: 2020 2020 6966 206e 6f74 2064 7269 6674      if not drift
+0000fbe0: 696e 673a 0a20 2020 2020 2020 2020 2020  ing:.           
+0000fbf0: 2020 2020 2020 2020 2074 656d 706c 6174           templat
+0000fc00: 6573 5f72 735b 692c 203a 2c20 3a20 6c65  es_rs[i, :, : le
+0000fc10: 6e28 7465 6d70 6c61 7465 5f72 7329 5d20  n(template_rs)] 
+0000fc20: 3d20 7465 6d70 6c61 7465 5f72 730a 2020  = template_rs.  
+0000fc30: 2020 2020 2020 2020 2020 2020 2020 656c                el
+0000fc40: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+0000fc50: 2020 2020 2020 2020 7465 6d70 6c61 7465          template
+0000fc60: 735f 7273 5b69 2c20 3a2c 203a 2c20 3a20  s_rs[i, :, :, : 
+0000fc70: 6c65 6e28 7465 6d70 6c61 7465 5f72 7329  len(template_rs)
+0000fc80: 5d20 3d20 7465 6d70 6c61 7465 5f72 730a  ] = template_rs.
+0000fc90: 2020 2020 2020 2020 2020 2020 656c 6966              elif
+0000fca0: 2074 656d 706c 6174 655f 7273 2e73 6861   template_rs.sha
+0000fcb0: 7065 5b2d 315d 203e 2074 656d 706c 6174  pe[-1] > templat
+0000fcc0: 6573 5f72 732e 7368 6170 655b 2d31 5d3a  es_rs.shape[-1]:
+0000fcd0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000fce0: 2069 6620 6e6f 7420 6472 6966 7469 6e67   if not drifting
+0000fcf0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0000fd00: 2020 2020 2020 7465 6d70 6c61 7465 735f        templates_
+0000fd10: 7273 5b69 5d20 3d20 7465 6d70 6c61 7465  rs[i] = template
+0000fd20: 5f72 735b 3a2c 203a 2074 656d 706c 6174  _rs[:, : templat
+0000fd30: 6573 5f72 732e 7368 6170 655b 2d31 5d5d  es_rs.shape[-1]]
+0000fd40: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000fd50: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+0000fd60: 2020 2020 2020 2020 2020 2074 656d 706c             templ
+0000fd70: 6174 6573 5f72 735b 695d 203d 2074 656d  ates_rs[i] = tem
+0000fd80: 706c 6174 655f 7273 5b3a 2c20 3a2c 203a  plate_rs[:, :, :
+0000fd90: 2074 656d 706c 6174 6573 5f72 732e 7368   templates_rs.sh
+0000fda0: 6170 655b 2d31 5d5d 0a20 2020 2020 2020  ape[-1]].       
+0000fdb0: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+0000fdc0: 2020 2020 2020 2020 2020 2074 656d 706c             templ
+0000fdd0: 6174 6573 5f72 735b 695d 203d 2074 656d  ates_rs[i] = tem
+0000fde0: 706c 6174 655f 7273 0a20 2020 2065 6c73  plate_rs.    els
+0000fdf0: 653a 0a20 2020 2020 2020 2066 6f72 2069  e:.        for i
+0000fe00: 2c20 7465 6d20 696e 2065 6e75 6d65 7261  , tem in enumera
+0000fe10: 7465 2874 656d 706c 6174 6573 293a 0a20  te(templates):. 
+0000fe20: 2020 2020 2020 2020 2020 2074 656d 706c             templ
+0000fe30: 6174 655f 7273 203d 205f 7265 7361 6d70  ate_rs = _resamp
+0000fe40: 6c65 5f70 6172 616c 6c65 6c28 692c 2074  le_parallel(i, t
+0000fe50: 656d 2c20 7570 2c20 646f 776e 2c20 6472  em, up, down, dr
+0000fe60: 6966 7469 6e67 290a 2020 2020 2020 2020  ifting).        
+0000fe70: 2020 2020 6966 2074 656d 706c 6174 655f      if template_
+0000fe80: 7273 2e73 6861 7065 5b2d 315d 203c 2074  rs.shape[-1] < t
+0000fe90: 656d 706c 6174 6573 5f72 732e 7368 6170  emplates_rs.shap
+0000fea0: 655b 2d31 5d3a 0a20 2020 2020 2020 2020  e[-1]:.         
+0000feb0: 2020 2020 2020 2069 6620 6e6f 7420 6472         if not dr
+0000fec0: 6966 7469 6e67 3a0a 2020 2020 2020 2020  ifting:.        
+0000fed0: 2020 2020 2020 2020 2020 2020 7465 6d70              temp
+0000fee0: 6c61 7465 735f 7273 5b69 2c20 3a2c 203a  lates_rs[i, :, :
+0000fef0: 206c 656e 2874 656d 706c 6174 655f 7273   len(template_rs
+0000ff00: 295d 203d 2074 656d 706c 6174 655f 7273  )] = template_rs
+0000ff10: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000ff20: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+0000ff30: 2020 2020 2020 2020 2020 2074 656d 706c             templ
+0000ff40: 6174 6573 5f72 735b 692c 203a 2c20 3a2c  ates_rs[i, :, :,
+0000ff50: 203a 206c 656e 2874 656d 706c 6174 655f   : len(template_
+0000ff60: 7273 295d 203d 2074 656d 706c 6174 655f  rs)] = template_
+0000ff70: 7273 0a20 2020 2020 2020 2020 2020 2065  rs.            e
+0000ff80: 6c69 6620 7465 6d70 6c61 7465 5f72 732e  lif template_rs.
+0000ff90: 7368 6170 655b 2d31 5d20 3e20 7465 6d70  shape[-1] > temp
+0000ffa0: 6c61 7465 735f 7273 2e73 6861 7065 5b2d  lates_rs.shape[-
+0000ffb0: 315d 3a0a 2020 2020 2020 2020 2020 2020  1]:.            
+0000ffc0: 2020 2020 6966 206e 6f74 2064 7269 6674      if not drift
+0000ffd0: 696e 673a 0a20 2020 2020 2020 2020 2020  ing:.           
+0000ffe0: 2020 2020 2020 2020 2074 656d 706c 6174           templat
+0000fff0: 6573 5f72 735b 695d 203d 2074 656d 706c  es_rs[i] = templ
+00010000: 6174 655f 7273 5b3a 2c20 3a20 7465 6d70  ate_rs[:, : temp
+00010010: 6c61 7465 735f 7273 2e73 6861 7065 5b2d  lates_rs.shape[-
+00010020: 315d 5d0a 2020 2020 2020 2020 2020 2020  1]].            
+00010030: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+00010040: 2020 2020 2020 2020 2020 2020 2020 7465                te
+00010050: 6d70 6c61 7465 735f 7273 5b69 5d20 3d20  mplates_rs[i] = 
+00010060: 7465 6d70 6c61 7465 5f72 735b 3a2c 203a  template_rs[:, :
+00010070: 2c20 3a20 7465 6d70 6c61 7465 735f 7273  , : templates_rs
+00010080: 2e73 6861 7065 5b2d 315d 5d0a 2020 2020  .shape[-1]].    
+00010090: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+000100a0: 2020 2020 2020 2020 2020 2020 2020 7465                te
+000100b0: 6d70 6c61 7465 735f 7273 5b69 5d20 3d20  mplates_rs[i] = 
+000100c0: 7465 6d70 6c61 7465 5f72 730a 0a20 2020  template_rs..   
+000100d0: 2072 6574 7572 6e20 7465 6d70 6c61 7465   return template
+000100e0: 735f 7273 0a0a 0a64 6566 2070 6164 5f74  s_rs...def pad_t
+000100f0: 656d 706c 6174 6573 2874 656d 706c 6174  emplates(templat
+00010100: 6573 2c20 7061 645f 7361 6d70 6c65 732c  es, pad_samples,
+00010110: 2064 7269 6674 696e 672c 2064 7479 7065   drifting, dtype
+00010120: 2c20 7665 7262 6f73 652c 206e 5f6a 6f62  , verbose, n_job
+00010130: 733d 4e6f 6e65 2c20 746d 705f 6669 6c65  s=None, tmp_file
+00010140: 3d4e 6f6e 652c 2070 6172 616c 6c65 6c3d  =None, parallel=
+00010150: 4661 6c73 6529 3a0a 2020 2020 2222 220a  False):.    """.
+00010160: 2020 2020 5061 6473 2074 6865 2074 656d      Pads the tem
+00010170: 706c 6174 6573 206f 6e20 626f 7468 2065  plates on both e
+00010180: 6e64 732e 0a20 2020 2050 6172 616d 6574  nds..    Paramet
+00010190: 6572 730a 2020 2020 2d2d 2d2d 2d2d 2d2d  ers.    --------
+000101a0: 2d2d 0a20 2020 2074 656d 706c 6174 6573  --.    templates
+000101b0: 203a 206e 702e 6172 7261 790a 2020 2020   : np.array.    
+000101c0: 2020 2020 4172 7261 7920 7769 7468 2074      Array with t
+000101d0: 656d 706c 6174 6573 2028 6e5f 6e65 7572  emplates (n_neur
+000101e0: 6f6e 732c 206e 5f63 6861 6e6e 656c 732c  ons, n_channels,
+000101f0: 206e 5f73 616d 706c 6573 290a 2020 2020   n_samples).    
+00010200: 2020 2020 6f72 2028 6e5f 6e65 7572 6f6e      or (n_neuron
+00010210: 732c 206e 5f64 7269 6674 2c20 6e5f 6368  s, n_drift, n_ch
+00010220: 616e 6e65 6c73 2c20 6e5f 7361 6d70 6c65  annels, n_sample
+00010230: 7329 2069 6620 6472 6966 7469 6e67 0a20  s) if drifting. 
+00010240: 2020 2070 6164 5f73 616d 706c 6573 203a     pad_samples :
+00010250: 206c 6973 740a 2020 2020 2020 2020 4c69   list.        Li
+00010260: 7374 206f 6620 3220 696e 7473 2077 6974  st of 2 ints wit
+00010270: 6820 6e75 6d62 6572 206f 6620 7361 6d70  h number of samp
+00010280: 6c65 7320 666f 7220 7061 6464 696e 6720  les for padding 
+00010290: 6265 666f 7265 2061 6e64 2061 6674 6572  before and after
+000102a0: 0a20 2020 2064 7269 6674 696e 6720 3a20  .    drifting : 
+000102b0: 626f 6f6c 0a20 2020 2020 2020 2049 6620  bool.        If 
+000102c0: 5472 7565 2074 656d 706c 6174 6573 2061  True templates a
+000102d0: 7265 2061 7373 756d 6564 2074 6f20 6265  re assumed to be
+000102e0: 2064 7269 6674 696e 670a 2020 2020 7665   drifting.    ve
+000102f0: 7262 6f73 6520 3a20 626f 6f6c 0a20 2020  rbose : bool.   
+00010300: 2020 2020 2049 6620 5472 7565 206f 7574       If True out
+00010310: 7075 7420 6973 2076 6572 626f 7365 0a20  put is verbose. 
+00010320: 2020 206e 5f6a 6f62 7320 3a20 696e 740a     n_jobs : int.
+00010330: 2020 2020 2020 2020 4e75 6d62 6572 206f          Number o
+00010340: 6620 6a6f 6273 2066 6f72 2070 6172 616c  f jobs for paral
+00010350: 6c65 6c20 7072 6f63 6573 7369 6e67 2e20  lel processing. 
+00010360: 4966 204e 6f6e 6520 6861 6c66 2063 7075  If None half cpu
+00010370: 7320 6172 6520 7573 6564 0a20 2020 2074  s are used.    t
+00010380: 6d70 5f66 696c 6520 3a20 7374 720a 2020  mp_file : str.  
+00010390: 2020 2020 2020 5061 7468 2074 6f20 746d        Path to tm
+000103a0: 7020 6669 6c65 2074 6f20 6d65 6d6d 6170  p file to memmap
+000103b0: 2e20 4966 204e 6f6e 652c 2070 726f 6365  . If None, proce
+000103c0: 7373 696e 6720 6973 2069 6e20 6d65 6d6f  ssing is in memo
+000103d0: 7279 0a20 2020 2070 6172 616c 6c65 6c20  ry.    parallel 
+000103e0: 3a20 626f 6f6c 0a20 2020 2020 2020 2049  : bool.        I
+000103f0: 6620 5472 7565 2065 6163 6820 7465 6d70  f True each temp
+00010400: 6c61 7465 2069 7320 7061 6464 6564 2069  late is padded i
+00010410: 6e20 7061 7265 6c6c 656c 0a20 2020 2052  n parellel.    R
+00010420: 6574 7572 6e73 0a20 2020 202d 2d2d 2d2d  eturns.    -----
+00010430: 2d2d 0a20 2020 2074 656d 706c 6174 655f  --.    template_
+00010440: 7061 6420 3a20 6e70 2e61 7272 6179 0a20  pad : np.array. 
+00010450: 2020 2020 2020 2041 7272 6179 2077 6974         Array wit
+00010460: 6820 7061 6464 6564 2074 656d 706c 6174  h padded templat
+00010470: 6573 2028 6e5f 6e65 7572 6f6e 732c 206e  es (n_neurons, n
+00010480: 5f63 6861 6e6e 656c 732c 206e 5f70 6164  _channels, n_pad
+00010490: 6465 645f 7361 6d70 6c65 290a 2020 2020  ded_sample).    
+000104a0: 2020 2020 6f72 2028 6e5f 6e65 7572 6f6e      or (n_neuron
+000104b0: 732c 206e 5f64 7269 6674 2c20 6e5f 6368  s, n_drift, n_ch
+000104c0: 616e 6e65 6c73 2c20 6e5f 7061 6464 6564  annels, n_padded
+000104d0: 5f73 616d 706c 6529 2069 6620 6472 6966  _sample) if drif
+000104e0: 7469 6e67 0a20 2020 2022 2222 0a20 2020  ting.    """.   
+000104f0: 2070 6164 6465 645f 7465 6d70 6c61 7465   padded_template
+00010500: 5f73 616d 706c 6573 203d 2074 656d 706c  _samples = templ
+00010510: 6174 6573 2e73 6861 7065 5b2d 315d 202b  ates.shape[-1] +
+00010520: 206e 702e 7375 6d28 7061 645f 7361 6d70   np.sum(pad_samp
+00010530: 6c65 7329 0a20 2020 2023 2063 7265 6174  les).    # creat
+00010540: 6520 7061 6464 6564 2074 656d 706c 6174  e padded templat
+00010550: 6573 0a20 2020 2069 6620 6e6f 7420 6472  es.    if not dr
+00010560: 6966 7469 6e67 3a0a 2020 2020 2020 2020  ifting:.        
+00010570: 6966 2074 6d70 5f66 696c 6520 6973 206e  if tmp_file is n
+00010580: 6f74 204e 6f6e 653a 0a20 2020 2020 2020  ot None:.       
+00010590: 2020 2020 2074 656d 706c 6174 6573 5f70       templates_p
+000105a0: 6164 203d 206e 702e 6d65 6d6d 6170 280a  ad = np.memmap(.
+000105b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000105c0: 746d 705f 6669 6c65 2c0a 2020 2020 2020  tmp_file,.      
+000105d0: 2020 2020 2020 2020 2020 7368 6170 653d            shape=
+000105e0: 2874 656d 706c 6174 6573 2e73 6861 7065  (templates.shape
+000105f0: 5b30 5d2c 2074 656d 706c 6174 6573 2e73  [0], templates.s
+00010600: 6861 7065 5b31 5d2c 2070 6164 6465 645f  hape[1], padded_
+00010610: 7465 6d70 6c61 7465 5f73 616d 706c 6573  template_samples
+00010620: 292c 0a20 2020 2020 2020 2020 2020 2020  ),.             
+00010630: 2020 2064 7479 7065 3d64 7479 7065 2c0a     dtype=dtype,.
+00010640: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010650: 6d6f 6465 3d22 772b 222c 0a20 2020 2020  mode="w+",.     
+00010660: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+00010670: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+00010680: 2020 2074 656d 706c 6174 6573 5f70 6164     templates_pad
+00010690: 203d 206e 702e 7a65 726f 7328 2874 656d   = np.zeros((tem
+000106a0: 706c 6174 6573 2e73 6861 7065 5b30 5d2c  plates.shape[0],
+000106b0: 2074 656d 706c 6174 6573 2e73 6861 7065   templates.shape
+000106c0: 5b31 5d2c 2070 6164 6465 645f 7465 6d70  [1], padded_temp
+000106d0: 6c61 7465 5f73 616d 706c 6573 2929 0a20  late_samples)). 
+000106e0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+000106f0: 2069 6620 746d 705f 6669 6c65 2069 7320   if tmp_file is 
+00010700: 6e6f 7420 4e6f 6e65 3a0a 2020 2020 2020  not None:.      
+00010710: 2020 2020 2020 7465 6d70 6c61 7465 735f        templates_
+00010720: 7061 6420 3d20 6e70 2e6d 656d 6d61 7028  pad = np.memmap(
+00010730: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00010740: 2074 6d70 5f66 696c 652c 0a20 2020 2020   tmp_file,.     
+00010750: 2020 2020 2020 2020 2020 2073 6861 7065             shape
+00010760: 3d28 7465 6d70 6c61 7465 732e 7368 6170  =(templates.shap
+00010770: 655b 305d 2c20 7465 6d70 6c61 7465 732e  e[0], templates.
+00010780: 7368 6170 655b 315d 2c20 7465 6d70 6c61  shape[1], templa
+00010790: 7465 732e 7368 6170 655b 325d 2c20 7061  tes.shape[2], pa
+000107a0: 6464 6564 5f74 656d 706c 6174 655f 7361  dded_template_sa
+000107b0: 6d70 6c65 7329 2c0a 2020 2020 2020 2020  mples),.        
+000107c0: 2020 2020 2020 2020 6474 7970 653d 6474          dtype=dt
+000107d0: 7970 652c 0a20 2020 2020 2020 2020 2020  ype,.           
+000107e0: 2020 2020 206d 6f64 653d 2277 2b22 2c0a       mode="w+",.
+000107f0: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
+00010800: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+00010810: 2020 2020 2020 2020 7465 6d70 6c61 7465          template
+00010820: 735f 7061 6420 3d20 6e70 2e7a 6572 6f73  s_pad = np.zeros
+00010830: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+00010840: 2020 2874 656d 706c 6174 6573 2e73 6861    (templates.sha
+00010850: 7065 5b30 5d2c 2074 656d 706c 6174 6573  pe[0], templates
+00010860: 2e73 6861 7065 5b31 5d2c 2074 656d 706c  .shape[1], templ
+00010870: 6174 6573 2e73 6861 7065 5b32 5d2c 2070  ates.shape[2], p
+00010880: 6164 6465 645f 7465 6d70 6c61 7465 5f73  added_template_s
+00010890: 616d 706c 6573 290a 2020 2020 2020 2020  amples).        
+000108a0: 2020 2020 290a 2020 2020 6966 2070 6172      ).    if par
+000108b0: 616c 6c65 6c3a 0a20 2020 2020 2020 2061  allel:.        a
+000108c0: 7373 6572 7420 746d 705f 6669 6c65 2069  ssert tmp_file i
+000108d0: 7320 6e6f 7420 4e6f 6e65 0a20 2020 2020  s not None.     
+000108e0: 2020 2069 6620 6e5f 6a6f 6273 2069 7320     if n_jobs is 
+000108f0: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
+00010900: 2020 6e5f 6a6f 6273 203d 206f 732e 6370    n_jobs = os.cp
+00010910: 755f 636f 756e 7428 2920 2f2f 2032 0a0a  u_count() // 2..
+00010920: 2020 2020 2020 2020 6966 2076 6572 626f          if verbo
+00010930: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+00010940: 7072 696e 7428 2250 6164 6469 6e67 2077  print("Padding w
+00010950: 6974 6822 2c20 6e5f 6a6f 6273 2c20 226a  ith", n_jobs, "j
+00010960: 6f62 7322 290a 2020 2020 2020 2020 6f75  obs").        ou
+00010970: 7470 7574 5f6c 6973 7420 3d20 5061 7261  tput_list = Para
+00010980: 6c6c 656c 286e 5f6a 6f62 733d 6e5f 6a6f  llel(n_jobs=n_jo
+00010990: 6273 2928 0a20 2020 2020 2020 2020 2020  bs)(.           
+000109a0: 2064 656c 6179 6564 285f 7061 645f 7061   delayed(_pad_pa
+000109b0: 7261 6c6c 656c 2928 692c 2074 656d 2c20  rallel)(i, tem, 
+000109c0: 7061 645f 7361 6d70 6c65 732c 2064 7269  pad_samples, dri
+000109d0: 6674 696e 672c 2076 6572 626f 7365 2c20  fting, verbose, 
+000109e0: 7465 6d70 6c61 7465 735f 7061 6429 0a20  templates_pad). 
+000109f0: 2020 2020 2020 2020 2020 2066 6f72 2069             for i
+00010a00: 2c20 7465 6d20 696e 2065 6e75 6d65 7261  , tem in enumera
+00010a10: 7465 2874 656d 706c 6174 6573 290a 2020  te(templates).  
+00010a20: 2020 2020 2020 290a 2020 2020 656c 7365        ).    else
+00010a30: 3a0a 2020 2020 2020 2020 666f 7220 692c  :.        for i,
+00010a40: 2074 656d 2069 6e20 656e 756d 6572 6174   tem in enumerat
+00010a50: 6528 7465 6d70 6c61 7465 7329 3a0a 2020  e(templates):.  
+00010a60: 2020 2020 2020 2020 2020 7465 6d70 6c61            templa
+00010a70: 7465 735f 7061 645b 695d 203d 205f 7061  tes_pad[i] = _pa
+00010a80: 645f 7061 7261 6c6c 656c 2869 2c20 7465  d_parallel(i, te
+00010a90: 6d2c 2070 6164 5f73 616d 706c 6573 2c20  m, pad_samples, 
+00010aa0: 6472 6966 7469 6e67 2c20 7665 7262 6f73  drifting, verbos
+00010ab0: 652c 204e 6f6e 6529 0a20 2020 2072 6574  e, None).    ret
+00010ac0: 7572 6e20 7465 6d70 6c61 7465 735f 7061  urn templates_pa
+00010ad0: 640a 0a0a 6465 6620 6a69 7474 6572 5f74  d...def jitter_t
+00010ae0: 656d 706c 6174 6573 280a 2020 2020 7465  emplates(.    te
+00010af0: 6d70 6c61 7465 732c 2075 7073 616d 706c  mplates, upsampl
+00010b00: 652c 2066 732c 206e 5f6a 6974 7465 7273  e, fs, n_jitters
+00010b10: 2c20 6a69 7474 6572 2c20 6472 6966 7469  , jitter, drifti
+00010b20: 6e67 2c20 6474 7970 652c 2076 6572 626f  ng, dtype, verbo
+00010b30: 7365 2c20 6e5f 6a6f 6273 3d4e 6f6e 652c  se, n_jobs=None,
+00010b40: 2074 6d70 5f66 696c 653d 4e6f 6e65 2c20   tmp_file=None, 
+00010b50: 7061 7261 6c6c 656c 3d46 616c 7365 0a29  parallel=False.)
+00010b60: 3a0a 2020 2020 2222 220a 2020 2020 4164  :.    """.    Ad
+00010b70: 6473 206a 6974 7465 7265 6420 7265 706c  ds jittered repl
+00010b80: 6963 6173 2074 6f20 7468 6520 7465 6d70  icas to the temp
+00010b90: 6c61 7465 732e 0a20 2020 2050 6172 616d  lates..    Param
+00010ba0: 6574 6572 730a 2020 2020 2d2d 2d2d 2d2d  eters.    ------
+00010bb0: 2d2d 2d2d 0a20 2020 2074 656d 706c 6174  ----.    templat
+00010bc0: 6573 203a 206e 702e 6172 7261 790a 2020  es : np.array.  
+00010bd0: 2020 2020 2020 4172 7261 7920 7769 7468        Array with
+00010be0: 2074 656d 706c 6174 6573 2028 6e5f 6e65   templates (n_ne
+00010bf0: 7572 6f6e 732c 206e 5f63 6861 6e6e 656c  urons, n_channel
+00010c00: 732c 206e 5f73 616d 706c 6573 290a 2020  s, n_samples).  
+00010c10: 2020 2020 2020 6f72 2028 6e5f 6e65 7572        or (n_neur
+00010c20: 6f6e 732c 206e 5f64 7269 6674 2c20 6e5f  ons, n_drift, n_
+00010c30: 6368 616e 6e65 6c73 2c20 6e5f 7361 6d70  channels, n_samp
+00010c40: 6c65 7329 2069 6620 6472 6966 7469 6e67  les) if drifting
+00010c50: 0a20 2020 2075 7073 616d 706c 6520 3a20  .    upsample : 
+00010c60: 696e 740a 2020 2020 2020 2020 4661 6374  int.        Fact
+00010c70: 6f72 2066 6f72 2075 7073 616d 706c 696e  or for upsamplin
+00010c80: 6720 7468 6520 7465 6d70 6c61 7465 730a  g the templates.
+00010c90: 2020 2020 6e5f 6a69 7474 6572 7320 3a20      n_jitters : 
+00010ca0: 696e 740a 2020 2020 2020 2020 4e75 6d62  int.        Numb
+00010cb0: 6572 206f 6620 6a69 7474 6572 6564 2063  er of jittered c
+00010cc0: 6f70 6965 7320 666f 7220 6561 6368 2074  opies for each t
+00010cd0: 656d 706c 6174 650a 2020 2020 6a69 7474  emplate.    jitt
+00010ce0: 6572 203a 2071 7561 6e74 6974 790a 2020  er : quantity.  
+00010cf0: 2020 2020 2020 4a69 7474 6572 2069 6e20        Jitter in 
+00010d00: 7469 6d65 2066 6f72 2073 6869 6674 696e  time for shiftin
+00010d10: 6720 7468 6520 7465 6d70 6c61 7465 0a20  g the template. 
+00010d20: 2020 2064 7269 6674 696e 6720 3a20 626f     drifting : bo
+00010d30: 6f6c 0a20 2020 2020 2020 2049 6620 5472  ol.        If Tr
+00010d40: 7565 2074 656d 706c 6174 6573 2061 7265  ue templates are
+00010d50: 2061 7373 756d 6564 2074 6f20 6265 2064   assumed to be d
+00010d60: 7269 6674 696e 670a 2020 2020 7665 7262  rifting.    verb
+00010d70: 6f73 6520 3a20 626f 6f6c 0a20 2020 2020  ose : bool.     
+00010d80: 2020 2049 6620 5472 7565 206f 7574 7075     If True outpu
+00010d90: 7420 6973 2076 6572 626f 7365 0a20 2020  t is verbose.   
+00010da0: 206e 5f6a 6f62 7320 3a20 696e 740a 2020   n_jobs : int.  
+00010db0: 2020 2020 2020 4e75 6d62 6572 206f 6620        Number of 
+00010dc0: 6a6f 6273 2066 6f72 2070 6172 616c 6c65  jobs for paralle
+00010dd0: 6c20 7072 6f63 6573 7369 6e67 2e20 4966  l processing. If
+00010de0: 204e 6f6e 6520 6861 6c66 2063 7075 7320   None half cpus 
+00010df0: 6172 6520 7573 6564 0a20 2020 2074 6d70  are used.    tmp
+00010e00: 5f66 696c 6520 3a20 7374 720a 2020 2020  _file : str.    
+00010e10: 2020 2020 5061 7468 2074 6f20 746d 7020      Path to tmp 
+00010e20: 6669 6c65 2074 6f20 6d65 6d6d 6170 2e20  file to memmap. 
+00010e30: 4966 204e 6f6e 652c 2070 726f 6365 7373  If None, process
+00010e40: 696e 6720 6973 2069 6e20 6d65 6d6f 7279  ing is in memory
+00010e50: 0a20 2020 2070 6172 616c 6c65 6c20 3a20  .    parallel : 
+00010e60: 626f 6f6c 0a20 2020 2020 2020 2049 6620  bool.        If 
+00010e70: 5472 7565 2065 6163 6820 7465 6d70 6c61  True each templa
+00010e80: 7465 2069 7320 6a69 7474 6572 6564 2069  te is jittered i
+00010e90: 6e20 7061 7265 6c6c 656c 0a20 2020 2052  n parellel.    R
+00010ea0: 6574 7572 6e73 0a20 2020 202d 2d2d 2d2d  eturns.    -----
+00010eb0: 2d2d 0a20 2020 2074 656d 706c 6174 655f  --.    template_
+00010ec0: 6a69 7474 203a 206e 702e 6172 7261 790a  jitt : np.array.
+00010ed0: 2020 2020 2020 2020 4172 7261 7920 7769          Array wi
+00010ee0: 7468 206a 6974 7465 7265 6420 7465 6d70  th jittered temp
+00010ef0: 6c61 7465 7320 286e 5f6e 6575 726f 6e73  lates (n_neurons
+00010f00: 2c20 6e5f 6a69 7474 6572 732c 206e 5f63  , n_jitters, n_c
+00010f10: 6861 6e6e 656c 732c 206e 5f73 616d 706c  hannels, n_sampl
+00010f20: 6573 290a 2020 2020 2020 2020 6f72 2028  es).        or (
+00010f30: 6e5f 6e65 7572 6f6e 732c 206e 5f64 7269  n_neurons, n_dri
+00010f40: 6674 2c20 6e5f 6a69 7474 6572 732c 206e  ft, n_jitters, n
+00010f50: 5f63 6861 6e6e 656c 732c 206e 5f73 616d  _channels, n_sam
+00010f60: 706c 6573 2920 6966 2064 7269 6674 696e  ples) if driftin
+00010f70: 670a 2020 2020 2222 220a 2020 2020 2320  g.    """.    # 
+00010f80: 6372 6561 7465 2070 6164 6465 6420 7465  create padded te
+00010f90: 6d70 6c61 7465 730a 2020 2020 6966 206e  mplates.    if n
+00010fa0: 6f74 2064 7269 6674 696e 673a 0a20 2020  ot drifting:.   
+00010fb0: 2020 2020 2069 6620 746d 705f 6669 6c65       if tmp_file
+00010fc0: 2069 7320 6e6f 7420 4e6f 6e65 3a0a 2020   is not None:.  
+00010fd0: 2020 2020 2020 2020 2020 7465 6d70 6c61            templa
+00010fe0: 7465 735f 6a69 7474 6572 203d 206e 702e  tes_jitter = np.
+00010ff0: 6d65 6d6d 6170 280a 2020 2020 2020 2020  memmap(.        
+00011000: 2020 2020 2020 2020 746d 705f 6669 6c65          tmp_file
+00011010: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00011020: 2020 7368 6170 653d 2874 656d 706c 6174    shape=(templat
+00011030: 6573 2e73 6861 7065 5b30 5d2c 206e 5f6a  es.shape[0], n_j
+00011040: 6974 7465 7273 2c20 7465 6d70 6c61 7465  itters, template
+00011050: 732e 7368 6170 655b 315d 2c20 7465 6d70  s.shape[1], temp
+00011060: 6c61 7465 732e 7368 6170 655b 325d 292c  lates.shape[2]),
+00011070: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00011080: 2064 7479 7065 3d64 7479 7065 2c0a 2020   dtype=dtype,.  
+00011090: 2020 2020 2020 2020 2020 2020 2020 6d6f                mo
+000110a0: 6465 3d22 772b 222c 0a20 2020 2020 2020  de="w+",.       
+000110b0: 2020 2020 2029 0a20 2020 2020 2020 2065       ).        e
+000110c0: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+000110d0: 2074 656d 706c 6174 6573 5f6a 6974 7465   templates_jitte
+000110e0: 7220 3d20 6e70 2e7a 6572 6f73 2828 7465  r = np.zeros((te
+000110f0: 6d70 6c61 7465 732e 7368 6170 655b 305d  mplates.shape[0]
+00011100: 2c20 6e5f 6a69 7474 6572 732c 2074 656d  , n_jitters, tem
+00011110: 706c 6174 6573 2e73 6861 7065 5b31 5d2c  plates.shape[1],
+00011120: 2074 656d 706c 6174 6573 2e73 6861 7065   templates.shape
+00011130: 5b32 5d29 290a 2020 2020 656c 7365 3a0a  [2])).    else:.
+00011140: 2020 2020 2020 2020 6966 2074 6d70 5f66          if tmp_f
+00011150: 696c 6520 6973 206e 6f74 204e 6f6e 653a  ile is not None:
+00011160: 0a20 2020 2020 2020 2020 2020 2074 656d  .            tem
+00011170: 706c 6174 6573 5f6a 6974 7465 7220 3d20  plates_jitter = 
+00011180: 6e70 2e6d 656d 6d61 7028 0a20 2020 2020  np.memmap(.     
+00011190: 2020 2020 2020 2020 2020 2074 6d70 5f66             tmp_f
+000111a0: 696c 652c 0a20 2020 2020 2020 2020 2020  ile,.           
+000111b0: 2020 2020 2073 6861 7065 3d28 7465 6d70       shape=(temp
+000111c0: 6c61 7465 732e 7368 6170 655b 305d 2c20  lates.shape[0], 
+000111d0: 7465 6d70 6c61 7465 732e 7368 6170 655b  templates.shape[
+000111e0: 315d 2c20 6e5f 6a69 7474 6572 732c 2074  1], n_jitters, t
+000111f0: 656d 706c 6174 6573 2e73 6861 7065 5b32  emplates.shape[2
+00011200: 5d2c 2074 656d 706c 6174 6573 2e73 6861  ], templates.sha
+00011210: 7065 5b33 5d29 2c0a 2020 2020 2020 2020  pe[3]),.        
+00011220: 2020 2020 2020 2020 6474 7970 653d 6474          dtype=dt
+00011230: 7970 652c 0a20 2020 2020 2020 2020 2020  ype,.           
+00011240: 2020 2020 206d 6f64 653d 2277 2b22 2c0a       mode="w+",.
+00011250: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
+00011260: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+00011270: 2020 2020 2020 2020 7465 6d70 6c61 7465          template
+00011280: 735f 6a69 7474 6572 203d 206e 702e 7a65  s_jitter = np.ze
+00011290: 726f 7328 0a20 2020 2020 2020 2020 2020  ros(.           
+000112a0: 2020 2020 2028 7465 6d70 6c61 7465 732e       (templates.
+000112b0: 7368 6170 655b 305d 2c20 7465 6d70 6c61  shape[0], templa
+000112c0: 7465 732e 7368 6170 655b 315d 2c20 6e5f  tes.shape[1], n_
+000112d0: 6a69 7474 6572 732c 2074 656d 706c 6174  jitters, templat
+000112e0: 6573 2e73 6861 7065 5b32 5d2c 2074 656d  es.shape[2], tem
+000112f0: 706c 6174 6573 2e73 6861 7065 5b33 5d29  plates.shape[3])
+00011300: 0a20 2020 2020 2020 2020 2020 2029 0a20  .            ). 
+00011310: 2020 2069 6620 7061 7261 6c6c 656c 3a0a     if parallel:.
+00011320: 2020 2020 2020 2020 6173 7365 7274 2074          assert t
+00011330: 6d70 5f66 696c 6520 6973 206e 6f74 204e  mp_file is not N
+00011340: 6f6e 650a 2020 2020 2020 2020 6966 206e  one.        if n
+00011350: 5f6a 6f62 7320 6973 204e 6f6e 653a 0a20  _jobs is None:. 
+00011360: 2020 2020 2020 2020 2020 206e 5f6a 6f62             n_job
+00011370: 7320 3d20 6f73 2e63 7075 5f63 6f75 6e74  s = os.cpu_count
+00011380: 2829 202f 2f20 320a 0a20 2020 2020 2020  () // 2..       
+00011390: 2069 6620 7665 7262 6f73 653a 0a20 2020   if verbose:.   
+000113a0: 2020 2020 2020 2020 2070 7269 6e74 2822           print("
+000113b0: 4a69 7474 6572 696e 6720 7769 7468 222c  Jittering with",
+000113c0: 206e 5f6a 6f62 732c 2022 6a6f 6273 2229   n_jobs, "jobs")
+000113d0: 0a0a 2020 2020 2020 2020 6f75 7470 7574  ..        output
+000113e0: 5f6c 6973 7420 3d20 5061 7261 6c6c 656c  _list = Parallel
+000113f0: 286e 5f6a 6f62 733d 6e5f 6a6f 6273 2928  (n_jobs=n_jobs)(
+00011400: 0a20 2020 2020 2020 2020 2020 2064 656c  .            del
+00011410: 6179 6564 285f 6a69 7474 6572 5f70 6172  ayed(_jitter_par
+00011420: 616c 6c65 6c29 2869 2c20 7465 6d2c 2075  allel)(i, tem, u
+00011430: 7073 616d 706c 652c 2066 732c 206e 5f6a  psample, fs, n_j
+00011440: 6974 7465 7273 2c20 6a69 7474 6572 2c20  itters, jitter, 
+00011450: 6472 6966 7469 6e67 2c20 7665 7262 6f73  drifting, verbos
+00011460: 652c 2074 656d 706c 6174 6573 5f6a 6974  e, templates_jit
+00011470: 7465 7229 0a20 2020 2020 2020 2020 2020  ter).           
+00011480: 2066 6f72 2069 2c20 7465 6d20 696e 2065   for i, tem in e
+00011490: 6e75 6d65 7261 7465 2874 656d 706c 6174  numerate(templat
+000114a0: 6573 290a 2020 2020 2020 2020 290a 2020  es).        ).  
+000114b0: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+000114c0: 666f 7220 692c 2074 656d 2069 6e20 656e  for i, tem in en
+000114d0: 756d 6572 6174 6528 7465 6d70 6c61 7465  umerate(template
+000114e0: 7329 3a0a 2020 2020 2020 2020 2020 2020  s):.            
+000114f0: 7465 6d70 6c61 7465 735f 6a69 7474 6572  templates_jitter
+00011500: 5b69 5d20 3d20 5f6a 6974 7465 725f 7061  [i] = _jitter_pa
+00011510: 7261 6c6c 656c 2869 2c20 7465 6d2c 2075  rallel(i, tem, u
+00011520: 7073 616d 706c 652c 2066 732c 206e 5f6a  psample, fs, n_j
+00011530: 6974 7465 7273 2c20 6a69 7474 6572 2c20  itters, jitter, 
+00011540: 6472 6966 7469 6e67 2c20 7665 7262 6f73  drifting, verbos
+00011550: 652c 204e 6f6e 6529 0a0a 2020 2020 7265  e, None)..    re
+00011560: 7475 726e 2074 656d 706c 6174 6573 5f6a  turn templates_j
+00011570: 6974 7465 720a 0a0a 6465 6620 6375 6269  itter...def cubi
+00011580: 635f 7061 6464 696e 6728 7465 6d70 6c61  c_padding(templa
+00011590: 7465 2c20 7061 645f 7361 6d70 6c65 7329  te, pad_samples)
+000115a0: 3a0a 2020 2020 2222 220a 2020 2020 4375  :.    """.    Cu
+000115b0: 6269 6320 7370 6c69 6e65 2070 6164 6469  bic spline paddi
+000115c0: 6e67 206f 6e20 6c65 6674 2061 6e64 2072  ng on left and r
+000115d0: 6967 6874 2073 6964 6520 746f 2030 2e20  ight side to 0. 
+000115e0: 5468 6520 696e 6974 6961 6c20 6f66 6673  The initial offs
+000115f0: 6574 206f 6620 7468 6520 7465 6d70 6c61  et of the templa
+00011600: 7465 7320 6973 2061 6c73 6f20 7265 6d6f  tes is also remo
+00011610: 7665 642e 0a0a 2020 2020 5061 7261 6d65  ved...    Parame
+00011620: 7465 7273 0a20 2020 202d 2d2d 2d2d 2d2d  ters.    -------
+00011630: 2d2d 2d0a 2020 2020 7465 6d70 6c61 7465  ---.    template
+00011640: 203a 206e 702e 6172 7261 790a 2020 2020   : np.array.    
+00011650: 2020 2020 5465 6d70 6c61 7465 7320 746f      Templates to
+00011660: 2062 6520 7061 6464 6564 2028 6e5f 656c   be padded (n_el
+00011670: 6563 2c20 6e5f 7361 6d70 6c65 7329 0a20  ec, n_samples). 
+00011680: 2020 2070 6164 5f73 616d 706c 6573 203a     pad_samples :
+00011690: 206c 6973 740a 2020 2020 2020 2020 5061   list.        Pa
+000116a0: 6464 696e 6720 7361 6d70 6c65 7320 6265  dding samples be
+000116b0: 666f 7265 2061 6e64 2061 6674 6572 2074  fore and after t
+000116c0: 6865 2074 656d 706c 6174 650a 0a20 2020  he template..   
+000116d0: 2052 6574 7572 6e73 0a20 2020 202d 2d2d   Returns.    ---
+000116e0: 2d2d 2d2d 0a20 2020 2070 6164 6465 645f  ----.    padded_
+000116f0: 7465 6d70 6c61 7465 203a 206e 702e 6172  template : np.ar
+00011700: 7261 790a 2020 2020 2020 2020 5061 6464  ray.        Padd
+00011710: 6564 2074 656d 706c 6174 650a 0a20 2020  ed template..   
+00011720: 2022 2222 0a20 2020 2069 6d70 6f72 7420   """.    import 
+00011730: 7363 6970 792e 696e 7465 7270 6f6c 6174  scipy.interpolat
+00011740: 6520 6173 2069 6e74 6572 700a 0a20 2020  e as interp..   
+00011750: 206e 5f70 7265 203d 2070 6164 5f73 616d   n_pre = pad_sam
+00011760: 706c 6573 5b30 5d0a 2020 2020 6e5f 706f  ples[0].    n_po
+00011770: 7374 203d 2070 6164 5f73 616d 706c 6573  st = pad_samples
+00011780: 5b31 5d0a 0a20 2020 2070 6164 6465 645f  [1]..    padded_
+00011790: 7465 6d70 6c61 7465 203d 206e 702e 7a65  template = np.ze
+000117a0: 726f 7328 2874 656d 706c 6174 652e 7368  ros((template.sh
+000117b0: 6170 655b 305d 2c20 696e 7428 6e5f 7072  ape[0], int(n_pr
+000117c0: 6529 202b 2074 656d 706c 6174 652e 7368  e) + template.sh
+000117d0: 6170 655b 315d 202b 206e 5f70 6f73 7429  ape[1] + n_post)
+000117e0: 290a 2020 2020 7370 6c69 6e65 7320 3d20  ).    splines = 
+000117f0: 6e70 2e7a 6572 6f73 2828 7465 6d70 6c61  np.zeros((templa
+00011800: 7465 2e73 6861 7065 5b30 5d2c 2069 6e74  te.shape[0], int
+00011810: 286e 5f70 7265 2920 2b20 7465 6d70 6c61  (n_pre) + templa
+00011820: 7465 2e73 6861 7065 5b31 5d20 2b20 6e5f  te.shape[1] + n_
+00011830: 706f 7374 2929 0a0a 2020 2020 666f 7220  post))..    for 
+00011840: 692c 2073 7020 696e 2065 6e75 6d65 7261  i, sp in enumera
+00011850: 7465 2874 656d 706c 6174 6529 3a0a 2020  te(template):.  
+00011860: 2020 2020 2020 2320 5265 6d6f 7665 2069        # Remove i
+00011870: 6e69 7461 6c20 6f66 6673 6574 0a20 2020  nital offset.   
+00011880: 2020 2020 2073 705f 636f 7079 203d 2064       sp_copy = d
+00011890: 6565 7063 6f70 7928 7370 290a 2020 2020  eepcopy(sp).    
+000118a0: 2020 2020 7061 6464 6564 5f73 7020 3d20      padded_sp = 
+000118b0: 6e70 2e7a 6572 6f73 286e 5f70 7265 202b  np.zeros(n_pre +
+000118c0: 206c 656e 2873 7029 202b 206e 5f70 6f73   len(sp) + n_pos
+000118d0: 7429 0a20 2020 2020 2020 2070 6164 6465  t).        padde
+000118e0: 645f 7420 3d20 6e70 2e61 7261 6e67 6528  d_t = np.arange(
+000118f0: 6c65 6e28 7061 6464 6564 5f73 7029 290a  len(padded_sp)).
+00011900: 2020 2020 2020 2020 696e 6974 6961 6c5f          initial_
+00011910: 6f66 6673 6574 203d 206e 702e 6d65 616e  offset = np.mean
+00011920: 2873 705b 305d 290a 2020 2020 2020 2020  (sp[0]).        
+00011930: 7370 5f63 6f70 7920 2d3d 2069 6e69 7469  sp_copy -= initi
+00011940: 616c 5f6f 6666 7365 740a 0a20 2020 2020  al_offset..     
+00011950: 2020 2078 5f70 7265 203d 2066 6c6f 6174     x_pre = float
+00011960: 286e 5f70 7265 290a 2020 2020 2020 2020  (n_pre).        
+00011970: 785f 7072 655f 7061 6420 3d20 6e70 2e61  x_pre_pad = np.a
+00011980: 7261 6e67 6528 6e5f 7072 6529 0a20 2020  range(n_pre).   
+00011990: 2020 2020 2078 5f70 6f73 7420 3d20 666c       x_post = fl
+000119a0: 6f61 7428 6e5f 706f 7374 290a 2020 2020  oat(n_post).    
+000119b0: 2020 2020 785f 706f 7374 5f70 6164 203d      x_post_pad =
+000119c0: 206e 702e 6172 616e 6765 286e 5f70 6f73   np.arange(n_pos
+000119d0: 7429 5b3a 3a2d 315d 0a0a 2020 2020 2020  t)[::-1]..      
+000119e0: 2020 2320 6669 6c6c 2070 7265 2061 6e64    # fill pre and
+000119f0: 2070 6f73 7420 696e 7465 7276 616c 7320   post intervals 
+00011a00: 7769 7468 206c 696e 6561 7220 7661 6c75  with linear valu
+00011a10: 6573 2066 726f 6d20 7370 5b30 5d20 2d20  es from sp[0] - 
+00011a20: 7370 5b2d 315d 2074 6f20 3020 666f 7220  sp[-1] to 0 for 
+00011a30: 6265 7474 6572 2066 6974 0a20 2020 2020  better fit.     
+00011a40: 2020 206d 5f70 7265 203d 2073 705f 636f     m_pre = sp_co
+00011a50: 7079 5b30 5d20 2f20 785f 7072 650a 2020  py[0] / x_pre.  
+00011a60: 2020 2020 2020 6d5f 706f 7374 203d 2073        m_post = s
+00011a70: 705f 636f 7079 5b2d 315d 202f 2078 5f70  p_copy[-1] / x_p
+00011a80: 6f73 740a 0a20 2020 2020 2020 2070 6164  ost..        pad
+00011a90: 6465 645f 7370 5b3a 6e5f 7072 655d 203d  ded_sp[:n_pre] =
+00011aa0: 206d 5f70 7265 202a 2078 5f70 7265 5f70   m_pre * x_pre_p
+00011ab0: 6164 0a20 2020 2020 2020 2070 6164 6465  ad.        padde
+00011ac0: 645f 7370 5b6e 5f70 7265 3a2d 6e5f 706f  d_sp[n_pre:-n_po
+00011ad0: 7374 5d20 3d20 7370 5f63 6f70 790a 2020  st] = sp_copy.  
+00011ae0: 2020 2020 2020 7061 6464 6564 5f73 705b        padded_sp[
+00011af0: 2d6e 5f70 6f73 743a 5d20 3d20 6d5f 706f  -n_post:] = m_po
+00011b00: 7374 202a 2078 5f70 6f73 745f 7061 640a  st * x_post_pad.
+00011b10: 0a20 2020 2020 2020 2066 203d 2069 6e74  .        f = int
+00011b20: 6572 702e 696e 7465 7270 3164 2870 6164  erp.interp1d(pad
+00011b30: 6465 645f 742c 2070 6164 6465 645f 7370  ded_t, padded_sp
+00011b40: 2c20 6b69 6e64 3d22 6375 6269 6322 290a  , kind="cubic").
+00011b50: 2020 2020 2020 2020 7370 6c69 6e65 735b          splines[
+00011b60: 695d 203d 2066 286e 702e 6172 616e 6765  i] = f(np.arange
+00011b70: 286c 656e 2870 6164 6465 645f 7370 2929  (len(padded_sp))
+00011b80: 290a 0a20 2020 2020 2020 2070 6164 6465  )..        padde
+00011b90: 645f 7465 6d70 6c61 7465 5b69 2c20 3a6e  d_template[i, :n
+00011ba0: 5f70 7265 5d20 3d20 6628 785f 7072 655f  _pre] = f(x_pre_
+00011bb0: 7061 6429 0a20 2020 2020 2020 2070 6164  pad).        pad
+00011bc0: 6465 645f 7465 6d70 6c61 7465 5b69 2c20  ded_template[i, 
+00011bd0: 6e5f 7072 653a 2d6e 5f70 6f73 745d 203d  n_pre:-n_post] =
+00011be0: 2073 705f 636f 7079 0a20 2020 2020 2020   sp_copy.       
+00011bf0: 2070 6164 6465 645f 7465 6d70 6c61 7465   padded_template
+00011c00: 5b69 2c20 2d6e 5f70 6f73 743a 5d20 3d20  [i, -n_post:] = 
+00011c10: 6628 6e70 2e61 7261 6e67 6528 6e5f 7072  f(np.arange(n_pr
+00011c20: 6520 2b20 6c65 6e28 7370 5f63 6f70 7929  e + len(sp_copy)
+00011c30: 2c20 6e5f 7072 6520 2b20 6c65 6e28 7370  , n_pre + len(sp
+00011c40: 5f63 6f70 7929 202b 206e 5f70 6f73 7429  _copy) + n_post)
+00011c50: 290a 0a20 2020 2072 6574 7572 6e20 7061  )..    return pa
+00011c60: 6464 6564 5f74 656d 706c 6174 650a 0a0a  dded_template...
+00011c70: 6465 6620 6669 6e64 5f6f 7665 726c 6170  def find_overlap
+00011c80: 7069 6e67 5f74 656d 706c 6174 6573 2874  ping_templates(t
+00011c90: 656d 706c 6174 6573 2c20 7468 7265 7368  emplates, thresh
+00011ca0: 3d30 2e38 293a 0a20 2020 2022 2222 0a20  =0.8):.    """. 
+00011cb0: 2020 2046 696e 6420 7370 6174 6961 6c6c     Find spatiall
+00011cc0: 7920 6f76 6572 6c61 7070 696e 6720 7465  y overlapping te
+00011cd0: 6d70 6c61 7465 732e 0a0a 2020 2020 5061  mplates...    Pa
+00011ce0: 7261 6d65 7465 7273 0a20 2020 202d 2d2d  rameters.    ---
+00011cf0: 2d2d 2d2d 2d2d 2d0a 2020 2020 7465 6d70  -------.    temp
+00011d00: 6c61 7465 7320 3a20 6e70 2e61 7272 6179  lates : np.array
+00011d10: 0a20 2020 2020 2020 2041 7272 6179 2077  .        Array w
+00011d20: 6974 6820 7465 6d70 6c61 7465 7320 286e  ith templates (n
+00011d30: 5f74 656d 706c 6174 6573 2c20 6e5f 656c  _templates, n_el
+00011d40: 6563 2c20 6e5f 7361 6d70 6c65 7329 0a20  ec, n_samples). 
+00011d50: 2020 2074 6872 6573 6820 3a20 666c 6f61     thresh : floa
+00011d60: 740a 2020 2020 2020 2020 5065 7263 656e  t.        Percen
+00011d70: 7420 7468 7265 7368 6f6c 6420 746f 2063  t threshold to c
+00011d80: 6f6e 7369 6465 7220 7477 6f20 7465 6d70  onsider two temp
+00011d90: 6c61 7465 7320 746f 2062 6520 6f76 6572  lates to be over
+00011da0: 6c61 7070 696e 672e 0a0a 2020 2020 5265  lapping...    Re
+00011db0: 7475 726e 730a 2020 2020 2d2d 2d2d 2d2d  turns.    ------
+00011dc0: 2d0a 2020 2020 6f76 6572 6c61 7070 696e  -.    overlappin
+00011dd0: 675f 7061 6972 7320 3a20 6e70 2e61 7272  g_pairs : np.arr
+00011de0: 6179 0a20 2020 2020 2020 2041 7272 6179  ay.        Array
+00011df0: 2077 6974 6820 6f76 6572 6c61 7070 696e   with overlappin
+00011e00: 6720 7061 6972 7320 286e 5f6f 7665 726c  g pairs (n_overl
+00011e10: 6170 7069 6e67 2c20 3229 0a0a 2020 2020  apping, 2)..    
+00011e20: 2222 220a 2020 2020 6f76 6572 6c61 7070  """.    overlapp
+00011e30: 696e 675f 7061 6972 7320 3d20 5b5d 0a0a  ing_pairs = []..
+00011e40: 2020 2020 666f 7220 692c 2074 656d 705f      for i, temp_
+00011e50: 3120 696e 2065 6e75 6d65 7261 7465 2874  1 in enumerate(t
+00011e60: 656d 706c 6174 6573 293a 0a20 2020 2020  emplates):.     
+00011e70: 2020 2069 6620 6c65 6e28 7465 6d70 6c61     if len(templa
+00011e80: 7465 732e 7368 6170 6529 203d 3d20 343a  tes.shape) == 4:
+00011e90: 2020 2320 6a69 7474 6572 0a20 2020 2020    # jitter.     
+00011ea0: 2020 2020 2020 2074 656d 705f 3120 3d20         temp_1 = 
+00011eb0: 7465 6d70 5f31 5b30 5d0a 0a20 2020 2020  temp_1[0]..     
+00011ec0: 2020 2070 6561 6b5f 656c 6563 7472 6f64     peak_electrod
+00011ed0: 655f 6964 7820 3d20 6e70 2e75 6e72 6176  e_idx = np.unrav
+00011ee0: 656c 5f69 6e64 6578 2874 656d 705f 312e  el_index(temp_1.
+00011ef0: 6172 676d 696e 2829 2c20 7465 6d70 5f31  argmin(), temp_1
+00011f00: 2e73 6861 7065 290a 0a20 2020 2020 2020  .shape)..       
+00011f10: 2066 6f72 206a 2c20 7465 6d70 5f32 2069   for j, temp_2 i
+00011f20: 6e20 656e 756d 6572 6174 6528 7465 6d70  n enumerate(temp
+00011f30: 6c61 7465 7329 3a0a 2020 2020 2020 2020  lates):.        
+00011f40: 2020 2020 6966 206c 656e 2874 656d 706c      if len(templ
+00011f50: 6174 6573 2e73 6861 7065 2920 3d3d 2034  ates.shape) == 4
+00011f60: 3a20 2023 206a 6974 7465 720a 2020 2020  :  # jitter.    
+00011f70: 2020 2020 2020 2020 2020 2020 7465 6d70              temp
+00011f80: 5f32 203d 2074 656d 705f 325b 305d 0a0a  _2 = temp_2[0]..
+00011f90: 2020 2020 2020 2020 2020 2020 6966 2069              if i
+00011fa0: 2021 3d20 6a3a 0a20 2020 2020 2020 2020   != j:.         
+00011fb0: 2020 2020 2020 2069 6620 6172 655f 7465         if are_te
+00011fc0: 6d70 6c61 7465 735f 6f76 6572 6c61 7070  mplates_overlapp
+00011fd0: 696e 6728 5b74 656d 705f 312c 2074 656d  ing([temp_1, tem
+00011fe0: 705f 325d 2c20 7468 7265 7368 293a 0a20  p_2], thresh):. 
+00011ff0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012000: 2020 2069 6620 5b69 2c20 6a5d 206e 6f74     if [i, j] not
+00012010: 2069 6e20 6f76 6572 6c61 7070 696e 675f   in overlapping_
+00012020: 7061 6972 7320 616e 6420 5b6a 2c20 695d  pairs and [j, i]
+00012030: 206e 6f74 2069 6e20 6f76 6572 6c61 7070   not in overlapp
+00012040: 696e 675f 7061 6972 733a 0a20 2020 2020  ing_pairs:.     
+00012050: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012060: 2020 206f 7665 726c 6170 7069 6e67 5f70     overlapping_p
+00012070: 6169 7273 2e61 7070 656e 6428 736f 7274  airs.append(sort
+00012080: 6564 285b 692c 206a 5d29 290a 0a20 2020  ed([i, j]))..   
+00012090: 2072 6574 7572 6e20 6e70 2e61 7272 6179   return np.array
+000120a0: 286f 7665 726c 6170 7069 6e67 5f70 6169  (overlapping_pai
+000120b0: 7273 290a 0a0a 6465 6620 6172 655f 7465  rs)...def are_te
+000120c0: 6d70 6c61 7465 735f 6f76 6572 6c61 7070  mplates_overlapp
+000120d0: 696e 6728 7465 6d70 6c61 7465 732c 2074  ing(templates, t
+000120e0: 6872 6573 6829 3a0a 2020 2020 2222 220a  hresh):.    """.
+000120f0: 2020 2020 5265 7475 726e 7320 7472 7565      Returns true
+00012100: 2069 6620 7465 6d70 6c61 7465 7320 6172   if templates ar
+00012110: 6520 7370 6174 6961 6c6c 7920 6f76 6572  e spatially over
+00012120: 6c61 7070 696e 670a 0a20 2020 2050 6172  lapping..    Par
+00012130: 616d 6574 6572 730a 2020 2020 2d2d 2d2d  ameters.    ----
+00012140: 2d2d 2d2d 2d2d 0a20 2020 2074 656d 706c  ------.    templ
+00012150: 6174 6573 203a 206e 702e 6172 7261 790a  ates : np.array.
+00012160: 2020 2020 2020 2020 4172 7261 7920 7769          Array wi
+00012170: 7468 2032 2074 656d 706c 6174 6573 2028  th 2 templates (
+00012180: 322c 206e 5f65 6c65 632c 206e 5f73 616d  2, n_elec, n_sam
+00012190: 706c 6573 290a 2020 2020 7468 7265 7368  ples).    thresh
+000121a0: 203a 2066 6c6f 6174 0a20 2020 2020 2020   : float.       
+000121b0: 204f 7665 726c 6170 7069 6e67 2074 6872   Overlapping thr
+000121c0: 6573 686f 6c64 2028 5b30 202d 2031 5d29  eshold ([0 - 1])
+000121d0: 0a0a 2020 2020 5265 7475 726e 730a 2020  ..    Returns.  
+000121e0: 2020 2d2d 2d2d 2d2d 2d0a 2020 2020 6f76    -------.    ov
+000121f0: 6572 6c61 6220 3a20 626f 6f6c 0a20 2020  erlab : bool.   
+00012200: 2020 2020 2057 6865 7468 6572 2074 6865       Whether the
+00012210: 2074 656d 706c 6174 6573 2061 7265 2073   templates are s
+00012220: 7061 7469 616c 6c79 206f 7665 726c 6170  patially overlap
+00012230: 7069 6e67 206f 7220 6e6f 740a 2020 2020  ping or not.    
+00012240: 2222 220a 2020 2020 6173 7365 7274 206c  """.    assert l
+00012250: 656e 2874 656d 706c 6174 6573 2920 3d3d  en(templates) ==
+00012260: 2032 0a20 2020 2074 656d 705f 3120 3d20   2.    temp_1 = 
+00012270: 7465 6d70 6c61 7465 735b 305d 0a20 2020  templates[0].   
+00012280: 2074 656d 705f 3220 3d20 7465 6d70 6c61   temp_2 = templa
+00012290: 7465 735b 315d 0a20 2020 2070 6561 6b5f  tes[1].    peak_
+000122a0: 656c 6563 7472 6f64 655f 6964 7820 3d20  electrode_idx = 
+000122b0: 6e70 2e75 6e72 6176 656c 5f69 6e64 6578  np.unravel_index
+000122c0: 2874 656d 705f 312e 6172 676d 696e 2829  (temp_1.argmin()
+000122d0: 2c20 7465 6d70 5f31 2e73 6861 7065 290a  , temp_1.shape).
+000122e0: 2020 2020 7065 616b 5f32 5f6f 6e5f 6d61      peak_2_on_ma
+000122f0: 7820 3d20 6e70 2e61 6273 286e 702e 6d69  x = np.abs(np.mi
+00012300: 6e28 7465 6d70 5f32 5b70 6561 6b5f 656c  n(temp_2[peak_el
+00012310: 6563 7472 6f64 655f 6964 785d 2929 0a20  ectrode_idx])). 
+00012320: 2020 2070 6561 6b5f 3220 3d20 6e70 2e61     peak_2 = np.a
+00012330: 6273 286e 702e 6d69 6e28 7465 6d70 5f32  bs(np.min(temp_2
+00012340: 2929 0a0a 2020 2020 6966 2070 6561 6b5f  ))..    if peak_
+00012350: 325f 6f6e 5f6d 6178 203e 2074 6872 6573  2_on_max > thres
+00012360: 6820 2a20 7065 616b 5f32 3a0a 2020 2020  h * peak_2:.    
+00012370: 2020 2020 7265 7475 726e 2054 7275 650a      return True.
+00012380: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+00012390: 2020 7265 7475 726e 2046 616c 7365 0a0a    return False..
+000123a0: 0a23 2323 2053 5049 4b45 5452 4149 4e20  .### SPIKETRAIN 
+000123b0: 4f50 4552 4154 494f 4e53 2023 2323 0a64  OPERATIONS ###.d
+000123c0: 6566 2061 6e6e 6f74 6174 655f 6f76 6572  ef annotate_over
+000123d0: 6c61 7070 696e 675f 7370 696b 6573 2873  lapping_spikes(s
+000123e0: 7069 6b65 7472 6169 6e73 2c20 745f 6a69  piketrains, t_ji
+000123f0: 7474 3d31 202a 2070 712e 6d73 2c20 6f76  tt=1 * pq.ms, ov
+00012400: 6572 6c61 7070 696e 675f 7061 6972 733d  erlapping_pairs=
+00012410: 4e6f 6e65 2c20 7061 7261 6c6c 656c 3d54  None, parallel=T
+00012420: 7275 652c 2076 6572 626f 7365 3d54 7275  rue, verbose=Tru
+00012430: 6529 3a0a 2020 2020 2222 220a 2020 2020  e):.    """.    
+00012440: 416e 6e6f 7461 7465 2073 7069 6b65 2074  Annotate spike t
+00012450: 7261 696e 7320 7769 7468 2074 656d 706f  rains with tempo
+00012460: 7261 6c20 616e 6420 7370 6174 696f 2d74  ral and spatio-t
+00012470: 656d 706f 7261 6c20 6f76 6572 6c61 7070  emporal overlapp
+00012480: 696e 6720 6c61 6265 6c73 2e0a 2020 2020  ing labels..    
+00012490: 4e4f 202d 204e 6f6e 206f 7665 726c 6170  NO - Non overlap
+000124a0: 0a20 2020 2054 4f20 2d20 5465 6d70 6f72  .    TO - Tempor
+000124b0: 616c 206f 7665 726c 6170 0a20 2020 2053  al overlap.    S
+000124c0: 4f20 2d20 5370 6174 696f 2d74 656d 706f  O - Spatio-tempo
+000124d0: 7261 6c20 6f76 6572 6c61 700a 0a20 2020  ral overlap..   
+000124e0: 2050 6172 616d 6574 6572 730a 2020 2020   Parameters.    
+000124f0: 2d2d 2d2d 2d2d 2d2d 2d2d 0a20 2020 2073  ----------.    s
+00012500: 7069 6b65 7472 6169 6e73 203a 206c 6973  piketrains : lis
+00012510: 740a 2020 2020 2020 2020 4c69 7374 206f  t.        List o
+00012520: 6620 6e65 6f20 7370 696b 6520 7472 6169  f neo spike trai
+00012530: 6e73 2074 6f20 6265 2061 6e6e 6f74 6174  ns to be annotat
+00012540: 6564 0a20 2020 2074 5f6a 6974 7420 3a20  ed.    t_jitt : 
+00012550: 5175 616e 7469 7479 0a20 2020 2020 2020  Quantity.       
+00012560: 2054 696d 6520 6a69 7474 6572 2074 6f20   Time jitter to 
+00012570: 636f 6e73 6964 6572 206f 7665 726c 6170  consider overlap
+00012580: 7069 6e67 2073 7069 6b65 7320 696e 2074  ping spikes in t
+00012590: 696d 6520 2864 6566 6175 6c74 2031 206d  ime (default 1 m
+000125a0: 7329 0a20 2020 206f 7665 726c 6170 7069  s).    overlappi
+000125b0: 6e67 5f70 6169 7273 203a 206e 702e 6172  ng_pairs : np.ar
+000125c0: 7261 790a 2020 2020 2020 2020 4172 7261  ray.        Arra
+000125d0: 7920 7769 7468 206f 7665 726c 6170 7069  y with overlappi
+000125e0: 6e67 2069 6e66 6f72 6d61 7469 6f6e 2062  ng information b
+000125f0: 6574 7765 656e 2073 7069 6b65 2074 7261  etween spike tra
+00012600: 696e 7320 286e 5f73 7069 6b65 7472 6169  ins (n_spiketrai
+00012610: 6e73 2c20 3229 0a20 2020 2070 6172 616c  ns, 2).    paral
+00012620: 6c65 6c20 3a20 626f 6f6c 0a20 2020 2020  lel : bool.     
+00012630: 2020 2049 6620 5472 7565 2073 7069 6b65     If True spike
+00012640: 2074 7261 696e 7320 6172 6520 7072 6f63   trains are proc
+00012650: 6573 7365 6420 696e 2070 6172 616c 6c65  essed in paralle
+00012660: 6c20 7769 7468 206d 756c 7469 7072 6f63  l with multiproc
+00012670: 6573 7369 6e67 0a20 2020 2076 6572 626f  essing.    verbo
+00012680: 7365 203a 2062 6f6f 6c0a 2020 2020 2020  se : bool.      
+00012690: 2020 4966 2054 7275 6520 6f75 7470 7574    If True output
+000126a0: 2069 7320 7665 7262 6f73 650a 0a20 2020   is verbose..   
+000126b0: 2022 2222 0a20 2020 2069 6620 7061 7261   """.    if para
+000126c0: 6c6c 656c 3a0a 2020 2020 2020 2020 696d  llel:.        im
+000126d0: 706f 7274 206d 756c 7469 7072 6f63 6573  port multiproces
+000126e0: 7369 6e67 0a0a 2020 2020 2020 2020 7468  sing..        th
+000126f0: 7265 6164 7320 3d20 5b5d 0a20 2020 2020  reads = [].     
+00012700: 2020 206d 616e 6167 6572 203d 206d 756c     manager = mul
+00012710: 7469 7072 6f63 6573 7369 6e67 2e4d 616e  tiprocessing.Man
+00012720: 6167 6572 2829 0a20 2020 2020 2020 2072  ager().        r
+00012730: 6574 7572 6e5f 7370 696b 6574 7261 696e  eturn_spiketrain
+00012740: 7320 3d20 6d61 6e61 6765 722e 6469 6374  s = manager.dict
+00012750: 2829 0a20 2020 2020 2020 2066 6f72 2069  ().        for i
+00012760: 2c20 7374 5f69 2069 6e20 656e 756d 6572  , st_i in enumer
+00012770: 6174 6528 7370 696b 6574 7261 696e 7329  ate(spiketrains)
+00012780: 3a0a 2020 2020 2020 2020 2020 2020 7020  :.            p 
+00012790: 3d20 6d75 6c74 6970 726f 6365 7373 696e  = multiprocessin
+000127a0: 672e 5072 6f63 6573 7328 0a20 2020 2020  g.Process(.     
+000127b0: 2020 2020 2020 2020 2020 2074 6172 6765             targe
+000127c0: 743d 616e 6e6f 7461 7465 5f70 6172 616c  t=annotate_paral
+000127d0: 6c65 6c2c 0a20 2020 2020 2020 2020 2020  lel,.           
+000127e0: 2020 2020 2061 7267 733d 280a 2020 2020       args=(.    
 000127f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012800: 2020 2020 2020 2020 6964 5f6f 7665 7220          id_over 
-00012810: 3d20 6e70 2e77 6865 7265 2828 7374 5f6a  = np.where((st_j
-00012820: 203e 2074 5f69 202d 2074 5f6a 6974 7429   > t_i - t_jitt)
-00012830: 2026 2028 7374 5f6a 203c 2074 5f69 202b   & (st_j < t_i +
-00012840: 2074 5f6a 6974 7429 295b 305d 0a20 2020   t_jitt))[0].   
-00012850: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012860: 2020 2020 2069 6620 6e6f 7420 6e70 2e61       if not np.a
-00012870: 6e79 286f 7665 726c 6170 7069 6e67 5f70  ny(overlapping_p
-00012880: 6169 7273 293a 0a20 2020 2020 2020 2020  airs):.         
-00012890: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000128a0: 2020 2069 6620 6c65 6e28 6964 5f6f 7665     if len(id_ove
-000128b0: 7229 2021 3d20 303a 0a20 2020 2020 2020  r) != 0:.       
-000128c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000128d0: 2020 2020 2020 2020 206f 7665 725b 695f           over[i_
-000128e0: 7370 5d20 3d20 2754 4f27 0a20 2020 2020  sp] = 'TO'.     
-000128f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012900: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-00012910: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012920: 2020 2020 2070 6169 7220 3d20 5b69 2c20       pair = [i, 
-00012930: 6a5d 0a20 2020 2020 2020 2020 2020 2020  j].             
-00012940: 2020 2020 2020 2020 2020 2020 2020 2070                 p
-00012950: 6169 725f 6920 3d20 5b6a 2c20 695d 0a20  air_i = [j, i]. 
-00012960: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012970: 2020 2020 2020 2020 2020 2069 6620 6e70             if np
-00012980: 2e61 6e79 285b 6e70 2e61 6c6c 2870 6169  .any([np.all(pai
-00012990: 7220 3d3d 2070 2920 666f 7220 7020 696e  r == p) for p in
-000129a0: 206f 7665 726c 6170 7069 6e67 5f70 6169   overlapping_pai
-000129b0: 7273 5d29 206f 7220 5c0a 2020 2020 2020  rs]) or \.      
-000129c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000129d0: 2020 2020 2020 2020 2020 2020 2020 6e70                np
-000129e0: 2e61 6e79 285b 6e70 2e61 6c6c 2870 6169  .any([np.all(pai
-000129f0: 725f 6920 3d3d 2070 2920 666f 7220 7020  r_i == p) for p 
-00012a00: 696e 206f 7665 726c 6170 7069 6e67 5f70  in overlapping_p
-00012a10: 6169 7273 5d29 3a0a 2020 2020 2020 2020  airs]):.        
-00012a20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012a30: 2020 2020 2020 2020 6966 206c 656e 2869          if len(i
-00012a40: 645f 6f76 6572 2920 213d 2030 3a0a 2020  d_over) != 0:.  
-00012a50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012a60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012a70: 2020 6f76 6572 5b69 5f73 705d 203d 2027    over[i_sp] = '
-00012a80: 5354 4f27 0a20 2020 2020 2020 2020 2020  STO'.           
-00012a90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012aa0: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
-00012ab0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012ac0: 2020 2020 2020 2069 6620 6c65 6e28 6964         if len(id
-00012ad0: 5f6f 7665 7229 2021 3d20 303a 0a20 2020  _over) != 0:.   
-00012ae0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012af0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012b00: 206f 7665 725b 695f 7370 5d20 3d20 2754   over[i_sp] = 'T
-00012b10: 4f27 0a20 2020 2020 2020 2020 2020 206f  O'.            o
-00012b20: 7665 725b 6f76 6572 203d 3d20 274e 4f4e  ver[over == 'NON
-00012b30: 4527 5d20 3d20 274e 4f27 0a20 2020 2020  E'] = 'NO'.     
-00012b40: 2020 2020 2020 2073 745f 692e 616e 6e6f         st_i.anno
-00012b50: 7461 7465 286f 7665 726c 6170 3d6f 7665  tate(overlap=ove
-00012b60: 7229 0a0a 0a64 6566 2061 6e6e 6f74 6174  r)...def annotat
-00012b70: 655f 7061 7261 6c6c 656c 2869 2c20 7374  e_parallel(i, st
-00012b80: 5f69 2c20 7370 696b 6574 7261 696e 732c  _i, spiketrains,
-00012b90: 2074 5f6a 6974 742c 206f 7665 726c 6170   t_jitt, overlap
-00012ba0: 7069 6e67 5f70 6169 7273 2c20 7265 7475  ping_pairs, retu
-00012bb0: 726e 5f73 7069 6b65 7472 6169 6e73 2c20  rn_spiketrains, 
-00012bc0: 7665 7262 6f73 6529 3a0a 2020 2020 2222  verbose):.    ""
-00012bd0: 220a 2020 2020 4865 6c70 6572 2066 756e  ".    Helper fun
-00012be0: 6374 696f 6e20 746f 2061 6e6e 6f74 6174  ction to annotat
-00012bf0: 6520 7370 696b 6520 7472 6169 6e73 2069  e spike trains i
-00012c00: 6e20 7061 7261 6c6c 656c 2e0a 0a20 2020  n parallel...   
-00012c10: 2050 6172 616d 6574 6572 730a 2020 2020   Parameters.    
-00012c20: 2d2d 2d2d 2d2d 2d2d 2d2d 0a20 2020 2069  ----------.    i
-00012c30: 203a 2069 6e74 0a20 2020 2020 2020 2049   : int.        I
-00012c40: 6e64 6578 206f 6620 7370 696b 6520 7472  ndex of spike tr
-00012c50: 6169 6e0a 2020 2020 7374 5f69 203a 206e  ain.    st_i : n
-00012c60: 656f 2e53 7069 6b65 5472 6169 6e0a 2020  eo.SpikeTrain.  
-00012c70: 2020 2020 2020 5370 696b 6520 7472 6169        Spike trai
-00012c80: 6e20 746f 2062 6520 7072 6f63 6573 7365  n to be processe
-00012c90: 640a 2020 2020 7370 696b 6574 7261 696e  d.    spiketrain
-00012ca0: 7320 3a20 6c69 7374 0a20 2020 2020 2020  s : list.       
-00012cb0: 204c 6973 7420 6f66 206e 656f 2073 7069   List of neo spi
-00012cc0: 6b65 7472 6169 6e73 0a20 2020 2074 5f6a  ketrains.    t_j
-00012cd0: 6974 7420 3a20 5175 616e 7469 7479 0a20  itt : Quantity. 
-00012ce0: 2020 2020 2020 2054 696d 6520 6a69 7474         Time jitt
-00012cf0: 6572 2074 6f20 636f 6e73 6964 6572 206f  er to consider o
-00012d00: 7665 726c 6170 7069 6e67 2073 7069 6b65  verlapping spike
-00012d10: 7320 696e 2074 696d 6520 2864 6566 6175  s in time (defau
-00012d20: 6c74 2031 206d 7329 0a20 2020 206f 7665  lt 1 ms).    ove
-00012d30: 726c 6170 7069 6e67 5f70 6169 7273 203a  rlapping_pairs :
-00012d40: 206e 702e 6172 7261 790a 2020 2020 2020   np.array.      
-00012d50: 2020 4172 7261 7920 7769 7468 206f 7665    Array with ove
-00012d60: 726c 6170 7069 6e67 2069 6e66 6f72 6d61  rlapping informa
-00012d70: 7469 6f6e 2062 6574 7765 656e 2073 7069  tion between spi
-00012d80: 6b65 2074 7261 696e 7320 286e 5f73 7069  ke trains (n_spi
-00012d90: 6b65 7472 6169 6e73 2c20 3229 0a20 2020  ketrains, 2).   
-00012da0: 2076 6572 626f 7365 203a 2062 6f6f 6c0a   verbose : bool.
-00012db0: 2020 2020 2020 2020 4966 2054 7275 6520          If True 
-00012dc0: 6f75 7470 7574 2069 7320 7665 7262 6f73  output is verbos
-00012dd0: 650a 0a20 2020 2022 2222 0a20 2020 2069  e..    """.    i
-00012de0: 6620 7665 7262 6f73 653a 0a20 2020 2020  f verbose:.     
-00012df0: 2020 2070 7269 6e74 2827 416e 6e6f 7461     print('Annota
-00012e00: 7469 6e67 206f 7665 726c 6170 7069 6e67  ting overlapping
-00012e10: 2073 7069 6b65 2074 7261 696e 2027 2c20   spike train ', 
-00012e20: 6929 0a20 2020 206f 7665 7220 3d20 6e70  i).    over = np
-00012e30: 2e61 7272 6179 285b 274e 4f4e 4527 5d20  .array(['NONE'] 
-00012e40: 2a20 6c65 6e28 7374 5f69 2929 0a20 2020  * len(st_i)).   
-00012e50: 2066 6f72 2069 5f73 702c 2074 5f69 2069   for i_sp, t_i i
-00012e60: 6e20 656e 756d 6572 6174 6528 7374 5f69  n enumerate(st_i
-00012e70: 293a 0a20 2020 2020 2020 2066 6f72 206a  ):.        for j
-00012e80: 2c20 7374 5f6a 2069 6e20 656e 756d 6572  , st_j in enumer
-00012e90: 6174 6528 7370 696b 6574 7261 696e 7329  ate(spiketrains)
-00012ea0: 3a0a 2020 2020 2020 2020 2020 2020 6966  :.            if
-00012eb0: 2069 2021 3d20 6a3a 0a20 2020 2020 2020   i != j:.       
-00012ec0: 2020 2020 2020 2020 2023 2066 696e 6420           # find 
-00012ed0: 6f76 6572 6c61 7070 696e 670a 2020 2020  overlapping.    
-00012ee0: 2020 2020 2020 2020 2020 2020 6964 5f6f              id_o
-00012ef0: 7665 7220 3d20 6e70 2e77 6865 7265 2828  ver = np.where((
-00012f00: 7374 5f6a 203e 2074 5f69 202d 2074 5f6a  st_j > t_i - t_j
-00012f10: 6974 7429 2026 2028 7374 5f6a 203c 2074  itt) & (st_j < t
-00012f20: 5f69 202b 2074 5f6a 6974 7429 295b 305d  _i + t_jitt))[0]
-00012f30: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00012f40: 2069 6620 6e6f 7420 6e70 2e61 6e79 286f   if not np.any(o
-00012f50: 7665 726c 6170 7069 6e67 5f70 6169 7273  verlapping_pairs
-00012f60: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
-00012f70: 2020 2020 2020 2069 6620 6c65 6e28 6964         if len(id
-00012f80: 5f6f 7665 7229 2021 3d20 303a 0a20 2020  _over) != 0:.   
-00012f90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012fa0: 2020 2020 206f 7665 725b 695f 7370 5d20       over[i_sp] 
-00012fb0: 3d20 2754 4f27 0a20 2020 2020 2020 2020  = 'TO'.         
-00012fc0: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-00012fd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012fe0: 2070 6169 7220 3d20 5b69 2c20 6a5d 0a20   pair = [i, j]. 
-00012ff0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013000: 2020 2070 6169 725f 6920 3d20 5b6a 2c20     pair_i = [j, 
-00013010: 695d 0a20 2020 2020 2020 2020 2020 2020  i].             
-00013020: 2020 2020 2020 2069 6620 6e70 2e61 6e79         if np.any
-00013030: 285b 6e70 2e61 6c6c 2870 6169 7220 3d3d  ([np.all(pair ==
-00013040: 2070 2920 666f 7220 7020 696e 206f 7665   p) for p in ove
-00013050: 726c 6170 7069 6e67 5f70 6169 7273 5d29  rlapping_pairs])
-00013060: 206f 7220 5c0a 2020 2020 2020 2020 2020   or \.          
-00013070: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013080: 2020 6e70 2e61 6e79 285b 6e70 2e61 6c6c    np.any([np.all
-00013090: 2870 6169 725f 6920 3d3d 2070 2920 666f  (pair_i == p) fo
-000130a0: 7220 7020 696e 206f 7665 726c 6170 7069  r p in overlappi
-000130b0: 6e67 5f70 6169 7273 5d29 3a0a 2020 2020  ng_pairs]):.    
-000130c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000130d0: 2020 2020 6966 206c 656e 2869 645f 6f76      if len(id_ov
-000130e0: 6572 2920 213d 2030 3a0a 2020 2020 2020  er) != 0:.      
-000130f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013100: 2020 2020 2020 6f76 6572 5b69 5f73 705d        over[i_sp]
-00013110: 203d 2027 5354 4f27 0a20 2020 2020 2020   = 'STO'.       
-00013120: 2020 2020 2020 2020 2020 2020 2065 6c73               els
-00013130: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-00013140: 2020 2020 2020 2020 2020 2069 6620 6c65             if le
-00013150: 6e28 6964 5f6f 7665 7229 2021 3d20 303a  n(id_over) != 0:
-00013160: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00013170: 2020 2020 2020 2020 2020 2020 206f 7665               ove
-00013180: 725b 695f 7370 5d20 3d20 2754 4f27 0a20  r[i_sp] = 'TO'. 
-00013190: 2020 206f 7665 725b 6f76 6572 203d 3d20     over[over == 
-000131a0: 274e 4f4e 4527 5d20 3d20 274e 4f27 0a20  'NONE'] = 'NO'. 
-000131b0: 2020 2073 745f 692e 616e 6e6f 7461 7465     st_i.annotate
-000131c0: 286f 7665 726c 6170 3d6f 7665 7229 0a20  (overlap=over). 
-000131d0: 2020 2072 6574 7572 6e5f 7370 696b 6574     return_spiket
-000131e0: 7261 696e 735b 695d 203d 2073 745f 690a  rains[i] = st_i.
-000131f0: 0a0a 6465 6620 7265 7361 6d70 6c65 5f73  ..def resample_s
-00013200: 7069 6b65 7472 6169 6e73 2873 7069 6b65  piketrains(spike
-00013210: 7472 6169 6e73 2c20 6673 3d4e 6f6e 6529  trains, fs=None)
-00013220: 3a0a 2020 2020 2222 220a 2020 2020 5265  :.    """.    Re
-00013230: 7361 6d70 6c65 7320 7370 696b 6520 7472  samples spike tr
-00013240: 6169 6e73 2e20 5072 6f76 6964 6520 6569  ains. Provide ei
-00013250: 7468 6572 2066 7320 6f72 2054 2070 6172  ther fs or T par
-00013260: 616d 6574 6572 730a 0a20 2020 2050 6172  ameters..    Par
-00013270: 616d 6574 6572 730a 2020 2020 2d2d 2d2d  ameters.    ----
-00013280: 2d2d 2d2d 2d2d 0a20 2020 2073 7069 6b65  ------.    spike
-00013290: 7472 6169 6e73 203a 206c 6973 740a 2020  trains : list.  
-000132a0: 2020 2020 2020 4c69 7374 206f 6620 6e65        List of ne
-000132b0: 6f20 7370 696b 6574 7261 696e 7320 746f  o spiketrains to
-000132c0: 2062 6520 7265 7361 6d70 6c65 640a 2020   be resampled.  
-000132d0: 2020 6673 203a 2051 7561 6e74 6974 790a    fs : Quantity.
-000132e0: 2020 2020 2020 2020 4e65 7720 7361 6d70          New samp
-000132f0: 6c69 6e67 2066 7265 7175 656e 6379 0a0a  ling frequency..
-00013300: 2020 2020 5265 7475 726e 730a 2020 2020      Returns.    
-00013310: 2d2d 2d2d 2d2d 2d0a 2020 2020 7265 7361  -------.    resa
-00013320: 6d70 6c65 645f 6d61 7420 3a20 6e70 2e61  mpled_mat : np.a
-00013330: 7272 6179 0a20 2020 2020 2020 204d 6174  rray.        Mat
-00013340: 7269 7820 7769 7468 2072 6573 616d 706c  rix with resampl
-00013350: 6564 2062 696e 6e65 6420 7370 696b 6520  ed binned spike 
-00013360: 7472 6169 6e73 0a0a 2020 2020 2222 220a  trains..    """.
-00013370: 2020 2020 696d 706f 7274 2065 6c65 7068      import eleph
-00013380: 616e 742e 636f 6e76 6572 7369 6f6e 2061  ant.conversion a
-00013390: 7320 636f 6e76 0a0a 2020 2020 7265 7361  s conv..    resa
-000133a0: 6d70 6c65 645f 6d61 7420 3d20 5b5d 0a20  mpled_mat = []. 
-000133b0: 2020 2069 6620 6e6f 7420 6673 3a0a 2020     if not fs:.  
-000133c0: 2020 2020 2020 7261 6973 6520 4578 6365        raise Exce
-000133d0: 7074 696f 6e28 2750 726f 7669 6465 2065  ption('Provide e
-000133e0: 6974 6865 7220 7361 6d70 6c69 6e67 2066  ither sampling f
-000133f0: 7265 7175 656e 6379 2066 7320 6f72 2074  requency fs or t
-00013400: 696d 6520 7065 7269 6f64 2054 2729 0a20  ime period T'). 
-00013410: 2020 2065 6c69 6620 6673 3a0a 2020 2020     elif fs:.    
-00013420: 2020 2020 6966 206e 6f74 2069 7369 6e73      if not isins
-00013430: 7461 6e63 6528 6673 2c20 5175 616e 7469  tance(fs, Quanti
-00013440: 7479 293a 0a20 2020 2020 2020 2020 2020  ty):.           
-00013450: 2072 6169 7365 2056 616c 7565 4572 726f   raise ValueErro
-00013460: 7228 2266 7320 6d75 7374 2062 6520 6f66  r("fs must be of
-00013470: 2074 7970 6520 7071 2e51 7561 6e74 6974   type pq.Quantit
-00013480: 7922 290a 2020 2020 2020 2020 6269 6e73  y").        bins
-00013490: 697a 6520 3d20 312e 202f 2066 730a 2020  ize = 1. / fs.  
-000134a0: 2020 2020 2020 6269 6e73 697a 652e 7265        binsize.re
-000134b0: 7363 616c 6528 276d 7327 290a 2020 2020  scale('ms').    
-000134c0: 2020 2020 7265 7361 6d70 6c65 645f 6d61      resampled_ma
-000134d0: 7420 3d20 5b5d 0a20 2020 2020 2020 2066  t = [].        f
-000134e0: 6f72 2073 7473 2069 6e20 7370 696b 6574  or sts in spiket
-000134f0: 7261 696e 733a 0a20 2020 2020 2020 2020  rains:.         
-00013500: 2020 2073 7069 6b65 7320 3d20 636f 6e76     spikes = conv
-00013510: 2e42 696e 6e65 6453 7069 6b65 5472 6169  .BinnedSpikeTrai
-00013520: 6e28 7374 732c 2062 696e 7369 7a65 3d62  n(sts, binsize=b
-00013530: 696e 7369 7a65 292e 746f 5f61 7272 6179  insize).to_array
-00013540: 2829 0a20 2020 2020 2020 2020 2020 2072  ().            r
-00013550: 6573 616d 706c 6564 5f6d 6174 2e61 7070  esampled_mat.app
-00013560: 656e 6428 6e70 2e73 7175 6565 7a65 2873  end(np.squeeze(s
-00013570: 7069 6b65 7329 290a 2020 2020 7265 7475  pikes)).    retu
-00013580: 726e 206e 702e 6172 7261 7928 7265 7361  rn np.array(resa
-00013590: 6d70 6c65 645f 6d61 7429 0a0a 0a64 6566  mpled_mat)...def
-000135a0: 2063 6f6d 7075 7465 5f73 796e 635f 7261   compute_sync_ra
-000135b0: 7465 2874 696d 6573 312c 2074 696d 6573  te(times1, times
-000135c0: 322c 2074 696d 655f 6a69 7474 293a 0a20  2, time_jitt):. 
-000135d0: 2020 2022 2222 0a20 2020 2043 6f6d 7075     """.    Compu
-000135e0: 7465 2073 796e 6368 726f 6e79 2072 6174  te synchrony rat
-000135f0: 6520 6265 7477 6565 6e20 7477 6f20 7770  e between two wp
-00013600: 696b 6520 7472 6169 6e73 2e0a 0a20 2020  ike trains...   
-00013610: 2050 6172 616d 6574 6572 730a 2020 2020   Parameters.    
-00013620: 2d2d 2d2d 2d2d 2d2d 2d2d 0a20 2020 2074  ----------.    t
-00013630: 696d 6573 3120 3a20 7175 616e 7469 7479  imes1 : quantity
-00013640: 2061 7272 6179 0a20 2020 2020 2020 2053   array.        S
-00013650: 7069 6b65 2074 696d 6573 2031 0a20 2020  pike times 1.   
-00013660: 2074 696d 6573 3220 3a20 7175 616e 7469   times2 : quanti
-00013670: 7479 2061 7272 6179 0a20 2020 2020 2020  ty array.       
-00013680: 2053 7069 6b65 2074 696d 6573 2032 0a20   Spike times 2. 
-00013690: 2020 2074 696d 655f 6a69 7474 203a 2071     time_jitt : q
-000136a0: 7561 6e74 6974 790a 2020 2020 2020 2020  uantity.        
-000136b0: 4d61 7869 6d75 6d20 7469 6d65 206a 6974  Maximum time jit
-000136c0: 7465 7269 6e67 2062 6574 7765 656e 2061  tering between a
-000136d0: 6464 6564 2073 7069 6b65 730a 0a20 2020  dded spikes..   
-000136e0: 2052 6574 7572 6e73 0a20 2020 202d 2d2d   Returns.    ---
-000136f0: 2d2d 2d2d 0a20 2020 2072 6174 6520 3a20  ----.    rate : 
-00013700: 666c 6f61 740a 2020 2020 2020 2020 5379  float.        Sy
-00013710: 6e63 6872 6f6e 7920 7261 7465 2028 302d  nchrony rate (0-
-00013720: 3129 0a20 2020 2022 2222 0a20 2020 2023  1).    """.    #
-00013730: 2054 4f44 4f20 6d61 6b65 2074 6869 7320   TODO make this 
-00013740: 6661 7374 6572 0a20 2020 2063 6f75 6e74  faster.    count
-00013750: 203d 2030 0a20 2020 2066 6f72 2074 3120   = 0.    for t1 
-00013760: 696e 2074 696d 6573 313a 0a20 2020 2020  in times1:.     
-00013770: 2020 2069 6620 6c65 6e28 6e70 2e77 6865     if len(np.whe
-00013780: 7265 286e 702e 6162 7328 7469 6d65 7332  re(np.abs(times2
-00013790: 202d 2074 3129 203c 3d20 7469 6d65 5f6a   - t1) <= time_j
-000137a0: 6974 7429 5b30 5d29 203e 3d20 313a 0a20  itt)[0]) >= 1:. 
-000137b0: 2020 2020 2020 2020 2020 2069 6620 6c65             if le
-000137c0: 6e28 6e70 2e77 6865 7265 286e 702e 6162  n(np.where(np.ab
-000137d0: 7328 7469 6d65 7332 202d 2074 3129 203c  s(times2 - t1) <
-000137e0: 3d20 7469 6d65 5f6a 6974 7429 5b30 5d29  = time_jitt)[0])
-000137f0: 203e 2031 3a0a 2020 2020 2020 2020 2020   > 1:.          
-00013800: 2020 2020 2020 7072 696e 7428 274c 656e        print('Len
-00013810: 3a20 272c 206c 656e 286e 702e 7768 6572  : ', len(np.wher
-00013820: 6528 6e70 2e61 6273 2874 696d 6573 3220  e(np.abs(times2 
-00013830: 2d20 7431 2920 3c3d 2074 696d 655f 6a69  - t1) <= time_ji
-00013840: 7474 295b 305d 2929 0a20 2020 2020 2020  tt)[0])).       
-00013850: 2020 2020 2063 6f75 6e74 202b 3d20 310a       count += 1.
-00013860: 2020 2020 7261 7465 203d 2063 6f75 6e74      rate = count
-00013870: 202f 2028 6c65 6e28 7469 6d65 7331 2920   / (len(times1) 
-00013880: 2b20 6c65 6e28 7469 6d65 7332 2929 0a20  + len(times2)). 
-00013890: 2020 2072 6574 7572 6e20 7261 7465 0a0a     return rate..
-000138a0: 0a23 2323 2043 4f4e 564f 4c55 5449 4f4e  .### CONVOLUTION
-000138b0: 204f 5045 5241 5449 4f4e 5320 2323 230a   OPERATIONS ###.
-000138c0: 6465 6620 636f 6d70 7574 655f 6d6f 6475  def compute_modu
-000138d0: 6c61 7469 6f6e 2873 742c 206e 5f65 6c3d  lation(st, n_el=
-000138e0: 312c 206d 7261 6e64 3d31 2c20 7364 7261  1, mrand=1, sdra
-000138f0: 6e64 3d30 2e30 352c 206e 5f73 7069 6b65  nd=0.05, n_spike
-00013900: 733d 312c 2065 7870 3d30 2e32 2c20 6d61  s=1, exp=0.2, ma
-00013910: 785f 6275 7273 745f 6475 7261 7469 6f6e  x_burst_duration
-00013920: 3d31 3030 202a 2070 712e 6d73 293a 0a20  =100 * pq.ms):. 
-00013930: 2020 2022 2222 0a20 2020 2043 6f6d 7075     """.    Compu
-00013940: 7465 7320 6d6f 6475 6c61 7469 6f6e 2076  tes modulation v
-00013950: 616c 7565 2066 6f72 2061 6e20 696e 7075  alue for an inpu
-00013960: 7420 7370 696b 6520 7472 6169 6e2e 0a0a  t spike train...
-00013970: 2020 2020 5061 7261 6d65 7465 7273 0a20      Parameters. 
-00013980: 2020 202d 2d2d 2d2d 2d2d 2d2d 2d0a 2020     ----------.  
-00013990: 2020 7374 203a 206e 656f 2e53 7069 6b65    st : neo.Spike
-000139a0: 5472 6169 6e0a 2020 2020 2020 2020 496e  Train.        In
-000139b0: 7075 7420 7370 696b 6520 7472 6169 6e0a  put spike train.
-000139c0: 2020 2020 6e5f 656c 203a 2069 6e74 0a20      n_el : int. 
-000139d0: 2020 2020 2020 204e 756d 6265 7220 6f66         Number of
-000139e0: 2065 6c65 6374 726f 6465 7320 746f 2063   electrodes to c
-000139f0: 6f6d 7075 7465 206d 6f64 756c 6174 696f  ompute modulatio
-00013a00: 6e2e 0a20 2020 2020 2020 2049 6620 312c  n..        If 1,
-00013a10: 206d 6f64 756c 6174 696f 6e20 6973 2063   modulation is c
-00013a20: 6f6d 7075 7465 6420 6174 2074 6865 2074  omputed at the t
-00013a30: 656d 706c 6174 6520 6c65 7665 6c2e 0a20  emplate level.. 
-00013a40: 2020 2020 2020 2049 6620 6e5f 656c 6563         If n_elec
-00013a50: 2c20 6d6f 6475 6c61 7469 6f6e 2069 7320  , modulation is 
-00013a60: 636f 6d70 7574 6564 2061 7420 7468 6520  computed at the 
-00013a70: 656c 6563 7472 6f64 6520 6c65 7665 6c2e  electrode level.
-00013a80: 0a20 2020 206d 7261 6e64 203a 2066 6c6f  .    mrand : flo
-00013a90: 6174 0a20 2020 2020 2020 204d 6561 6e20  at.        Mean 
-00013aa0: 666f 7220 4761 7573 7369 616e 206d 6f64  for Gaussian mod
-00013ab0: 756c 6174 696f 6e20 2873 686f 756c 6420  ulation (should 
-00013ac0: 6265 2031 290a 2020 2020 7364 7261 6e64  be 1).    sdrand
-00013ad0: 203a 2066 6c6f 6174 0a20 2020 2020 2020   : float.       
-00013ae0: 2053 7461 6e64 6172 6420 6465 7669 6174   Standard deviat
-00013af0: 696f 6e20 666f 7220 4761 7573 7369 616e  ion for Gaussian
-00013b00: 206d 6f64 756c 6174 696f 6e0a 2020 2020   modulation.    
-00013b10: 6e5f 7370 696b 6573 203a 2069 6e74 0a20  n_spikes : int. 
-00013b20: 2020 2020 2020 204e 756d 6265 7220 6f66         Number of
-00013b30: 2073 7069 6b65 7320 666f 7220 6275 7273   spikes for burs
-00013b40: 7469 6e67 2062 6568 6176 696f 722e 0a20  ting behavior.. 
-00013b50: 2020 2020 2020 2049 6620 312c 206e 6f20         If 1, no 
-00013b60: 6275 7273 7469 6e67 2062 6568 6176 696f  bursting behavio
-00013b70: 722e 0a20 2020 2020 2020 2049 6620 3e20  r..        If > 
-00013b80: 312c 2075 7020 746f 206e 5f73 7069 6b65  1, up to n_spike
-00013b90: 7320 636f 6e73 6563 7574 6976 6520 7370  s consecutive sp
-00013ba0: 696b 6520 6172 6520 6d6f 6475 6c61 7465  ike are modulate
-00013bb0: 6420 7769 7468 2061 6e20 6578 706f 6e65  d with an expone
-00013bc0: 6e74 6961 6c6c 7920 6465 6361 7969 6e67  ntially decaying
-00013bd0: 2066 756e 6374 696f 6e2e 0a20 2020 2065   function..    e
-00013be0: 7870 203a 2066 6c6f 6174 0a20 2020 2020  xp : float.     
-00013bf0: 2020 2045 7870 6f6e 656e 7420 666f 7220     Exponent for 
-00013c00: 6578 706f 6e65 6e74 6961 6c20 6d6f 6475  exponential modu
-00013c10: 6c61 7469 6f6e 2028 6465 6661 756c 7420  lation (default 
-00013c20: 302e 3229 0a20 2020 206d 6178 5f62 7572  0.2).    max_bur
-00013c30: 7374 5f64 7572 6174 696f 6e20 3a20 5175  st_duration : Qu
-00013c40: 616e 7469 7479 0a20 2020 2020 2020 204d  antity.        M
-00013c50: 6178 696d 756d 2064 7572 6174 696f 6e20  aximum duration 
-00013c60: 6f66 2061 2062 7572 7374 696e 6720 6576  of a bursting ev
-00013c70: 656e 742e 2041 6674 6572 2074 6869 7320  ent. After this 
-00013c80: 6475 7261 7469 6f6e 2c20 6275 7273 7469  duration, bursti
-00013c90: 6e67 206d 6f64 756c 6174 696f 6e20 6973  ng modulation is
-00013ca0: 2072 6573 6574 2e0a 0a0a 2020 2020 5265   reset....    Re
-00013cb0: 7475 726e 730a 2020 2020 2d2d 2d2d 2d2d  turns.    ------
-00013cc0: 2d0a 2020 2020 6d6f 6420 3a20 6e70 2e61  -.    mod : np.a
-00013cd0: 7272 6179 0a20 2020 2020 2020 204d 6f64  rray.        Mod
-00013ce0: 756c 6174 696f 6e20 7661 6c75 6520 666f  ulation value fo
-00013cf0: 7220 6561 6368 2073 7069 6b65 2069 6e20  r each spike in 
-00013d00: 7468 6520 7370 696b 6520 7472 6169 6e0a  the spike train.
-00013d10: 2020 2020 636f 6e73 203a 206e 702e 6172      cons : np.ar
-00013d20: 7261 790a 2020 2020 2020 2020 4e75 6d62  ray.        Numb
-00013d30: 6572 206f 6620 636f 6e73 6563 7574 6976  er of consecutiv
-00013d40: 6520 7370 696b 6573 2063 6f6d 7075 7465  e spikes compute
-00013d50: 6420 666f 7220 6561 6368 2073 7069 6b65  d for each spike
-00013d60: 0a0a 2020 2020 2222 220a 0a20 2020 2069  ..    """..    i
-00013d70: 6d70 6f72 7420 656c 6570 6861 6e74 2e73  mport elephant.s
-00013d80: 7461 7469 7374 6963 7320 6173 2073 7461  tatistics as sta
-00013d90: 740a 0a20 2020 2069 6620 6e5f 656c 203d  t..    if n_el =
-00013da0: 3d20 313a 0a20 2020 2020 2020 2049 5349  = 1:.        ISI
-00013db0: 203d 2073 7461 742e 6973 6928 7374 292e   = stat.isi(st).
-00013dc0: 7265 7363 616c 6528 276d 7327 290a 2020  rescale('ms').  
-00013dd0: 2020 2020 2020 2320 6d61 785f 6275 7273        # max_burs
-00013de0: 745f 6475 7261 7469 6f6e 203d 2032 2a6d  t_duration = 2*m
-00013df0: 6561 6e5f 4953 490a 2020 2020 2020 2020  ean_ISI.        
-00013e00: 6d6f 6420 3d20 6e70 2e7a 6572 6f73 286c  mod = np.zeros(l
-00013e10: 656e 2873 7429 290a 2020 2020 2020 2020  en(st)).        
-00013e20: 6d6f 645b 305d 203d 2073 6472 616e 6420  mod[0] = sdrand 
-00013e30: 2a20 6e70 2e72 616e 646f 6d2e 7261 6e64  * np.random.rand
-00013e40: 6e28 2920 2b20 6d72 616e 640a 2020 2020  n() + mrand.    
-00013e50: 2020 2020 636f 6e73 203d 206e 702e 7a65      cons = np.ze
-00013e60: 726f 7328 6c65 6e28 7374 2929 0a0a 2020  ros(len(st))..  
-00013e70: 2020 2020 2020 6c61 7374 5f62 7572 7374        last_burst
-00013e80: 5f65 7665 6e74 203d 2030 202a 2070 712e  _event = 0 * pq.
-00013e90: 730a 2020 2020 2020 2020 666f 7220 692c  s.        for i,
-00013ea0: 2069 7369 2069 6e20 656e 756d 6572 6174   isi in enumerat
-00013eb0: 6528 4953 4929 3a0a 2020 2020 2020 2020  e(ISI):.        
-00013ec0: 2020 2020 6966 206e 5f73 7069 6b65 7320      if n_spikes 
-00013ed0: 3d3d 2030 3a0a 2020 2020 2020 2020 2020  == 0:.          
-00013ee0: 2020 2020 2020 2320 6e6f 2069 7369 2d64        # no isi-d
-00013ef0: 6570 656e 6465 6e74 206d 6f64 756c 6174  ependent modulat
-00013f00: 696f 6e0a 2020 2020 2020 2020 2020 2020  ion.            
-00013f10: 2020 2020 6d6f 645b 6920 2b20 315d 203d      mod[i + 1] =
-00013f20: 2073 6472 616e 6420 2a20 6e70 2e72 616e   sdrand * np.ran
-00013f30: 646f 6d2e 7261 6e64 6e28 2920 2b20 6d72  dom.randn() + mr
-00013f40: 616e 640a 2020 2020 2020 2020 2020 2020  and.            
-00013f50: 656c 6966 206e 5f73 7069 6b65 7320 3d3d  elif n_spikes ==
-00013f60: 2031 3a0a 2020 2020 2020 2020 2020 2020   1:.            
-00013f70: 2020 2020 6966 2069 7369 203e 206d 6178      if isi > max
-00013f80: 5f62 7572 7374 5f64 7572 6174 696f 6e3a  _burst_duration:
-00013f90: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00013fa0: 2020 2020 206d 6f64 5b69 202b 2031 5d20       mod[i + 1] 
-00013fb0: 3d20 7364 7261 6e64 202a 206e 702e 7261  = sdrand * np.ra
-00013fc0: 6e64 6f6d 2e72 616e 646e 2829 202b 206d  ndom.randn() + m
-00013fd0: 7261 6e64 0a20 2020 2020 2020 2020 2020  rand.           
-00013fe0: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
-00013ff0: 2020 2020 2020 2020 2020 2020 2020 206d                 m
-00014000: 6f64 5b69 202b 2031 5d20 3d20 6973 692e  od[i + 1] = isi.
-00014010: 6d61 676e 6974 7564 6520 2a2a 2065 7870  magnitude ** exp
-00014020: 202a 2028 312e 202f 206d 6178 5f62 7572   * (1. / max_bur
-00014030: 7374 5f64 7572 6174 696f 6e2e 6d61 676e  st_duration.magn
-00014040: 6974 7564 6520 2a2a 2065 7870 2920 5c0a  itude ** exp) \.
-00014050: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014060: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014070: 202b 2073 6472 616e 6420 2a20 6e70 2e72   + sdrand * np.r
-00014080: 616e 646f 6d2e 7261 6e64 6e28 290a 2020  andom.randn().  
-00014090: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
-000140a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000140b0: 6966 206c 6173 745f 6275 7273 745f 6576  if last_burst_ev
-000140c0: 656e 742e 6d61 676e 6974 7564 6520 3d3d  ent.magnitude ==
-000140d0: 2030 3a0a 2020 2020 2020 2020 2020 2020   0:.            
-000140e0: 2020 2020 2020 2020 636f 6e73 6563 7574          consecut
-000140f0: 6976 655f 6964 7820 3d20 6e70 2e77 6865  ive_idx = np.whe
-00014100: 7265 2828 7374 203e 2073 745b 695d 202d  re((st > st[i] -
-00014110: 206d 6178 5f62 7572 7374 5f64 7572 6174   max_burst_durat
-00014120: 696f 6e29 2026 2028 7374 203c 3d20 7374  ion) & (st <= st
-00014130: 5b69 5d29 295b 305d 0a20 2020 2020 2020  [i]))[0].       
-00014140: 2020 2020 2020 2020 2020 2020 2063 6f6e               con
-00014150: 7365 6375 7469 7665 203d 206c 656e 2863  secutive = len(c
-00014160: 6f6e 7365 6375 7469 7665 5f69 6478 290a  onsecutive_idx).
-00014170: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014180: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
-00014190: 2020 2020 2020 2020 2020 636f 6e73 6563            consec
-000141a0: 7574 6976 655f 6964 7820 3d20 6e70 2e77  utive_idx = np.w
-000141b0: 6865 7265 2828 7374 203e 206c 6173 745f  here((st > last_
-000141c0: 6275 7273 745f 6576 656e 7429 2026 2028  burst_event) & (
-000141d0: 7374 203c 3d20 7374 5b69 5d29 295b 305d  st <= st[i]))[0]
-000141e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000141f0: 2020 2020 2063 6f6e 7365 6375 7469 7665       consecutive
-00014200: 203d 206c 656e 2863 6f6e 7365 6375 7469   = len(consecuti
-00014210: 7665 5f69 6478 290a 0a20 2020 2020 2020  ve_idx)..       
-00014220: 2020 2020 2020 2020 2069 6620 636f 6e73           if cons
-00014230: 6563 7574 6976 6520 3d3d 206e 5f73 7069  ecutive == n_spi
-00014240: 6b65 7320 2d20 313a 0a20 2020 2020 2020  kes - 1:.       
-00014250: 2020 2020 2020 2020 2020 2020 206c 6173               las
-00014260: 745f 6275 7273 745f 6576 656e 7420 3d20  t_burst_event = 
-00014270: 7374 5b69 202b 2031 5d0a 2020 2020 2020  st[i + 1].      
-00014280: 2020 2020 2020 2020 2020 6966 2063 6f6e            if con
-00014290: 7365 6375 7469 7665 203e 3d20 313a 0a20  secutive >= 1:. 
-000142a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000142b0: 2020 2069 6620 7374 5b69 202b 2031 5d20     if st[i + 1] 
-000142c0: 2d20 7374 5b63 6f6e 7365 6375 7469 7665  - st[consecutive
-000142d0: 5f69 6478 5b30 5d5d 203e 3d20 6d61 785f  _idx[0]] >= max_
-000142e0: 6275 7273 745f 6475 7261 7469 6f6e 3a0a  burst_duration:.
-000142f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014300: 2020 2020 2020 2020 6c61 7374 5f62 7572          last_bur
-00014310: 7374 5f65 7665 6e74 203d 2073 745b 6920  st_event = st[i 
-00014320: 2b20 315d 202d 2030 2e30 3031 202a 2070  + 1] - 0.001 * p
-00014330: 712e 6d73 0a20 2020 2020 2020 2020 2020  q.ms.           
-00014340: 2020 2020 2020 2020 2020 2020 2063 6f6e               con
-00014350: 7365 6375 7469 7665 203d 2030 0a0a 2020  secutive = 0..  
-00014360: 2020 2020 2020 2020 2020 2020 2020 6966                if
-00014370: 2063 6f6e 7365 6375 7469 7665 203d 3d20   consecutive == 
-00014380: 303a 0a20 2020 2020 2020 2020 2020 2020  0:.             
-00014390: 2020 2020 2020 206d 6f64 5b69 202b 2031         mod[i + 1
-000143a0: 5d20 3d20 7364 7261 6e64 202a 206e 702e  ] = sdrand * np.
-000143b0: 7261 6e64 6f6d 2e72 616e 646e 2829 202b  random.randn() +
-000143c0: 206d 7261 6e64 0a20 2020 2020 2020 2020   mrand.         
-000143d0: 2020 2020 2020 2065 6c69 6620 636f 6e73         elif cons
-000143e0: 6563 7574 6976 6520 3d3d 2031 3a0a 2020  ecutive == 1:.  
-000143f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014400: 2020 616d 7020 3d20 2869 7369 202f 2066    amp = (isi / f
-00014410: 6c6f 6174 2863 6f6e 7365 6375 7469 7665  loat(consecutive
-00014420: 2929 202a 2a20 6578 7020 2a20 2831 2e20  )) ** exp * (1. 
-00014430: 2f20 6d61 785f 6275 7273 745f 6475 7261  / max_burst_dura
-00014440: 7469 6f6e 2e6d 6167 6e69 7475 6465 202a  tion.magnitude *
-00014450: 2a20 6578 7029 0a20 2020 2020 2020 2020  * exp).         
-00014460: 2020 2020 2020 2020 2020 2023 2073 6361             # sca
-00014470: 6c65 2073 7464 2062 7920 616d 700a 2020  le std by amp.  
+00012800: 692c 0a20 2020 2020 2020 2020 2020 2020  i,.             
+00012810: 2020 2020 2020 2073 745f 692c 0a20 2020         st_i,.   
+00012820: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012830: 2073 7069 6b65 7472 6169 6e73 2c0a 2020   spiketrains,.  
+00012840: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012850: 2020 745f 6a69 7474 2c0a 2020 2020 2020    t_jitt,.      
+00012860: 2020 2020 2020 2020 2020 2020 2020 6f76                ov
+00012870: 6572 6c61 7070 696e 675f 7061 6972 732c  erlapping_pairs,
+00012880: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00012890: 2020 2020 2072 6574 7572 6e5f 7370 696b       return_spik
+000128a0: 6574 7261 696e 732c 0a20 2020 2020 2020  etrains,.       
+000128b0: 2020 2020 2020 2020 2020 2020 2076 6572               ver
+000128c0: 626f 7365 2c0a 2020 2020 2020 2020 2020  bose,.          
+000128d0: 2020 2020 2020 292c 0a20 2020 2020 2020        ),.       
+000128e0: 2020 2020 2029 0a20 2020 2020 2020 2020       ).         
+000128f0: 2020 2070 2e73 7461 7274 2829 0a20 2020     p.start().   
+00012900: 2020 2020 2020 2020 2074 6872 6561 6473           threads
+00012910: 2e61 7070 656e 6428 7029 0a20 2020 2020  .append(p).     
+00012920: 2020 2066 6f72 2070 2069 6e20 7468 7265     for p in thre
+00012930: 6164 733a 0a20 2020 2020 2020 2020 2020  ads:.           
+00012940: 2070 2e6a 6f69 6e28 290a 2020 2020 2020   p.join().      
+00012950: 2020 2320 7265 7472 6965 7665 2061 6e6e    # retrieve ann
+00012960: 6f74 6174 6564 2073 7069 6b65 7472 6169  otated spiketrai
+00012970: 6e73 0a20 2020 2020 2020 2066 6f72 2069  ns.        for i
+00012980: 2c20 7374 2069 6e20 656e 756d 6572 6174  , st in enumerat
+00012990: 6528 7370 696b 6574 7261 696e 7329 3a0a  e(spiketrains):.
+000129a0: 2020 2020 2020 2020 2020 2020 7370 696b              spik
+000129b0: 6574 7261 696e 735b 695d 203d 2072 6574  etrains[i] = ret
+000129c0: 7572 6e5f 7370 696b 6574 7261 696e 735b  urn_spiketrains[
+000129d0: 695d 0a20 2020 2065 6c73 653a 0a20 2020  i].    else:.   
+000129e0: 2020 2020 2023 2066 696e 6420 6f76 6572       # find over
+000129f0: 6c61 7070 696e 6720 7370 696b 6573 0a20  lapping spikes. 
+00012a00: 2020 2020 2020 2066 6f72 2069 2c20 7374         for i, st
+00012a10: 5f69 2069 6e20 656e 756d 6572 6174 6528  _i in enumerate(
+00012a20: 7370 696b 6574 7261 696e 7329 3a0a 2020  spiketrains):.  
+00012a30: 2020 2020 2020 2020 2020 6966 2076 6572            if ver
+00012a40: 626f 7365 3a0a 2020 2020 2020 2020 2020  bose:.          
+00012a50: 2020 2020 2020 7072 696e 7428 2241 6e6e        print("Ann
+00012a60: 6f74 6174 696e 6720 6f76 6572 6c61 7070  otating overlapp
+00012a70: 696e 6720 7370 696b 6520 7472 6169 6e20  ing spike train 
+00012a80: 222c 2069 290a 2020 2020 2020 2020 2020  ", i).          
+00012a90: 2020 6f76 6572 203d 206e 702e 6172 7261    over = np.arra
+00012aa0: 7928 5b22 4e4f 4e45 225d 202a 206c 656e  y(["NONE"] * len
+00012ab0: 2873 745f 6929 290a 2020 2020 2020 2020  (st_i)).        
+00012ac0: 2020 2020 666f 7220 695f 7370 2c20 745f      for i_sp, t_
+00012ad0: 6920 696e 2065 6e75 6d65 7261 7465 2873  i in enumerate(s
+00012ae0: 745f 6929 3a0a 2020 2020 2020 2020 2020  t_i):.          
+00012af0: 2020 2020 2020 666f 7220 6a2c 2073 745f        for j, st_
+00012b00: 6a20 696e 2065 6e75 6d65 7261 7465 2873  j in enumerate(s
+00012b10: 7069 6b65 7472 6169 6e73 293a 0a20 2020  piketrains):.   
+00012b20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012b30: 2069 6620 6920 213d 206a 3a0a 2020 2020   if i != j:.    
+00012b40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012b50: 2020 2020 2320 6669 6e64 206f 7665 726c      # find overl
+00012b60: 6170 7069 6e67 0a20 2020 2020 2020 2020  apping.         
+00012b70: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+00012b80: 645f 6f76 6572 203d 206e 702e 7768 6572  d_over = np.wher
+00012b90: 6528 2873 745f 6a20 3e20 745f 6920 2d20  e((st_j > t_i - 
+00012ba0: 745f 6a69 7474 2920 2620 2873 745f 6a20  t_jitt) & (st_j 
+00012bb0: 3c20 745f 6920 2b20 745f 6a69 7474 2929  < t_i + t_jitt))
+00012bc0: 5b30 5d0a 2020 2020 2020 2020 2020 2020  [0].            
+00012bd0: 2020 2020 2020 2020 2020 2020 6966 206e              if n
+00012be0: 6f74 206e 702e 616e 7928 6f76 6572 6c61  ot np.any(overla
+00012bf0: 7070 696e 675f 7061 6972 7329 3a0a 2020  pping_pairs):.  
+00012c00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012c10: 2020 2020 2020 2020 2020 6966 206c 656e            if len
+00012c20: 2869 645f 6f76 6572 2920 213d 2030 3a0a  (id_over) != 0:.
+00012c30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012c40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012c50: 6f76 6572 5b69 5f73 705d 203d 2022 544f  over[i_sp] = "TO
+00012c60: 220a 2020 2020 2020 2020 2020 2020 2020  ".              
+00012c70: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
+00012c80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012c90: 2020 2020 2020 2020 2020 2020 7061 6972              pair
+00012ca0: 203d 205b 692c 206a 5d0a 2020 2020 2020   = [i, j].      
+00012cb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012cc0: 2020 2020 2020 7061 6972 5f69 203d 205b        pair_i = [
+00012cd0: 6a2c 2069 5d0a 2020 2020 2020 2020 2020  j, i].          
+00012ce0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012cf0: 2020 6966 206e 702e 616e 7928 5b6e 702e    if np.any([np.
+00012d00: 616c 6c28 7061 6972 203d 3d20 7029 2066  all(pair == p) f
+00012d10: 6f72 2070 2069 6e20 6f76 6572 6c61 7070  or p in overlapp
+00012d20: 696e 675f 7061 6972 735d 2920 6f72 206e  ing_pairs]) or n
+00012d30: 702e 616e 7928 0a20 2020 2020 2020 2020  p.any(.         
+00012d40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012d50: 2020 2020 2020 205b 6e70 2e61 6c6c 2870         [np.all(p
+00012d60: 6169 725f 6920 3d3d 2070 2920 666f 7220  air_i == p) for 
+00012d70: 7020 696e 206f 7665 726c 6170 7069 6e67  p in overlapping
+00012d80: 5f70 6169 7273 5d0a 2020 2020 2020 2020  _pairs].        
+00012d90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012da0: 2020 2020 293a 0a20 2020 2020 2020 2020      ):.         
+00012db0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012dc0: 2020 2020 2020 2069 6620 6c65 6e28 6964         if len(id
+00012dd0: 5f6f 7665 7229 2021 3d20 303a 0a20 2020  _over) != 0:.   
+00012de0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012df0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012e00: 206f 7665 725b 695f 7370 5d20 3d20 2253   over[i_sp] = "S
+00012e10: 544f 220a 2020 2020 2020 2020 2020 2020  TO".            
+00012e20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012e30: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+00012e40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012e50: 2020 2020 2020 6966 206c 656e 2869 645f        if len(id_
+00012e60: 6f76 6572 2920 213d 2030 3a0a 2020 2020  over) != 0:.    
+00012e70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012e80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012e90: 6f76 6572 5b69 5f73 705d 203d 2022 544f  over[i_sp] = "TO
+00012ea0: 220a 2020 2020 2020 2020 2020 2020 6f76  ".            ov
+00012eb0: 6572 5b6f 7665 7220 3d3d 2022 4e4f 4e45  er[over == "NONE
+00012ec0: 225d 203d 2022 4e4f 220a 2020 2020 2020  "] = "NO".      
+00012ed0: 2020 2020 2020 7374 5f69 2e61 6e6e 6f74        st_i.annot
+00012ee0: 6174 6528 6f76 6572 6c61 703d 6f76 6572  ate(overlap=over
+00012ef0: 290a 0a0a 6465 6620 616e 6e6f 7461 7465  )...def annotate
+00012f00: 5f70 6172 616c 6c65 6c28 692c 2073 745f  _parallel(i, st_
+00012f10: 692c 2073 7069 6b65 7472 6169 6e73 2c20  i, spiketrains, 
+00012f20: 745f 6a69 7474 2c20 6f76 6572 6c61 7070  t_jitt, overlapp
+00012f30: 696e 675f 7061 6972 732c 2072 6574 7572  ing_pairs, retur
+00012f40: 6e5f 7370 696b 6574 7261 696e 732c 2076  n_spiketrains, v
+00012f50: 6572 626f 7365 293a 0a20 2020 2022 2222  erbose):.    """
+00012f60: 0a20 2020 2048 656c 7065 7220 6675 6e63  .    Helper func
+00012f70: 7469 6f6e 2074 6f20 616e 6e6f 7461 7465  tion to annotate
+00012f80: 2073 7069 6b65 2074 7261 696e 7320 696e   spike trains in
+00012f90: 2070 6172 616c 6c65 6c2e 0a0a 2020 2020   parallel...    
+00012fa0: 5061 7261 6d65 7465 7273 0a20 2020 202d  Parameters.    -
+00012fb0: 2d2d 2d2d 2d2d 2d2d 2d0a 2020 2020 6920  ---------.    i 
+00012fc0: 3a20 696e 740a 2020 2020 2020 2020 496e  : int.        In
+00012fd0: 6465 7820 6f66 2073 7069 6b65 2074 7261  dex of spike tra
+00012fe0: 696e 0a20 2020 2073 745f 6920 3a20 6e65  in.    st_i : ne
+00012ff0: 6f2e 5370 696b 6554 7261 696e 0a20 2020  o.SpikeTrain.   
+00013000: 2020 2020 2053 7069 6b65 2074 7261 696e       Spike train
+00013010: 2074 6f20 6265 2070 726f 6365 7373 6564   to be processed
+00013020: 0a20 2020 2073 7069 6b65 7472 6169 6e73  .    spiketrains
+00013030: 203a 206c 6973 740a 2020 2020 2020 2020   : list.        
+00013040: 4c69 7374 206f 6620 6e65 6f20 7370 696b  List of neo spik
+00013050: 6574 7261 696e 730a 2020 2020 745f 6a69  etrains.    t_ji
+00013060: 7474 203a 2051 7561 6e74 6974 790a 2020  tt : Quantity.  
+00013070: 2020 2020 2020 5469 6d65 206a 6974 7465        Time jitte
+00013080: 7220 746f 2063 6f6e 7369 6465 7220 6f76  r to consider ov
+00013090: 6572 6c61 7070 696e 6720 7370 696b 6573  erlapping spikes
+000130a0: 2069 6e20 7469 6d65 2028 6465 6661 756c   in time (defaul
+000130b0: 7420 3120 6d73 290a 2020 2020 6f76 6572  t 1 ms).    over
+000130c0: 6c61 7070 696e 675f 7061 6972 7320 3a20  lapping_pairs : 
+000130d0: 6e70 2e61 7272 6179 0a20 2020 2020 2020  np.array.       
+000130e0: 2041 7272 6179 2077 6974 6820 6f76 6572   Array with over
+000130f0: 6c61 7070 696e 6720 696e 666f 726d 6174  lapping informat
+00013100: 696f 6e20 6265 7477 6565 6e20 7370 696b  ion between spik
+00013110: 6520 7472 6169 6e73 2028 6e5f 7370 696b  e trains (n_spik
+00013120: 6574 7261 696e 732c 2032 290a 2020 2020  etrains, 2).    
+00013130: 7665 7262 6f73 6520 3a20 626f 6f6c 0a20  verbose : bool. 
+00013140: 2020 2020 2020 2049 6620 5472 7565 206f         If True o
+00013150: 7574 7075 7420 6973 2076 6572 626f 7365  utput is verbose
+00013160: 0a0a 2020 2020 2222 220a 2020 2020 6966  ..    """.    if
+00013170: 2076 6572 626f 7365 3a0a 2020 2020 2020   verbose:.      
+00013180: 2020 7072 696e 7428 2241 6e6e 6f74 6174    print("Annotat
+00013190: 696e 6720 6f76 6572 6c61 7070 696e 6720  ing overlapping 
+000131a0: 7370 696b 6520 7472 6169 6e20 222c 2069  spike train ", i
+000131b0: 290a 2020 2020 6f76 6572 203d 206e 702e  ).    over = np.
+000131c0: 6172 7261 7928 5b22 4e4f 4e45 225d 202a  array(["NONE"] *
+000131d0: 206c 656e 2873 745f 6929 290a 2020 2020   len(st_i)).    
+000131e0: 666f 7220 695f 7370 2c20 745f 6920 696e  for i_sp, t_i in
+000131f0: 2065 6e75 6d65 7261 7465 2873 745f 6929   enumerate(st_i)
+00013200: 3a0a 2020 2020 2020 2020 666f 7220 6a2c  :.        for j,
+00013210: 2073 745f 6a20 696e 2065 6e75 6d65 7261   st_j in enumera
+00013220: 7465 2873 7069 6b65 7472 6169 6e73 293a  te(spiketrains):
+00013230: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+00013240: 6920 213d 206a 3a0a 2020 2020 2020 2020  i != j:.        
+00013250: 2020 2020 2020 2020 2320 6669 6e64 206f          # find o
+00013260: 7665 726c 6170 7069 6e67 0a20 2020 2020  verlapping.     
+00013270: 2020 2020 2020 2020 2020 2069 645f 6f76             id_ov
+00013280: 6572 203d 206e 702e 7768 6572 6528 2873  er = np.where((s
+00013290: 745f 6a20 3e20 745f 6920 2d20 745f 6a69  t_j > t_i - t_ji
+000132a0: 7474 2920 2620 2873 745f 6a20 3c20 745f  tt) & (st_j < t_
+000132b0: 6920 2b20 745f 6a69 7474 2929 5b30 5d0a  i + t_jitt))[0].
+000132c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000132d0: 6966 206e 6f74 206e 702e 616e 7928 6f76  if not np.any(ov
+000132e0: 6572 6c61 7070 696e 675f 7061 6972 7329  erlapping_pairs)
+000132f0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00013300: 2020 2020 2020 6966 206c 656e 2869 645f        if len(id_
+00013310: 6f76 6572 2920 213d 2030 3a0a 2020 2020  over) != 0:.    
+00013320: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013330: 2020 2020 6f76 6572 5b69 5f73 705d 203d      over[i_sp] =
+00013340: 2022 544f 220a 2020 2020 2020 2020 2020   "TO".          
+00013350: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+00013360: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013370: 7061 6972 203d 205b 692c 206a 5d0a 2020  pair = [i, j].  
+00013380: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013390: 2020 7061 6972 5f69 203d 205b 6a2c 2069    pair_i = [j, i
+000133a0: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
+000133b0: 2020 2020 2020 6966 206e 702e 616e 7928        if np.any(
+000133c0: 5b6e 702e 616c 6c28 7061 6972 203d 3d20  [np.all(pair == 
+000133d0: 7029 2066 6f72 2070 2069 6e20 6f76 6572  p) for p in over
+000133e0: 6c61 7070 696e 675f 7061 6972 735d 2920  lapping_pairs]) 
+000133f0: 6f72 206e 702e 616e 7928 0a20 2020 2020  or np.any(.     
+00013400: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013410: 2020 205b 6e70 2e61 6c6c 2870 6169 725f     [np.all(pair_
+00013420: 6920 3d3d 2070 2920 666f 7220 7020 696e  i == p) for p in
+00013430: 206f 7665 726c 6170 7069 6e67 5f70 6169   overlapping_pai
+00013440: 7273 5d0a 2020 2020 2020 2020 2020 2020  rs].            
+00013450: 2020 2020 2020 2020 293a 0a20 2020 2020          ):.     
+00013460: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013470: 2020 2069 6620 6c65 6e28 6964 5f6f 7665     if len(id_ove
+00013480: 7229 2021 3d20 303a 0a20 2020 2020 2020  r) != 0:.       
+00013490: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000134a0: 2020 2020 206f 7665 725b 695f 7370 5d20       over[i_sp] 
+000134b0: 3d20 2253 544f 220a 2020 2020 2020 2020  = "STO".        
+000134c0: 2020 2020 2020 2020 2020 2020 656c 7365              else
+000134d0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+000134e0: 2020 2020 2020 2020 2020 6966 206c 656e            if len
+000134f0: 2869 645f 6f76 6572 2920 213d 2030 3a0a  (id_over) != 0:.
+00013500: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013510: 2020 2020 2020 2020 2020 2020 6f76 6572              over
+00013520: 5b69 5f73 705d 203d 2022 544f 220a 2020  [i_sp] = "TO".  
+00013530: 2020 6f76 6572 5b6f 7665 7220 3d3d 2022    over[over == "
+00013540: 4e4f 4e45 225d 203d 2022 4e4f 220a 2020  NONE"] = "NO".  
+00013550: 2020 7374 5f69 2e61 6e6e 6f74 6174 6528    st_i.annotate(
+00013560: 6f76 6572 6c61 703d 6f76 6572 290a 2020  overlap=over).  
+00013570: 2020 7265 7475 726e 5f73 7069 6b65 7472    return_spiketr
+00013580: 6169 6e73 5b69 5d20 3d20 7374 5f69 0a0a  ains[i] = st_i..
+00013590: 0a64 6566 2072 6573 616d 706c 655f 7370  .def resample_sp
+000135a0: 696b 6574 7261 696e 7328 7370 696b 6574  iketrains(spiket
+000135b0: 7261 696e 732c 2066 733d 4e6f 6e65 293a  rains, fs=None):
+000135c0: 0a20 2020 2022 2222 0a20 2020 2052 6573  .    """.    Res
+000135d0: 616d 706c 6573 2073 7069 6b65 2074 7261  amples spike tra
+000135e0: 696e 732e 2050 726f 7669 6465 2065 6974  ins. Provide eit
+000135f0: 6865 7220 6673 206f 7220 5420 7061 7261  her fs or T para
+00013600: 6d65 7465 7273 0a0a 2020 2020 5061 7261  meters..    Para
+00013610: 6d65 7465 7273 0a20 2020 202d 2d2d 2d2d  meters.    -----
+00013620: 2d2d 2d2d 2d0a 2020 2020 7370 696b 6574  -----.    spiket
+00013630: 7261 696e 7320 3a20 6c69 7374 0a20 2020  rains : list.   
+00013640: 2020 2020 204c 6973 7420 6f66 206e 656f       List of neo
+00013650: 2073 7069 6b65 7472 6169 6e73 2074 6f20   spiketrains to 
+00013660: 6265 2072 6573 616d 706c 6564 0a20 2020  be resampled.   
+00013670: 2066 7320 3a20 5175 616e 7469 7479 0a20   fs : Quantity. 
+00013680: 2020 2020 2020 204e 6577 2073 616d 706c         New sampl
+00013690: 696e 6720 6672 6571 7565 6e63 790a 0a20  ing frequency.. 
+000136a0: 2020 2052 6574 7572 6e73 0a20 2020 202d     Returns.    -
+000136b0: 2d2d 2d2d 2d2d 0a20 2020 2072 6573 616d  ------.    resam
+000136c0: 706c 6564 5f6d 6174 203a 206e 702e 6172  pled_mat : np.ar
+000136d0: 7261 790a 2020 2020 2020 2020 4d61 7472  ray.        Matr
+000136e0: 6978 2077 6974 6820 7265 7361 6d70 6c65  ix with resample
+000136f0: 6420 6269 6e6e 6564 2073 7069 6b65 2074  d binned spike t
+00013700: 7261 696e 730a 0a20 2020 2022 2222 0a20  rains..    """. 
+00013710: 2020 2069 6d70 6f72 7420 656c 6570 6861     import elepha
+00013720: 6e74 2e63 6f6e 7665 7273 696f 6e20 6173  nt.conversion as
+00013730: 2063 6f6e 760a 0a20 2020 2072 6573 616d   conv..    resam
+00013740: 706c 6564 5f6d 6174 203d 205b 5d0a 2020  pled_mat = [].  
+00013750: 2020 6966 206e 6f74 2066 733a 0a20 2020    if not fs:.   
+00013760: 2020 2020 2072 6169 7365 2045 7863 6570       raise Excep
+00013770: 7469 6f6e 2822 5072 6f76 6964 6520 6569  tion("Provide ei
+00013780: 7468 6572 2073 616d 706c 696e 6720 6672  ther sampling fr
+00013790: 6571 7565 6e63 7920 6673 206f 7220 7469  equency fs or ti
+000137a0: 6d65 2070 6572 696f 6420 5422 290a 2020  me period T").  
+000137b0: 2020 656c 6966 2066 733a 0a20 2020 2020    elif fs:.     
+000137c0: 2020 2069 6620 6e6f 7420 6973 696e 7374     if not isinst
+000137d0: 616e 6365 2866 732c 2051 7561 6e74 6974  ance(fs, Quantit
+000137e0: 7929 3a0a 2020 2020 2020 2020 2020 2020  y):.            
+000137f0: 7261 6973 6520 5661 6c75 6545 7272 6f72  raise ValueError
+00013800: 2822 6673 206d 7573 7420 6265 206f 6620  ("fs must be of 
+00013810: 7479 7065 2070 712e 5175 616e 7469 7479  type pq.Quantity
+00013820: 2229 0a20 2020 2020 2020 2062 696e 7369  ").        binsi
+00013830: 7a65 203d 2031 2e30 202f 2066 730a 2020  ze = 1.0 / fs.  
+00013840: 2020 2020 2020 6269 6e73 697a 652e 7265        binsize.re
+00013850: 7363 616c 6528 226d 7322 290a 2020 2020  scale("ms").    
+00013860: 2020 2020 7265 7361 6d70 6c65 645f 6d61      resampled_ma
+00013870: 7420 3d20 5b5d 0a20 2020 2020 2020 2066  t = [].        f
+00013880: 6f72 2073 7473 2069 6e20 7370 696b 6574  or sts in spiket
+00013890: 7261 696e 733a 0a20 2020 2020 2020 2020  rains:.         
+000138a0: 2020 2073 7069 6b65 7320 3d20 636f 6e76     spikes = conv
+000138b0: 2e42 696e 6e65 6453 7069 6b65 5472 6169  .BinnedSpikeTrai
+000138c0: 6e28 7374 732c 2062 696e 7369 7a65 3d62  n(sts, binsize=b
+000138d0: 696e 7369 7a65 292e 746f 5f61 7272 6179  insize).to_array
+000138e0: 2829 0a20 2020 2020 2020 2020 2020 2072  ().            r
+000138f0: 6573 616d 706c 6564 5f6d 6174 2e61 7070  esampled_mat.app
+00013900: 656e 6428 6e70 2e73 7175 6565 7a65 2873  end(np.squeeze(s
+00013910: 7069 6b65 7329 290a 2020 2020 7265 7475  pikes)).    retu
+00013920: 726e 206e 702e 6172 7261 7928 7265 7361  rn np.array(resa
+00013930: 6d70 6c65 645f 6d61 7429 0a0a 0a64 6566  mpled_mat)...def
+00013940: 2063 6f6d 7075 7465 5f73 796e 635f 7261   compute_sync_ra
+00013950: 7465 2874 696d 6573 312c 2074 696d 6573  te(times1, times
+00013960: 322c 2074 696d 655f 6a69 7474 293a 0a20  2, time_jitt):. 
+00013970: 2020 2022 2222 0a20 2020 2043 6f6d 7075     """.    Compu
+00013980: 7465 2073 796e 6368 726f 6e79 2072 6174  te synchrony rat
+00013990: 6520 6265 7477 6565 6e20 7477 6f20 7770  e between two wp
+000139a0: 696b 6520 7472 6169 6e73 2e0a 0a20 2020  ike trains...   
+000139b0: 2050 6172 616d 6574 6572 730a 2020 2020   Parameters.    
+000139c0: 2d2d 2d2d 2d2d 2d2d 2d2d 0a20 2020 2074  ----------.    t
+000139d0: 696d 6573 3120 3a20 7175 616e 7469 7479  imes1 : quantity
+000139e0: 2061 7272 6179 0a20 2020 2020 2020 2053   array.        S
+000139f0: 7069 6b65 2074 696d 6573 2031 0a20 2020  pike times 1.   
+00013a00: 2074 696d 6573 3220 3a20 7175 616e 7469   times2 : quanti
+00013a10: 7479 2061 7272 6179 0a20 2020 2020 2020  ty array.       
+00013a20: 2053 7069 6b65 2074 696d 6573 2032 0a20   Spike times 2. 
+00013a30: 2020 2074 696d 655f 6a69 7474 203a 2071     time_jitt : q
+00013a40: 7561 6e74 6974 790a 2020 2020 2020 2020  uantity.        
+00013a50: 4d61 7869 6d75 6d20 7469 6d65 206a 6974  Maximum time jit
+00013a60: 7465 7269 6e67 2062 6574 7765 656e 2061  tering between a
+00013a70: 6464 6564 2073 7069 6b65 730a 0a20 2020  dded spikes..   
+00013a80: 2052 6574 7572 6e73 0a20 2020 202d 2d2d   Returns.    ---
+00013a90: 2d2d 2d2d 0a20 2020 2072 6174 6520 3a20  ----.    rate : 
+00013aa0: 666c 6f61 740a 2020 2020 2020 2020 5379  float.        Sy
+00013ab0: 6e63 6872 6f6e 7920 7261 7465 2028 302d  nchrony rate (0-
+00013ac0: 3129 0a20 2020 2022 2222 0a20 2020 2023  1).    """.    #
+00013ad0: 2054 4f44 4f20 6d61 6b65 2074 6869 7320   TODO make this 
+00013ae0: 6661 7374 6572 0a20 2020 2063 6f75 6e74  faster.    count
+00013af0: 203d 2030 0a20 2020 2066 6f72 2074 3120   = 0.    for t1 
+00013b00: 696e 2074 696d 6573 313a 0a20 2020 2020  in times1:.     
+00013b10: 2020 2069 6620 6c65 6e28 6e70 2e77 6865     if len(np.whe
+00013b20: 7265 286e 702e 6162 7328 7469 6d65 7332  re(np.abs(times2
+00013b30: 202d 2074 3129 203c 3d20 7469 6d65 5f6a   - t1) <= time_j
+00013b40: 6974 7429 5b30 5d29 203e 3d20 313a 0a20  itt)[0]) >= 1:. 
+00013b50: 2020 2020 2020 2020 2020 2069 6620 6c65             if le
+00013b60: 6e28 6e70 2e77 6865 7265 286e 702e 6162  n(np.where(np.ab
+00013b70: 7328 7469 6d65 7332 202d 2074 3129 203c  s(times2 - t1) <
+00013b80: 3d20 7469 6d65 5f6a 6974 7429 5b30 5d29  = time_jitt)[0])
+00013b90: 203e 2031 3a0a 2020 2020 2020 2020 2020   > 1:.          
+00013ba0: 2020 2020 2020 7072 696e 7428 224c 656e        print("Len
+00013bb0: 3a20 222c 206c 656e 286e 702e 7768 6572  : ", len(np.wher
+00013bc0: 6528 6e70 2e61 6273 2874 696d 6573 3220  e(np.abs(times2 
+00013bd0: 2d20 7431 2920 3c3d 2074 696d 655f 6a69  - t1) <= time_ji
+00013be0: 7474 295b 305d 2929 0a20 2020 2020 2020  tt)[0])).       
+00013bf0: 2020 2020 2063 6f75 6e74 202b 3d20 310a       count += 1.
+00013c00: 2020 2020 7261 7465 203d 2063 6f75 6e74      rate = count
+00013c10: 202f 2028 6c65 6e28 7469 6d65 7331 2920   / (len(times1) 
+00013c20: 2b20 6c65 6e28 7469 6d65 7332 2929 0a20  + len(times2)). 
+00013c30: 2020 2072 6574 7572 6e20 7261 7465 0a0a     return rate..
+00013c40: 0a23 2323 2043 4f4e 564f 4c55 5449 4f4e  .### CONVOLUTION
+00013c50: 204f 5045 5241 5449 4f4e 5320 2323 230a   OPERATIONS ###.
+00013c60: 6465 6620 636f 6d70 7574 655f 6d6f 6475  def compute_modu
+00013c70: 6c61 7469 6f6e 2873 742c 206e 5f65 6c3d  lation(st, n_el=
+00013c80: 312c 206d 7261 6e64 3d31 2c20 7364 7261  1, mrand=1, sdra
+00013c90: 6e64 3d30 2e30 352c 206e 5f73 7069 6b65  nd=0.05, n_spike
+00013ca0: 733d 312c 2065 7870 3d30 2e32 2c20 6d61  s=1, exp=0.2, ma
+00013cb0: 785f 6275 7273 745f 6475 7261 7469 6f6e  x_burst_duration
+00013cc0: 3d31 3030 202a 2070 712e 6d73 293a 0a20  =100 * pq.ms):. 
+00013cd0: 2020 2022 2222 0a20 2020 2043 6f6d 7075     """.    Compu
+00013ce0: 7465 7320 6d6f 6475 6c61 7469 6f6e 2076  tes modulation v
+00013cf0: 616c 7565 2066 6f72 2061 6e20 696e 7075  alue for an inpu
+00013d00: 7420 7370 696b 6520 7472 6169 6e2e 0a0a  t spike train...
+00013d10: 2020 2020 5061 7261 6d65 7465 7273 0a20      Parameters. 
+00013d20: 2020 202d 2d2d 2d2d 2d2d 2d2d 2d0a 2020     ----------.  
+00013d30: 2020 7374 203a 206e 656f 2e53 7069 6b65    st : neo.Spike
+00013d40: 5472 6169 6e0a 2020 2020 2020 2020 496e  Train.        In
+00013d50: 7075 7420 7370 696b 6520 7472 6169 6e0a  put spike train.
+00013d60: 2020 2020 6e5f 656c 203a 2069 6e74 0a20      n_el : int. 
+00013d70: 2020 2020 2020 204e 756d 6265 7220 6f66         Number of
+00013d80: 2065 6c65 6374 726f 6465 7320 746f 2063   electrodes to c
+00013d90: 6f6d 7075 7465 206d 6f64 756c 6174 696f  ompute modulatio
+00013da0: 6e2e 0a20 2020 2020 2020 2049 6620 312c  n..        If 1,
+00013db0: 206d 6f64 756c 6174 696f 6e20 6973 2063   modulation is c
+00013dc0: 6f6d 7075 7465 6420 6174 2074 6865 2074  omputed at the t
+00013dd0: 656d 706c 6174 6520 6c65 7665 6c2e 0a20  emplate level.. 
+00013de0: 2020 2020 2020 2049 6620 6e5f 656c 6563         If n_elec
+00013df0: 2c20 6d6f 6475 6c61 7469 6f6e 2069 7320  , modulation is 
+00013e00: 636f 6d70 7574 6564 2061 7420 7468 6520  computed at the 
+00013e10: 656c 6563 7472 6f64 6520 6c65 7665 6c2e  electrode level.
+00013e20: 0a20 2020 206d 7261 6e64 203a 2066 6c6f  .    mrand : flo
+00013e30: 6174 0a20 2020 2020 2020 204d 6561 6e20  at.        Mean 
+00013e40: 666f 7220 4761 7573 7369 616e 206d 6f64  for Gaussian mod
+00013e50: 756c 6174 696f 6e20 2873 686f 756c 6420  ulation (should 
+00013e60: 6265 2031 290a 2020 2020 7364 7261 6e64  be 1).    sdrand
+00013e70: 203a 2066 6c6f 6174 0a20 2020 2020 2020   : float.       
+00013e80: 2053 7461 6e64 6172 6420 6465 7669 6174   Standard deviat
+00013e90: 696f 6e20 666f 7220 4761 7573 7369 616e  ion for Gaussian
+00013ea0: 206d 6f64 756c 6174 696f 6e0a 2020 2020   modulation.    
+00013eb0: 6e5f 7370 696b 6573 203a 2069 6e74 0a20  n_spikes : int. 
+00013ec0: 2020 2020 2020 204e 756d 6265 7220 6f66         Number of
+00013ed0: 2073 7069 6b65 7320 666f 7220 6275 7273   spikes for burs
+00013ee0: 7469 6e67 2062 6568 6176 696f 722e 0a20  ting behavior.. 
+00013ef0: 2020 2020 2020 2049 6620 312c 206e 6f20         If 1, no 
+00013f00: 6275 7273 7469 6e67 2062 6568 6176 696f  bursting behavio
+00013f10: 722e 0a20 2020 2020 2020 2049 6620 3e20  r..        If > 
+00013f20: 312c 2075 7020 746f 206e 5f73 7069 6b65  1, up to n_spike
+00013f30: 7320 636f 6e73 6563 7574 6976 6520 7370  s consecutive sp
+00013f40: 696b 6520 6172 6520 6d6f 6475 6c61 7465  ike are modulate
+00013f50: 6420 7769 7468 2061 6e20 6578 706f 6e65  d with an expone
+00013f60: 6e74 6961 6c6c 7920 6465 6361 7969 6e67  ntially decaying
+00013f70: 2066 756e 6374 696f 6e2e 0a20 2020 2065   function..    e
+00013f80: 7870 203a 2066 6c6f 6174 0a20 2020 2020  xp : float.     
+00013f90: 2020 2045 7870 6f6e 656e 7420 666f 7220     Exponent for 
+00013fa0: 6578 706f 6e65 6e74 6961 6c20 6d6f 6475  exponential modu
+00013fb0: 6c61 7469 6f6e 2028 6465 6661 756c 7420  lation (default 
+00013fc0: 302e 3229 0a20 2020 206d 6178 5f62 7572  0.2).    max_bur
+00013fd0: 7374 5f64 7572 6174 696f 6e20 3a20 5175  st_duration : Qu
+00013fe0: 616e 7469 7479 0a20 2020 2020 2020 204d  antity.        M
+00013ff0: 6178 696d 756d 2064 7572 6174 696f 6e20  aximum duration 
+00014000: 6f66 2061 2062 7572 7374 696e 6720 6576  of a bursting ev
+00014010: 656e 742e 2041 6674 6572 2074 6869 7320  ent. After this 
+00014020: 6475 7261 7469 6f6e 2c20 6275 7273 7469  duration, bursti
+00014030: 6e67 206d 6f64 756c 6174 696f 6e20 6973  ng modulation is
+00014040: 2072 6573 6574 2e0a 0a0a 2020 2020 5265   reset....    Re
+00014050: 7475 726e 730a 2020 2020 2d2d 2d2d 2d2d  turns.    ------
+00014060: 2d0a 2020 2020 6d6f 6420 3a20 6e70 2e61  -.    mod : np.a
+00014070: 7272 6179 0a20 2020 2020 2020 204d 6f64  rray.        Mod
+00014080: 756c 6174 696f 6e20 7661 6c75 6520 666f  ulation value fo
+00014090: 7220 6561 6368 2073 7069 6b65 2069 6e20  r each spike in 
+000140a0: 7468 6520 7370 696b 6520 7472 6169 6e0a  the spike train.
+000140b0: 2020 2020 636f 6e73 203a 206e 702e 6172      cons : np.ar
+000140c0: 7261 790a 2020 2020 2020 2020 4e75 6d62  ray.        Numb
+000140d0: 6572 206f 6620 636f 6e73 6563 7574 6976  er of consecutiv
+000140e0: 6520 7370 696b 6573 2063 6f6d 7075 7465  e spikes compute
+000140f0: 6420 666f 7220 6561 6368 2073 7069 6b65  d for each spike
+00014100: 0a0a 2020 2020 2222 220a 0a20 2020 2069  ..    """..    i
+00014110: 6d70 6f72 7420 656c 6570 6861 6e74 2e73  mport elephant.s
+00014120: 7461 7469 7374 6963 7320 6173 2073 7461  tatistics as sta
+00014130: 740a 0a20 2020 2069 6620 6e5f 656c 203d  t..    if n_el =
+00014140: 3d20 313a 0a20 2020 2020 2020 2049 5349  = 1:.        ISI
+00014150: 203d 2073 7461 742e 6973 6928 7374 292e   = stat.isi(st).
+00014160: 7265 7363 616c 6528 226d 7322 290a 2020  rescale("ms").  
+00014170: 2020 2020 2020 2320 6d61 785f 6275 7273        # max_burs
+00014180: 745f 6475 7261 7469 6f6e 203d 2032 2a6d  t_duration = 2*m
+00014190: 6561 6e5f 4953 490a 2020 2020 2020 2020  ean_ISI.        
+000141a0: 6d6f 6420 3d20 6e70 2e7a 6572 6f73 286c  mod = np.zeros(l
+000141b0: 656e 2873 7429 290a 2020 2020 2020 2020  en(st)).        
+000141c0: 6d6f 645b 305d 203d 2073 6472 616e 6420  mod[0] = sdrand 
+000141d0: 2a20 6e70 2e72 616e 646f 6d2e 7261 6e64  * np.random.rand
+000141e0: 6e28 2920 2b20 6d72 616e 640a 2020 2020  n() + mrand.    
+000141f0: 2020 2020 636f 6e73 203d 206e 702e 7a65      cons = np.ze
+00014200: 726f 7328 6c65 6e28 7374 2929 0a0a 2020  ros(len(st))..  
+00014210: 2020 2020 2020 6c61 7374 5f62 7572 7374        last_burst
+00014220: 5f65 7665 6e74 203d 2030 202a 2070 712e  _event = 0 * pq.
+00014230: 730a 2020 2020 2020 2020 666f 7220 692c  s.        for i,
+00014240: 2069 7369 2069 6e20 656e 756d 6572 6174   isi in enumerat
+00014250: 6528 4953 4929 3a0a 2020 2020 2020 2020  e(ISI):.        
+00014260: 2020 2020 6966 206e 5f73 7069 6b65 7320      if n_spikes 
+00014270: 3d3d 2030 3a0a 2020 2020 2020 2020 2020  == 0:.          
+00014280: 2020 2020 2020 2320 6e6f 2069 7369 2d64        # no isi-d
+00014290: 6570 656e 6465 6e74 206d 6f64 756c 6174  ependent modulat
+000142a0: 696f 6e0a 2020 2020 2020 2020 2020 2020  ion.            
+000142b0: 2020 2020 6d6f 645b 6920 2b20 315d 203d      mod[i + 1] =
+000142c0: 2073 6472 616e 6420 2a20 6e70 2e72 616e   sdrand * np.ran
+000142d0: 646f 6d2e 7261 6e64 6e28 2920 2b20 6d72  dom.randn() + mr
+000142e0: 616e 640a 2020 2020 2020 2020 2020 2020  and.            
+000142f0: 656c 6966 206e 5f73 7069 6b65 7320 3d3d  elif n_spikes ==
+00014300: 2031 3a0a 2020 2020 2020 2020 2020 2020   1:.            
+00014310: 2020 2020 6966 2069 7369 203e 206d 6178      if isi > max
+00014320: 5f62 7572 7374 5f64 7572 6174 696f 6e3a  _burst_duration:
+00014330: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00014340: 2020 2020 206d 6f64 5b69 202b 2031 5d20       mod[i + 1] 
+00014350: 3d20 7364 7261 6e64 202a 206e 702e 7261  = sdrand * np.ra
+00014360: 6e64 6f6d 2e72 616e 646e 2829 202b 206d  ndom.randn() + m
+00014370: 7261 6e64 0a20 2020 2020 2020 2020 2020  rand.           
+00014380: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+00014390: 2020 2020 2020 2020 2020 2020 2020 206d                 m
+000143a0: 6f64 5b69 202b 2031 5d20 3d20 280a 2020  od[i + 1] = (.  
+000143b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000143c0: 2020 2020 2020 6973 692e 6d61 676e 6974        isi.magnit
+000143d0: 7564 652a 2a65 7870 202a 2028 312e 3020  ude**exp * (1.0 
+000143e0: 2f20 6d61 785f 6275 7273 745f 6475 7261  / max_burst_dura
+000143f0: 7469 6f6e 2e6d 6167 6e69 7475 6465 2a2a  tion.magnitude**
+00014400: 6578 7029 202b 2073 6472 616e 6420 2a20  exp) + sdrand * 
+00014410: 6e70 2e72 616e 646f 6d2e 7261 6e64 6e28  np.random.randn(
+00014420: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+00014430: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
+00014440: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+00014450: 2020 2020 2020 2020 2020 6966 206c 6173            if las
+00014460: 745f 6275 7273 745f 6576 656e 742e 6d61  t_burst_event.ma
+00014470: 676e 6974 7564 6520 3d3d 2030 3a0a 2020  gnitude == 0:.  
 00014480: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014490: 2020 6d6f 645b 6920 2b20 315d 203d 2061    mod[i + 1] = a
-000144a0: 6d70 202b 2061 6d70 202a 2073 6472 616e  mp + amp * sdran
-000144b0: 6420 2a20 6e70 2e72 616e 646f 6d2e 7261  d * np.random.ra
-000144c0: 6e64 6e28 290a 2020 2020 2020 2020 2020  ndn().          
-000144d0: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
-000144e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000144f0: 6966 2069 2021 3d20 6c65 6e28 4953 4929  if i != len(ISI)
-00014500: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00014510: 2020 2020 2020 2020 2020 6973 695f 6d65            isi_me
-00014520: 616e 203d 206e 702e 6d65 616e 2849 5349  an = np.mean(ISI
-00014530: 5b69 202d 2063 6f6e 7365 6375 7469 7665  [i - consecutive
-00014540: 202b 2031 3a69 202b 2031 5d29 0a20 2020   + 1:i + 1]).   
-00014550: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014560: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
-00014570: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-00014580: 7369 5f6d 6561 6e20 3d20 6e70 2e6d 6561  si_mean = np.mea
-00014590: 6e28 4953 495b 6920 2d20 636f 6e73 6563  n(ISI[i - consec
-000145a0: 7574 6976 6520 2b20 313a 5d29 0a20 2020  utive + 1:]).   
-000145b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000145c0: 2061 6d70 203d 2028 6973 695f 6d65 616e   amp = (isi_mean
-000145d0: 202f 2066 6c6f 6174 2863 6f6e 7365 6375   / float(consecu
-000145e0: 7469 7665 2929 202a 2a20 6578 7020 2a20  tive)) ** exp * 
-000145f0: 2831 2e20 2f20 6d61 785f 6275 7273 745f  (1. / max_burst_
-00014600: 6475 7261 7469 6f6e 2e6d 6167 6e69 7475  duration.magnitu
-00014610: 6465 202a 2a20 6578 7029 0a20 2020 2020  de ** exp).     
-00014620: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-00014630: 2073 6361 6c65 2073 7464 2062 7920 616d   scale std by am
-00014640: 700a 2020 2020 2020 2020 2020 2020 2020  p.              
-00014650: 2020 2020 2020 6d6f 645b 6920 2b20 315d        mod[i + 1]
-00014660: 203d 2061 6d70 202b 2061 6d70 202a 2073   = amp + amp * s
-00014670: 6472 616e 6420 2a20 6e70 2e72 616e 646f  drand * np.rando
-00014680: 6d2e 7261 6e64 6e28 290a 0a20 2020 2020  m.randn()..     
-00014690: 2020 2020 2020 2020 2020 2063 6f6e 735b             cons[
-000146a0: 6920 2b20 315d 203d 2063 6f6e 7365 6375  i + 1] = consecu
-000146b0: 7469 7665 0a20 2020 2065 6c73 653a 0a20  tive.    else:. 
-000146c0: 2020 2020 2020 2069 6620 6e5f 7370 696b         if n_spik
-000146d0: 6573 203d 3d20 303a 0a20 2020 2020 2020  es == 0:.       
-000146e0: 2020 2020 206d 6f64 203d 2073 6472 616e       mod = sdran
-000146f0: 6420 2a20 6e70 2e72 616e 646f 6d2e 7261  d * np.random.ra
-00014700: 6e64 6e28 6c65 6e28 7374 292c 206e 5f65  ndn(len(st), n_e
-00014710: 6c29 202b 206d 7261 6e64 0a20 2020 2020  l) + mrand.     
-00014720: 2020 2020 2020 2063 6f6e 7320 3d20 5b5d         cons = []
-00014730: 0a20 2020 2020 2020 2065 6c73 653a 0a20  .        else:. 
-00014740: 2020 2020 2020 2020 2020 2049 5349 203d             ISI =
-00014750: 2073 7461 742e 6973 6928 7374 292e 7265   stat.isi(st).re
-00014760: 7363 616c 6528 276d 7327 290a 2020 2020  scale('ms').    
-00014770: 2020 2020 2020 2020 6d6f 6420 3d20 6e70          mod = np
-00014780: 2e7a 6572 6f73 2828 6c65 6e28 7374 292c  .zeros((len(st),
-00014790: 206e 5f65 6c29 290a 2020 2020 2020 2020   n_el)).        
-000147a0: 2020 2020 6d6f 645b 305d 203d 2073 6472      mod[0] = sdr
-000147b0: 616e 6420 2a20 6e70 2e72 616e 646f 6d2e  and * np.random.
-000147c0: 7261 6e64 6e28 6e5f 656c 2920 2b20 6d72  randn(n_el) + mr
-000147d0: 616e 640a 2020 2020 2020 2020 2020 2020  and.            
-000147e0: 636f 6e73 203d 206e 702e 7a65 726f 7328  cons = np.zeros(
-000147f0: 6c65 6e28 7374 2929 0a0a 2020 2020 2020  len(st))..      
-00014800: 2020 2020 2020 6c61 7374 5f62 7572 7374        last_burst
-00014810: 5f65 7665 6e74 203d 2030 202a 2070 712e  _event = 0 * pq.
-00014820: 730a 2020 2020 2020 2020 2020 2020 666f  s.            fo
-00014830: 7220 692c 2069 7369 2069 6e20 656e 756d  r i, isi in enum
-00014840: 6572 6174 6528 4953 4929 3a0a 2020 2020  erate(ISI):.    
-00014850: 2020 2020 2020 2020 2020 2020 6966 206e              if n
-00014860: 5f73 7069 6b65 7320 3d3d 2031 3a0a 2020  _spikes == 1:.  
-00014870: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014880: 2020 6966 2069 7369 203e 206d 6178 5f62    if isi > max_b
-00014890: 7572 7374 5f64 7572 6174 696f 6e3a 0a20  urst_duration:. 
-000148a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000148b0: 2020 2020 2020 206d 6f64 5b69 202b 2031         mod[i + 1
-000148c0: 5d20 3d20 7364 7261 6e64 202a 206e 702e  ] = sdrand * np.
-000148d0: 7261 6e64 6f6d 2e72 616e 646e 286e 5f65  random.randn(n_e
-000148e0: 6c29 202b 206d 7261 6e64 0a20 2020 2020  l) + mrand.     
-000148f0: 2020 2020 2020 2020 2020 2020 2020 2065                 e
-00014900: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
-00014910: 2020 2020 2020 2020 2020 2020 206d 6f64               mod
-00014920: 5b69 202b 2031 5d20 3d20 6973 692e 6d61  [i + 1] = isi.ma
-00014930: 676e 6974 7564 6520 2a2a 2065 7870 202a  gnitude ** exp *
-00014940: 2028 0a20 2020 2020 2020 2020 2020 2020   (.             
-00014950: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014960: 2020 2031 2e20 2f20 6d61 785f 6275 7273     1. / max_burs
-00014970: 745f 6475 7261 7469 6f6e 2e6d 6167 6e69  t_duration.magni
-00014980: 7475 6465 202a 2a20 6578 7029 202b 2073  tude ** exp) + s
-00014990: 6472 616e 6420 2a20 6e70 2e72 616e 646f  drand * np.rando
-000149a0: 6d2e 7261 6e64 6e28 6e5f 656c 290a 2020  m.randn(n_el).  
-000149b0: 2020 2020 2020 2020 2020 2020 2020 656c                el
-000149c0: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-000149d0: 2020 2020 2020 2020 6966 2069 7369 203e          if isi >
-000149e0: 206d 6178 5f62 7572 7374 5f64 7572 6174   max_burst_durat
-000149f0: 696f 6e3a 0a20 2020 2020 2020 2020 2020  ion:.           
-00014a00: 2020 2020 2020 2020 2020 2020 206d 6f64               mod
-00014a10: 5b69 202b 2031 5d20 3d20 7364 7261 6e64  [i + 1] = sdrand
+00014490: 2020 636f 6e73 6563 7574 6976 655f 6964    consecutive_id
+000144a0: 7820 3d20 6e70 2e77 6865 7265 2828 7374  x = np.where((st
+000144b0: 203e 2073 745b 695d 202d 206d 6178 5f62   > st[i] - max_b
+000144c0: 7572 7374 5f64 7572 6174 696f 6e29 2026  urst_duration) &
+000144d0: 2028 7374 203c 3d20 7374 5b69 5d29 295b   (st <= st[i]))[
+000144e0: 305d 0a20 2020 2020 2020 2020 2020 2020  0].             
+000144f0: 2020 2020 2020 2063 6f6e 7365 6375 7469         consecuti
+00014500: 7665 203d 206c 656e 2863 6f6e 7365 6375  ve = len(consecu
+00014510: 7469 7665 5f69 6478 290a 2020 2020 2020  tive_idx).      
+00014520: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
+00014530: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014540: 2020 2020 636f 6e73 6563 7574 6976 655f      consecutive_
+00014550: 6964 7820 3d20 6e70 2e77 6865 7265 2828  idx = np.where((
+00014560: 7374 203e 206c 6173 745f 6275 7273 745f  st > last_burst_
+00014570: 6576 656e 7429 2026 2028 7374 203c 3d20  event) & (st <= 
+00014580: 7374 5b69 5d29 295b 305d 0a20 2020 2020  st[i]))[0].     
+00014590: 2020 2020 2020 2020 2020 2020 2020 2063                 c
+000145a0: 6f6e 7365 6375 7469 7665 203d 206c 656e  onsecutive = len
+000145b0: 2863 6f6e 7365 6375 7469 7665 5f69 6478  (consecutive_idx
+000145c0: 290a 0a20 2020 2020 2020 2020 2020 2020  )..             
+000145d0: 2020 2069 6620 636f 6e73 6563 7574 6976     if consecutiv
+000145e0: 6520 3d3d 206e 5f73 7069 6b65 7320 2d20  e == n_spikes - 
+000145f0: 313a 0a20 2020 2020 2020 2020 2020 2020  1:.             
+00014600: 2020 2020 2020 206c 6173 745f 6275 7273         last_burs
+00014610: 745f 6576 656e 7420 3d20 7374 5b69 202b  t_event = st[i +
+00014620: 2031 5d0a 2020 2020 2020 2020 2020 2020   1].            
+00014630: 2020 2020 6966 2063 6f6e 7365 6375 7469      if consecuti
+00014640: 7665 203e 3d20 313a 0a20 2020 2020 2020  ve >= 1:.       
+00014650: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+00014660: 7374 5b69 202b 2031 5d20 2d20 7374 5b63  st[i + 1] - st[c
+00014670: 6f6e 7365 6375 7469 7665 5f69 6478 5b30  onsecutive_idx[0
+00014680: 5d5d 203e 3d20 6d61 785f 6275 7273 745f  ]] >= max_burst_
+00014690: 6475 7261 7469 6f6e 3a0a 2020 2020 2020  duration:.      
+000146a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000146b0: 2020 6c61 7374 5f62 7572 7374 5f65 7665    last_burst_eve
+000146c0: 6e74 203d 2073 745b 6920 2b20 315d 202d  nt = st[i + 1] -
+000146d0: 2030 2e30 3031 202a 2070 712e 6d73 0a20   0.001 * pq.ms. 
+000146e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000146f0: 2020 2020 2020 2063 6f6e 7365 6375 7469         consecuti
+00014700: 7665 203d 2030 0a0a 2020 2020 2020 2020  ve = 0..        
+00014710: 2020 2020 2020 2020 6966 2063 6f6e 7365          if conse
+00014720: 6375 7469 7665 203d 3d20 303a 0a20 2020  cutive == 0:.   
+00014730: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014740: 206d 6f64 5b69 202b 2031 5d20 3d20 7364   mod[i + 1] = sd
+00014750: 7261 6e64 202a 206e 702e 7261 6e64 6f6d  rand * np.random
+00014760: 2e72 616e 646e 2829 202b 206d 7261 6e64  .randn() + mrand
+00014770: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00014780: 2065 6c69 6620 636f 6e73 6563 7574 6976   elif consecutiv
+00014790: 6520 3d3d 2031 3a0a 2020 2020 2020 2020  e == 1:.        
+000147a0: 2020 2020 2020 2020 2020 2020 616d 7020              amp 
+000147b0: 3d20 2869 7369 202f 2066 6c6f 6174 2863  = (isi / float(c
+000147c0: 6f6e 7365 6375 7469 7665 2929 202a 2a20  onsecutive)) ** 
+000147d0: 6578 7020 2a20 2831 2e30 202f 206d 6178  exp * (1.0 / max
+000147e0: 5f62 7572 7374 5f64 7572 6174 696f 6e2e  _burst_duration.
+000147f0: 6d61 676e 6974 7564 652a 2a65 7870 290a  magnitude**exp).
+00014800: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014810: 2020 2020 2320 7363 616c 6520 7374 6420      # scale std 
+00014820: 6279 2061 6d70 0a20 2020 2020 2020 2020  by amp.         
+00014830: 2020 2020 2020 2020 2020 206d 6f64 5b69             mod[i
+00014840: 202b 2031 5d20 3d20 616d 7020 2b20 616d   + 1] = amp + am
+00014850: 7020 2a20 7364 7261 6e64 202a 206e 702e  p * sdrand * np.
+00014860: 7261 6e64 6f6d 2e72 616e 646e 2829 0a20  random.randn(). 
+00014870: 2020 2020 2020 2020 2020 2020 2020 2065                 e
+00014880: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+00014890: 2020 2020 2020 2020 2069 6620 6920 213d           if i !=
+000148a0: 206c 656e 2849 5349 293a 0a20 2020 2020   len(ISI):.     
+000148b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000148c0: 2020 2069 7369 5f6d 6561 6e20 3d20 6e70     isi_mean = np
+000148d0: 2e6d 6561 6e28 4953 495b 6920 2d20 636f  .mean(ISI[i - co
+000148e0: 6e73 6563 7574 6976 6520 2b20 3120 3a20  nsecutive + 1 : 
+000148f0: 6920 2b20 315d 290a 2020 2020 2020 2020  i + 1]).        
+00014900: 2020 2020 2020 2020 2020 2020 656c 7365              else
+00014910: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00014920: 2020 2020 2020 2020 2020 6973 695f 6d65            isi_me
+00014930: 616e 203d 206e 702e 6d65 616e 2849 5349  an = np.mean(ISI
+00014940: 5b69 202d 2063 6f6e 7365 6375 7469 7665  [i - consecutive
+00014950: 202b 2031 203a 5d29 0a20 2020 2020 2020   + 1 :]).       
+00014960: 2020 2020 2020 2020 2020 2020 2061 6d70               amp
+00014970: 203d 2028 6973 695f 6d65 616e 202f 2066   = (isi_mean / f
+00014980: 6c6f 6174 2863 6f6e 7365 6375 7469 7665  loat(consecutive
+00014990: 2929 202a 2a20 6578 7020 2a20 2831 2e30  )) ** exp * (1.0
+000149a0: 202f 206d 6178 5f62 7572 7374 5f64 7572   / max_burst_dur
+000149b0: 6174 696f 6e2e 6d61 676e 6974 7564 652a  ation.magnitude*
+000149c0: 2a65 7870 290a 2020 2020 2020 2020 2020  *exp).          
+000149d0: 2020 2020 2020 2020 2020 2320 7363 616c            # scal
+000149e0: 6520 7374 6420 6279 2061 6d70 0a20 2020  e std by amp.   
+000149f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014a00: 206d 6f64 5b69 202b 2031 5d20 3d20 616d   mod[i + 1] = am
+00014a10: 7020 2b20 616d 7020 2a20 7364 7261 6e64  p + amp * sdrand
 00014a20: 202a 206e 702e 7261 6e64 6f6d 2e72 616e   * np.random.ran
-00014a30: 646e 286e 5f65 6c29 202b 206d 7261 6e64  dn(n_el) + mrand
-00014a40: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00014a50: 2020 2020 2020 2020 2063 6f6e 7365 6375           consecu
-00014a60: 7469 7665 203d 2030 0a20 2020 2020 2020  tive = 0.       
-00014a70: 2020 2020 2020 2020 2020 2020 2065 6c69               eli
-00014a80: 6620 6c61 7374 5f62 7572 7374 5f65 7665  f last_burst_eve
-00014a90: 6e74 2e6d 6167 6e69 7475 6465 203d 3d20  nt.magnitude == 
-00014aa0: 303a 0a20 2020 2020 2020 2020 2020 2020  0:.             
-00014ab0: 2020 2020 2020 2020 2020 2063 6f6e 7365             conse
-00014ac0: 6375 7469 7665 5f69 6478 203d 206e 702e  cutive_idx = np.
-00014ad0: 7768 6572 6528 2873 7420 3e20 7374 5b69  where((st > st[i
-00014ae0: 5d20 2d20 6d61 785f 6275 7273 745f 6475  ] - max_burst_du
-00014af0: 7261 7469 6f6e 2920 2620 2873 7420 3c3d  ration) & (st <=
-00014b00: 2073 745b 695d 2929 5b30 5d0a 2020 2020   st[i]))[0].    
-00014b10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014b20: 2020 2020 636f 6e73 6563 7574 6976 6520      consecutive 
-00014b30: 3d20 6c65 6e28 636f 6e73 6563 7574 6976  = len(consecutiv
-00014b40: 655f 6964 7829 0a20 2020 2020 2020 2020  e_idx).         
-00014b50: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
-00014b60: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00014b70: 2020 2020 2020 2020 2063 6f6e 7365 6375           consecu
-00014b80: 7469 7665 5f69 6478 203d 206e 702e 7768  tive_idx = np.wh
-00014b90: 6572 6528 2873 7420 3e20 6c61 7374 5f62  ere((st > last_b
-00014ba0: 7572 7374 5f65 7665 6e74 2920 2620 2873  urst_event) & (s
-00014bb0: 7420 3c3d 2073 745b 695d 2929 5b30 5d0a  t <= st[i]))[0].
-00014bc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014bd0: 2020 2020 2020 2020 636f 6e73 6563 7574          consecut
-00014be0: 6976 6520 3d20 6c65 6e28 636f 6e73 6563  ive = len(consec
-00014bf0: 7574 6976 655f 6964 7829 0a0a 2020 2020  utive_idx)..    
-00014c00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014c10: 6966 2063 6f6e 7365 6375 7469 7665 203d  if consecutive =
-00014c20: 3d20 6e5f 7370 696b 6573 3a0a 2020 2020  = n_spikes:.    
-00014c30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014c40: 2020 2020 6c61 7374 5f62 7572 7374 5f65      last_burst_e
-00014c50: 7665 6e74 203d 2073 745b 6920 2b20 315d  vent = st[i + 1]
-00014c60: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00014c70: 2020 2020 2069 6620 636f 6e73 6563 7574       if consecut
-00014c80: 6976 6520 3e3d 2031 3a0a 2020 2020 2020  ive >= 1:.      
-00014c90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014ca0: 2020 6966 2073 745b 6920 2b20 315d 202d    if st[i + 1] -
-00014cb0: 2073 745b 636f 6e73 6563 7574 6976 655f   st[consecutive_
-00014cc0: 6964 785b 305d 5d20 3e3d 206d 6178 5f62  idx[0]] >= max_b
-00014cd0: 7572 7374 5f64 7572 6174 696f 6e3a 0a20  urst_duration:. 
-00014ce0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014cf0: 2020 2020 2020 2020 2020 206c 6173 745f             last_
-00014d00: 6275 7273 745f 6576 656e 7420 3d20 7374  burst_event = st
-00014d10: 5b69 202b 2031 5d20 2d20 302e 3030 3120  [i + 1] - 0.001 
-00014d20: 2a20 7071 2e6d 730a 2020 2020 2020 2020  * pq.ms.        
+00014a30: 646e 2829 0a0a 2020 2020 2020 2020 2020  dn()..          
+00014a40: 2020 2020 2020 636f 6e73 5b69 202b 2031        cons[i + 1
+00014a50: 5d20 3d20 636f 6e73 6563 7574 6976 650a  ] = consecutive.
+00014a60: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+00014a70: 2020 6966 206e 5f73 7069 6b65 7320 3d3d    if n_spikes ==
+00014a80: 2030 3a0a 2020 2020 2020 2020 2020 2020   0:.            
+00014a90: 6d6f 6420 3d20 7364 7261 6e64 202a 206e  mod = sdrand * n
+00014aa0: 702e 7261 6e64 6f6d 2e72 616e 646e 286c  p.random.randn(l
+00014ab0: 656e 2873 7429 2c20 6e5f 656c 2920 2b20  en(st), n_el) + 
+00014ac0: 6d72 616e 640a 2020 2020 2020 2020 2020  mrand.          
+00014ad0: 2020 636f 6e73 203d 205b 5d0a 2020 2020    cons = [].    
+00014ae0: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+00014af0: 2020 2020 2020 4953 4920 3d20 7374 6174        ISI = stat
+00014b00: 2e69 7369 2873 7429 2e72 6573 6361 6c65  .isi(st).rescale
+00014b10: 2822 6d73 2229 0a20 2020 2020 2020 2020  ("ms").         
+00014b20: 2020 206d 6f64 203d 206e 702e 7a65 726f     mod = np.zero
+00014b30: 7328 286c 656e 2873 7429 2c20 6e5f 656c  s((len(st), n_el
+00014b40: 2929 0a20 2020 2020 2020 2020 2020 206d  )).            m
+00014b50: 6f64 5b30 5d20 3d20 7364 7261 6e64 202a  od[0] = sdrand *
+00014b60: 206e 702e 7261 6e64 6f6d 2e72 616e 646e   np.random.randn
+00014b70: 286e 5f65 6c29 202b 206d 7261 6e64 0a20  (n_el) + mrand. 
+00014b80: 2020 2020 2020 2020 2020 2063 6f6e 7320             cons 
+00014b90: 3d20 6e70 2e7a 6572 6f73 286c 656e 2873  = np.zeros(len(s
+00014ba0: 7429 290a 0a20 2020 2020 2020 2020 2020  t))..           
+00014bb0: 206c 6173 745f 6275 7273 745f 6576 656e   last_burst_even
+00014bc0: 7420 3d20 3020 2a20 7071 2e73 0a20 2020  t = 0 * pq.s.   
+00014bd0: 2020 2020 2020 2020 2066 6f72 2069 2c20           for i, 
+00014be0: 6973 6920 696e 2065 6e75 6d65 7261 7465  isi in enumerate
+00014bf0: 2849 5349 293a 0a20 2020 2020 2020 2020  (ISI):.         
+00014c00: 2020 2020 2020 2069 6620 6e5f 7370 696b         if n_spik
+00014c10: 6573 203d 3d20 313a 0a20 2020 2020 2020  es == 1:.       
+00014c20: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+00014c30: 6973 6920 3e20 6d61 785f 6275 7273 745f  isi > max_burst_
+00014c40: 6475 7261 7469 6f6e 3a0a 2020 2020 2020  duration:.      
+00014c50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014c60: 2020 6d6f 645b 6920 2b20 315d 203d 2073    mod[i + 1] = s
+00014c70: 6472 616e 6420 2a20 6e70 2e72 616e 646f  drand * np.rando
+00014c80: 6d2e 7261 6e64 6e28 6e5f 656c 2920 2b20  m.randn(n_el) + 
+00014c90: 6d72 616e 640a 2020 2020 2020 2020 2020  mrand.          
+00014ca0: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
+00014cb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014cc0: 2020 2020 2020 2020 6d6f 645b 6920 2b20          mod[i + 
+00014cd0: 315d 203d 2069 7369 2e6d 6167 6e69 7475  1] = isi.magnitu
+00014ce0: 6465 2a2a 6578 7020 2a20 280a 2020 2020  de**exp * (.    
+00014cf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014d00: 2020 2020 2020 2020 312e 3020 2f20 6d61          1.0 / ma
+00014d10: 785f 6275 7273 745f 6475 7261 7469 6f6e  x_burst_duration
+00014d20: 2e6d 6167 6e69 7475 6465 2a2a 6578 700a  .magnitude**exp.
 00014d30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014d40: 2020 2020 636f 6e73 6563 7574 6976 6520      consecutive 
-00014d50: 3d20 300a 0a20 2020 2020 2020 2020 2020  = 0..           
-00014d60: 2020 2020 2020 2020 2069 6620 636f 6e73           if cons
-00014d70: 6563 7574 6976 6520 3d3d 2030 3a0a 2020  ecutive == 0:.  
-00014d80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014d90: 2020 2020 2020 6d6f 645b 6920 2b20 315d        mod[i + 1]
-00014da0: 203d 2073 6472 616e 6420 2a20 6e70 2e72   = sdrand * np.r
-00014db0: 616e 646f 6d2e 7261 6e64 6e28 6e5f 656c  andom.randn(n_el
-00014dc0: 2920 2b20 6d72 616e 640a 2020 2020 2020  ) + mrand.      
-00014dd0: 2020 2020 2020 2020 2020 2020 2020 656c                el
-00014de0: 6966 2063 6f6e 7365 6375 7469 7665 203d  if consecutive =
-00014df0: 3d20 313a 0a20 2020 2020 2020 2020 2020  = 1:.           
-00014e00: 2020 2020 2020 2020 2020 2020 2061 6d70               amp
-00014e10: 203d 2028 6973 692e 6d61 676e 6974 7564   = (isi.magnitud
-00014e20: 6520 2f20 666c 6f61 7428 636f 6e73 6563  e / float(consec
-00014e30: 7574 6976 6529 2920 2a2a 2065 7870 202a  utive)) ** exp *
-00014e40: 2028 312e 202f 206d 6178 5f62 7572 7374   (1. / max_burst
-00014e50: 5f64 7572 6174 696f 6e2e 6d61 676e 6974  _duration.magnit
-00014e60: 7564 6520 2a2a 2065 7870 290a 2020 2020  ude ** exp).    
-00014e70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014e80: 2020 2020 2320 7363 616c 6520 7374 6420      # scale std 
-00014e90: 6279 2061 6d70 0a20 2020 2020 2020 2020  by amp.         
-00014ea0: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-00014eb0: 6620 616d 7020 3e20 313a 0a20 2020 2020  f amp > 1:.     
-00014ec0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014ed0: 2020 2020 2020 2072 6169 7365 2045 7863         raise Exc
-00014ee0: 6570 7469 6f6e 0a20 2020 2020 2020 2020  eption.         
-00014ef0: 2020 2020 2020 2020 2020 2020 2020 206d                 m
-00014f00: 6f64 5b69 202b 2031 5d20 3d20 616d 7020  od[i + 1] = amp 
-00014f10: 2b20 616d 7020 2a20 7364 7261 6e64 202a  + amp * sdrand *
-00014f20: 206e 702e 7261 6e64 6f6d 2e72 616e 646e   np.random.randn
-00014f30: 286e 5f65 6c29 0a20 2020 2020 2020 2020  (n_el).         
-00014f40: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
-00014f50: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00014f60: 2020 2020 2020 2020 2069 6620 6920 213d           if i !=
-00014f70: 206c 656e 2849 5349 293a 0a20 2020 2020   len(ISI):.     
+00014d40: 2020 2020 2020 2020 2920 2b20 7364 7261          ) + sdra
+00014d50: 6e64 202a 206e 702e 7261 6e64 6f6d 2e72  nd * np.random.r
+00014d60: 616e 646e 286e 5f65 6c29 0a20 2020 2020  andn(n_el).     
+00014d70: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
+00014d80: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00014d90: 2020 2020 2069 6620 6973 6920 3e20 6d61       if isi > ma
+00014da0: 785f 6275 7273 745f 6475 7261 7469 6f6e  x_burst_duration
+00014db0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00014dc0: 2020 2020 2020 2020 2020 6d6f 645b 6920            mod[i 
+00014dd0: 2b20 315d 203d 2073 6472 616e 6420 2a20  + 1] = sdrand * 
+00014de0: 6e70 2e72 616e 646f 6d2e 7261 6e64 6e28  np.random.randn(
+00014df0: 6e5f 656c 2920 2b20 6d72 616e 640a 2020  n_el) + mrand.  
+00014e00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014e10: 2020 2020 2020 636f 6e73 6563 7574 6976        consecutiv
+00014e20: 6520 3d20 300a 2020 2020 2020 2020 2020  e = 0.          
+00014e30: 2020 2020 2020 2020 2020 656c 6966 206c            elif l
+00014e40: 6173 745f 6275 7273 745f 6576 656e 742e  ast_burst_event.
+00014e50: 6d61 676e 6974 7564 6520 3d3d 2030 3a0a  magnitude == 0:.
+00014e60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014e70: 2020 2020 2020 2020 636f 6e73 6563 7574          consecut
+00014e80: 6976 655f 6964 7820 3d20 6e70 2e77 6865  ive_idx = np.whe
+00014e90: 7265 2828 7374 203e 2073 745b 695d 202d  re((st > st[i] -
+00014ea0: 206d 6178 5f62 7572 7374 5f64 7572 6174   max_burst_durat
+00014eb0: 696f 6e29 2026 2028 7374 203c 3d20 7374  ion) & (st <= st
+00014ec0: 5b69 5d29 295b 305d 0a20 2020 2020 2020  [i]))[0].       
+00014ed0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014ee0: 2063 6f6e 7365 6375 7469 7665 203d 206c   consecutive = l
+00014ef0: 656e 2863 6f6e 7365 6375 7469 7665 5f69  en(consecutive_i
+00014f00: 6478 290a 2020 2020 2020 2020 2020 2020  dx).            
+00014f10: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+00014f20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014f30: 2020 2020 2020 636f 6e73 6563 7574 6976        consecutiv
+00014f40: 655f 6964 7820 3d20 6e70 2e77 6865 7265  e_idx = np.where
+00014f50: 2828 7374 203e 206c 6173 745f 6275 7273  ((st > last_burs
+00014f60: 745f 6576 656e 7429 2026 2028 7374 203c  t_event) & (st <
+00014f70: 3d20 7374 5b69 5d29 295b 305d 0a20 2020  = st[i]))[0].   
 00014f80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014f90: 2020 2020 2020 2069 7369 5f6d 6561 6e20         isi_mean 
-00014fa0: 3d20 6e70 2e6d 6561 6e28 4953 495b 6920  = np.mean(ISI[i 
-00014fb0: 2d20 636f 6e73 6563 7574 6976 6520 2b20  - consecutive + 
-00014fc0: 313a 6920 2b20 315d 290a 2020 2020 2020  1:i + 1]).      
-00014fd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014fe0: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+00014f90: 2020 2020 2063 6f6e 7365 6375 7469 7665       consecutive
+00014fa0: 203d 206c 656e 2863 6f6e 7365 6375 7469   = len(consecuti
+00014fb0: 7665 5f69 6478 290a 0a20 2020 2020 2020  ve_idx)..       
+00014fc0: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+00014fd0: 636f 6e73 6563 7574 6976 6520 3d3d 206e  consecutive == n
+00014fe0: 5f73 7069 6b65 733a 0a20 2020 2020 2020  _spikes:.       
 00014ff0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015000: 2020 2020 6973 695f 6d65 616e 203d 206e      isi_mean = n
-00015010: 702e 6d65 616e 2849 5349 5b69 202d 2063  p.mean(ISI[i - c
-00015020: 6f6e 7365 6375 7469 7665 202b 2031 3a5d  onsecutive + 1:]
-00015030: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-00015040: 2020 2020 2020 2020 2020 616d 7020 3d20            amp = 
-00015050: 2869 7369 5f6d 6561 6e20 2f20 666c 6f61  (isi_mean / floa
-00015060: 7428 636f 6e73 6563 7574 6976 6529 2920  t(consecutive)) 
-00015070: 2a2a 2065 7870 202a 2028 312e 202f 206d  ** exp * (1. / m
-00015080: 6178 5f62 7572 7374 5f64 7572 6174 696f  ax_burst_duratio
-00015090: 6e2e 6d61 676e 6974 7564 6520 2a2a 2065  n.magnitude ** e
-000150a0: 7870 290a 2020 2020 2020 2020 2020 2020  xp).            
-000150b0: 2020 2020 2020 2020 2020 2020 2320 7363              # sc
-000150c0: 616c 6520 7374 6420 6279 2061 6d70 0a20  ale std by amp. 
-000150d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000150e0: 2020 2020 2020 206d 6f64 5b69 202b 2031         mod[i + 1
-000150f0: 5d20 3d20 616d 7020 2b20 616d 7020 2a20  ] = amp + amp * 
-00015100: 7364 7261 6e64 202a 206e 702e 7261 6e64  sdrand * np.rand
-00015110: 6f6d 2e72 616e 646e 286e 5f65 6c29 0a20  om.randn(n_el). 
-00015120: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015130: 2020 2063 6f6e 735b 6920 2b20 315d 203d     cons[i + 1] =
-00015140: 2063 6f6e 7365 6375 7469 7665 0a0a 2020   consecutive..  
-00015150: 2020 7265 7475 726e 206e 702e 6172 7261    return np.arra
-00015160: 7928 6d6f 6429 2c20 636f 6e73 0a0a 0a64  y(mod), cons...d
-00015170: 6566 2063 6f6d 7075 7465 5f62 7572 7374  ef compute_burst
-00015180: 696e 675f 7465 6d70 6c61 7465 2874 656d  ing_template(tem
-00015190: 706c 6174 652c 206d 6f64 2c20 7763 5f6d  plate, mod, wc_m
-000151a0: 6f64 2c20 6669 6c74 6669 6c74 3d46 616c  od, filtfilt=Fal
-000151b0: 7365 293a 0a20 2020 2022 2222 0a20 2020  se):.    """.   
-000151c0: 2043 6f6d 7075 7465 206d 6f64 756c 6174   Compute modulat
-000151d0: 696f 6e20 696e 2073 6861 7065 2066 6f72  ion in shape for
-000151e0: 2061 2074 656d 706c 6174 6520 7769 7468   a template with
-000151f0: 206c 6f77 2d70 6173 7320 6669 6c74 6572   low-pass filter
-00015200: 2e0a 0a20 2020 2050 6172 616d 6574 6572  ...    Parameter
-00015210: 730a 2020 2020 2d2d 2d2d 2d2d 2d2d 2d2d  s.    ----------
-00015220: 0a20 2020 2074 656d 706c 6174 6520 3a20  .    template : 
-00015230: 6e70 2e61 7272 6179 0a20 2020 2020 2020  np.array.       
-00015240: 2054 656d 706c 6174 6520 746f 2062 6520   Template to be 
-00015250: 6d6f 6475 6c61 7465 6420 286e 756d 5f63  modulated (num_c
-00015260: 6861 6e2c 206e 5f73 616d 706c 6573 2920  han, n_samples) 
-00015270: 6f72 2028 6e5f 7361 6d70 6c65 7329 0a20  or (n_samples). 
-00015280: 2020 206d 6f64 203a 2069 6e74 206f 7220     mod : int or 
-00015290: 6e70 2e61 7272 6179 0a20 2020 2020 2020  np.array.       
-000152a0: 2041 6d70 6c69 7475 6465 206d 6f64 756c   Amplitude modul
-000152b0: 6174 696f 6e20 666f 7220 7465 6d70 6c61  ation for templa
-000152c0: 7465 206f 7220 7369 6e67 6c65 2065 6c65  te or single ele
-000152d0: 6374 726f 6465 730a 2020 2020 7763 5f6d  ctrodes.    wc_m
-000152e0: 6f64 203a 2066 6c6f 6174 0a20 2020 2020  od : float.     
-000152f0: 2020 204e 6f72 6d61 6c69 7a65 6420 6672     Normalized fr
-00015300: 6571 7565 6e63 7920 6f66 206c 6f77 2d70  equency of low-p
-00015310: 6173 7320 6669 6c74 6572 0a20 2020 2066  ass filter.    f
-00015320: 696c 7466 696c 743a 2062 6f6f 6c0a 2020  iltfilt: bool.  
-00015330: 2020 2020 2020 4966 2054 7275 6520 666f        If True fo
-00015340: 7277 6172 642d 6261 636b 7761 7264 2066  rward-backward f
-00015350: 696c 7465 7220 6973 2075 7365 640a 0a20  ilter is used.. 
-00015360: 2020 2052 6574 7572 6e73 0a20 2020 202d     Returns.    -
-00015370: 2d2d 2d2d 2d2d 0a20 2020 2074 656d 705f  ------.    temp_
-00015380: 6669 6c74 203a 206e 702e 6172 7261 790a  filt : np.array.
-00015390: 2020 2020 2020 2020 4d6f 6475 6c61 7465          Modulate
-000153a0: 6420 7465 6d70 6c61 7465 0a0a 2020 2020  d template..    
-000153b0: 2222 220a 2020 2020 696d 706f 7274 2073  """.    import s
-000153c0: 6369 7079 2e73 6967 6e61 6c20 6173 2073  cipy.signal as s
-000153d0: 730a 2020 2020 622c 2061 203d 2073 732e  s.    b, a = ss.
-000153e0: 6275 7474 6572 2833 2c20 7763 5f6d 6f64  butter(3, wc_mod
-000153f0: 290a 2020 2020 6966 206c 656e 2874 656d  ).    if len(tem
-00015400: 706c 6174 652e 7368 6170 6529 203d 3d20  plate.shape) == 
-00015410: 323a 0a20 2020 2020 2020 2069 6620 6669  2:.        if fi
-00015420: 6c74 6669 6c74 3a0a 2020 2020 2020 2020  ltfilt:.        
-00015430: 2020 2020 7465 6d70 5f66 696c 7420 3d20      temp_filt = 
-00015440: 7373 2e66 696c 7466 696c 7428 622c 2061  ss.filtfilt(b, a
-00015450: 2c20 7465 6d70 6c61 7465 2c20 6178 6973  , template, axis
-00015460: 3d31 290a 2020 2020 2020 2020 656c 7365  =1).        else
-00015470: 3a0a 2020 2020 2020 2020 2020 2020 7465  :.            te
-00015480: 6d70 5f66 696c 7420 3d20 7373 2e6c 6669  mp_filt = ss.lfi
-00015490: 6c74 6572 2862 2c20 612c 2074 656d 706c  lter(b, a, templ
-000154a0: 6174 652c 2061 7869 733d 3129 0a20 2020  ate, axis=1).   
-000154b0: 2020 2020 2069 6620 6d6f 642e 7369 7a65       if mod.size
-000154c0: 203e 2031 3a0a 2020 2020 2020 2020 2020   > 1:.          
-000154d0: 2020 7465 6d70 5f66 696c 7420 3d20 6e70    temp_filt = np
-000154e0: 2e61 7272 6179 285b 6d20 2a20 6e70 2e6d  .array([m * np.m
-000154f0: 696e 2874 656d 7029 202f 206e 702e 6d69  in(temp) / np.mi
-00015500: 6e28 7465 6d70 5f66 2920 2a0a 2020 2020  n(temp_f) *.    
-00015510: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015520: 2020 2020 2020 2020 2020 2020 2020 7465                te
-00015530: 6d70 5f66 2066 6f72 2028 6d2c 2074 656d  mp_f for (m, tem
-00015540: 702c 2074 656d 705f 6629 2069 6e20 7a69  p, temp_f) in zi
-00015550: 7028 6d6f 642c 2074 656d 706c 6174 652c  p(mod, template,
-00015560: 2074 656d 705f 6669 6c74 295d 290a 2020   temp_filt)]).  
-00015570: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
-00015580: 2020 2020 2020 2020 7465 6d70 5f66 696c          temp_fil
-00015590: 7420 3d20 286d 6f64 202a 206e 702e 6d69  t = (mod * np.mi
-000155a0: 6e28 7465 6d70 6c61 7465 2920 2f20 6e70  n(template) / np
-000155b0: 2e6d 696e 2874 656d 705f 6669 6c74 2929  .min(temp_filt))
-000155c0: 202a 2074 656d 705f 6669 6c74 0a20 2020   * temp_filt.   
-000155d0: 2065 6c73 653a 0a20 2020 2020 2020 2069   else:.        i
-000155e0: 6620 6669 6c74 6669 6c74 3a0a 2020 2020  f filtfilt:.    
-000155f0: 2020 2020 2020 2020 7465 6d70 5f66 696c          temp_fil
-00015600: 7420 3d20 7373 2e66 696c 7466 696c 7428  t = ss.filtfilt(
-00015610: 622c 2061 2c20 7465 6d70 6c61 7465 290a  b, a, template).
-00015620: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
-00015630: 2020 2020 2020 2020 2020 7465 6d70 5f66            temp_f
-00015640: 696c 7420 3d20 7373 2e6c 6669 6c74 6572  ilt = ss.lfilter
-00015650: 2862 2c20 612c 2074 656d 706c 6174 6529  (b, a, template)
-00015660: 0a20 2020 2020 2020 2074 656d 705f 6669  .        temp_fi
-00015670: 6c74 203d 2028 6d6f 6420 2a20 6e70 2e6d  lt = (mod * np.m
-00015680: 696e 2874 656d 706c 6174 6529 202f 206e  in(template) / n
-00015690: 702e 6d69 6e28 7465 6d70 5f66 696c 7429  p.min(temp_filt)
-000156a0: 2920 2a20 7465 6d70 5f66 696c 740a 2020  ) * temp_filt.  
-000156b0: 2020 7265 7475 726e 2074 656d 705f 6669    return temp_fi
-000156c0: 6c74 0a0a 0a64 6566 2073 6967 6d6f 6964  lt...def sigmoid
-000156d0: 2878 2c20 623d 3129 3a0a 2020 2020 2222  (x, b=1):.    ""
-000156e0: 220a 2020 2020 436f 6d70 7574 6520 7369  ".    Compute si
-000156f0: 676d 6f69 6420 6675 6e63 7469 6f6e 0a0a  gmoid function..
-00015700: 2020 2020 5061 7261 6d65 7465 7273 0a20      Parameters. 
-00015710: 2020 202d 2d2d 2d2d 2d2d 2d2d 2d0a 2020     ----------.  
-00015720: 2020 783a 206e 702e 6172 7261 790a 2020    x: np.array.  
-00015730: 2020 2020 2020 4172 7261 7920 746f 2063        Array to c
-00015740: 6f6d 7075 7465 2073 6967 6d6f 6964 0a20  ompute sigmoid. 
-00015750: 2020 2062 3a20 666c 6f61 740a 2020 2020     b: float.    
-00015760: 2020 2020 5369 676d 6f69 6420 736c 6f70      Sigmoid slop
-00015770: 650a 0a20 2020 2052 6574 7572 6e73 0a20  e..    Returns. 
-00015780: 2020 202d 2d2d 2d2d 2d2d 0a20 2020 2078     -------.    x
-00015790: 5f73 6967 3a20 6e70 2e61 7272 6179 0a20  _sig: np.array. 
-000157a0: 2020 2020 2020 204f 7574 7075 7420 7369         Output si
-000157b0: 676d 6f69 6420 6172 7261 790a 2020 2020  gmoid array.    
-000157c0: 2222 220a 2020 2020 7265 7475 726e 2031  """.    return 1
-000157d0: 202f 2028 3120 2b20 6e70 2e65 7870 282d   / (1 + np.exp(-
-000157e0: 6220 2a20 7829 2920 2d20 302e 350a 0a0a  b * x)) - 0.5...
-000157f0: 6465 6620 636f 6d70 7574 655f 7374 7265  def compute_stre
-00015800: 7463 6865 645f 7465 6d70 6c61 7465 2874  tched_template(t
-00015810: 656d 706c 6174 652c 206d 6f64 2c20 7368  emplate, mod, sh
-00015820: 6170 655f 7374 7265 7463 683d 3330 2e29  ape_stretch=30.)
-00015830: 3a0a 2020 2020 2222 220a 2020 2020 436f  :.    """.    Co
-00015840: 6d70 7574 6520 6d6f 6475 6c61 7469 6f6e  mpute modulation
-00015850: 2069 6e20 7368 6170 6520 666f 7220 6120   in shape for a 
-00015860: 7465 6d70 6c61 7465 2077 6974 6820 6c6f  template with lo
-00015870: 772d 7061 7373 2066 696c 7465 722e 0a0a  w-pass filter...
-00015880: 2020 2020 5061 7261 6d65 7465 7273 0a20      Parameters. 
-00015890: 2020 202d 2d2d 2d2d 2d2d 2d2d 2d0a 2020     ----------.  
-000158a0: 2020 7465 6d70 6c61 7465 203a 206e 702e    template : np.
-000158b0: 6172 7261 790a 2020 2020 2020 2020 5465  array.        Te
-000158c0: 6d70 6c61 7465 2074 6f20 6265 206d 6f64  mplate to be mod
-000158d0: 756c 6174 6564 2028 6e75 6d5f 6368 616e  ulated (num_chan
-000158e0: 2c20 6e5f 7361 6d70 6c65 7329 206f 7220  , n_samples) or 
-000158f0: 286e 5f73 616d 706c 6573 290a 2020 2020  (n_samples).    
-00015900: 6d6f 6420 3a20 696e 7420 6f72 206e 702e  mod : int or np.
-00015910: 6172 7261 790a 2020 2020 2020 2020 416d  array.        Am
-00015920: 706c 6974 7564 6520 6d6f 6475 6c61 7469  plitude modulati
-00015930: 6f6e 2066 6f72 2074 656d 706c 6174 6520  on for template 
-00015940: 6f72 2073 696e 676c 6520 656c 6563 7472  or single electr
-00015950: 6f64 6573 0a20 2020 2073 6861 7065 5f73  odes.    shape_s
-00015960: 7472 6574 6368 203a 2066 6c6f 6174 0a20  tretch : float. 
-00015970: 2020 2020 2020 2053 6967 6d6f 6964 2072         Sigmoid r
-00015980: 616e 6765 2074 6f20 7374 7265 7463 6820  ange to stretch 
-00015990: 7468 6520 7465 6d70 6c61 7465 0a0a 2020  the template..  
-000159a0: 2020 5265 7475 726e 730a 2020 2020 2d2d    Returns.    --
-000159b0: 2d2d 2d2d 2d0a 2020 2020 7465 6d70 5f66  -----.    temp_f
-000159c0: 696c 7420 3a20 6e70 2e61 7272 6179 0a20  ilt : np.array. 
-000159d0: 2020 2020 2020 204d 6f64 756c 6174 6564         Modulated
-000159e0: 2074 656d 706c 6174 650a 2020 2020 2222   template.    ""
-000159f0: 220a 2020 2020 696d 706f 7274 2073 6369  ".    import sci
-00015a00: 7079 2e69 6e74 6572 706f 6c61 7465 2061  py.interpolate a
-00015a10: 7320 696e 7465 7270 0a0a 2020 2020 6966  s interp..    if
-00015a20: 2069 7369 6e73 7461 6e63 6528 6d6f 642c   isinstance(mod,
-00015a30: 2028 696e 742c 206e 702e 696e 7465 6765   (int, np.intege
-00015a40: 7229 293a 0a20 2020 2020 2020 206d 6f64  r)):.        mod
-00015a50: 203d 206e 702e 6172 7261 7928 6d6f 6429   = np.array(mod)
-00015a60: 0a0a 2020 2020 6966 206d 6f64 2e73 697a  ..    if mod.siz
-00015a70: 6520 3e20 313a 0a20 2020 2020 2020 2073  e > 1:.        s
-00015a80: 7472 6574 6368 5f66 6163 746f 7220 3d20  tretch_factor = 
-00015a90: 6e70 2e6d 6561 6e28 6d6f 6429 0a20 2020  np.mean(mod).   
-00015aa0: 2020 2020 206d 6f64 5f76 616c 7565 203d       mod_value =
-00015ab0: 206e 702e 6d65 616e 286d 6f64 290a 2020   np.mean(mod).  
-00015ac0: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
-00015ad0: 7374 7265 7463 685f 6661 6374 6f72 203d  stretch_factor =
-00015ae0: 206d 6f64 0a20 2020 2020 2020 206d 6f64   mod.        mod
-00015af0: 5f76 616c 7565 203d 206d 6f64 0a0a 2020  _value = mod..  
-00015b00: 2020 6966 206c 656e 2874 656d 706c 6174    if len(templat
-00015b10: 652e 7368 6170 6529 203d 3d20 323a 0a20  e.shape) == 2:. 
-00015b20: 2020 2020 2020 206d 696e 5f69 6478 203d         min_idx =
-00015b30: 206e 702e 756e 7261 7665 6c5f 696e 6465   np.unravel_inde
-00015b40: 7828 6e70 2e61 7267 6d69 6e28 7465 6d70  x(np.argmin(temp
-00015b50: 6c61 7465 292c 2074 656d 706c 6174 652e  late), template.
-00015b60: 7368 6170 6529 5b31 5d0a 2020 2020 2020  shape)[1].      
-00015b70: 2020 785f 6365 6e74 6572 6564 203d 206e    x_centered = n
-00015b80: 702e 6172 616e 6765 282d 6d69 6e5f 6964  p.arange(-min_id
-00015b90: 782c 2074 656d 706c 6174 652e 7368 6170  x, template.shap
-00015ba0: 655b 315d 202d 206d 696e 5f69 6478 290a  e[1] - min_idx).
-00015bb0: 2020 2020 2020 2020 785f 6365 6e74 6572          x_center
-00015bc0: 6564 203d 2078 5f63 656e 7465 7265 6420  ed = x_centered 
-00015bd0: 2f20 666c 6f61 7428 6e70 2e70 7470 2878  / float(np.ptp(x
-00015be0: 5f63 656e 7465 7265 6429 290a 2020 2020  _centered)).    
-00015bf0: 2020 2020 785f 6365 6e74 6572 6564 203d      x_centered =
-00015c00: 2078 5f63 656e 7465 7265 6420 2a20 7368   x_centered * sh
-00015c10: 6170 655f 7374 7265 7463 680a 0a20 2020  ape_stretch..   
-00015c20: 2020 2020 2069 6620 7374 7265 7463 685f       if stretch_
-00015c30: 6661 6374 6f72 203e 3d20 313a 0a20 2020  factor >= 1:.   
-00015c40: 2020 2020 2020 2020 2078 5f73 7472 6574           x_stret
-00015c50: 6368 203d 2078 5f63 656e 7465 7265 640a  ch = x_centered.
-00015c60: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
-00015c70: 2020 2020 2020 2020 2020 785f 7374 7265            x_stre
-00015c80: 7463 6820 3d20 7369 676d 6f69 6428 785f  tch = sigmoid(x_
-00015c90: 6365 6e74 6572 6564 2c20 3120 2d20 7374  centered, 1 - st
-00015ca0: 7265 7463 685f 6661 6374 6f72 290a 0a20  retch_factor).. 
-00015cb0: 2020 2020 2020 2078 5f73 7472 6574 6368         x_stretch
-00015cc0: 203d 2078 5f73 7472 6574 6368 202f 2066   = x_stretch / f
-00015cd0: 6c6f 6174 286e 702e 7074 7028 785f 7374  loat(np.ptp(x_st
-00015ce0: 7265 7463 6829 290a 2020 2020 2020 2020  retch)).        
-00015cf0: 785f 7374 7265 7463 6820 2a3d 2073 6861  x_stretch *= sha
-00015d00: 7065 5f73 7472 6574 6368 202b 2028 6e70  pe_stretch + (np
-00015d10: 2e6d 696e 2878 5f63 656e 7465 7265 6429  .min(x_centered)
-00015d20: 202d 206e 702e 6d69 6e28 785f 7374 7265   - np.min(x_stre
-00015d30: 7463 6829 290a 2020 2020 2020 2020 785f  tch)).        x_
-00015d40: 7265 636f 7665 7265 6420 3d20 6e70 2e6d  recovered = np.m
-00015d50: 6178 2878 5f73 7472 6574 6368 2920 2f20  ax(x_stretch) / 
-00015d60: 6e70 2e6d 6178 2878 5f63 656e 7465 7265  np.max(x_centere
-00015d70: 6429 202a 2078 5f63 656e 7465 7265 640a  d) * x_centered.
-00015d80: 2020 2020 2020 2020 785f 7374 7265 7463          x_stretc
-00015d90: 6820 3d20 6e70 2e72 6f75 6e64 2878 5f73  h = np.round(x_s
-00015da0: 7472 6574 6368 2c20 3629 0a20 2020 2020  tretch, 6).     
-00015db0: 2020 2078 5f72 6563 6f76 6572 6564 203d     x_recovered =
-00015dc0: 206e 702e 726f 756e 6428 785f 7265 636f   np.round(x_reco
-00015dd0: 7665 7265 642c 2036 290a 2020 2020 2020  vered, 6).      
-00015de0: 2020 7465 6d70 5f66 696c 7420 3d20 6e70    temp_filt = np
-00015df0: 2e7a 6572 6f73 2874 656d 706c 6174 652e  .zeros(template.
-00015e00: 7368 6170 6529 0a20 2020 2020 2020 2066  shape).        f
-00015e10: 6f72 2069 2c20 7420 696e 2065 6e75 6d65  or i, t in enume
-00015e20: 7261 7465 2874 656d 706c 6174 6529 3a0a  rate(template):.
-00015e30: 2020 2020 2020 2020 2020 2020 7472 793a              try:
-00015e40: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00015e50: 2066 203d 2069 6e74 6572 702e 696e 7465   f = interp.inte
-00015e60: 7270 3164 2878 5f73 7472 6574 6368 2c20  rp1d(x_stretch, 
-00015e70: 742c 206b 696e 643d 2763 7562 6963 2729  t, kind='cubic')
-00015e80: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00015e90: 2074 656d 705f 6669 6c74 5b69 5d20 3d20   temp_filt[i] = 
-00015ea0: 6628 785f 7265 636f 7665 7265 6429 0a20  f(x_recovered). 
-00015eb0: 2020 2020 2020 2020 2020 2065 7863 6570             excep
-00015ec0: 7420 4578 6365 7074 696f 6e20 6173 2065  t Exception as e
-00015ed0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00015ee0: 2020 7261 6973 6520 4578 6365 7074 696f    raise Exceptio
-00015ef0: 6e28 2227 7368 6170 655f 7374 7265 7463  n("'shape_stretc
-00015f00: 6827 2069 7320 746f 6f20 6c61 7267 652e  h' is too large.
-00015f10: 2054 7279 2072 6564 7563 696e 6720 6974   Try reducing it
-00015f20: 2028 6465 6661 756c 7420 3d20 3330 2922   (default = 30)"
-00015f30: 290a 2020 2020 2020 2020 6966 206d 6f64  ).        if mod
-00015f40: 2e73 697a 6520 3e20 313a 0a20 2020 2020  .size > 1:.     
-00015f50: 2020 2020 2020 2074 656d 705f 6669 6c74         temp_filt
-00015f60: 203d 206e 702e 6172 7261 7928 5b6d 202a   = np.array([m *
-00015f70: 206e 702e 6d69 6e28 7465 6d70 2920 2f20   np.min(temp) / 
-00015f80: 6e70 2e6d 696e 2874 656d 705f 6629 202a  np.min(temp_f) *
-00015f90: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00015fa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015fb0: 2020 2074 656d 705f 6620 666f 7220 286d     temp_f for (m
-00015fc0: 2c20 7465 6d70 2c20 7465 6d70 5f66 2920  , temp, temp_f) 
-00015fd0: 696e 207a 6970 286d 6f64 2c20 7465 6d70  in zip(mod, temp
-00015fe0: 6c61 7465 2c20 7465 6d70 5f66 696c 7429  late, temp_filt)
-00015ff0: 5d29 0a20 2020 2020 2020 2065 6c73 653a  ]).        else:
-00016000: 0a20 2020 2020 2020 2020 2020 2074 656d  .            tem
-00016010: 705f 6669 6c74 203d 2028 6d6f 6420 2a20  p_filt = (mod * 
-00016020: 6e70 2e6d 696e 2874 656d 706c 6174 6529  np.min(template)
-00016030: 202f 206e 702e 6d69 6e28 7465 6d70 5f66   / np.min(temp_f
-00016040: 696c 7429 2920 2a20 7465 6d70 5f66 696c  ilt)) * temp_fil
-00016050: 740a 2020 2020 656c 7365 3a0a 2020 2020  t.    else:.    
-00016060: 2020 2020 6d69 6e5f 6964 7820 3d20 6e70      min_idx = np
-00016070: 2e61 7267 6d69 6e28 7465 6d70 6c61 7465  .argmin(template
-00016080: 290a 2020 2020 2020 2020 785f 6365 6e74  ).        x_cent
-00016090: 6572 6564 203d 206e 702e 6172 616e 6765  ered = np.arange
-000160a0: 282d 6d69 6e5f 6964 782c 206c 656e 2874  (-min_idx, len(t
-000160b0: 656d 706c 6174 6529 202d 206d 696e 5f69  emplate) - min_i
-000160c0: 6478 290a 2020 2020 2020 2020 785f 6365  dx).        x_ce
-000160d0: 6e74 6572 6564 203d 2078 5f63 656e 7465  ntered = x_cente
-000160e0: 7265 6420 2f20 666c 6f61 7428 6e70 2e70  red / float(np.p
-000160f0: 7470 2878 5f63 656e 7465 7265 6429 290a  tp(x_centered)).
-00016100: 2020 2020 2020 2020 785f 6365 6e74 6572          x_center
-00016110: 6564 203d 2078 5f63 656e 7465 7265 6420  ed = x_centered 
-00016120: 2a20 7368 6170 655f 7374 7265 7463 680a  * shape_stretch.
-00016130: 0a20 2020 2020 2020 2069 6620 7374 7265  .        if stre
-00016140: 7463 685f 6661 6374 6f72 203e 3d20 313a  tch_factor >= 1:
-00016150: 0a20 2020 2020 2020 2020 2020 2078 5f73  .            x_s
-00016160: 7472 6574 6368 203d 2078 5f63 656e 7465  tretch = x_cente
-00016170: 7265 640a 2020 2020 2020 2020 656c 7365  red.        else
-00016180: 3a0a 2020 2020 2020 2020 2020 2020 785f  :.            x_
-00016190: 7374 7265 7463 6820 3d20 7369 676d 6f69  stretch = sigmoi
-000161a0: 6428 785f 6365 6e74 6572 6564 2c20 3120  d(x_centered, 1 
-000161b0: 2d20 7374 7265 7463 685f 6661 6374 6f72  - stretch_factor
-000161c0: 290a 2020 2020 2020 2020 785f 7374 7265  ).        x_stre
-000161d0: 7463 6820 3d20 785f 7374 7265 7463 6820  tch = x_stretch 
-000161e0: 2f20 666c 6f61 7428 6e70 2e70 7470 2878  / float(np.ptp(x
-000161f0: 5f73 7472 6574 6368 2929 0a20 2020 2020  _stretch)).     
-00016200: 2020 2078 5f73 7472 6574 6368 202a 3d20     x_stretch *= 
-00016210: 7368 6170 655f 7374 7265 7463 6820 2b20  shape_stretch + 
-00016220: 286e 702e 6d69 6e28 785f 6365 6e74 6572  (np.min(x_center
-00016230: 6564 2920 2d20 6e70 2e6d 696e 2878 5f73  ed) - np.min(x_s
-00016240: 7472 6574 6368 2929 0a20 2020 2020 2020  tretch)).       
-00016250: 2078 5f72 6563 6f76 6572 6564 203d 206e   x_recovered = n
-00016260: 702e 6d61 7828 785f 7374 7265 7463 6829  p.max(x_stretch)
-00016270: 202f 206e 702e 6d61 7828 785f 6365 6e74   / np.max(x_cent
-00016280: 6572 6564 2920 2a20 785f 6365 6e74 6572  ered) * x_center
-00016290: 6564 0a20 2020 2020 2020 2078 5f73 7472  ed.        x_str
-000162a0: 6574 6368 203d 206e 702e 726f 756e 6428  etch = np.round(
-000162b0: 785f 7374 7265 7463 682c 2036 290a 2020  x_stretch, 6).  
-000162c0: 2020 2020 2020 785f 7265 636f 7665 7265        x_recovere
-000162d0: 6420 3d20 6e70 2e72 6f75 6e64 2878 5f72  d = np.round(x_r
-000162e0: 6563 6f76 6572 6564 2c20 3629 0a20 2020  ecovered, 6).   
-000162f0: 2020 2020 2074 7279 3a0a 2020 2020 2020       try:.      
-00016300: 2020 2020 2020 6620 3d20 696e 7465 7270        f = interp
-00016310: 2e69 6e74 6572 7031 6428 785f 7374 7265  .interp1d(x_stre
-00016320: 7463 682c 2074 656d 706c 6174 652c 206b  tch, template, k
-00016330: 696e 643d 2763 7562 6963 2729 0a20 2020  ind='cubic').   
-00016340: 2020 2020 2020 2020 2074 656d 705f 6669           temp_fi
-00016350: 6c74 203d 2066 2878 5f72 6563 6f76 6572  lt = f(x_recover
-00016360: 6564 290a 2020 2020 2020 2020 6578 6365  ed).        exce
-00016370: 7074 2045 7863 6570 7469 6f6e 2061 7320  pt Exception as 
-00016380: 653a 0a20 2020 2020 2020 2020 2020 2072  e:.            r
-00016390: 6169 7365 2045 7863 6570 7469 6f6e 2822  aise Exception("
-000163a0: 2773 6861 7065 5f73 7472 6574 6368 2720  'shape_stretch' 
-000163b0: 6973 2074 6f6f 206c 6172 6765 2e20 5472  is too large. Tr
-000163c0: 7920 7265 6475 6369 6e67 2069 7420 2864  y reducing it (d
-000163d0: 6566 6175 6c74 203d 2033 3029 2229 0a20  efault = 30)"). 
-000163e0: 2020 2020 2020 2074 656d 705f 6669 6c74         temp_filt
-000163f0: 203d 2028 6d6f 645f 7661 6c75 6520 2a20   = (mod_value * 
-00016400: 6e70 2e6d 696e 2874 656d 706c 6174 6529  np.min(template)
-00016410: 202f 206e 702e 6d69 6e28 7465 6d70 5f66   / np.min(temp_f
-00016420: 696c 7429 2920 2a20 7465 6d70 5f66 696c  ilt)) * temp_fil
-00016430: 740a 2020 2020 7265 7475 726e 2074 656d  t.    return tem
-00016440: 705f 6669 6c74 0a0a 0a64 6566 2063 6f6e  p_filt...def con
-00016450: 766f 6c76 655f 7369 6e67 6c65 5f74 656d  volve_single_tem
-00016460: 706c 6174 6528 7370 696b 655f 6964 2c20  plate(spike_id, 
-00016470: 7374 5f69 6478 2c20 7465 6d70 6c61 7465  st_idx, template
-00016480: 2c20 6e5f 7361 6d70 6c65 732c 2063 7574  , n_samples, cut
-00016490: 5f6f 7574 3d4e 6f6e 652c 206d 6f64 756c  _out=None, modul
-000164a0: 6174 696f 6e3d 4661 6c73 652c 206d 6f64  ation=False, mod
-000164b0: 5f61 7272 6179 3d4e 6f6e 652c 0a20 2020  _array=None,.   
-000164c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000164d0: 2020 2020 2020 2020 2020 6275 7273 7469            bursti
-000164e0: 6e67 3d46 616c 7365 2c20 7368 6170 655f  ng=False, shape_
-000164f0: 7374 7265 7463 683d 4e6f 6e65 293a 0a20  stretch=None):. 
-00016500: 2020 2022 2222 436f 6e76 6f6c 7665 2073     """Convolve s
-00016510: 696e 676c 6520 7465 6d70 6c61 7465 2077  ingle template w
-00016520: 6974 6820 7370 696b 6520 7472 6169 6e2e  ith spike train.
-00016530: 2055 7365 6420 746f 2063 6f6d 7075 7465   Used to compute
-00016540: 2027 7370 696b 655f 7472 6163 6573 272e   'spike_traces'.
-00016550: 0a0a 2020 2020 5061 7261 6d65 7465 7273  ..    Parameters
-00016560: 0a20 2020 202d 2d2d 2d2d 2d2d 2d2d 2d0a  .    ----------.
-00016570: 2020 2020 7370 696b 655f 6964 203a 2069      spike_id : i
-00016580: 6e74 0a20 2020 2020 2020 2049 6e64 6578  nt.        Index
-00016590: 206f 6620 7370 696b 6520 7472 6169 6e73   of spike trains
-000165a0: 202d 2074 656d 706c 6174 652e 0a20 2020   - template..   
-000165b0: 2073 745f 6964 7820 3a20 6e70 2e61 7272   st_idx : np.arr
-000165c0: 6179 0a20 2020 2020 2020 2053 7069 6b65  ay.        Spike
-000165d0: 2074 696d 6573 0a20 2020 2074 656d 706c   times.    templ
-000165e0: 6174 6520 3a20 6e70 2e61 7272 6179 0a20  ate : np.array. 
-000165f0: 2020 2020 2020 2041 7272 6179 2077 6974         Array wit
-00016600: 6820 7369 6e67 6c65 2074 656d 706c 6174  h single templat
-00016610: 650a 2020 2020 6e5f 7361 6d70 6c65 7320  e.    n_samples 
-00016620: 3a20 696e 740a 2020 2020 2020 2020 4e75  : int.        Nu
-00016630: 6d62 6572 206f 6620 7361 6d70 6c65 7320  mber of samples 
-00016640: 696e 2063 6875 6e6b 0a20 2020 2063 7574  in chunk.    cut
-00016650: 5f6f 7574 203a 206c 6973 740a 2020 2020  _out : list.    
-00016660: 2020 2020 4e75 6d62 6572 206f 6620 7361      Number of sa
-00016670: 6d70 6c65 7320 6265 666f 7265 2061 6e64  mples before and
-00016680: 2061 6674 6572 2074 6865 2070 6561 6b0a   after the peak.
-00016690: 2020 2020 6d6f 6475 6c61 7469 6f6e 203a      modulation :
-000166a0: 2062 6f6f 6c0a 2020 2020 2020 2020 4966   bool.        If
-000166b0: 2054 7275 6520 6d6f 6475 6c61 7469 6f6e   True modulation
-000166c0: 2069 7320 6170 706c 6965 640a 2020 2020   is applied.    
-000166d0: 6d6f 645f 6172 7261 7920 3a20 6e70 2e61  mod_array : np.a
-000166e0: 7272 6179 0a20 2020 2020 2020 2041 7272  rray.        Arr
-000166f0: 6179 2077 6974 6820 6d6f 6475 6c61 7469  ay with modulati
-00016700: 6f6e 2076 616c 7565 2066 6f72 2065 6163  on value for eac
-00016710: 6820 7370 696b 650a 2020 2020 6275 7273  h spike.    burs
-00016720: 7469 6e67 203a 2062 6f6f 6c0a 2020 2020  ting : bool.    
-00016730: 2020 2020 4966 2054 7275 6520 7465 6d70      If True temp
-00016740: 6c61 7465 7320 6172 6520 6d6f 6475 6c61  lates are modula
-00016750: 7465 6420 696e 2073 6861 7065 0a20 2020  ted in shape.   
-00016760: 2073 6861 7065 5f73 7472 6574 6368 203a   shape_stretch :
-00016770: 2066 6c6f 6174 0a20 2020 2020 2020 2052   float.        R
-00016780: 616e 6765 206f 6620 7369 676d 6f69 6420  ange of sigmoid 
-00016790: 7472 616e 7366 6f72 6d20 666f 7220 6275  transform for bu
-000167a0: 7273 7469 6e67 2073 6861 7065 2073 7472  rsting shape str
-000167b0: 6574 6368 0a0a 2020 2020 5265 7475 726e  etch..    Return
-000167c0: 730a 2020 2020 2d2d 2d2d 2d2d 2d0a 2020  s.    -------.  
-000167d0: 2020 7370 696b 655f 7472 6163 6520 3a20    spike_trace : 
-000167e0: 6e70 2e61 7272 6179 0a20 2020 2020 2020  np.array.       
-000167f0: 2054 7261 6365 2077 6974 6820 636f 6e76   Trace with conv
-00016800: 6f6c 7665 6420 7369 676e 616c 2028 6e5f  olved signal (n_
-00016810: 7361 6d70 6c65 7329 0a20 2020 2022 2222  samples).    """
-00016820: 0a20 2020 2069 6620 6c65 6e28 7465 6d70  .    if len(temp
-00016830: 6c61 7465 2e73 6861 7065 2920 3d3d 2032  late.shape) == 2
-00016840: 3a0a 2020 2020 2020 2020 6e6a 6974 7420  :.        njitt 
-00016850: 3d20 7465 6d70 6c61 7465 2e73 6861 7065  = template.shape
-00016860: 5b30 5d0a 2020 2020 2020 2020 6c65 6e5f  [0].        len_
-00016870: 7370 696b 6520 3d20 7465 6d70 6c61 7465  spike = template
-00016880: 2e73 6861 7065 5b31 5d0a 2020 2020 6966  .shape[1].    if
-00016890: 2063 7574 5f6f 7574 2069 7320 4e6f 6e65   cut_out is None
-000168a0: 3a0a 2020 2020 2020 2020 6375 745f 6f75  :.        cut_ou
-000168b0: 7420 3d20 5b6c 656e 5f73 7069 6b65 202f  t = [len_spike /
-000168c0: 2f20 322c 206c 656e 5f73 7069 6b65 202f  / 2, len_spike /
-000168d0: 2f20 325d 0a0a 2020 2020 7370 696b 655f  / 2]..    spike_
-000168e0: 7472 6163 6520 3d20 6e70 2e7a 6572 6f73  trace = np.zeros
-000168f0: 286e 5f73 616d 706c 6573 290a 0a20 2020  (n_samples)..   
-00016900: 2069 6620 6c65 6e28 7465 6d70 6c61 7465   if len(template
-00016910: 2e73 6861 7065 2920 3d3d 2032 3a0a 2020  .shape) == 2:.  
-00016920: 2020 2020 2020 7261 6e64 5f69 6478 203d        rand_idx =
-00016930: 206e 702e 7261 6e64 6f6d 2e72 616e 6469   np.random.randi
-00016940: 6e74 286e 6a69 7474 290a 2020 2020 2020  nt(njitt).      
-00016950: 2020 7465 6d70 5f6a 6974 7420 3d20 7465    temp_jitt = te
-00016960: 6d70 6c61 7465 5b72 616e 645f 6964 785d  mplate[rand_idx]
-00016970: 0a20 2020 2020 2020 2066 6f72 2070 6f73  .        for pos
-00016980: 2c20 7370 6f73 2069 6e20 656e 756d 6572  , spos in enumer
-00016990: 6174 6528 7374 5f69 6478 293a 0a20 2020  ate(st_idx):.   
-000169a0: 2020 2020 2020 2020 2069 6620 6e6f 7420           if not 
-000169b0: 6d6f 6475 6c61 7469 6f6e 3a0a 2020 2020  modulation:.    
-000169c0: 2020 2020 2020 2020 2020 2020 6966 2073              if s
-000169d0: 706f 7320 2d20 6375 745f 6f75 745b 305d  pos - cut_out[0]
-000169e0: 203e 3d20 3020 616e 6420 7370 6f73 202d   >= 0 and spos -
-000169f0: 2063 7574 5f6f 7574 5b30 5d20 2b20 6c65   cut_out[0] + le
-00016a00: 6e5f 7370 696b 6520 3c3d 206e 5f73 616d  n_spike <= n_sam
-00016a10: 706c 6573 3a0a 2020 2020 2020 2020 2020  ples:.          
-00016a20: 2020 2020 2020 2020 2020 7370 696b 655f            spike_
-00016a30: 7472 6163 655b 7370 6f73 202d 2063 7574  trace[spos - cut
-00016a40: 5f6f 7574 5b30 5d3a 7370 6f73 202d 2063  _out[0]:spos - c
-00016a50: 7574 5f6f 7574 5b30 5d20 2b20 6c65 6e5f  ut_out[0] + len_
-00016a60: 7370 696b 655d 202b 3d20 7465 6d70 5f6a  spike] += temp_j
-00016a70: 6974 740a 2020 2020 2020 2020 2020 2020  itt.            
-00016a80: 2020 2020 656c 6966 2073 706f 7320 2d20      elif spos - 
-00016a90: 6375 745f 6f75 745b 305d 203c 2030 3a0a  cut_out[0] < 0:.
-00016aa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016ab0: 2020 2020 6469 6666 203d 202d 2873 706f      diff = -(spo
-00016ac0: 7320 2d20 6375 745f 6f75 745b 305d 290a  s - cut_out[0]).
-00016ad0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016ae0: 2020 2020 7370 696b 655f 7472 6163 655b      spike_trace[
-00016af0: 3a73 706f 7320 2d20 6375 745f 6f75 745b  :spos - cut_out[
-00016b00: 305d 202b 206c 656e 5f73 7069 6b65 5d20  0] + len_spike] 
-00016b10: 2b3d 2074 656d 705f 6a69 7474 5b64 6966  += temp_jitt[dif
-00016b20: 663a 5d0a 2020 2020 2020 2020 2020 2020  f:].            
-00016b30: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-00016b40: 2020 2020 2020 2020 2020 2020 2020 6469                di
-00016b50: 6666 203d 206e 5f73 616d 706c 6573 202d  ff = n_samples -
-00016b60: 2028 7370 6f73 202d 2063 7574 5f6f 7574   (spos - cut_out
-00016b70: 5b30 5d29 0a20 2020 2020 2020 2020 2020  [0]).           
-00016b80: 2020 2020 2020 2020 2073 7069 6b65 5f74           spike_t
-00016b90: 7261 6365 5b73 706f 7320 2d20 6375 745f  race[spos - cut_
-00016ba0: 6f75 745b 305d 3a5d 202b 3d20 7465 6d70  out[0]:] += temp
-00016bb0: 5f6a 6974 745b 3a64 6966 665d 0a20 2020  _jitt[:diff].   
-00016bc0: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
-00016bd0: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-00016be0: 6620 6275 7273 7469 6e67 3a0a 2020 2020  f bursting:.    
-00016bf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016c00: 6966 2073 706f 7320 2d20 6375 745f 6f75  if spos - cut_ou
-00016c10: 745b 305d 203e 3d20 3020 616e 6420 7370  t[0] >= 0 and sp
-00016c20: 6f73 202d 2063 7574 5f6f 7574 5b30 5d20  os - cut_out[0] 
-00016c30: 2b20 6c65 6e5f 7370 696b 6520 3c3d 206e  + len_spike <= n
-00016c40: 5f73 616d 706c 6573 3a0a 2020 2020 2020  _samples:.      
-00016c50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016c60: 2020 7370 696b 655f 7472 6163 655b 7370    spike_trace[sp
-00016c70: 6f73 202d 2063 7574 5f6f 7574 5b30 5d3a  os - cut_out[0]:
-00016c80: 7370 6f73 202d 2063 7574 5f6f 7574 5b30  spos - cut_out[0
-00016c90: 5d20 2b20 6c65 6e5f 7370 696b 655d 202b  ] + len_spike] +
-00016ca0: 3d20 5c0a 2020 2020 2020 2020 2020 2020  = \.            
-00016cb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016cc0: 636f 6d70 7574 655f 7374 7265 7463 6865  compute_stretche
-00016cd0: 645f 7465 6d70 6c61 7465 2874 656d 705f  d_template(temp_
-00016ce0: 6a69 7474 2c20 6d6f 645f 6172 7261 795b  jitt, mod_array[
-00016cf0: 706f 735d 2c20 7368 6170 655f 7374 7265  pos], shape_stre
-00016d00: 7463 6829 0a20 2020 2020 2020 2020 2020  tch).           
-00016d10: 2020 2020 2020 2020 2065 6c69 6620 7370           elif sp
-00016d20: 6f73 202d 2063 7574 5f6f 7574 5b30 5d20  os - cut_out[0] 
-00016d30: 3c20 303a 0a20 2020 2020 2020 2020 2020  < 0:.           
-00016d40: 2020 2020 2020 2020 2020 2020 2064 6966               dif
-00016d50: 6620 3d20 2d28 7370 6f73 202d 2063 7574  f = -(spos - cut
-00016d60: 5f6f 7574 5b30 5d29 0a20 2020 2020 2020  _out[0]).       
-00016d70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016d80: 2074 656d 705f 6669 6c74 203d 2063 6f6d   temp_filt = com
-00016d90: 7075 7465 5f73 7472 6574 6368 6564 5f74  pute_stretched_t
-00016da0: 656d 706c 6174 6528 7465 6d70 5f6a 6974  emplate(temp_jit
-00016db0: 742c 206d 6f64 5f61 7272 6179 5b70 6f73  t, mod_array[pos
-00016dc0: 5d2c 2073 6861 7065 5f73 7472 6574 6368  ], shape_stretch
-00016dd0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-00016de0: 2020 2020 2020 2020 2020 7370 696b 655f            spike_
-00016df0: 7472 6163 655b 3a73 706f 7320 2d20 6375  trace[:spos - cu
-00016e00: 745f 6f75 745b 305d 202b 206c 656e 5f73  t_out[0] + len_s
-00016e10: 7069 6b65 5d20 2b3d 2074 656d 705f 6669  pike] += temp_fi
-00016e20: 6c74 5b64 6966 663a 5d0a 2020 2020 2020  lt[diff:].      
-00016e30: 2020 2020 2020 2020 2020 2020 2020 656c                el
-00016e40: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-00016e50: 2020 2020 2020 2020 2020 2020 6469 6666              diff
-00016e60: 203d 206e 5f73 616d 706c 6573 202d 2028   = n_samples - (
-00016e70: 7370 6f73 202d 2063 7574 5f6f 7574 5b30  spos - cut_out[0
-00016e80: 5d29 0a20 2020 2020 2020 2020 2020 2020  ]).             
-00016e90: 2020 2020 2020 2020 2020 2074 656d 705f             temp_
-00016ea0: 6669 6c74 203d 2063 6f6d 7075 7465 5f73  filt = compute_s
-00016eb0: 7472 6574 6368 6564 5f74 656d 706c 6174  tretched_templat
-00016ec0: 6528 7465 6d70 5f6a 6974 742c 206d 6f64  e(temp_jitt, mod
-00016ed0: 5f61 7272 6179 5b70 6f73 5d2c 2073 6861  _array[pos], sha
-00016ee0: 7065 5f73 7472 6574 6368 290a 2020 2020  pe_stretch).    
-00016ef0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016f00: 2020 2020 7370 696b 655f 7472 6163 655b      spike_trace[
-00016f10: 7370 6f73 202d 2063 7574 5f6f 7574 5b30  spos - cut_out[0
-00016f20: 5d3a 5d20 2b3d 2074 656d 705f 6669 6c74  ]:] += temp_filt
-00016f30: 5b3a 6469 6666 5d0a 2020 2020 2020 2020  [:diff].        
-00016f40: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
-00016f50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016f60: 2020 6966 206d 6f64 5f61 7272 6179 5b70    if mod_array[p
-00016f70: 6f73 5d2e 7369 7a65 203e 2031 3a0a 2020  os].size > 1:.  
-00016f80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016f90: 2020 2020 2020 6d6f 645f 7661 6c75 6520        mod_value 
-00016fa0: 3d20 6e70 2e6d 6561 6e28 6d6f 645f 6172  = np.mean(mod_ar
-00016fb0: 7261 795b 706f 735d 290a 2020 2020 2020  ray[pos]).      
-00016fc0: 2020 2020 2020 2020 2020 2020 2020 656c                el
-00016fd0: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-00016fe0: 2020 2020 2020 2020 2020 2020 6d6f 645f              mod_
-00016ff0: 7661 6c75 6520 3d20 6d6f 645f 6172 7261  value = mod_arra
-00017000: 795b 706f 735d 0a20 2020 2020 2020 2020  y[pos].         
-00017010: 2020 2020 2020 2020 2020 2069 6620 7370             if sp
-00017020: 6f73 202d 2063 7574 5f6f 7574 5b30 5d20  os - cut_out[0] 
-00017030: 3e3d 2030 2061 6e64 2073 706f 7320 2d20  >= 0 and spos - 
-00017040: 6375 745f 6f75 745b 305d 202b 206c 656e  cut_out[0] + len
-00017050: 5f73 7069 6b65 203c 3d20 6e5f 7361 6d70  _spike <= n_samp
-00017060: 6c65 733a 0a20 2020 2020 2020 2020 2020  les:.           
-00017070: 2020 2020 2020 2020 2020 2020 2073 7069               spi
-00017080: 6b65 5f74 7261 6365 5b73 706f 7320 2d20  ke_trace[spos - 
-00017090: 6375 745f 6f75 745b 305d 3a73 706f 7320  cut_out[0]:spos 
-000170a0: 2d20 6375 745f 6f75 745b 305d 202b 206c  - cut_out[0] + l
-000170b0: 656e 5f73 7069 6b65 5d20 2b3d 206d 6f64  en_spike] += mod
-000170c0: 5f76 616c 7565 202a 2074 656d 705f 6a69  _value * temp_ji
-000170d0: 7474 0a20 2020 2020 2020 2020 2020 2020  tt.             
-000170e0: 2020 2020 2020 2065 6c69 6620 7370 6f73         elif spos
-000170f0: 202d 2063 7574 5f6f 7574 5b30 5d20 3c20   - cut_out[0] < 
-00017100: 303a 0a20 2020 2020 2020 2020 2020 2020  0:.             
-00017110: 2020 2020 2020 2020 2020 2064 6966 6620             diff 
-00017120: 3d20 2d28 7370 6f73 202d 2063 7574 5f6f  = -(spos - cut_o
-00017130: 7574 5b30 5d29 0a20 2020 2020 2020 2020  ut[0]).         
-00017140: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-00017150: 7069 6b65 5f74 7261 6365 5b3a 7370 6f73  pike_trace[:spos
-00017160: 202d 2063 7574 5f6f 7574 5b30 5d20 2b20   - cut_out[0] + 
-00017170: 6c65 6e5f 7370 696b 655d 202b 3d20 6d6f  len_spike] += mo
-00017180: 645f 7661 6c75 6520 2a20 7465 6d70 5f6a  d_value * temp_j
-00017190: 6974 745b 6469 6666 3a5d 0a20 2020 2020  itt[diff:].     
-000171a0: 2020 2020 2020 2020 2020 2020 2020 2065                 e
-000171b0: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
-000171c0: 2020 2020 2020 2020 2020 2020 2064 6966               dif
-000171d0: 6620 3d20 6e5f 7361 6d70 6c65 7320 2d20  f = n_samples - 
-000171e0: 2873 706f 7320 2d20 6375 745f 6f75 745b  (spos - cut_out[
-000171f0: 305d 290a 2020 2020 2020 2020 2020 2020  0]).            
-00017200: 2020 2020 2020 2020 2020 2020 7370 696b              spik
-00017210: 655f 7472 6163 655b 7370 6f73 202d 2063  e_trace[spos - c
-00017220: 7574 5f6f 7574 5b30 5d3a 5d20 2b3d 206d  ut_out[0]:] += m
-00017230: 6f64 5f76 616c 7565 202a 2074 656d 705f  od_value * temp_
-00017240: 6a69 7474 5b3a 6469 6666 5d0a 2020 2020  jitt[:diff].    
-00017250: 656c 7365 3a0a 2020 2020 2020 2020 7261  else:.        ra
-00017260: 6973 6520 4578 6365 7074 696f 6e28 2746  ise Exception('F
-00017270: 6f72 2064 7269 6674 696e 6720 6c65 6e28  or drifting len(
-00017280: 7465 6d70 6c61 7465 2e73 6861 7065 2920  template.shape) 
-00017290: 7368 6f75 6c64 2062 6520 3227 290a 2020  should be 2').  
-000172a0: 2020 7265 7475 726e 2073 7069 6b65 5f74    return spike_t
-000172b0: 7261 6365 0a0a 0a64 6566 2063 6f6e 766f  race...def convo
-000172c0: 6c76 655f 7465 6d70 6c61 7465 735f 7370  lve_templates_sp
-000172d0: 696b 6574 7261 696e 7328 7370 696b 655f  iketrains(spike_
-000172e0: 6964 2c20 7374 5f69 6478 2c20 7465 6d70  id, st_idx, temp
-000172f0: 6c61 7465 2c20 6e5f 7361 6d70 6c65 732c  late, n_samples,
-00017300: 2063 7574 5f6f 7574 3d4e 6f6e 652c 206d   cut_out=None, m
-00017310: 6f64 756c 6174 696f 6e3d 4661 6c73 652c  odulation=False,
-00017320: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00015000: 206c 6173 745f 6275 7273 745f 6576 656e   last_burst_even
+00015010: 7420 3d20 7374 5b69 202b 2031 5d0a 2020  t = st[i + 1].  
+00015020: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015030: 2020 6966 2063 6f6e 7365 6375 7469 7665    if consecutive
+00015040: 203e 3d20 313a 0a20 2020 2020 2020 2020   >= 1:.         
+00015050: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+00015060: 6620 7374 5b69 202b 2031 5d20 2d20 7374  f st[i + 1] - st
+00015070: 5b63 6f6e 7365 6375 7469 7665 5f69 6478  [consecutive_idx
+00015080: 5b30 5d5d 203e 3d20 6d61 785f 6275 7273  [0]] >= max_burs
+00015090: 745f 6475 7261 7469 6f6e 3a0a 2020 2020  t_duration:.    
+000150a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000150b0: 2020 2020 2020 2020 6c61 7374 5f62 7572          last_bur
+000150c0: 7374 5f65 7665 6e74 203d 2073 745b 6920  st_event = st[i 
+000150d0: 2b20 315d 202d 2030 2e30 3031 202a 2070  + 1] - 0.001 * p
+000150e0: 712e 6d73 0a20 2020 2020 2020 2020 2020  q.ms.           
+000150f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015100: 2063 6f6e 7365 6375 7469 7665 203d 2030   consecutive = 0
+00015110: 0a0a 2020 2020 2020 2020 2020 2020 2020  ..              
+00015120: 2020 2020 2020 6966 2063 6f6e 7365 6375        if consecu
+00015130: 7469 7665 203d 3d20 303a 0a20 2020 2020  tive == 0:.     
+00015140: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015150: 2020 206d 6f64 5b69 202b 2031 5d20 3d20     mod[i + 1] = 
+00015160: 7364 7261 6e64 202a 206e 702e 7261 6e64  sdrand * np.rand
+00015170: 6f6d 2e72 616e 646e 286e 5f65 6c29 202b  om.randn(n_el) +
+00015180: 206d 7261 6e64 0a20 2020 2020 2020 2020   mrand.         
+00015190: 2020 2020 2020 2020 2020 2065 6c69 6620             elif 
+000151a0: 636f 6e73 6563 7574 6976 6520 3d3d 2031  consecutive == 1
+000151b0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+000151c0: 2020 2020 2020 2020 2020 616d 7020 3d20            amp = 
+000151d0: 2869 7369 2e6d 6167 6e69 7475 6465 202f  (isi.magnitude /
+000151e0: 2066 6c6f 6174 2863 6f6e 7365 6375 7469   float(consecuti
+000151f0: 7665 2929 202a 2a20 6578 7020 2a20 2831  ve)) ** exp * (1
+00015200: 2e30 202f 206d 6178 5f62 7572 7374 5f64  .0 / max_burst_d
+00015210: 7572 6174 696f 6e2e 6d61 676e 6974 7564  uration.magnitud
+00015220: 652a 2a65 7870 290a 2020 2020 2020 2020  e**exp).        
+00015230: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015240: 2320 7363 616c 6520 7374 6420 6279 2061  # scale std by a
+00015250: 6d70 0a20 2020 2020 2020 2020 2020 2020  mp.             
+00015260: 2020 2020 2020 2020 2020 2069 6620 616d             if am
+00015270: 7020 3e20 313a 0a20 2020 2020 2020 2020  p > 1:.         
+00015280: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015290: 2020 2072 6169 7365 2045 7863 6570 7469     raise Excepti
+000152a0: 6f6e 0a20 2020 2020 2020 2020 2020 2020  on.             
+000152b0: 2020 2020 2020 2020 2020 206d 6f64 5b69             mod[i
+000152c0: 202b 2031 5d20 3d20 616d 7020 2b20 616d   + 1] = amp + am
+000152d0: 7020 2a20 7364 7261 6e64 202a 206e 702e  p * sdrand * np.
+000152e0: 7261 6e64 6f6d 2e72 616e 646e 286e 5f65  random.randn(n_e
+000152f0: 6c29 0a20 2020 2020 2020 2020 2020 2020  l).             
+00015300: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+00015310: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015320: 2020 2020 2069 6620 6920 213d 206c 656e       if i != len
+00015330: 2849 5349 293a 0a20 2020 2020 2020 2020  (ISI):.         
+00015340: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015350: 2020 2069 7369 5f6d 6561 6e20 3d20 6e70     isi_mean = np
+00015360: 2e6d 6561 6e28 4953 495b 6920 2d20 636f  .mean(ISI[i - co
+00015370: 6e73 6563 7574 6976 6520 2b20 3120 3a20  nsecutive + 1 : 
+00015380: 6920 2b20 315d 290a 2020 2020 2020 2020  i + 1]).        
+00015390: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000153a0: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+000153b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000153c0: 2020 6973 695f 6d65 616e 203d 206e 702e    isi_mean = np.
+000153d0: 6d65 616e 2849 5349 5b69 202d 2063 6f6e  mean(ISI[i - con
+000153e0: 7365 6375 7469 7665 202b 2031 203a 5d29  secutive + 1 :])
+000153f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00015400: 2020 2020 2020 2020 2061 6d70 203d 2028           amp = (
+00015410: 6973 695f 6d65 616e 202f 2066 6c6f 6174  isi_mean / float
+00015420: 2863 6f6e 7365 6375 7469 7665 2929 202a  (consecutive)) *
+00015430: 2a20 6578 7020 2a20 2831 2e30 202f 206d  * exp * (1.0 / m
+00015440: 6178 5f62 7572 7374 5f64 7572 6174 696f  ax_burst_duratio
+00015450: 6e2e 6d61 676e 6974 7564 652a 2a65 7870  n.magnitude**exp
+00015460: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+00015470: 2020 2020 2020 2020 2020 2320 7363 616c            # scal
+00015480: 6520 7374 6420 6279 2061 6d70 0a20 2020  e std by amp.   
+00015490: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000154a0: 2020 2020 206d 6f64 5b69 202b 2031 5d20       mod[i + 1] 
+000154b0: 3d20 616d 7020 2b20 616d 7020 2a20 7364  = amp + amp * sd
+000154c0: 7261 6e64 202a 206e 702e 7261 6e64 6f6d  rand * np.random
+000154d0: 2e72 616e 646e 286e 5f65 6c29 0a20 2020  .randn(n_el).   
+000154e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000154f0: 2063 6f6e 735b 6920 2b20 315d 203d 2063   cons[i + 1] = c
+00015500: 6f6e 7365 6375 7469 7665 0a0a 2020 2020  onsecutive..    
+00015510: 7265 7475 726e 206e 702e 6172 7261 7928  return np.array(
+00015520: 6d6f 6429 2c20 636f 6e73 0a0a 0a64 6566  mod), cons...def
+00015530: 2063 6f6d 7075 7465 5f62 7572 7374 696e   compute_burstin
+00015540: 675f 7465 6d70 6c61 7465 2874 656d 706c  g_template(templ
+00015550: 6174 652c 206d 6f64 2c20 7763 5f6d 6f64  ate, mod, wc_mod
+00015560: 2c20 6669 6c74 6669 6c74 3d46 616c 7365  , filtfilt=False
+00015570: 293a 0a20 2020 2022 2222 0a20 2020 2043  ):.    """.    C
+00015580: 6f6d 7075 7465 206d 6f64 756c 6174 696f  ompute modulatio
+00015590: 6e20 696e 2073 6861 7065 2066 6f72 2061  n in shape for a
+000155a0: 2074 656d 706c 6174 6520 7769 7468 206c   template with l
+000155b0: 6f77 2d70 6173 7320 6669 6c74 6572 2e0a  ow-pass filter..
+000155c0: 0a20 2020 2050 6172 616d 6574 6572 730a  .    Parameters.
+000155d0: 2020 2020 2d2d 2d2d 2d2d 2d2d 2d2d 0a20      ----------. 
+000155e0: 2020 2074 656d 706c 6174 6520 3a20 6e70     template : np
+000155f0: 2e61 7272 6179 0a20 2020 2020 2020 2054  .array.        T
+00015600: 656d 706c 6174 6520 746f 2062 6520 6d6f  emplate to be mo
+00015610: 6475 6c61 7465 6420 286e 756d 5f63 6861  dulated (num_cha
+00015620: 6e2c 206e 5f73 616d 706c 6573 2920 6f72  n, n_samples) or
+00015630: 2028 6e5f 7361 6d70 6c65 7329 0a20 2020   (n_samples).   
+00015640: 206d 6f64 203a 2069 6e74 206f 7220 6e70   mod : int or np
+00015650: 2e61 7272 6179 0a20 2020 2020 2020 2041  .array.        A
+00015660: 6d70 6c69 7475 6465 206d 6f64 756c 6174  mplitude modulat
+00015670: 696f 6e20 666f 7220 7465 6d70 6c61 7465  ion for template
+00015680: 206f 7220 7369 6e67 6c65 2065 6c65 6374   or single elect
+00015690: 726f 6465 730a 2020 2020 7763 5f6d 6f64  rodes.    wc_mod
+000156a0: 203a 2066 6c6f 6174 0a20 2020 2020 2020   : float.       
+000156b0: 204e 6f72 6d61 6c69 7a65 6420 6672 6571   Normalized freq
+000156c0: 7565 6e63 7920 6f66 206c 6f77 2d70 6173  uency of low-pas
+000156d0: 7320 6669 6c74 6572 0a20 2020 2066 696c  s filter.    fil
+000156e0: 7466 696c 743a 2062 6f6f 6c0a 2020 2020  tfilt: bool.    
+000156f0: 2020 2020 4966 2054 7275 6520 666f 7277      If True forw
+00015700: 6172 642d 6261 636b 7761 7264 2066 696c  ard-backward fil
+00015710: 7465 7220 6973 2075 7365 640a 0a20 2020  ter is used..   
+00015720: 2052 6574 7572 6e73 0a20 2020 202d 2d2d   Returns.    ---
+00015730: 2d2d 2d2d 0a20 2020 2074 656d 705f 6669  ----.    temp_fi
+00015740: 6c74 203a 206e 702e 6172 7261 790a 2020  lt : np.array.  
+00015750: 2020 2020 2020 4d6f 6475 6c61 7465 6420        Modulated 
+00015760: 7465 6d70 6c61 7465 0a0a 2020 2020 2222  template..    ""
+00015770: 220a 2020 2020 696d 706f 7274 2073 6369  ".    import sci
+00015780: 7079 2e73 6967 6e61 6c20 6173 2073 730a  py.signal as ss.
+00015790: 0a20 2020 2062 2c20 6120 3d20 7373 2e62  .    b, a = ss.b
+000157a0: 7574 7465 7228 332c 2077 635f 6d6f 6429  utter(3, wc_mod)
+000157b0: 0a20 2020 2069 6620 6c65 6e28 7465 6d70  .    if len(temp
+000157c0: 6c61 7465 2e73 6861 7065 2920 3d3d 2032  late.shape) == 2
+000157d0: 3a0a 2020 2020 2020 2020 6966 2066 696c  :.        if fil
+000157e0: 7466 696c 743a 0a20 2020 2020 2020 2020  tfilt:.         
+000157f0: 2020 2074 656d 705f 6669 6c74 203d 2073     temp_filt = s
+00015800: 732e 6669 6c74 6669 6c74 2862 2c20 612c  s.filtfilt(b, a,
+00015810: 2074 656d 706c 6174 652c 2061 7869 733d   template, axis=
+00015820: 3129 0a20 2020 2020 2020 2065 6c73 653a  1).        else:
+00015830: 0a20 2020 2020 2020 2020 2020 2074 656d  .            tem
+00015840: 705f 6669 6c74 203d 2073 732e 6c66 696c  p_filt = ss.lfil
+00015850: 7465 7228 622c 2061 2c20 7465 6d70 6c61  ter(b, a, templa
+00015860: 7465 2c20 6178 6973 3d31 290a 2020 2020  te, axis=1).    
+00015870: 2020 2020 6966 206d 6f64 2e73 697a 6520      if mod.size 
+00015880: 3e20 313a 0a20 2020 2020 2020 2020 2020  > 1:.           
+00015890: 2074 656d 705f 6669 6c74 203d 206e 702e   temp_filt = np.
+000158a0: 6172 7261 7928 0a20 2020 2020 2020 2020  array(.         
+000158b0: 2020 2020 2020 205b 6d20 2a20 6e70 2e6d         [m * np.m
+000158c0: 696e 2874 656d 7029 202f 206e 702e 6d69  in(temp) / np.mi
+000158d0: 6e28 7465 6d70 5f66 2920 2a20 7465 6d70  n(temp_f) * temp
+000158e0: 5f66 2066 6f72 2028 6d2c 2074 656d 702c  _f for (m, temp,
+000158f0: 2074 656d 705f 6629 2069 6e20 7a69 7028   temp_f) in zip(
+00015900: 6d6f 642c 2074 656d 706c 6174 652c 2074  mod, template, t
+00015910: 656d 705f 6669 6c74 295d 0a20 2020 2020  emp_filt)].     
+00015920: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+00015930: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+00015940: 2020 2074 656d 705f 6669 6c74 203d 2028     temp_filt = (
+00015950: 6d6f 6420 2a20 6e70 2e6d 696e 2874 656d  mod * np.min(tem
+00015960: 706c 6174 6529 202f 206e 702e 6d69 6e28  plate) / np.min(
+00015970: 7465 6d70 5f66 696c 7429 2920 2a20 7465  temp_filt)) * te
+00015980: 6d70 5f66 696c 740a 2020 2020 656c 7365  mp_filt.    else
+00015990: 3a0a 2020 2020 2020 2020 6966 2066 696c  :.        if fil
+000159a0: 7466 696c 743a 0a20 2020 2020 2020 2020  tfilt:.         
+000159b0: 2020 2074 656d 705f 6669 6c74 203d 2073     temp_filt = s
+000159c0: 732e 6669 6c74 6669 6c74 2862 2c20 612c  s.filtfilt(b, a,
+000159d0: 2074 656d 706c 6174 6529 0a20 2020 2020   template).     
+000159e0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+000159f0: 2020 2020 2074 656d 705f 6669 6c74 203d       temp_filt =
+00015a00: 2073 732e 6c66 696c 7465 7228 622c 2061   ss.lfilter(b, a
+00015a10: 2c20 7465 6d70 6c61 7465 290a 2020 2020  , template).    
+00015a20: 2020 2020 7465 6d70 5f66 696c 7420 3d20      temp_filt = 
+00015a30: 286d 6f64 202a 206e 702e 6d69 6e28 7465  (mod * np.min(te
+00015a40: 6d70 6c61 7465 2920 2f20 6e70 2e6d 696e  mplate) / np.min
+00015a50: 2874 656d 705f 6669 6c74 2929 202a 2074  (temp_filt)) * t
+00015a60: 656d 705f 6669 6c74 0a20 2020 2072 6574  emp_filt.    ret
+00015a70: 7572 6e20 7465 6d70 5f66 696c 740a 0a0a  urn temp_filt...
+00015a80: 6465 6620 7369 676d 6f69 6428 782c 2062  def sigmoid(x, b
+00015a90: 3d31 293a 0a20 2020 2022 2222 0a20 2020  =1):.    """.   
+00015aa0: 2043 6f6d 7075 7465 2073 6967 6d6f 6964   Compute sigmoid
+00015ab0: 2066 756e 6374 696f 6e0a 0a20 2020 2050   function..    P
+00015ac0: 6172 616d 6574 6572 730a 2020 2020 2d2d  arameters.    --
+00015ad0: 2d2d 2d2d 2d2d 2d2d 0a20 2020 2078 3a20  --------.    x: 
+00015ae0: 6e70 2e61 7272 6179 0a20 2020 2020 2020  np.array.       
+00015af0: 2041 7272 6179 2074 6f20 636f 6d70 7574   Array to comput
+00015b00: 6520 7369 676d 6f69 640a 2020 2020 623a  e sigmoid.    b:
+00015b10: 2066 6c6f 6174 0a20 2020 2020 2020 2053   float.        S
+00015b20: 6967 6d6f 6964 2073 6c6f 7065 0a0a 2020  igmoid slope..  
+00015b30: 2020 5265 7475 726e 730a 2020 2020 2d2d    Returns.    --
+00015b40: 2d2d 2d2d 2d0a 2020 2020 785f 7369 673a  -----.    x_sig:
+00015b50: 206e 702e 6172 7261 790a 2020 2020 2020   np.array.      
+00015b60: 2020 4f75 7470 7574 2073 6967 6d6f 6964    Output sigmoid
+00015b70: 2061 7272 6179 0a20 2020 2022 2222 0a20   array.    """. 
+00015b80: 2020 2072 6574 7572 6e20 3120 2f20 2831     return 1 / (1
+00015b90: 202b 206e 702e 6578 7028 2d62 202a 2078   + np.exp(-b * x
+00015ba0: 2929 202d 2030 2e35 0a0a 0a64 6566 2063  )) - 0.5...def c
+00015bb0: 6f6d 7075 7465 5f73 7472 6574 6368 6564  ompute_stretched
+00015bc0: 5f74 656d 706c 6174 6528 7465 6d70 6c61  _template(templa
+00015bd0: 7465 2c20 6d6f 642c 2073 6861 7065 5f73  te, mod, shape_s
+00015be0: 7472 6574 6368 3d33 302e 3029 3a0a 2020  tretch=30.0):.  
+00015bf0: 2020 2222 220a 2020 2020 436f 6d70 7574    """.    Comput
+00015c00: 6520 6d6f 6475 6c61 7469 6f6e 2069 6e20  e modulation in 
+00015c10: 7368 6170 6520 666f 7220 6120 7465 6d70  shape for a temp
+00015c20: 6c61 7465 2077 6974 6820 6c6f 772d 7061  late with low-pa
+00015c30: 7373 2066 696c 7465 722e 0a0a 2020 2020  ss filter...    
+00015c40: 5061 7261 6d65 7465 7273 0a20 2020 202d  Parameters.    -
+00015c50: 2d2d 2d2d 2d2d 2d2d 2d0a 2020 2020 7465  ---------.    te
+00015c60: 6d70 6c61 7465 203a 206e 702e 6172 7261  mplate : np.arra
+00015c70: 790a 2020 2020 2020 2020 5465 6d70 6c61  y.        Templa
+00015c80: 7465 2074 6f20 6265 206d 6f64 756c 6174  te to be modulat
+00015c90: 6564 2028 6e75 6d5f 6368 616e 2c20 6e5f  ed (num_chan, n_
+00015ca0: 7361 6d70 6c65 7329 206f 7220 286e 5f73  samples) or (n_s
+00015cb0: 616d 706c 6573 290a 2020 2020 6d6f 6420  amples).    mod 
+00015cc0: 3a20 696e 7420 6f72 206e 702e 6172 7261  : int or np.arra
+00015cd0: 790a 2020 2020 2020 2020 416d 706c 6974  y.        Amplit
+00015ce0: 7564 6520 6d6f 6475 6c61 7469 6f6e 2066  ude modulation f
+00015cf0: 6f72 2074 656d 706c 6174 6520 6f72 2073  or template or s
+00015d00: 696e 676c 6520 656c 6563 7472 6f64 6573  ingle electrodes
+00015d10: 0a20 2020 2073 6861 7065 5f73 7472 6574  .    shape_stret
+00015d20: 6368 203a 2066 6c6f 6174 0a20 2020 2020  ch : float.     
+00015d30: 2020 2053 6967 6d6f 6964 2072 616e 6765     Sigmoid range
+00015d40: 2074 6f20 7374 7265 7463 6820 7468 6520   to stretch the 
+00015d50: 7465 6d70 6c61 7465 0a0a 2020 2020 5265  template..    Re
+00015d60: 7475 726e 730a 2020 2020 2d2d 2d2d 2d2d  turns.    ------
+00015d70: 2d0a 2020 2020 7465 6d70 5f66 696c 7420  -.    temp_filt 
+00015d80: 3a20 6e70 2e61 7272 6179 0a20 2020 2020  : np.array.     
+00015d90: 2020 204d 6f64 756c 6174 6564 2074 656d     Modulated tem
+00015da0: 706c 6174 650a 2020 2020 2222 220a 2020  plate.    """.  
+00015db0: 2020 696d 706f 7274 2073 6369 7079 2e69    import scipy.i
+00015dc0: 6e74 6572 706f 6c61 7465 2061 7320 696e  nterpolate as in
+00015dd0: 7465 7270 0a0a 2020 2020 6966 2069 7369  terp..    if isi
+00015de0: 6e73 7461 6e63 6528 6d6f 642c 2028 696e  nstance(mod, (in
+00015df0: 742c 206e 702e 696e 7465 6765 7229 293a  t, np.integer)):
+00015e00: 0a20 2020 2020 2020 206d 6f64 203d 206e  .        mod = n
+00015e10: 702e 6172 7261 7928 6d6f 6429 0a0a 2020  p.array(mod)..  
+00015e20: 2020 6966 206d 6f64 2e73 697a 6520 3e20    if mod.size > 
+00015e30: 313a 0a20 2020 2020 2020 2073 7472 6574  1:.        stret
+00015e40: 6368 5f66 6163 746f 7220 3d20 6e70 2e6d  ch_factor = np.m
+00015e50: 6561 6e28 6d6f 6429 0a20 2020 2020 2020  ean(mod).       
+00015e60: 206d 6f64 5f76 616c 7565 203d 206e 702e   mod_value = np.
+00015e70: 6d65 616e 286d 6f64 290a 2020 2020 656c  mean(mod).    el
+00015e80: 7365 3a0a 2020 2020 2020 2020 7374 7265  se:.        stre
+00015e90: 7463 685f 6661 6374 6f72 203d 206d 6f64  tch_factor = mod
+00015ea0: 0a20 2020 2020 2020 206d 6f64 5f76 616c  .        mod_val
+00015eb0: 7565 203d 206d 6f64 0a0a 2020 2020 6966  ue = mod..    if
+00015ec0: 206c 656e 2874 656d 706c 6174 652e 7368   len(template.sh
+00015ed0: 6170 6529 203d 3d20 323a 0a20 2020 2020  ape) == 2:.     
+00015ee0: 2020 206d 696e 5f69 6478 203d 206e 702e     min_idx = np.
+00015ef0: 756e 7261 7665 6c5f 696e 6465 7828 6e70  unravel_index(np
+00015f00: 2e61 7267 6d69 6e28 7465 6d70 6c61 7465  .argmin(template
+00015f10: 292c 2074 656d 706c 6174 652e 7368 6170  ), template.shap
+00015f20: 6529 5b31 5d0a 2020 2020 2020 2020 785f  e)[1].        x_
+00015f30: 6365 6e74 6572 6564 203d 206e 702e 6172  centered = np.ar
+00015f40: 616e 6765 282d 6d69 6e5f 6964 782c 2074  ange(-min_idx, t
+00015f50: 656d 706c 6174 652e 7368 6170 655b 315d  emplate.shape[1]
+00015f60: 202d 206d 696e 5f69 6478 290a 2020 2020   - min_idx).    
+00015f70: 2020 2020 785f 6365 6e74 6572 6564 203d      x_centered =
+00015f80: 2078 5f63 656e 7465 7265 6420 2f20 666c   x_centered / fl
+00015f90: 6f61 7428 6e70 2e70 7470 2878 5f63 656e  oat(np.ptp(x_cen
+00015fa0: 7465 7265 6429 290a 2020 2020 2020 2020  tered)).        
+00015fb0: 785f 6365 6e74 6572 6564 203d 2078 5f63  x_centered = x_c
+00015fc0: 656e 7465 7265 6420 2a20 7368 6170 655f  entered * shape_
+00015fd0: 7374 7265 7463 680a 0a20 2020 2020 2020  stretch..       
+00015fe0: 2069 6620 7374 7265 7463 685f 6661 6374   if stretch_fact
+00015ff0: 6f72 203e 3d20 313a 0a20 2020 2020 2020  or >= 1:.       
+00016000: 2020 2020 2078 5f73 7472 6574 6368 203d       x_stretch =
+00016010: 2078 5f63 656e 7465 7265 640a 2020 2020   x_centered.    
+00016020: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+00016030: 2020 2020 2020 785f 7374 7265 7463 6820        x_stretch 
+00016040: 3d20 7369 676d 6f69 6428 785f 6365 6e74  = sigmoid(x_cent
+00016050: 6572 6564 2c20 3120 2d20 7374 7265 7463  ered, 1 - stretc
+00016060: 685f 6661 6374 6f72 290a 0a20 2020 2020  h_factor)..     
+00016070: 2020 2078 5f73 7472 6574 6368 203d 2078     x_stretch = x
+00016080: 5f73 7472 6574 6368 202f 2066 6c6f 6174  _stretch / float
+00016090: 286e 702e 7074 7028 785f 7374 7265 7463  (np.ptp(x_stretc
+000160a0: 6829 290a 2020 2020 2020 2020 785f 7374  h)).        x_st
+000160b0: 7265 7463 6820 2a3d 2073 6861 7065 5f73  retch *= shape_s
+000160c0: 7472 6574 6368 202b 2028 6e70 2e6d 696e  tretch + (np.min
+000160d0: 2878 5f63 656e 7465 7265 6429 202d 206e  (x_centered) - n
+000160e0: 702e 6d69 6e28 785f 7374 7265 7463 6829  p.min(x_stretch)
+000160f0: 290a 2020 2020 2020 2020 785f 7265 636f  ).        x_reco
+00016100: 7665 7265 6420 3d20 6e70 2e6d 6178 2878  vered = np.max(x
+00016110: 5f73 7472 6574 6368 2920 2f20 6e70 2e6d  _stretch) / np.m
+00016120: 6178 2878 5f63 656e 7465 7265 6429 202a  ax(x_centered) *
+00016130: 2078 5f63 656e 7465 7265 640a 2020 2020   x_centered.    
+00016140: 2020 2020 785f 7374 7265 7463 6820 3d20      x_stretch = 
+00016150: 6e70 2e72 6f75 6e64 2878 5f73 7472 6574  np.round(x_stret
+00016160: 6368 2c20 3629 0a20 2020 2020 2020 2078  ch, 6).        x
+00016170: 5f72 6563 6f76 6572 6564 203d 206e 702e  _recovered = np.
+00016180: 726f 756e 6428 785f 7265 636f 7665 7265  round(x_recovere
+00016190: 642c 2036 290a 2020 2020 2020 2020 7465  d, 6).        te
+000161a0: 6d70 5f66 696c 7420 3d20 6e70 2e7a 6572  mp_filt = np.zer
+000161b0: 6f73 2874 656d 706c 6174 652e 7368 6170  os(template.shap
+000161c0: 6529 0a20 2020 2020 2020 2066 6f72 2069  e).        for i
+000161d0: 2c20 7420 696e 2065 6e75 6d65 7261 7465  , t in enumerate
+000161e0: 2874 656d 706c 6174 6529 3a0a 2020 2020  (template):.    
+000161f0: 2020 2020 2020 2020 7472 793a 0a20 2020          try:.   
+00016200: 2020 2020 2020 2020 2020 2020 2066 203d               f =
+00016210: 2069 6e74 6572 702e 696e 7465 7270 3164   interp.interp1d
+00016220: 2878 5f73 7472 6574 6368 2c20 742c 206b  (x_stretch, t, k
+00016230: 696e 643d 2263 7562 6963 2229 0a20 2020  ind="cubic").   
+00016240: 2020 2020 2020 2020 2020 2020 2074 656d               tem
+00016250: 705f 6669 6c74 5b69 5d20 3d20 6628 785f  p_filt[i] = f(x_
+00016260: 7265 636f 7665 7265 6429 0a20 2020 2020  recovered).     
+00016270: 2020 2020 2020 2065 7863 6570 7420 4578         except Ex
+00016280: 6365 7074 696f 6e20 6173 2065 3a0a 2020  ception as e:.  
+00016290: 2020 2020 2020 2020 2020 2020 2020 7261                ra
+000162a0: 6973 6520 4578 6365 7074 696f 6e28 2227  ise Exception("'
+000162b0: 7368 6170 655f 7374 7265 7463 6827 2069  shape_stretch' i
+000162c0: 7320 746f 6f20 6c61 7267 652e 2054 7279  s too large. Try
+000162d0: 2072 6564 7563 696e 6720 6974 2028 6465   reducing it (de
+000162e0: 6661 756c 7420 3d20 3330 2922 290a 2020  fault = 30)").  
+000162f0: 2020 2020 2020 6966 206d 6f64 2e73 697a        if mod.siz
+00016300: 6520 3e20 313a 0a20 2020 2020 2020 2020  e > 1:.         
+00016310: 2020 2074 656d 705f 6669 6c74 203d 206e     temp_filt = n
+00016320: 702e 6172 7261 7928 0a20 2020 2020 2020  p.array(.       
+00016330: 2020 2020 2020 2020 205b 6d20 2a20 6e70           [m * np
+00016340: 2e6d 696e 2874 656d 7029 202f 206e 702e  .min(temp) / np.
+00016350: 6d69 6e28 7465 6d70 5f66 2920 2a20 7465  min(temp_f) * te
+00016360: 6d70 5f66 2066 6f72 2028 6d2c 2074 656d  mp_f for (m, tem
+00016370: 702c 2074 656d 705f 6629 2069 6e20 7a69  p, temp_f) in zi
+00016380: 7028 6d6f 642c 2074 656d 706c 6174 652c  p(mod, template,
+00016390: 2074 656d 705f 6669 6c74 295d 0a20 2020   temp_filt)].   
+000163a0: 2020 2020 2020 2020 2029 0a20 2020 2020           ).     
+000163b0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+000163c0: 2020 2020 2074 656d 705f 6669 6c74 203d       temp_filt =
+000163d0: 2028 6d6f 6420 2a20 6e70 2e6d 696e 2874   (mod * np.min(t
+000163e0: 656d 706c 6174 6529 202f 206e 702e 6d69  emplate) / np.mi
+000163f0: 6e28 7465 6d70 5f66 696c 7429 2920 2a20  n(temp_filt)) * 
+00016400: 7465 6d70 5f66 696c 740a 2020 2020 656c  temp_filt.    el
+00016410: 7365 3a0a 2020 2020 2020 2020 6d69 6e5f  se:.        min_
+00016420: 6964 7820 3d20 6e70 2e61 7267 6d69 6e28  idx = np.argmin(
+00016430: 7465 6d70 6c61 7465 290a 2020 2020 2020  template).      
+00016440: 2020 785f 6365 6e74 6572 6564 203d 206e    x_centered = n
+00016450: 702e 6172 616e 6765 282d 6d69 6e5f 6964  p.arange(-min_id
+00016460: 782c 206c 656e 2874 656d 706c 6174 6529  x, len(template)
+00016470: 202d 206d 696e 5f69 6478 290a 2020 2020   - min_idx).    
+00016480: 2020 2020 785f 6365 6e74 6572 6564 203d      x_centered =
+00016490: 2078 5f63 656e 7465 7265 6420 2f20 666c   x_centered / fl
+000164a0: 6f61 7428 6e70 2e70 7470 2878 5f63 656e  oat(np.ptp(x_cen
+000164b0: 7465 7265 6429 290a 2020 2020 2020 2020  tered)).        
+000164c0: 785f 6365 6e74 6572 6564 203d 2078 5f63  x_centered = x_c
+000164d0: 656e 7465 7265 6420 2a20 7368 6170 655f  entered * shape_
+000164e0: 7374 7265 7463 680a 0a20 2020 2020 2020  stretch..       
+000164f0: 2069 6620 7374 7265 7463 685f 6661 6374   if stretch_fact
+00016500: 6f72 203e 3d20 313a 0a20 2020 2020 2020  or >= 1:.       
+00016510: 2020 2020 2078 5f73 7472 6574 6368 203d       x_stretch =
+00016520: 2078 5f63 656e 7465 7265 640a 2020 2020   x_centered.    
+00016530: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+00016540: 2020 2020 2020 785f 7374 7265 7463 6820        x_stretch 
+00016550: 3d20 7369 676d 6f69 6428 785f 6365 6e74  = sigmoid(x_cent
+00016560: 6572 6564 2c20 3120 2d20 7374 7265 7463  ered, 1 - stretc
+00016570: 685f 6661 6374 6f72 290a 2020 2020 2020  h_factor).      
+00016580: 2020 785f 7374 7265 7463 6820 3d20 785f    x_stretch = x_
+00016590: 7374 7265 7463 6820 2f20 666c 6f61 7428  stretch / float(
+000165a0: 6e70 2e70 7470 2878 5f73 7472 6574 6368  np.ptp(x_stretch
+000165b0: 2929 0a20 2020 2020 2020 2078 5f73 7472  )).        x_str
+000165c0: 6574 6368 202a 3d20 7368 6170 655f 7374  etch *= shape_st
+000165d0: 7265 7463 6820 2b20 286e 702e 6d69 6e28  retch + (np.min(
+000165e0: 785f 6365 6e74 6572 6564 2920 2d20 6e70  x_centered) - np
+000165f0: 2e6d 696e 2878 5f73 7472 6574 6368 2929  .min(x_stretch))
+00016600: 0a20 2020 2020 2020 2078 5f72 6563 6f76  .        x_recov
+00016610: 6572 6564 203d 206e 702e 6d61 7828 785f  ered = np.max(x_
+00016620: 7374 7265 7463 6829 202f 206e 702e 6d61  stretch) / np.ma
+00016630: 7828 785f 6365 6e74 6572 6564 2920 2a20  x(x_centered) * 
+00016640: 785f 6365 6e74 6572 6564 0a20 2020 2020  x_centered.     
+00016650: 2020 2078 5f73 7472 6574 6368 203d 206e     x_stretch = n
+00016660: 702e 726f 756e 6428 785f 7374 7265 7463  p.round(x_stretc
+00016670: 682c 2036 290a 2020 2020 2020 2020 785f  h, 6).        x_
+00016680: 7265 636f 7665 7265 6420 3d20 6e70 2e72  recovered = np.r
+00016690: 6f75 6e64 2878 5f72 6563 6f76 6572 6564  ound(x_recovered
+000166a0: 2c20 3629 0a20 2020 2020 2020 2074 7279  , 6).        try
+000166b0: 3a0a 2020 2020 2020 2020 2020 2020 6620  :.            f 
+000166c0: 3d20 696e 7465 7270 2e69 6e74 6572 7031  = interp.interp1
+000166d0: 6428 785f 7374 7265 7463 682c 2074 656d  d(x_stretch, tem
+000166e0: 706c 6174 652c 206b 696e 643d 2263 7562  plate, kind="cub
+000166f0: 6963 2229 0a20 2020 2020 2020 2020 2020  ic").           
+00016700: 2074 656d 705f 6669 6c74 203d 2066 2878   temp_filt = f(x
+00016710: 5f72 6563 6f76 6572 6564 290a 2020 2020  _recovered).    
+00016720: 2020 2020 6578 6365 7074 2045 7863 6570      except Excep
+00016730: 7469 6f6e 2061 7320 653a 0a20 2020 2020  tion as e:.     
+00016740: 2020 2020 2020 2072 6169 7365 2045 7863         raise Exc
+00016750: 6570 7469 6f6e 2822 2773 6861 7065 5f73  eption("'shape_s
+00016760: 7472 6574 6368 2720 6973 2074 6f6f 206c  tretch' is too l
+00016770: 6172 6765 2e20 5472 7920 7265 6475 6369  arge. Try reduci
+00016780: 6e67 2069 7420 2864 6566 6175 6c74 203d  ng it (default =
+00016790: 2033 3029 2229 0a20 2020 2020 2020 2074   30)").        t
+000167a0: 656d 705f 6669 6c74 203d 2028 6d6f 645f  emp_filt = (mod_
+000167b0: 7661 6c75 6520 2a20 6e70 2e6d 696e 2874  value * np.min(t
+000167c0: 656d 706c 6174 6529 202f 206e 702e 6d69  emplate) / np.mi
+000167d0: 6e28 7465 6d70 5f66 696c 7429 2920 2a20  n(temp_filt)) * 
+000167e0: 7465 6d70 5f66 696c 740a 2020 2020 7265  temp_filt.    re
+000167f0: 7475 726e 2074 656d 705f 6669 6c74 0a0a  turn temp_filt..
+00016800: 0a64 6566 2063 6f6e 766f 6c76 655f 7369  .def convolve_si
+00016810: 6e67 6c65 5f74 656d 706c 6174 6528 0a20  ngle_template(. 
+00016820: 2020 2073 7069 6b65 5f69 642c 0a20 2020     spike_id,.   
+00016830: 2073 745f 6964 782c 0a20 2020 2074 656d   st_idx,.    tem
+00016840: 706c 6174 652c 0a20 2020 206e 5f73 616d  plate,.    n_sam
+00016850: 706c 6573 2c0a 2020 2020 6375 745f 6f75  ples,.    cut_ou
+00016860: 743d 4e6f 6e65 2c0a 2020 2020 6d6f 6475  t=None,.    modu
+00016870: 6c61 7469 6f6e 3d46 616c 7365 2c0a 2020  lation=False,.  
+00016880: 2020 6d6f 645f 6172 7261 793d 4e6f 6e65    mod_array=None
+00016890: 2c0a 2020 2020 6275 7273 7469 6e67 3d46  ,.    bursting=F
+000168a0: 616c 7365 2c0a 2020 2020 7368 6170 655f  alse,.    shape_
+000168b0: 7374 7265 7463 683d 4e6f 6e65 2c0a 293a  stretch=None,.):
+000168c0: 0a20 2020 2022 2222 436f 6e76 6f6c 7665  .    """Convolve
+000168d0: 2073 696e 676c 6520 7465 6d70 6c61 7465   single template
+000168e0: 2077 6974 6820 7370 696b 6520 7472 6169   with spike trai
+000168f0: 6e2e 2055 7365 6420 746f 2063 6f6d 7075  n. Used to compu
+00016900: 7465 2027 7370 696b 655f 7472 6163 6573  te 'spike_traces
+00016910: 272e 0a0a 2020 2020 5061 7261 6d65 7465  '...    Paramete
+00016920: 7273 0a20 2020 202d 2d2d 2d2d 2d2d 2d2d  rs.    ---------
+00016930: 2d0a 2020 2020 7370 696b 655f 6964 203a  -.    spike_id :
+00016940: 2069 6e74 0a20 2020 2020 2020 2049 6e64   int.        Ind
+00016950: 6578 206f 6620 7370 696b 6520 7472 6169  ex of spike trai
+00016960: 6e73 202d 2074 656d 706c 6174 652e 0a20  ns - template.. 
+00016970: 2020 2073 745f 6964 7820 3a20 6e70 2e61     st_idx : np.a
+00016980: 7272 6179 0a20 2020 2020 2020 2053 7069  rray.        Spi
+00016990: 6b65 2074 696d 6573 0a20 2020 2074 656d  ke times.    tem
+000169a0: 706c 6174 6520 3a20 6e70 2e61 7272 6179  plate : np.array
+000169b0: 0a20 2020 2020 2020 2041 7272 6179 2077  .        Array w
+000169c0: 6974 6820 7369 6e67 6c65 2074 656d 706c  ith single templ
+000169d0: 6174 650a 2020 2020 6e5f 7361 6d70 6c65  ate.    n_sample
+000169e0: 7320 3a20 696e 740a 2020 2020 2020 2020  s : int.        
+000169f0: 4e75 6d62 6572 206f 6620 7361 6d70 6c65  Number of sample
+00016a00: 7320 696e 2063 6875 6e6b 0a20 2020 2063  s in chunk.    c
+00016a10: 7574 5f6f 7574 203a 206c 6973 740a 2020  ut_out : list.  
+00016a20: 2020 2020 2020 4e75 6d62 6572 206f 6620        Number of 
+00016a30: 7361 6d70 6c65 7320 6265 666f 7265 2061  samples before a
+00016a40: 6e64 2061 6674 6572 2074 6865 2070 6561  nd after the pea
+00016a50: 6b0a 2020 2020 6d6f 6475 6c61 7469 6f6e  k.    modulation
+00016a60: 203a 2062 6f6f 6c0a 2020 2020 2020 2020   : bool.        
+00016a70: 4966 2054 7275 6520 6d6f 6475 6c61 7469  If True modulati
+00016a80: 6f6e 2069 7320 6170 706c 6965 640a 2020  on is applied.  
+00016a90: 2020 6d6f 645f 6172 7261 7920 3a20 6e70    mod_array : np
+00016aa0: 2e61 7272 6179 0a20 2020 2020 2020 2041  .array.        A
+00016ab0: 7272 6179 2077 6974 6820 6d6f 6475 6c61  rray with modula
+00016ac0: 7469 6f6e 2076 616c 7565 2066 6f72 2065  tion value for e
+00016ad0: 6163 6820 7370 696b 650a 2020 2020 6275  ach spike.    bu
+00016ae0: 7273 7469 6e67 203a 2062 6f6f 6c0a 2020  rsting : bool.  
+00016af0: 2020 2020 2020 4966 2054 7275 6520 7465        If True te
+00016b00: 6d70 6c61 7465 7320 6172 6520 6d6f 6475  mplates are modu
+00016b10: 6c61 7465 6420 696e 2073 6861 7065 0a20  lated in shape. 
+00016b20: 2020 2073 6861 7065 5f73 7472 6574 6368     shape_stretch
+00016b30: 203a 2066 6c6f 6174 0a20 2020 2020 2020   : float.       
+00016b40: 2052 616e 6765 206f 6620 7369 676d 6f69   Range of sigmoi
+00016b50: 6420 7472 616e 7366 6f72 6d20 666f 7220  d transform for 
+00016b60: 6275 7273 7469 6e67 2073 6861 7065 2073  bursting shape s
+00016b70: 7472 6574 6368 0a0a 2020 2020 5265 7475  tretch..    Retu
+00016b80: 726e 730a 2020 2020 2d2d 2d2d 2d2d 2d0a  rns.    -------.
+00016b90: 2020 2020 7370 696b 655f 7472 6163 6520      spike_trace 
+00016ba0: 3a20 6e70 2e61 7272 6179 0a20 2020 2020  : np.array.     
+00016bb0: 2020 2054 7261 6365 2077 6974 6820 636f     Trace with co
+00016bc0: 6e76 6f6c 7665 6420 7369 676e 616c 2028  nvolved signal (
+00016bd0: 6e5f 7361 6d70 6c65 7329 0a20 2020 2022  n_samples).    "
+00016be0: 2222 0a20 2020 2069 6620 6c65 6e28 7465  "".    if len(te
+00016bf0: 6d70 6c61 7465 2e73 6861 7065 2920 3d3d  mplate.shape) ==
+00016c00: 2032 3a0a 2020 2020 2020 2020 6e6a 6974   2:.        njit
+00016c10: 7420 3d20 7465 6d70 6c61 7465 2e73 6861  t = template.sha
+00016c20: 7065 5b30 5d0a 2020 2020 2020 2020 6c65  pe[0].        le
+00016c30: 6e5f 7370 696b 6520 3d20 7465 6d70 6c61  n_spike = templa
+00016c40: 7465 2e73 6861 7065 5b31 5d0a 2020 2020  te.shape[1].    
+00016c50: 6966 2063 7574 5f6f 7574 2069 7320 4e6f  if cut_out is No
+00016c60: 6e65 3a0a 2020 2020 2020 2020 6375 745f  ne:.        cut_
+00016c70: 6f75 7420 3d20 5b6c 656e 5f73 7069 6b65  out = [len_spike
+00016c80: 202f 2f20 322c 206c 656e 5f73 7069 6b65   // 2, len_spike
+00016c90: 202f 2f20 325d 0a0a 2020 2020 7370 696b   // 2]..    spik
+00016ca0: 655f 7472 6163 6520 3d20 6e70 2e7a 6572  e_trace = np.zer
+00016cb0: 6f73 286e 5f73 616d 706c 6573 290a 0a20  os(n_samples).. 
+00016cc0: 2020 2069 6620 6c65 6e28 7465 6d70 6c61     if len(templa
+00016cd0: 7465 2e73 6861 7065 2920 3d3d 2032 3a0a  te.shape) == 2:.
+00016ce0: 2020 2020 2020 2020 7261 6e64 5f69 6478          rand_idx
+00016cf0: 203d 206e 702e 7261 6e64 6f6d 2e72 616e   = np.random.ran
+00016d00: 6469 6e74 286e 6a69 7474 290a 2020 2020  dint(njitt).    
+00016d10: 2020 2020 7465 6d70 5f6a 6974 7420 3d20      temp_jitt = 
+00016d20: 7465 6d70 6c61 7465 5b72 616e 645f 6964  template[rand_id
+00016d30: 785d 0a20 2020 2020 2020 2066 6f72 2070  x].        for p
+00016d40: 6f73 2c20 7370 6f73 2069 6e20 656e 756d  os, spos in enum
+00016d50: 6572 6174 6528 7374 5f69 6478 293a 0a20  erate(st_idx):. 
+00016d60: 2020 2020 2020 2020 2020 2069 6620 6e6f             if no
+00016d70: 7420 6d6f 6475 6c61 7469 6f6e 3a0a 2020  t modulation:.  
+00016d80: 2020 2020 2020 2020 2020 2020 2020 6966                if
+00016d90: 2073 706f 7320 2d20 6375 745f 6f75 745b   spos - cut_out[
+00016da0: 305d 203e 3d20 3020 616e 6420 7370 6f73  0] >= 0 and spos
+00016db0: 202d 2063 7574 5f6f 7574 5b30 5d20 2b20   - cut_out[0] + 
+00016dc0: 6c65 6e5f 7370 696b 6520 3c3d 206e 5f73  len_spike <= n_s
+00016dd0: 616d 706c 6573 3a0a 2020 2020 2020 2020  amples:.        
+00016de0: 2020 2020 2020 2020 2020 2020 7370 696b              spik
+00016df0: 655f 7472 6163 655b 7370 6f73 202d 2063  e_trace[spos - c
+00016e00: 7574 5f6f 7574 5b30 5d20 3a20 7370 6f73  ut_out[0] : spos
+00016e10: 202d 2063 7574 5f6f 7574 5b30 5d20 2b20   - cut_out[0] + 
+00016e20: 6c65 6e5f 7370 696b 655d 202b 3d20 7465  len_spike] += te
+00016e30: 6d70 5f6a 6974 740a 2020 2020 2020 2020  mp_jitt.        
+00016e40: 2020 2020 2020 2020 656c 6966 2073 706f          elif spo
+00016e50: 7320 2d20 6375 745f 6f75 745b 305d 203c  s - cut_out[0] <
+00016e60: 2030 3a0a 2020 2020 2020 2020 2020 2020   0:.            
+00016e70: 2020 2020 2020 2020 6469 6666 203d 202d          diff = -
+00016e80: 2873 706f 7320 2d20 6375 745f 6f75 745b  (spos - cut_out[
+00016e90: 305d 290a 2020 2020 2020 2020 2020 2020  0]).            
+00016ea0: 2020 2020 2020 2020 7370 696b 655f 7472          spike_tr
+00016eb0: 6163 655b 3a20 7370 6f73 202d 2063 7574  ace[: spos - cut
+00016ec0: 5f6f 7574 5b30 5d20 2b20 6c65 6e5f 7370  _out[0] + len_sp
+00016ed0: 696b 655d 202b 3d20 7465 6d70 5f6a 6974  ike] += temp_jit
+00016ee0: 745b 6469 6666 3a5d 0a20 2020 2020 2020  t[diff:].       
+00016ef0: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
+00016f00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016f10: 2020 2064 6966 6620 3d20 6e5f 7361 6d70     diff = n_samp
+00016f20: 6c65 7320 2d20 2873 706f 7320 2d20 6375  les - (spos - cu
+00016f30: 745f 6f75 745b 305d 290a 2020 2020 2020  t_out[0]).      
+00016f40: 2020 2020 2020 2020 2020 2020 2020 7370                sp
+00016f50: 696b 655f 7472 6163 655b 7370 6f73 202d  ike_trace[spos -
+00016f60: 2063 7574 5f6f 7574 5b30 5d20 3a5d 202b   cut_out[0] :] +
+00016f70: 3d20 7465 6d70 5f6a 6974 745b 3a64 6966  = temp_jitt[:dif
+00016f80: 665d 0a20 2020 2020 2020 2020 2020 2065  f].            e
+00016f90: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+00016fa0: 2020 2020 2069 6620 6275 7273 7469 6e67       if bursting
+00016fb0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00016fc0: 2020 2020 2020 6966 2073 706f 7320 2d20        if spos - 
+00016fd0: 6375 745f 6f75 745b 305d 203e 3d20 3020  cut_out[0] >= 0 
+00016fe0: 616e 6420 7370 6f73 202d 2063 7574 5f6f  and spos - cut_o
+00016ff0: 7574 5b30 5d20 2b20 6c65 6e5f 7370 696b  ut[0] + len_spik
+00017000: 6520 3c3d 206e 5f73 616d 706c 6573 3a0a  e <= n_samples:.
+00017010: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00017020: 2020 2020 2020 2020 7370 696b 655f 7472          spike_tr
+00017030: 6163 655b 7370 6f73 202d 2063 7574 5f6f  ace[spos - cut_o
+00017040: 7574 5b30 5d20 3a20 7370 6f73 202d 2063  ut[0] : spos - c
+00017050: 7574 5f6f 7574 5b30 5d20 2b20 6c65 6e5f  ut_out[0] + len_
+00017060: 7370 696b 655d 202b 3d20 636f 6d70 7574  spike] += comput
+00017070: 655f 7374 7265 7463 6865 645f 7465 6d70  e_stretched_temp
+00017080: 6c61 7465 280a 2020 2020 2020 2020 2020  late(.          
+00017090: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000170a0: 2020 7465 6d70 5f6a 6974 742c 206d 6f64    temp_jitt, mod
+000170b0: 5f61 7272 6179 5b70 6f73 5d2c 2073 6861  _array[pos], sha
+000170c0: 7065 5f73 7472 6574 6368 0a20 2020 2020  pe_stretch.     
+000170d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000170e0: 2020 2029 0a20 2020 2020 2020 2020 2020     ).           
+000170f0: 2020 2020 2020 2020 2065 6c69 6620 7370           elif sp
+00017100: 6f73 202d 2063 7574 5f6f 7574 5b30 5d20  os - cut_out[0] 
+00017110: 3c20 303a 0a20 2020 2020 2020 2020 2020  < 0:.           
+00017120: 2020 2020 2020 2020 2020 2020 2064 6966               dif
+00017130: 6620 3d20 2d28 7370 6f73 202d 2063 7574  f = -(spos - cut
+00017140: 5f6f 7574 5b30 5d29 0a20 2020 2020 2020  _out[0]).       
+00017150: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00017160: 2074 656d 705f 6669 6c74 203d 2063 6f6d   temp_filt = com
+00017170: 7075 7465 5f73 7472 6574 6368 6564 5f74  pute_stretched_t
+00017180: 656d 706c 6174 6528 7465 6d70 5f6a 6974  emplate(temp_jit
+00017190: 742c 206d 6f64 5f61 7272 6179 5b70 6f73  t, mod_array[pos
+000171a0: 5d2c 2073 6861 7065 5f73 7472 6574 6368  ], shape_stretch
+000171b0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+000171c0: 2020 2020 2020 2020 2020 7370 696b 655f            spike_
+000171d0: 7472 6163 655b 3a20 7370 6f73 202d 2063  trace[: spos - c
+000171e0: 7574 5f6f 7574 5b30 5d20 2b20 6c65 6e5f  ut_out[0] + len_
+000171f0: 7370 696b 655d 202b 3d20 7465 6d70 5f66  spike] += temp_f
+00017200: 696c 745b 6469 6666 3a5d 0a20 2020 2020  ilt[diff:].     
+00017210: 2020 2020 2020 2020 2020 2020 2020 2065                 e
+00017220: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+00017230: 2020 2020 2020 2020 2020 2020 2064 6966               dif
+00017240: 6620 3d20 6e5f 7361 6d70 6c65 7320 2d20  f = n_samples - 
+00017250: 2873 706f 7320 2d20 6375 745f 6f75 745b  (spos - cut_out[
+00017260: 305d 290a 2020 2020 2020 2020 2020 2020  0]).            
+00017270: 2020 2020 2020 2020 2020 2020 7465 6d70              temp
+00017280: 5f66 696c 7420 3d20 636f 6d70 7574 655f  _filt = compute_
+00017290: 7374 7265 7463 6865 645f 7465 6d70 6c61  stretched_templa
+000172a0: 7465 2874 656d 705f 6a69 7474 2c20 6d6f  te(temp_jitt, mo
+000172b0: 645f 6172 7261 795b 706f 735d 2c20 7368  d_array[pos], sh
+000172c0: 6170 655f 7374 7265 7463 6829 0a20 2020  ape_stretch).   
+000172d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000172e0: 2020 2020 2073 7069 6b65 5f74 7261 6365       spike_trace
+000172f0: 5b73 706f 7320 2d20 6375 745f 6f75 745b  [spos - cut_out[
+00017300: 305d 203a 5d20 2b3d 2074 656d 705f 6669  0] :] += temp_fi
+00017310: 6c74 5b3a 6469 6666 5d0a 2020 2020 2020  lt[:diff].      
+00017320: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
 00017330: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017340: 2020 2020 6d6f 645f 6172 7261 793d 4e6f      mod_array=No
-00017350: 6e65 2c20 7665 7262 6f73 653d 4661 6c73  ne, verbose=Fals
-00017360: 652c 2062 7572 7374 696e 673d 4661 6c73  e, bursting=Fals
-00017370: 652c 2073 6861 7065 5f73 7472 6574 6368  e, shape_stretch
-00017380: 3d4e 6f6e 652c 0a20 2020 2020 2020 2020  =None,.         
-00017390: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000173a0: 2020 2020 2020 2020 2020 6d61 785f 6368            max_ch
-000173b0: 616e 6e65 6c73 5f70 6572 5f74 656d 706c  annels_per_templ
-000173c0: 6174 653d 4e6f 6e65 2c20 7265 636f 7264  ate=None, record
-000173d0: 696e 6773 3d4e 6f6e 652c 2064 7269 6674  ings=None, drift
-000173e0: 5f69 6478 733d 4e6f 6e65 293a 0a20 2020  _idxs=None):.   
-000173f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017400: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-00017410: 2c20 6472 6966 745f 7665 6374 6f72 3d4e  , drift_vector=N
-00017420: 6f6e 652c 2064 7269 6674 5f66 733d 4e6f  one, drift_fs=No
-00017430: 6e65 293a 0a20 2020 2022 2222 0a20 2020  ne):.    """.   
-00017440: 2043 6f6e 766f 6c76 6520 7465 6d70 6c61   Convolve templa
-00017450: 7465 2077 6974 6820 7370 696b 6520 7472  te with spike tr
-00017460: 6169 6e20 6f6e 2061 6c6c 2065 6c65 6374  ain on all elect
-00017470: 726f 6465 732e 2055 7365 6420 746f 2063  rodes. Used to c
-00017480: 6f6d 7075 7465 2027 7265 636f 7264 696e  ompute 'recordin
-00017490: 6773 272e 0a20 2020 200a 2020 2020 5061  gs'..    .    Pa
-000174a0: 7261 6d65 7465 7273 0a20 2020 202d 2d2d  rameters.    ---
-000174b0: 2d2d 2d2d 2d2d 2d0a 2020 2020 7370 696b  -------.    spik
-000174c0: 655f 6964 203a 2069 6e74 0a20 2020 2020  e_id : int.     
-000174d0: 2020 2049 6e64 6578 206f 6620 7370 696b     Index of spik
-000174e0: 6520 7472 6169 6e73 202d 2074 656d 706c  e trains - templ
-000174f0: 6174 652e 0a20 2020 2073 745f 6964 7820  ate..    st_idx 
-00017500: 3a20 6e70 2e61 7272 6179 0a20 2020 2020  : np.array.     
-00017510: 2020 2053 7069 6b65 2074 696d 6573 0a20     Spike times. 
-00017520: 2020 2074 656d 706c 6174 6520 3a20 6e70     template : np
-00017530: 2e61 7272 6179 0a20 2020 2020 2020 2041  .array.        A
-00017540: 7272 6179 2077 6974 6820 7465 6d70 6c61  rray with templa
-00017550: 7465 0a20 2020 206e 5f73 616d 706c 6573  te.    n_samples
-00017560: 203a 2069 6e74 0a20 2020 2020 2020 204e   : int.        N
-00017570: 756d 6265 7220 6f66 2073 616d 706c 6573  umber of samples
-00017580: 2069 6e20 6368 756e 6b0a 2020 2020 6673   in chunk.    fs
-00017590: 203a 2066 6c6f 6174 0a20 2020 2020 2020   : float.       
-000175a0: 2053 616d 706c 696e 6720 6672 6571 7565   Sampling freque
-000175b0: 6e63 7920 696e 2048 7a0a 2020 2020 6375  ncy in Hz.    cu
-000175c0: 745f 6f75 7420 3a20 6c69 7374 0a20 2020  t_out : list.   
-000175d0: 2020 2020 204e 756d 6265 7220 6f66 2073       Number of s
-000175e0: 616d 706c 6573 2062 6566 6f72 6520 616e  amples before an
-000175f0: 6420 6166 7465 7220 7468 6520 7065 616b  d after the peak
-00017600: 0a20 2020 206d 6f64 756c 6174 696f 6e20  .    modulation 
-00017610: 3a20 626f 6f6c 0a20 2020 2020 2020 2049  : bool.        I
-00017620: 6620 5472 7565 206d 6f64 756c 6174 696f  f True modulatio
-00017630: 6e20 6973 2061 7070 6c69 6564 0a20 2020  n is applied.   
-00017640: 206d 6f64 5f61 7272 6179 203a 206e 702e   mod_array : np.
-00017650: 6172 7261 790a 2020 2020 2020 2020 4172  array.        Ar
-00017660: 7261 7920 7769 7468 206d 6f64 756c 6174  ray with modulat
-00017670: 696f 6e20 7661 6c75 6520 666f 7220 6561  ion value for ea
-00017680: 6368 2073 7069 6b65 0a20 2020 2076 6572  ch spike.    ver
-00017690: 626f 7365 203a 2062 6f6f 6c0a 2020 2020  bose : bool.    
-000176a0: 2020 2020 4966 2054 7275 6520 6f75 7470      If True outp
-000176b0: 7574 2069 7320 7665 7262 6f73 650a 2020  ut is verbose.  
-000176c0: 2020 6275 7273 7469 6e67 203a 2062 6f6f    bursting : boo
-000176d0: 6c0a 2020 2020 2020 2020 4966 2054 7275  l.        If Tru
-000176e0: 6520 7465 6d70 6c61 7465 7320 6172 6520  e templates are 
-000176f0: 6d6f 6475 6c61 7465 6420 696e 2073 6861  modulated in sha
-00017700: 7065 0a20 2020 2073 6861 7065 5f73 7472  pe.    shape_str
-00017710: 6574 6368 203a 2066 6c6f 6174 0a20 2020  etch : float.   
-00017720: 2020 2020 2052 616e 6765 206f 6620 7369       Range of si
-00017730: 676d 6f69 6420 7472 616e 7366 6f72 6d20  gmoid transform 
-00017740: 666f 7220 6275 7273 7469 6e67 2073 6861  for bursting sha
-00017750: 7065 2073 7472 6574 6368 0a20 2020 206d  pe stretch.    m
-00017760: 6178 5f63 6861 6e6e 656c 735f 7065 725f  ax_channels_per_
-00017770: 7465 6d70 6c61 7465 203a 206e 702e 6172  template : np.ar
-00017780: 7261 790a 2020 2020 2020 2020 4d61 7869  ray.        Maxi
-00017790: 6d75 6d20 6e75 6d62 6572 206f 6620 6368  mum number of ch
-000177a0: 616e 6e65 6c73 2074 6f20 6265 2063 6f6e  annels to be con
-000177b0: 766f 6c76 6564 0a20 2020 2072 6563 6f72  volved.    recor
-000177c0: 6469 6e67 7320 3a20 206e 702e 6172 7261  dings :  np.arra
-000177d0: 7973 0a20 2020 2020 2020 2041 7272 6179  ys.        Array
-000177e0: 2074 6f20 7573 6520 666f 7220 7265 636f   to use for reco
-000177f0: 7264 696e 6773 2e20 4966 204e 6f6e 6520  rdings. If None 
-00017800: 6974 2069 7320 6372 6561 7465 640a 2020  it is created.  
-00017810: 2020 6472 6966 745f 7665 6374 6f72 3a20    drift_vector: 
-00017820: 4e6f 6e65 206f 7220 6e70 2e61 7272 6179  None or np.array
-00017830: 2031 640a 2020 2020 2020 2020 4f70 7469   1d.        Opti
-00017840: 6f6e 616c 6c79 2074 6865 2064 7269 6674  onally the drift
-00017850: 2076 6563 746f 7220 7265 6c61 7465 6420   vector related 
-00017860: 746f 2074 6865 2063 6875 6e6b 2121 210a  to the chunk!!!.
-00017870: 2020 2020 6472 6966 745f 6673 3a20 4e6f      drift_fs: No
-00017880: 6e65 206f 7220 666c 6f61 740a 2020 2020  ne or float.    
-00017890: 2020 2020 5361 6d70 6c69 6e67 2066 7265      Sampling fre
-000178a0: 7175 656e 6379 206f 6620 7468 6520 6472  quency of the dr
-000178b0: 6966 7420 7369 676e 616c 0a20 2020 2052  ift signal.    R
-000178c0: 6574 7572 6e73 0a20 2020 202d 2d2d 2d2d  eturns.    -----
-000178d0: 2d2d 0a20 2020 2072 6563 6f72 6469 6e67  --.    recording
-000178e0: 733a 206e 702e 6172 7261 790a 2020 2020  s: np.array.    
-000178f0: 2020 2020 5472 6163 6520 7769 7468 2063      Trace with c
-00017900: 6f6e 766f 6c76 6564 2073 6967 6e61 6c73  onvolved signals
-00017910: 2028 6e5f 656c 6563 2c20 6e5f 7361 6d70   (n_elec, n_samp
-00017920: 6c65 7329 0a20 2020 2022 2222 0a20 2020  les).    """.   
-00017930: 200a 2020 2020 2320 6472 6966 7469 6e67   .    # drifting
-00017940: 203d 2064 7269 6674 5f76 6563 746f 7220   = drift_vector 
-00017950: 6973 206e 6f74 204e 6f6e 650a 2020 2020  is not None.    
-00017960: 6472 6966 7469 6e67 203d 2064 7269 6674  drifting = drift
-00017970: 5f69 6478 7320 6973 206e 6f74 204e 6f6e  _idxs is not Non
-00017980: 650a 2020 2020 6966 2064 7269 6674 696e  e.    if driftin
-00017990: 673a 0a20 2020 2020 2020 2061 7373 6572  g:.        asser
-000179a0: 7420 7465 6d70 6c61 7465 2e6e 6469 6d20  t template.ndim 
-000179b0: 3d3d 2034 0a20 2020 2065 6c73 653a 0a20  == 4.    else:. 
-000179c0: 2020 2020 2020 2061 7373 6572 7420 7465         assert te
-000179d0: 6d70 6c61 7465 2e6e 6469 6d20 3d3d 2033  mplate.ndim == 3
-000179e0: 0a20 2020 200a 2020 2020 6966 2076 6572  .    .    if ver
-000179f0: 626f 7365 3a0a 2020 2020 2020 2020 7072  bose:.        pr
-00017a00: 696e 7428 2743 6f6e 766f 6c75 7469 6f6e  int('Convolution
-00017a10: 2077 6974 6820 7370 696b 653a 272c 2073   with spike:', s
-00017a20: 7069 6b65 5f69 6429 0a20 2020 200a 0a20  pike_id).    .. 
-00017a30: 2020 2069 6620 6472 6966 7469 6e67 3a0a     if drifting:.
-00017a40: 2020 2020 2020 2020 6472 6966 745f 7374          drift_st
-00017a50: 6570 7320 3d20 7465 6d70 6c61 7465 2e73  eps = template.s
-00017a60: 6861 7065 5b30 5d0a 2020 2020 2020 2020  hape[0].        
-00017a70: 6e5f 6a69 7474 203d 2074 656d 706c 6174  n_jitt = templat
-00017a80: 652e 7368 6170 655b 315d 0a20 2020 2020  e.shape[1].     
-00017a90: 2020 206e 5f65 6c65 6320 3d20 7465 6d70     n_elec = temp
-00017aa0: 6c61 7465 2e73 6861 7065 5b32 5d0a 2020  late.shape[2].  
-00017ab0: 2020 2020 2020 6c65 6e5f 7370 696b 6520        len_spike 
-00017ac0: 3d20 7465 6d70 6c61 7465 2e73 6861 7065  = template.shape
-00017ad0: 5b33 5d0a 2020 2020 2020 2020 6472 6966  [3].        drif
-00017ae0: 745f 6964 7873 203d 2064 7269 6674 5f69  t_idxs = drift_i
-00017af0: 6478 732e 636c 6970 2830 2c20 6472 6966  dxs.clip(0, drif
-00017b00: 745f 7374 6570 7320 2d20 3129 0a20 2020  t_steps - 1).   
-00017b10: 2065 6c73 653a 0a20 2020 2020 2020 206e   else:.        n
-00017b20: 5f6a 6974 7420 3d20 7465 6d70 6c61 7465  _jitt = template
-00017b30: 2e73 6861 7065 5b30 5d0a 2020 2020 2020  .shape[0].      
-00017b40: 2020 6e5f 656c 6563 203d 2074 656d 706c    n_elec = templ
-00017b50: 6174 652e 7368 6170 655b 315d 0a20 2020  ate.shape[1].   
-00017b60: 2020 2020 206c 656e 5f73 7069 6b65 203d       len_spike =
-00017b70: 2074 656d 706c 6174 652e 7368 6170 655b   template.shape[
-00017b80: 325d 0a0a 2020 2020 6966 2072 6563 6f72  2]..    if recor
-00017b90: 6469 6e67 7320 6973 204e 6f6e 653a 0a20  dings is None:. 
-00017ba0: 2020 2020 2020 2072 6563 6f72 6469 6e67         recording
-00017bb0: 7320 3d20 6e70 2e7a 6572 6f73 2828 6e5f  s = np.zeros((n_
-00017bc0: 7361 6d70 6c65 732c 206e 5f65 6c65 6329  samples, n_elec)
-00017bd0: 290a 2020 2020 656c 7365 3a0a 2020 2020  ).    else:.    
-00017be0: 2020 2020 6173 7365 7274 2072 6563 6f72      assert recor
-00017bf0: 6469 6e67 732e 7368 6170 6520 3d3d 2028  dings.shape == (
-00017c00: 6e5f 7361 6d70 6c65 732c 206e 5f65 6c65  n_samples, n_ele
-00017c10: 6329 2c20 2227 7265 636f 7264 696e 6773  c), "'recordings
-00017c20: 2720 6861 7320 7468 6520 7772 6f6e 6720  ' has the wrong 
-00017c30: 7368 6170 6522 0a0a 2020 2020 6474 7970  shape"..    dtyp
-00017c40: 6520 3d20 7265 636f 7264 696e 6773 2e64  e = recordings.d
-00017c50: 7479 7065 0a0a 2020 2020 6966 2063 7574  type..    if cut
-00017c60: 5f6f 7574 2069 7320 4e6f 6e65 3a0a 2020  _out is None:.  
-00017c70: 2020 2020 2020 6375 745f 6f75 7420 3d20        cut_out = 
-00017c80: 5b6c 656e 5f73 7069 6b65 202f 2f20 322c  [len_spike // 2,
-00017c90: 206c 656e 5f73 7069 6b65 202f 2f20 325d   len_spike // 2]
-00017ca0: 0a0a 2020 2020 6966 206e 6f74 206d 6f64  ..    if not mod
-00017cb0: 756c 6174 696f 6e3a 0a20 2020 2020 2020  ulation:.       
-00017cc0: 2023 204e 6f20 6d6f 6475 6c61 7469 6f6e   # No modulation
-00017cd0: 0a20 2020 2020 2020 206d 6f64 5f61 7272  .        mod_arr
-00017ce0: 6179 203d 206e 702e 6f6e 6573 5f6c 696b  ay = np.ones_lik
-00017cf0: 6528 7374 5f69 6478 290a 2020 2020 656c  e(st_idx).    el
-00017d00: 7365 3a0a 2020 2020 2020 2020 6173 7365  se:.        asse
-00017d10: 7274 206d 6f64 5f61 7272 6179 2069 7320  rt mod_array is 
-00017d20: 6e6f 7420 4e6f 6e65 2c20 2220 466f 7220  not None, " For 
-00017d30: 2765 6c65 6374 726f 6465 2720 616e 6420  'electrode' and 
-00017d40: 2774 656d 706c 6174 6527 206d 6f64 756c  'template' modul
-00017d50: 6174 696f 6e73 2070 726f 7669 6465 2027  ations provide '
-00017d60: 6d6f 645f 6172 7261 7927 220a 0a20 2020  mod_array'"..   
-00017d70: 2066 6f72 2070 6f73 2c20 7370 6f73 2069   for pos, spos i
-00017d80: 6e20 656e 756d 6572 6174 6528 7374 5f69  n enumerate(st_i
-00017d90: 6478 293a 0a0a 2020 2020 2020 2020 7261  dx):..        ra
-00017da0: 6e64 5f69 6478 203d 206e 702e 7261 6e64  nd_idx = np.rand
-00017db0: 6f6d 2e72 616e 6469 6e74 286e 5f6a 6974  om.randint(n_jit
-00017dc0: 7429 0a20 2020 2020 2020 2069 6620 6472  t).        if dr
-00017dd0: 6966 7469 6e67 3a0a 2020 2020 2020 2020  ifting:.        
-00017de0: 2020 2020 6472 6966 745f 696e 6420 3d20      drift_ind = 
-00017df0: 6472 6966 745f 6964 7873 5b70 6f73 5d20  drift_idxs[pos] 
-00017e00: 2369 6e74 2873 706f 7320 2f20 6673 202a  #int(spos / fs *
-00017e10: 2064 7269 6674 5f66 7329 0a20 2020 2020   drift_fs).     
-00017e20: 2020 2020 2020 2023 2064 7269 6674 5f69         # drift_i
-00017e30: 6e64 203d 2064 7269 6674 5f76 6563 746f  nd = drift_vecto
-00017e40: 725b 7370 6f73 5f64 7269 6674 5d0a 2020  r[spos_drift].  
-00017e50: 2020 2020 2020 2020 2020 7465 6d70 5f6a            temp_j
-00017e60: 6974 7420 3d20 7465 6d70 6c61 7465 5b64  itt = template[d
-00017e70: 7269 6674 5f69 6e64 2c20 7261 6e64 5f69  rift_ind, rand_i
-00017e80: 6478 5d0a 2020 2020 2020 2020 656c 7365  dx].        else
-00017e90: 3a0a 2020 2020 2020 2020 2020 2020 7465  :.            te
-00017ea0: 6d70 5f6a 6974 7420 3d20 7465 6d70 6c61  mp_jitt = templa
-00017eb0: 7465 5b72 616e 645f 6964 785d 0a0a 2020  te[rand_idx]..  
-00017ec0: 2020 2020 2020 6966 206d 6178 5f63 6861        if max_cha
-00017ed0: 6e6e 656c 735f 7065 725f 7465 6d70 6c61  nnels_per_templa
-00017ee0: 7465 2069 7320 4e6f 6e65 3a0a 2020 2020  te is None:.    
-00017ef0: 2020 2020 2020 2020 656c 6563 5f69 6478          elec_idx
-00017f00: 7320 3d20 6e70 2e61 7261 6e67 6528 6e5f  s = np.arange(n_
-00017f10: 656c 6563 290a 2020 2020 2020 2020 656c  elec).        el
-00017f20: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-00017f30: 2320 6669 6e64 206d 6178 2063 6861 6e6e  # find max chann
-00017f40: 656c 730a 2020 2020 2020 2020 2020 2020  els.            
-00017f50: 7065 616b 5f69 6478 203d 206e 702e 756e  peak_idx = np.un
-00017f60: 7261 7665 6c5f 696e 6465 7828 6e70 2e61  ravel_index(np.a
-00017f70: 7267 6d61 7828 6e70 2e61 6273 2874 656d  rgmax(np.abs(tem
-00017f80: 705f 6a69 7474 2929 2c20 7465 6d70 5f6a  p_jitt)), temp_j
-00017f90: 6974 742e 7368 6170 6529 5b31 5d0a 2020  itt.shape)[1].  
-00017fa0: 2020 2020 2020 2020 2020 656c 6563 5f69            elec_i
-00017fb0: 6478 7320 3d20 6e70 2e61 7267 736f 7274  dxs = np.argsort
-00017fc0: 286e 702e 6162 7328 7465 6d70 5f6a 6974  (np.abs(temp_jit
-00017fd0: 745b 3a2c 2070 6561 6b5f 6964 785d 2929  t[:, peak_idx]))
-00017fe0: 5b3a 3a2d 315d 5b3a 6d61 785f 6368 616e  [::-1][:max_chan
-00017ff0: 6e65 6c73 5f70 6572 5f74 656d 706c 6174  nels_per_templat
-00018000: 655d 0a20 2020 2020 2020 2020 2020 2074  e].            t
-00018010: 656d 705f 6a69 7474 203d 2074 656d 705f  emp_jitt = temp_
-00018020: 6a69 7474 5b65 6c65 635f 6964 7873 5d0a  jitt[elec_idxs].
-00018030: 0a20 2020 2020 2020 2069 6620 6275 7273  .        if burs
-00018040: 7469 6e67 3a0a 2020 2020 2020 2020 2020  ting:.          
-00018050: 2020 6966 206e 6f74 2069 7369 6e73 7461    if not isinsta
-00018060: 6e63 6528 6d6f 645f 6172 7261 795b 305d  nce(mod_array[0]
-00018070: 2c20 286c 6973 742c 2074 7570 6c65 2c20  , (list, tuple, 
-00018080: 6e70 2e6e 6461 7272 6179 2929 3a0a 2020  np.ndarray)):.  
-00018090: 2020 2020 2020 2020 2020 2020 2020 2320                # 
-000180a0: 7465 6d70 6c61 7465 0a20 2020 2020 2020  template.       
-000180b0: 2020 2020 2020 2020 2069 6620 7370 6f73           if spos
-000180c0: 202d 2063 7574 5f6f 7574 5b30 5d20 3e3d   - cut_out[0] >=
-000180d0: 2030 2061 6e64 2073 706f 7320 2d20 6375   0 and spos - cu
-000180e0: 745f 6f75 745b 305d 202b 206c 656e 5f73  t_out[0] + len_s
-000180f0: 7069 6b65 203c 3d20 6e5f 7361 6d70 6c65  pike <= n_sample
-00018100: 733a 0a20 2020 2020 2020 2020 2020 2020  s:.             
-00018110: 2020 2020 2020 2073 6e69 7070 6574 203d         snippet =
-00018120: 2063 6f6d 7075 7465 5f73 7472 6574 6368   compute_stretch
-00018130: 6564 5f74 656d 706c 6174 6528 7465 6d70  ed_template(temp
-00018140: 5f6a 6974 742c 206d 6f64 5f61 7272 6179  _jitt, mod_array
-00018150: 5b70 6f73 5d2c 2073 6861 7065 5f73 7472  [pos], shape_str
-00018160: 6574 6368 292e 540a 2020 2020 2020 2020  etch).T.        
-00018170: 2020 2020 2020 2020 2020 2020 7265 636f              reco
-00018180: 7264 696e 6773 5b73 706f 7320 2d20 6375  rdings[spos - cu
-00018190: 745f 6f75 745b 305d 3a73 706f 7320 2b20  t_out[0]:spos + 
-000181a0: 6375 745f 6f75 745b 315d 2c20 656c 6563  cut_out[1], elec
-000181b0: 5f69 6478 735d 202b 3d20 736e 6970 7065  _idxs] += snippe
-000181c0: 742e 6173 7479 7065 2864 7479 7065 290a  t.astype(dtype).
-000181d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000181e0: 656c 6966 2073 706f 7320 2d20 6375 745f  elif spos - cut_
-000181f0: 6f75 745b 305d 203c 2030 3a0a 2020 2020  out[0] < 0:.    
-00018200: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018210: 6469 6666 203d 202d 2873 706f 7320 2d20  diff = -(spos - 
-00018220: 6375 745f 6f75 745b 305d 290a 2020 2020  cut_out[0]).    
-00018230: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018240: 736e 6970 7065 7420 3d20 636f 6d70 7574  snippet = comput
-00018250: 655f 7374 7265 7463 6865 645f 7465 6d70  e_stretched_temp
-00018260: 6c61 7465 2874 656d 705f 6a69 7474 2c20  late(temp_jitt, 
-00018270: 6d6f 645f 6172 7261 795b 706f 735d 2c20  mod_array[pos], 
-00018280: 7368 6170 655f 7374 7265 7463 6829 5b3a  shape_stretch)[:
-00018290: 2c20 6469 6666 3a5d 2e54 0a20 2020 2020  , diff:].T.     
-000182a0: 2020 2020 2020 2020 2020 2020 2020 2072                 r
-000182b0: 6563 6f72 6469 6e67 735b 3a73 706f 7320  ecordings[:spos 
-000182c0: 2b20 6375 745f 6f75 745b 315d 2c20 656c  + cut_out[1], el
-000182d0: 6563 5f69 6478 735d 202b 3d20 736e 6970  ec_idxs] += snip
-000182e0: 7065 742e 6173 7479 7065 2864 7479 7065  pet.astype(dtype
-000182f0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-00018300: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
-00018310: 2020 2020 2020 2020 2020 2020 6469 6666              diff
-00018320: 203d 206e 5f73 616d 706c 6573 202d 2028   = n_samples - (
-00018330: 7370 6f73 202d 2063 7574 5f6f 7574 5b30  spos - cut_out[0
-00018340: 5d29 0a20 2020 2020 2020 2020 2020 2020  ]).             
-00018350: 2020 2020 2020 2073 6e69 7070 6574 203d         snippet =
-00018360: 2063 6f6d 7075 7465 5f73 7472 6574 6368   compute_stretch
-00018370: 6564 5f74 656d 706c 6174 6528 7465 6d70  ed_template(temp
-00018380: 5f6a 6974 742c 206d 6f64 5f61 7272 6179  _jitt, mod_array
-00018390: 5b70 6f73 5d2c 2073 6861 7065 5f73 7472  [pos], shape_str
-000183a0: 6574 6368 295b 3a2c 203a 6469 6666 5d2e  etch)[:, :diff].
-000183b0: 540a 2020 2020 2020 2020 2020 2020 2020  T.              
-000183c0: 2020 2020 2020 7265 636f 7264 696e 6773        recordings
-000183d0: 5b73 706f 7320 2d20 6375 745f 6f75 745b  [spos - cut_out[
-000183e0: 305d 3a2c 2065 6c65 635f 6964 7873 5d20  0]:, elec_idxs] 
-000183f0: 2b3d 2073 6e69 7070 6574 2e61 7374 7970  += snippet.astyp
-00018400: 6528 6474 7970 6529 0a20 2020 2020 2020  e(dtype).       
-00018410: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
-00018420: 2020 2020 2020 2020 2020 2023 2065 6c65             # ele
-00018430: 6374 726f 6465 0a20 2020 2020 2020 2020  ctrode.         
-00018440: 2020 2020 2020 2069 6620 7370 6f73 202d         if spos -
-00018450: 2063 7574 5f6f 7574 5b30 5d20 3e3d 2030   cut_out[0] >= 0
-00018460: 2061 6e64 2073 706f 7320 2d20 6375 745f   and spos - cut_
-00018470: 6f75 745b 305d 202b 206c 656e 5f73 7069  out[0] + len_spi
-00018480: 6b65 203c 3d20 6e5f 7361 6d70 6c65 733a  ke <= n_samples:
-00018490: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000184a0: 2020 2020 2073 6e69 7070 6574 203d 2063       snippet = c
-000184b0: 6f6d 7075 7465 5f73 7472 6574 6368 6564  ompute_stretched
-000184c0: 5f74 656d 706c 6174 6528 7465 6d70 5f6a  _template(temp_j
-000184d0: 6974 742c 206d 6f64 5f61 7272 6179 5b70  itt, mod_array[p
-000184e0: 6f73 5d2c 2073 6861 7065 5f73 7472 6574  os], shape_stret
-000184f0: 6368 292e 540a 2020 2020 2020 2020 2020  ch).T.          
-00018500: 2020 2020 2020 2020 2020 7265 636f 7264            record
-00018510: 696e 6773 5b73 706f 7320 2d20 6375 745f  ings[spos - cut_
-00018520: 6f75 745b 305d 3a73 706f 7320 2b20 6375  out[0]:spos + cu
-00018530: 745f 6f75 745b 315d 2c20 656c 6563 5f69  t_out[1], elec_i
-00018540: 6478 735d 202b 3d20 736e 6970 7065 742e  dxs] += snippet.
-00018550: 6173 7479 7065 2864 7479 7065 290a 2020  astype(dtype).  
-00018560: 2020 2020 2020 2020 2020 2020 2020 656c                el
-00018570: 6966 2073 706f 7320 2d20 6375 745f 6f75  if spos - cut_ou
-00018580: 745b 305d 203c 2030 3a0a 2020 2020 2020  t[0] < 0:.      
-00018590: 2020 2020 2020 2020 2020 2020 2020 6469                di
-000185a0: 6666 203d 202d 2873 706f 7320 2d20 6375  ff = -(spos - cu
-000185b0: 745f 6f75 745b 305d 290a 2020 2020 2020  t_out[0]).      
-000185c0: 2020 2020 2020 2020 2020 2020 2020 736e                sn
-000185d0: 6970 7065 7420 3d20 636f 6d70 7574 655f  ippet = compute_
-000185e0: 7374 7265 7463 6865 645f 7465 6d70 6c61  stretched_templa
-000185f0: 7465 2874 656d 705f 6a69 7474 2c20 6d6f  te(temp_jitt, mo
-00018600: 645f 6172 7261 795b 706f 735d 2c20 7368  d_array[pos], sh
-00018610: 6170 655f 7374 7265 7463 6829 5b3a 2c20  ape_stretch)[:, 
-00018620: 6469 6666 3a5d 2e54 0a20 2020 2020 2020  diff:].T.       
-00018630: 2020 2020 2020 2020 2020 2020 2072 6563               rec
-00018640: 6f72 6469 6e67 735b 3a73 706f 7320 2b20  ordings[:spos + 
-00018650: 6375 745f 6f75 745b 315d 2c20 656c 6563  cut_out[1], elec
-00018660: 5f69 6478 735d 202b 3d20 736e 6970 7065  _idxs] += snippe
-00018670: 742e 6173 7479 7065 2864 7479 7065 290a  t.astype(dtype).
-00018680: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018690: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
-000186a0: 2020 2020 2020 2020 2020 6469 6666 203d            diff =
-000186b0: 206e 5f73 616d 706c 6573 202d 2028 7370   n_samples - (sp
-000186c0: 6f73 202d 2063 7574 5f6f 7574 5b30 5d29  os - cut_out[0])
-000186d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000186e0: 2020 2020 2073 6e69 7070 6574 203d 2063       snippet = c
-000186f0: 6f6d 7075 7465 5f73 7472 6574 6368 6564  ompute_stretched
-00018700: 5f74 656d 706c 6174 6528 7465 6d70 5f6a  _template(temp_j
-00018710: 6974 742c 206d 6f64 5f61 7272 6179 5b70  itt, mod_array[p
-00018720: 6f73 5d2c 2073 6861 7065 5f73 7472 6574  os], shape_stret
-00018730: 6368 295b 3a2c 203a 6469 6666 5d2e 540a  ch)[:, :diff].T.
-00018740: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018750: 2020 2020 7265 636f 7264 696e 6773 5b73      recordings[s
-00018760: 706f 7320 2d20 6375 745f 6f75 745b 305d  pos - cut_out[0]
-00018770: 3a2c 2065 6c65 635f 6964 7873 5d20 2b3d  :, elec_idxs] +=
-00018780: 2073 6e69 7070 6574 2e61 7374 7970 6528   snippet.astype(
-00018790: 6474 7970 6529 0a20 2020 2020 2020 2065  dtype).        e
-000187a0: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
-000187b0: 2069 6620 6e6f 7420 6973 696e 7374 616e   if not isinstan
-000187c0: 6365 286d 6f64 5f61 7272 6179 5b30 5d2c  ce(mod_array[0],
-000187d0: 2028 6c69 7374 2c20 7475 706c 652c 206e   (list, tuple, n
-000187e0: 702e 6e64 6172 7261 7929 293a 0a20 2020  p.ndarray)):.   
-000187f0: 2020 2020 2020 2020 2020 2020 2023 2074               # t
-00018800: 656d 706c 6174 6520 2b20 6e6f 6e65 0a20  emplate + none. 
-00018810: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-00018820: 6620 7370 6f73 202d 2063 7574 5f6f 7574  f spos - cut_out
-00018830: 5b30 5d20 3e3d 2030 2061 6e64 2073 706f  [0] >= 0 and spo
-00018840: 7320 2b20 6375 745f 6f75 745b 315d 203c  s + cut_out[1] <
-00018850: 3d20 6e5f 7361 6d70 6c65 733a 0a20 2020  = n_samples:.   
-00018860: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018870: 2073 6e69 7070 6574 203d 206d 6f64 5f61   snippet = mod_a
-00018880: 7272 6179 5b70 6f73 5d20 2a20 7465 6d70  rray[pos] * temp
-00018890: 5f6a 6974 742e 540a 2020 2020 2020 2020  _jitt.T.        
-000188a0: 2020 2020 2020 2020 2020 2020 7265 636f              reco
-000188b0: 7264 696e 6773 5b73 706f 7320 2d20 6375  rdings[spos - cu
-000188c0: 745f 6f75 745b 305d 3a73 706f 7320 2b20  t_out[0]:spos + 
-000188d0: 6375 745f 6f75 745b 315d 2c20 656c 6563  cut_out[1], elec
-000188e0: 5f69 6478 735d 202b 3d20 736e 6970 7065  _idxs] += snippe
-000188f0: 742e 6173 7479 7065 2864 7479 7065 290a  t.astype(dtype).
-00018900: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018910: 656c 6966 2073 706f 7320 2d20 6375 745f  elif spos - cut_
-00018920: 6f75 745b 305d 203c 2030 3a0a 2020 2020  out[0] < 0:.    
-00018930: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018940: 6469 6666 203d 202d 2873 706f 7320 2d20  diff = -(spos - 
-00018950: 6375 745f 6f75 745b 305d 290a 2020 2020  cut_out[0]).    
-00018960: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018970: 736e 6970 7065 7420 3d20 6d6f 645f 6172  snippet = mod_ar
-00018980: 7261 795b 706f 735d 202a 2074 656d 705f  ray[pos] * temp_
-00018990: 6a69 7474 5b3a 2c20 6469 6666 3a5d 2e54  jitt[:, diff:].T
-000189a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000189b0: 2020 2020 2072 6563 6f72 6469 6e67 735b       recordings[
-000189c0: 3a73 706f 7320 2b20 6375 745f 6f75 745b  :spos + cut_out[
-000189d0: 315d 2c20 656c 6563 5f69 6478 735d 202b  1], elec_idxs] +
-000189e0: 3d20 736e 6970 7065 742e 6173 7479 7065  = snippet.astype
-000189f0: 2864 7479 7065 290a 2020 2020 2020 2020  (dtype).        
-00018a00: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
-00018a10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018a20: 2020 6469 6666 203d 206e 5f73 616d 706c    diff = n_sampl
-00018a30: 6573 202d 2028 7370 6f73 202d 2063 7574  es - (spos - cut
-00018a40: 5f6f 7574 5b30 5d29 0a20 2020 2020 2020  _out[0]).       
-00018a50: 2020 2020 2020 2020 2020 2020 2073 6e69               sni
-00018a60: 7070 6574 203d 206d 6f64 5f61 7272 6179  ppet = mod_array
-00018a70: 5b70 6f73 5d20 2a20 7465 6d70 5f6a 6974  [pos] * temp_jit
-00018a80: 745b 3a2c 203a 6469 6666 5d2e 540a 2020  t[:, :diff].T.  
-00018a90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018aa0: 2020 7265 636f 7264 696e 6773 5b73 706f    recordings[spo
-00018ab0: 7320 2d20 6375 745f 6f75 745b 305d 3a2c  s - cut_out[0]:,
-00018ac0: 2065 6c65 635f 6964 7873 5d20 2b3d 2073   elec_idxs] += s
-00018ad0: 6e69 7070 6574 2e61 7374 7970 6528 6474  nippet.astype(dt
-00018ae0: 7970 6529 0a20 2020 2020 2020 2020 2020  ype).           
-00018af0: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
-00018b00: 2020 2020 2020 2023 2065 6c65 6374 726f         # electro
-00018b10: 6465 0a20 2020 2020 2020 2020 2020 2020  de.             
-00018b20: 2020 2069 6620 7370 6f73 202d 2063 7574     if spos - cut
-00018b30: 5f6f 7574 5b30 5d20 3e3d 2030 2061 6e64  _out[0] >= 0 and
-00018b40: 2073 706f 7320 2b20 6375 745f 6f75 745b   spos + cut_out[
-00018b50: 315d 203c 3d20 6e5f 7361 6d70 6c65 733a  1] <= n_samples:
-00018b60: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00018b70: 2020 2020 2073 6e69 7070 6574 203d 206e       snippet = n
-00018b80: 702e 6172 7261 7928 5b61 202a 2074 2066  p.array([a * t f
-00018b90: 6f72 2028 612c 2074 2920 696e 207a 6970  or (a, t) in zip
-00018ba0: 286d 6f64 5f61 7272 6179 5b70 6f73 5d2c  (mod_array[pos],
-00018bb0: 2074 656d 705f 6a69 7474 295d 292e 540a   temp_jitt)]).T.
-00018bc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018bd0: 2020 2020 7265 636f 7264 696e 6773 5b73      recordings[s
-00018be0: 706f 7320 2d20 6375 745f 6f75 745b 305d  pos - cut_out[0]
-00018bf0: 3a73 706f 7320 2b20 6375 745f 6f75 745b  :spos + cut_out[
-00018c00: 315d 2c20 656c 6563 5f69 6478 735d 202b  1], elec_idxs] +
-00018c10: 3d20 736e 6970 7065 742e 6173 7479 7065  = snippet.astype
-00018c20: 2864 7479 7065 290a 2020 2020 2020 2020  (dtype).        
-00018c30: 2020 2020 2020 2020 656c 6966 2073 706f          elif spo
-00018c40: 7320 2d20 6375 745f 6f75 745b 305d 203c  s - cut_out[0] <
-00018c50: 2030 3a0a 2020 2020 2020 2020 2020 2020   0:.            
-00018c60: 2020 2020 2020 2020 6469 6666 203d 202d          diff = -
-00018c70: 2873 706f 7320 2d20 6375 745f 6f75 745b  (spos - cut_out[
-00018c80: 305d 290a 2020 2020 2020 2020 2020 2020  0]).            
-00018c90: 2020 2020 2020 2020 736e 6970 7065 7420          snippet 
-00018ca0: 3d20 6e70 2e61 7272 6179 285b 6120 2a20  = np.array([a * 
-00018cb0: 7420 666f 7220 2861 2c20 7429 2069 6e20  t for (a, t) in 
-00018cc0: 7a69 7028 6d6f 645f 6172 7261 795b 706f  zip(mod_array[po
-00018cd0: 735d 2c20 7465 6d70 5f6a 6974 745b 3a2c  s], temp_jitt[:,
-00018ce0: 2064 6966 663a 5d29 5d29 2e54 0a20 2020   diff:])]).T.   
-00018cf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018d00: 2072 6563 6f72 6469 6e67 735b 3a73 706f   recordings[:spo
-00018d10: 7320 2b20 6375 745f 6f75 745b 315d 2c20  s + cut_out[1], 
-00018d20: 656c 6563 5f69 6478 735d 202b 3d20 736e  elec_idxs] += sn
-00018d30: 6970 7065 742e 6173 7479 7065 2864 7479  ippet.astype(dty
-00018d40: 7065 290a 2020 2020 2020 2020 2020 2020  pe).            
-00018d50: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-00018d60: 2020 2020 2020 2020 2020 2020 2020 6469                di
-00018d70: 6666 203d 206e 5f73 616d 706c 6573 202d  ff = n_samples -
-00018d80: 2028 7370 6f73 202d 2063 7574 5f6f 7574   (spos - cut_out
-00018d90: 5b30 5d29 0a20 2020 2020 2020 2020 2020  [0]).           
-00018da0: 2020 2020 2020 2020 2073 6e69 7070 6574           snippet
-00018db0: 203d 206e 702e 6172 7261 7928 5b61 202a   = np.array([a *
-00018dc0: 2074 2066 6f72 2028 612c 2074 2920 696e   t for (a, t) in
-00018dd0: 207a 6970 286d 6f64 5f61 7272 6179 5b70   zip(mod_array[p
-00018de0: 6f73 5d2c 2074 656d 705f 6a69 7474 5b3a  os], temp_jitt[:
-00018df0: 2c20 3a64 6966 665d 295d 292e 540a 2020  , :diff])]).T.  
+00017340: 2020 2020 6966 206d 6f64 5f61 7272 6179      if mod_array
+00017350: 5b70 6f73 5d2e 7369 7a65 203e 2031 3a0a  [pos].size > 1:.
+00017360: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00017370: 2020 2020 2020 2020 6d6f 645f 7661 6c75          mod_valu
+00017380: 6520 3d20 6e70 2e6d 6561 6e28 6d6f 645f  e = np.mean(mod_
+00017390: 6172 7261 795b 706f 735d 290a 2020 2020  array[pos]).    
+000173a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000173b0: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+000173c0: 2020 2020 2020 2020 2020 2020 2020 6d6f                mo
+000173d0: 645f 7661 6c75 6520 3d20 6d6f 645f 6172  d_value = mod_ar
+000173e0: 7261 795b 706f 735d 0a20 2020 2020 2020  ray[pos].       
+000173f0: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+00017400: 7370 6f73 202d 2063 7574 5f6f 7574 5b30  spos - cut_out[0
+00017410: 5d20 3e3d 2030 2061 6e64 2073 706f 7320  ] >= 0 and spos 
+00017420: 2d20 6375 745f 6f75 745b 305d 202b 206c  - cut_out[0] + l
+00017430: 656e 5f73 7069 6b65 203c 3d20 6e5f 7361  en_spike <= n_sa
+00017440: 6d70 6c65 733a 0a20 2020 2020 2020 2020  mples:.         
+00017450: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+00017460: 7069 6b65 5f74 7261 6365 5b73 706f 7320  pike_trace[spos 
+00017470: 2d20 6375 745f 6f75 745b 305d 203a 2073  - cut_out[0] : s
+00017480: 706f 7320 2d20 6375 745f 6f75 745b 305d  pos - cut_out[0]
+00017490: 202b 206c 656e 5f73 7069 6b65 5d20 2b3d   + len_spike] +=
+000174a0: 206d 6f64 5f76 616c 7565 202a 2074 656d   mod_value * tem
+000174b0: 705f 6a69 7474 0a20 2020 2020 2020 2020  p_jitt.         
+000174c0: 2020 2020 2020 2020 2020 2065 6c69 6620             elif 
+000174d0: 7370 6f73 202d 2063 7574 5f6f 7574 5b30  spos - cut_out[0
+000174e0: 5d20 3c20 303a 0a20 2020 2020 2020 2020  ] < 0:.         
+000174f0: 2020 2020 2020 2020 2020 2020 2020 2064                 d
+00017500: 6966 6620 3d20 2d28 7370 6f73 202d 2063  iff = -(spos - c
+00017510: 7574 5f6f 7574 5b30 5d29 0a20 2020 2020  ut_out[0]).     
+00017520: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00017530: 2020 2073 7069 6b65 5f74 7261 6365 5b3a     spike_trace[:
+00017540: 2073 706f 7320 2d20 6375 745f 6f75 745b   spos - cut_out[
+00017550: 305d 202b 206c 656e 5f73 7069 6b65 5d20  0] + len_spike] 
+00017560: 2b3d 206d 6f64 5f76 616c 7565 202a 2074  += mod_value * t
+00017570: 656d 705f 6a69 7474 5b64 6966 663a 5d0a  emp_jitt[diff:].
+00017580: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00017590: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+000175a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000175b0: 2020 6469 6666 203d 206e 5f73 616d 706c    diff = n_sampl
+000175c0: 6573 202d 2028 7370 6f73 202d 2063 7574  es - (spos - cut
+000175d0: 5f6f 7574 5b30 5d29 0a20 2020 2020 2020  _out[0]).       
+000175e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000175f0: 2073 7069 6b65 5f74 7261 6365 5b73 706f   spike_trace[spo
+00017600: 7320 2d20 6375 745f 6f75 745b 305d 203a  s - cut_out[0] :
+00017610: 5d20 2b3d 206d 6f64 5f76 616c 7565 202a  ] += mod_value *
+00017620: 2074 656d 705f 6a69 7474 5b3a 6469 6666   temp_jitt[:diff
+00017630: 5d0a 2020 2020 656c 7365 3a0a 2020 2020  ].    else:.    
+00017640: 2020 2020 7261 6973 6520 4578 6365 7074      raise Except
+00017650: 696f 6e28 2246 6f72 2064 7269 6674 696e  ion("For driftin
+00017660: 6720 6c65 6e28 7465 6d70 6c61 7465 2e73  g len(template.s
+00017670: 6861 7065 2920 7368 6f75 6c64 2062 6520  hape) should be 
+00017680: 3222 290a 2020 2020 7265 7475 726e 2073  2").    return s
+00017690: 7069 6b65 5f74 7261 6365 0a0a 0a64 6566  pike_trace...def
+000176a0: 2063 6f6e 766f 6c76 655f 7465 6d70 6c61   convolve_templa
+000176b0: 7465 735f 7370 696b 6574 7261 696e 7328  tes_spiketrains(
+000176c0: 0a20 2020 2073 7069 6b65 5f69 642c 0a20  .    spike_id,. 
+000176d0: 2020 2073 745f 6964 782c 0a20 2020 2074     st_idx,.    t
+000176e0: 656d 706c 6174 652c 0a20 2020 206e 5f73  emplate,.    n_s
+000176f0: 616d 706c 6573 2c0a 2020 2020 6375 745f  amples,.    cut_
+00017700: 6f75 743d 4e6f 6e65 2c0a 2020 2020 6d6f  out=None,.    mo
+00017710: 6475 6c61 7469 6f6e 3d46 616c 7365 2c0a  dulation=False,.
+00017720: 2020 2020 6d6f 645f 6172 7261 793d 4e6f      mod_array=No
+00017730: 6e65 2c0a 2020 2020 7665 7262 6f73 653d  ne,.    verbose=
+00017740: 4661 6c73 652c 0a20 2020 2062 7572 7374  False,.    burst
+00017750: 696e 673d 4661 6c73 652c 0a20 2020 2073  ing=False,.    s
+00017760: 6861 7065 5f73 7472 6574 6368 3d4e 6f6e  hape_stretch=Non
+00017770: 652c 0a20 2020 206d 6178 5f63 6861 6e6e  e,.    max_chann
+00017780: 656c 735f 7065 725f 7465 6d70 6c61 7465  els_per_template
+00017790: 3d4e 6f6e 652c 0a20 2020 2072 6563 6f72  =None,.    recor
+000177a0: 6469 6e67 733d 4e6f 6e65 2c0a 2020 2020  dings=None,.    
+000177b0: 6472 6966 745f 6964 7873 3d4e 6f6e 652c  drift_idxs=None,
+000177c0: 0a29 3a0a 2020 2020 2320 2c20 6472 6966  .):.    # , drif
+000177d0: 745f 7665 6374 6f72 3d4e 6f6e 652c 2064  t_vector=None, d
+000177e0: 7269 6674 5f66 733d 4e6f 6e65 293a 0a20  rift_fs=None):. 
+000177f0: 2020 2022 2222 0a20 2020 2043 6f6e 766f     """.    Convo
+00017800: 6c76 6520 7465 6d70 6c61 7465 2077 6974  lve template wit
+00017810: 6820 7370 696b 6520 7472 6169 6e20 6f6e  h spike train on
+00017820: 2061 6c6c 2065 6c65 6374 726f 6465 732e   all electrodes.
+00017830: 2055 7365 6420 746f 2063 6f6d 7075 7465   Used to compute
+00017840: 2027 7265 636f 7264 696e 6773 272e 0a0a   'recordings'...
+00017850: 2020 2020 5061 7261 6d65 7465 7273 0a20      Parameters. 
+00017860: 2020 202d 2d2d 2d2d 2d2d 2d2d 2d0a 2020     ----------.  
+00017870: 2020 7370 696b 655f 6964 203a 2069 6e74    spike_id : int
+00017880: 0a20 2020 2020 2020 2049 6e64 6578 206f  .        Index o
+00017890: 6620 7370 696b 6520 7472 6169 6e73 202d  f spike trains -
+000178a0: 2074 656d 706c 6174 652e 0a20 2020 2073   template..    s
+000178b0: 745f 6964 7820 3a20 6e70 2e61 7272 6179  t_idx : np.array
+000178c0: 0a20 2020 2020 2020 2053 7069 6b65 2074  .        Spike t
+000178d0: 696d 6573 0a20 2020 2074 656d 706c 6174  imes.    templat
+000178e0: 6520 3a20 6e70 2e61 7272 6179 0a20 2020  e : np.array.   
+000178f0: 2020 2020 2041 7272 6179 2077 6974 6820       Array with 
+00017900: 7465 6d70 6c61 7465 0a20 2020 206e 5f73  template.    n_s
+00017910: 616d 706c 6573 203a 2069 6e74 0a20 2020  amples : int.   
+00017920: 2020 2020 204e 756d 6265 7220 6f66 2073       Number of s
+00017930: 616d 706c 6573 2069 6e20 6368 756e 6b0a  amples in chunk.
+00017940: 2020 2020 6673 203a 2066 6c6f 6174 0a20      fs : float. 
+00017950: 2020 2020 2020 2053 616d 706c 696e 6720         Sampling 
+00017960: 6672 6571 7565 6e63 7920 696e 2048 7a0a  frequency in Hz.
+00017970: 2020 2020 6375 745f 6f75 7420 3a20 6c69      cut_out : li
+00017980: 7374 0a20 2020 2020 2020 204e 756d 6265  st.        Numbe
+00017990: 7220 6f66 2073 616d 706c 6573 2062 6566  r of samples bef
+000179a0: 6f72 6520 616e 6420 6166 7465 7220 7468  ore and after th
+000179b0: 6520 7065 616b 0a20 2020 206d 6f64 756c  e peak.    modul
+000179c0: 6174 696f 6e20 3a20 626f 6f6c 0a20 2020  ation : bool.   
+000179d0: 2020 2020 2049 6620 5472 7565 206d 6f64       If True mod
+000179e0: 756c 6174 696f 6e20 6973 2061 7070 6c69  ulation is appli
+000179f0: 6564 0a20 2020 206d 6f64 5f61 7272 6179  ed.    mod_array
+00017a00: 203a 206e 702e 6172 7261 790a 2020 2020   : np.array.    
+00017a10: 2020 2020 4172 7261 7920 7769 7468 206d      Array with m
+00017a20: 6f64 756c 6174 696f 6e20 7661 6c75 6520  odulation value 
+00017a30: 666f 7220 6561 6368 2073 7069 6b65 0a20  for each spike. 
+00017a40: 2020 2076 6572 626f 7365 203a 2062 6f6f     verbose : boo
+00017a50: 6c0a 2020 2020 2020 2020 4966 2054 7275  l.        If Tru
+00017a60: 6520 6f75 7470 7574 2069 7320 7665 7262  e output is verb
+00017a70: 6f73 650a 2020 2020 6275 7273 7469 6e67  ose.    bursting
+00017a80: 203a 2062 6f6f 6c0a 2020 2020 2020 2020   : bool.        
+00017a90: 4966 2054 7275 6520 7465 6d70 6c61 7465  If True template
+00017aa0: 7320 6172 6520 6d6f 6475 6c61 7465 6420  s are modulated 
+00017ab0: 696e 2073 6861 7065 0a20 2020 2073 6861  in shape.    sha
+00017ac0: 7065 5f73 7472 6574 6368 203a 2066 6c6f  pe_stretch : flo
+00017ad0: 6174 0a20 2020 2020 2020 2052 616e 6765  at.        Range
+00017ae0: 206f 6620 7369 676d 6f69 6420 7472 616e   of sigmoid tran
+00017af0: 7366 6f72 6d20 666f 7220 6275 7273 7469  sform for bursti
+00017b00: 6e67 2073 6861 7065 2073 7472 6574 6368  ng shape stretch
+00017b10: 0a20 2020 206d 6178 5f63 6861 6e6e 656c  .    max_channel
+00017b20: 735f 7065 725f 7465 6d70 6c61 7465 203a  s_per_template :
+00017b30: 206e 702e 6172 7261 790a 2020 2020 2020   np.array.      
+00017b40: 2020 4d61 7869 6d75 6d20 6e75 6d62 6572    Maximum number
+00017b50: 206f 6620 6368 616e 6e65 6c73 2074 6f20   of channels to 
+00017b60: 6265 2063 6f6e 766f 6c76 6564 0a20 2020  be convolved.   
+00017b70: 2072 6563 6f72 6469 6e67 7320 3a20 206e   recordings :  n
+00017b80: 702e 6172 7261 7973 0a20 2020 2020 2020  p.arrays.       
+00017b90: 2041 7272 6179 2074 6f20 7573 6520 666f   Array to use fo
+00017ba0: 7220 7265 636f 7264 696e 6773 2e20 4966  r recordings. If
+00017bb0: 204e 6f6e 6520 6974 2069 7320 6372 6561   None it is crea
+00017bc0: 7465 640a 2020 2020 6472 6966 745f 7665  ted.    drift_ve
+00017bd0: 6374 6f72 3a20 4e6f 6e65 206f 7220 6e70  ctor: None or np
+00017be0: 2e61 7272 6179 2031 640a 2020 2020 2020  .array 1d.      
+00017bf0: 2020 4f70 7469 6f6e 616c 6c79 2074 6865    Optionally the
+00017c00: 2064 7269 6674 2076 6563 746f 7220 7265   drift vector re
+00017c10: 6c61 7465 6420 746f 2074 6865 2063 6875  lated to the chu
+00017c20: 6e6b 2121 210a 2020 2020 6472 6966 745f  nk!!!.    drift_
+00017c30: 6673 3a20 4e6f 6e65 206f 7220 666c 6f61  fs: None or floa
+00017c40: 740a 2020 2020 2020 2020 5361 6d70 6c69  t.        Sampli
+00017c50: 6e67 2066 7265 7175 656e 6379 206f 6620  ng frequency of 
+00017c60: 7468 6520 6472 6966 7420 7369 676e 616c  the drift signal
+00017c70: 0a20 2020 2052 6574 7572 6e73 0a20 2020  .    Returns.   
+00017c80: 202d 2d2d 2d2d 2d2d 0a20 2020 2072 6563   -------.    rec
+00017c90: 6f72 6469 6e67 733a 206e 702e 6172 7261  ordings: np.arra
+00017ca0: 790a 2020 2020 2020 2020 5472 6163 6520  y.        Trace 
+00017cb0: 7769 7468 2063 6f6e 766f 6c76 6564 2073  with convolved s
+00017cc0: 6967 6e61 6c73 2028 6e5f 656c 6563 2c20  ignals (n_elec, 
+00017cd0: 6e5f 7361 6d70 6c65 7329 0a20 2020 2022  n_samples).    "
+00017ce0: 2222 0a0a 2020 2020 2320 6472 6966 7469  ""..    # drifti
+00017cf0: 6e67 203d 2064 7269 6674 5f76 6563 746f  ng = drift_vecto
+00017d00: 7220 6973 206e 6f74 204e 6f6e 650a 2020  r is not None.  
+00017d10: 2020 6472 6966 7469 6e67 203d 2064 7269    drifting = dri
+00017d20: 6674 5f69 6478 7320 6973 206e 6f74 204e  ft_idxs is not N
+00017d30: 6f6e 650a 2020 2020 6966 2064 7269 6674  one.    if drift
+00017d40: 696e 673a 0a20 2020 2020 2020 2061 7373  ing:.        ass
+00017d50: 6572 7420 7465 6d70 6c61 7465 2e6e 6469  ert template.ndi
+00017d60: 6d20 3d3d 2034 0a20 2020 2065 6c73 653a  m == 4.    else:
+00017d70: 0a20 2020 2020 2020 2061 7373 6572 7420  .        assert 
+00017d80: 7465 6d70 6c61 7465 2e6e 6469 6d20 3d3d  template.ndim ==
+00017d90: 2033 0a0a 2020 2020 6966 2076 6572 626f   3..    if verbo
+00017da0: 7365 3a0a 2020 2020 2020 2020 7072 696e  se:.        prin
+00017db0: 7428 2243 6f6e 766f 6c75 7469 6f6e 2077  t("Convolution w
+00017dc0: 6974 6820 7370 696b 653a 222c 2073 7069  ith spike:", spi
+00017dd0: 6b65 5f69 6429 0a0a 2020 2020 6966 2064  ke_id)..    if d
+00017de0: 7269 6674 696e 673a 0a20 2020 2020 2020  rifting:.       
+00017df0: 2064 7269 6674 5f73 7465 7073 203d 2074   drift_steps = t
+00017e00: 656d 706c 6174 652e 7368 6170 655b 305d  emplate.shape[0]
+00017e10: 0a20 2020 2020 2020 206e 5f6a 6974 7420  .        n_jitt 
+00017e20: 3d20 7465 6d70 6c61 7465 2e73 6861 7065  = template.shape
+00017e30: 5b31 5d0a 2020 2020 2020 2020 6e5f 656c  [1].        n_el
+00017e40: 6563 203d 2074 656d 706c 6174 652e 7368  ec = template.sh
+00017e50: 6170 655b 325d 0a20 2020 2020 2020 206c  ape[2].        l
+00017e60: 656e 5f73 7069 6b65 203d 2074 656d 706c  en_spike = templ
+00017e70: 6174 652e 7368 6170 655b 335d 0a20 2020  ate.shape[3].   
+00017e80: 2020 2020 2064 7269 6674 5f69 6478 7320       drift_idxs 
+00017e90: 3d20 6472 6966 745f 6964 7873 2e63 6c69  = drift_idxs.cli
+00017ea0: 7028 302c 2064 7269 6674 5f73 7465 7073  p(0, drift_steps
+00017eb0: 202d 2031 290a 2020 2020 656c 7365 3a0a   - 1).    else:.
+00017ec0: 2020 2020 2020 2020 6e5f 6a69 7474 203d          n_jitt =
+00017ed0: 2074 656d 706c 6174 652e 7368 6170 655b   template.shape[
+00017ee0: 305d 0a20 2020 2020 2020 206e 5f65 6c65  0].        n_ele
+00017ef0: 6320 3d20 7465 6d70 6c61 7465 2e73 6861  c = template.sha
+00017f00: 7065 5b31 5d0a 2020 2020 2020 2020 6c65  pe[1].        le
+00017f10: 6e5f 7370 696b 6520 3d20 7465 6d70 6c61  n_spike = templa
+00017f20: 7465 2e73 6861 7065 5b32 5d0a 0a20 2020  te.shape[2]..   
+00017f30: 2069 6620 7265 636f 7264 696e 6773 2069   if recordings i
+00017f40: 7320 4e6f 6e65 3a0a 2020 2020 2020 2020  s None:.        
+00017f50: 7265 636f 7264 696e 6773 203d 206e 702e  recordings = np.
+00017f60: 7a65 726f 7328 286e 5f73 616d 706c 6573  zeros((n_samples
+00017f70: 2c20 6e5f 656c 6563 2929 0a20 2020 2065  , n_elec)).    e
+00017f80: 6c73 653a 0a20 2020 2020 2020 2061 7373  lse:.        ass
+00017f90: 6572 7420 7265 636f 7264 696e 6773 2e73  ert recordings.s
+00017fa0: 6861 7065 203d 3d20 286e 5f73 616d 706c  hape == (n_sampl
+00017fb0: 6573 2c20 6e5f 656c 6563 292c 2022 2772  es, n_elec), "'r
+00017fc0: 6563 6f72 6469 6e67 7327 2068 6173 2074  ecordings' has t
+00017fd0: 6865 2077 726f 6e67 2073 6861 7065 220a  he wrong shape".
+00017fe0: 0a20 2020 2064 7479 7065 203d 2072 6563  .    dtype = rec
+00017ff0: 6f72 6469 6e67 732e 6474 7970 650a 0a20  ordings.dtype.. 
+00018000: 2020 2069 6620 6375 745f 6f75 7420 6973     if cut_out is
+00018010: 204e 6f6e 653a 0a20 2020 2020 2020 2063   None:.        c
+00018020: 7574 5f6f 7574 203d 205b 6c65 6e5f 7370  ut_out = [len_sp
+00018030: 696b 6520 2f2f 2032 2c20 6c65 6e5f 7370  ike // 2, len_sp
+00018040: 696b 6520 2f2f 2032 5d0a 0a20 2020 2069  ike // 2]..    i
+00018050: 6620 6e6f 7420 6d6f 6475 6c61 7469 6f6e  f not modulation
+00018060: 3a0a 2020 2020 2020 2020 2320 4e6f 206d  :.        # No m
+00018070: 6f64 756c 6174 696f 6e0a 2020 2020 2020  odulation.      
+00018080: 2020 6d6f 645f 6172 7261 7920 3d20 6e70    mod_array = np
+00018090: 2e6f 6e65 735f 6c69 6b65 2873 745f 6964  .ones_like(st_id
+000180a0: 7829 0a20 2020 2065 6c73 653a 0a20 2020  x).    else:.   
+000180b0: 2020 2020 2061 7373 6572 7420 6d6f 645f       assert mod_
+000180c0: 6172 7261 7920 6973 206e 6f74 204e 6f6e  array is not Non
+000180d0: 652c 2022 2046 6f72 2027 656c 6563 7472  e, " For 'electr
+000180e0: 6f64 6527 2061 6e64 2027 7465 6d70 6c61  ode' and 'templa
+000180f0: 7465 2720 6d6f 6475 6c61 7469 6f6e 7320  te' modulations 
+00018100: 7072 6f76 6964 6520 276d 6f64 5f61 7272  provide 'mod_arr
+00018110: 6179 2722 0a0a 2020 2020 666f 7220 706f  ay'"..    for po
+00018120: 732c 2073 706f 7320 696e 2065 6e75 6d65  s, spos in enume
+00018130: 7261 7465 2873 745f 6964 7829 3a0a 2020  rate(st_idx):.  
+00018140: 2020 2020 2020 7261 6e64 5f69 6478 203d        rand_idx =
+00018150: 206e 702e 7261 6e64 6f6d 2e72 616e 6469   np.random.randi
+00018160: 6e74 286e 5f6a 6974 7429 0a20 2020 2020  nt(n_jitt).     
+00018170: 2020 2069 6620 6472 6966 7469 6e67 3a0a     if drifting:.
+00018180: 2020 2020 2020 2020 2020 2020 6472 6966              drif
+00018190: 745f 696e 6420 3d20 6472 6966 745f 6964  t_ind = drift_id
+000181a0: 7873 5b70 6f73 5d20 2023 2069 6e74 2873  xs[pos]  # int(s
+000181b0: 706f 7320 2f20 6673 202a 2064 7269 6674  pos / fs * drift
+000181c0: 5f66 7329 0a20 2020 2020 2020 2020 2020  _fs).           
+000181d0: 2023 2064 7269 6674 5f69 6e64 203d 2064   # drift_ind = d
+000181e0: 7269 6674 5f76 6563 746f 725b 7370 6f73  rift_vector[spos
+000181f0: 5f64 7269 6674 5d0a 2020 2020 2020 2020  _drift].        
+00018200: 2020 2020 7465 6d70 5f6a 6974 7420 3d20      temp_jitt = 
+00018210: 7465 6d70 6c61 7465 5b64 7269 6674 5f69  template[drift_i
+00018220: 6e64 2c20 7261 6e64 5f69 6478 5d0a 2020  nd, rand_idx].  
+00018230: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+00018240: 2020 2020 2020 2020 7465 6d70 5f6a 6974          temp_jit
+00018250: 7420 3d20 7465 6d70 6c61 7465 5b72 616e  t = template[ran
+00018260: 645f 6964 785d 0a0a 2020 2020 2020 2020  d_idx]..        
+00018270: 6966 206d 6178 5f63 6861 6e6e 656c 735f  if max_channels_
+00018280: 7065 725f 7465 6d70 6c61 7465 2069 7320  per_template is 
+00018290: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
+000182a0: 2020 656c 6563 5f69 6478 7320 3d20 6e70    elec_idxs = np
+000182b0: 2e61 7261 6e67 6528 6e5f 656c 6563 290a  .arange(n_elec).
+000182c0: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+000182d0: 2020 2020 2020 2020 2020 2320 6669 6e64            # find
+000182e0: 206d 6178 2063 6861 6e6e 656c 730a 2020   max channels.  
+000182f0: 2020 2020 2020 2020 2020 7065 616b 5f69            peak_i
+00018300: 6478 203d 206e 702e 756e 7261 7665 6c5f  dx = np.unravel_
+00018310: 696e 6465 7828 6e70 2e61 7267 6d61 7828  index(np.argmax(
+00018320: 6e70 2e61 6273 2874 656d 705f 6a69 7474  np.abs(temp_jitt
+00018330: 2929 2c20 7465 6d70 5f6a 6974 742e 7368  )), temp_jitt.sh
+00018340: 6170 6529 5b31 5d0a 2020 2020 2020 2020  ape)[1].        
+00018350: 2020 2020 656c 6563 5f69 6478 7320 3d20      elec_idxs = 
+00018360: 6e70 2e61 7267 736f 7274 286e 702e 6162  np.argsort(np.ab
+00018370: 7328 7465 6d70 5f6a 6974 745b 3a2c 2070  s(temp_jitt[:, p
+00018380: 6561 6b5f 6964 785d 2929 5b3a 3a2d 315d  eak_idx]))[::-1]
+00018390: 5b3a 6d61 785f 6368 616e 6e65 6c73 5f70  [:max_channels_p
+000183a0: 6572 5f74 656d 706c 6174 655d 0a20 2020  er_template].   
+000183b0: 2020 2020 2020 2020 2074 656d 705f 6a69           temp_ji
+000183c0: 7474 203d 2074 656d 705f 6a69 7474 5b65  tt = temp_jitt[e
+000183d0: 6c65 635f 6964 7873 5d0a 0a20 2020 2020  lec_idxs]..     
+000183e0: 2020 2069 6620 6275 7273 7469 6e67 3a0a     if bursting:.
+000183f0: 2020 2020 2020 2020 2020 2020 6966 206e              if n
+00018400: 6f74 2069 7369 6e73 7461 6e63 6528 6d6f  ot isinstance(mo
+00018410: 645f 6172 7261 795b 305d 2c20 286c 6973  d_array[0], (lis
+00018420: 742c 2074 7570 6c65 2c20 6e70 2e6e 6461  t, tuple, np.nda
+00018430: 7272 6179 2929 3a0a 2020 2020 2020 2020  rray)):.        
+00018440: 2020 2020 2020 2020 2320 7465 6d70 6c61          # templa
+00018450: 7465 0a20 2020 2020 2020 2020 2020 2020  te.             
+00018460: 2020 2069 6620 7370 6f73 202d 2063 7574     if spos - cut
+00018470: 5f6f 7574 5b30 5d20 3e3d 2030 2061 6e64  _out[0] >= 0 and
+00018480: 2073 706f 7320 2d20 6375 745f 6f75 745b   spos - cut_out[
+00018490: 305d 202b 206c 656e 5f73 7069 6b65 203c  0] + len_spike <
+000184a0: 3d20 6e5f 7361 6d70 6c65 733a 0a20 2020  = n_samples:.   
+000184b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000184c0: 2073 6e69 7070 6574 203d 2063 6f6d 7075   snippet = compu
+000184d0: 7465 5f73 7472 6574 6368 6564 5f74 656d  te_stretched_tem
+000184e0: 706c 6174 6528 7465 6d70 5f6a 6974 742c  plate(temp_jitt,
+000184f0: 206d 6f64 5f61 7272 6179 5b70 6f73 5d2c   mod_array[pos],
+00018500: 2073 6861 7065 5f73 7472 6574 6368 292e   shape_stretch).
+00018510: 540a 2020 2020 2020 2020 2020 2020 2020  T.              
+00018520: 2020 2020 2020 7265 636f 7264 696e 6773        recordings
+00018530: 5b73 706f 7320 2d20 6375 745f 6f75 745b  [spos - cut_out[
+00018540: 305d 203a 2073 706f 7320 2b20 6375 745f  0] : spos + cut_
+00018550: 6f75 745b 315d 2c20 656c 6563 5f69 6478  out[1], elec_idx
+00018560: 735d 202b 3d20 736e 6970 7065 742e 6173  s] += snippet.as
+00018570: 7479 7065 2864 7479 7065 290a 2020 2020  type(dtype).    
+00018580: 2020 2020 2020 2020 2020 2020 656c 6966              elif
+00018590: 2073 706f 7320 2d20 6375 745f 6f75 745b   spos - cut_out[
+000185a0: 305d 203c 2030 3a0a 2020 2020 2020 2020  0] < 0:.        
+000185b0: 2020 2020 2020 2020 2020 2020 6469 6666              diff
+000185c0: 203d 202d 2873 706f 7320 2d20 6375 745f   = -(spos - cut_
+000185d0: 6f75 745b 305d 290a 2020 2020 2020 2020  out[0]).        
+000185e0: 2020 2020 2020 2020 2020 2020 736e 6970              snip
+000185f0: 7065 7420 3d20 636f 6d70 7574 655f 7374  pet = compute_st
+00018600: 7265 7463 6865 645f 7465 6d70 6c61 7465  retched_template
+00018610: 2874 656d 705f 6a69 7474 2c20 6d6f 645f  (temp_jitt, mod_
+00018620: 6172 7261 795b 706f 735d 2c20 7368 6170  array[pos], shap
+00018630: 655f 7374 7265 7463 6829 5b3a 2c20 6469  e_stretch)[:, di
+00018640: 6666 3a5d 2e54 0a20 2020 2020 2020 2020  ff:].T.         
+00018650: 2020 2020 2020 2020 2020 2072 6563 6f72             recor
+00018660: 6469 6e67 735b 3a20 7370 6f73 202b 2063  dings[: spos + c
+00018670: 7574 5f6f 7574 5b31 5d2c 2065 6c65 635f  ut_out[1], elec_
+00018680: 6964 7873 5d20 2b3d 2073 6e69 7070 6574  idxs] += snippet
+00018690: 2e61 7374 7970 6528 6474 7970 6529 0a20  .astype(dtype). 
+000186a0: 2020 2020 2020 2020 2020 2020 2020 2065                 e
+000186b0: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+000186c0: 2020 2020 2020 2020 2064 6966 6620 3d20           diff = 
+000186d0: 6e5f 7361 6d70 6c65 7320 2d20 2873 706f  n_samples - (spo
+000186e0: 7320 2d20 6375 745f 6f75 745b 305d 290a  s - cut_out[0]).
+000186f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018700: 2020 2020 736e 6970 7065 7420 3d20 636f      snippet = co
+00018710: 6d70 7574 655f 7374 7265 7463 6865 645f  mpute_stretched_
+00018720: 7465 6d70 6c61 7465 2874 656d 705f 6a69  template(temp_ji
+00018730: 7474 2c20 6d6f 645f 6172 7261 795b 706f  tt, mod_array[po
+00018740: 735d 2c20 7368 6170 655f 7374 7265 7463  s], shape_stretc
+00018750: 6829 5b3a 2c20 3a64 6966 665d 2e54 0a20  h)[:, :diff].T. 
+00018760: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018770: 2020 2072 6563 6f72 6469 6e67 735b 7370     recordings[sp
+00018780: 6f73 202d 2063 7574 5f6f 7574 5b30 5d20  os - cut_out[0] 
+00018790: 3a2c 2065 6c65 635f 6964 7873 5d20 2b3d  :, elec_idxs] +=
+000187a0: 2073 6e69 7070 6574 2e61 7374 7970 6528   snippet.astype(
+000187b0: 6474 7970 6529 0a20 2020 2020 2020 2020  dtype).         
+000187c0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+000187d0: 2020 2020 2020 2020 2023 2065 6c65 6374           # elect
+000187e0: 726f 6465 0a20 2020 2020 2020 2020 2020  rode.           
+000187f0: 2020 2020 2069 6620 7370 6f73 202d 2063       if spos - c
+00018800: 7574 5f6f 7574 5b30 5d20 3e3d 2030 2061  ut_out[0] >= 0 a
+00018810: 6e64 2073 706f 7320 2d20 6375 745f 6f75  nd spos - cut_ou
+00018820: 745b 305d 202b 206c 656e 5f73 7069 6b65  t[0] + len_spike
+00018830: 203c 3d20 6e5f 7361 6d70 6c65 733a 0a20   <= n_samples:. 
+00018840: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018850: 2020 2073 6e69 7070 6574 203d 2063 6f6d     snippet = com
+00018860: 7075 7465 5f73 7472 6574 6368 6564 5f74  pute_stretched_t
+00018870: 656d 706c 6174 6528 7465 6d70 5f6a 6974  emplate(temp_jit
+00018880: 742c 206d 6f64 5f61 7272 6179 5b70 6f73  t, mod_array[pos
+00018890: 5d2c 2073 6861 7065 5f73 7472 6574 6368  ], shape_stretch
+000188a0: 292e 540a 2020 2020 2020 2020 2020 2020  ).T.            
+000188b0: 2020 2020 2020 2020 7265 636f 7264 696e          recordin
+000188c0: 6773 5b73 706f 7320 2d20 6375 745f 6f75  gs[spos - cut_ou
+000188d0: 745b 305d 203a 2073 706f 7320 2b20 6375  t[0] : spos + cu
+000188e0: 745f 6f75 745b 315d 2c20 656c 6563 5f69  t_out[1], elec_i
+000188f0: 6478 735d 202b 3d20 736e 6970 7065 742e  dxs] += snippet.
+00018900: 6173 7479 7065 2864 7479 7065 290a 2020  astype(dtype).  
+00018910: 2020 2020 2020 2020 2020 2020 2020 656c                el
+00018920: 6966 2073 706f 7320 2d20 6375 745f 6f75  if spos - cut_ou
+00018930: 745b 305d 203c 2030 3a0a 2020 2020 2020  t[0] < 0:.      
+00018940: 2020 2020 2020 2020 2020 2020 2020 6469                di
+00018950: 6666 203d 202d 2873 706f 7320 2d20 6375  ff = -(spos - cu
+00018960: 745f 6f75 745b 305d 290a 2020 2020 2020  t_out[0]).      
+00018970: 2020 2020 2020 2020 2020 2020 2020 736e                sn
+00018980: 6970 7065 7420 3d20 636f 6d70 7574 655f  ippet = compute_
+00018990: 7374 7265 7463 6865 645f 7465 6d70 6c61  stretched_templa
+000189a0: 7465 2874 656d 705f 6a69 7474 2c20 6d6f  te(temp_jitt, mo
+000189b0: 645f 6172 7261 795b 706f 735d 2c20 7368  d_array[pos], sh
+000189c0: 6170 655f 7374 7265 7463 6829 5b3a 2c20  ape_stretch)[:, 
+000189d0: 6469 6666 3a5d 2e54 0a20 2020 2020 2020  diff:].T.       
+000189e0: 2020 2020 2020 2020 2020 2020 2072 6563               rec
+000189f0: 6f72 6469 6e67 735b 3a20 7370 6f73 202b  ordings[: spos +
+00018a00: 2063 7574 5f6f 7574 5b31 5d2c 2065 6c65   cut_out[1], ele
+00018a10: 635f 6964 7873 5d20 2b3d 2073 6e69 7070  c_idxs] += snipp
+00018a20: 6574 2e61 7374 7970 6528 6474 7970 6529  et.astype(dtype)
+00018a30: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00018a40: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+00018a50: 2020 2020 2020 2020 2020 2064 6966 6620             diff 
+00018a60: 3d20 6e5f 7361 6d70 6c65 7320 2d20 2873  = n_samples - (s
+00018a70: 706f 7320 2d20 6375 745f 6f75 745b 305d  pos - cut_out[0]
+00018a80: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+00018a90: 2020 2020 2020 736e 6970 7065 7420 3d20        snippet = 
+00018aa0: 636f 6d70 7574 655f 7374 7265 7463 6865  compute_stretche
+00018ab0: 645f 7465 6d70 6c61 7465 2874 656d 705f  d_template(temp_
+00018ac0: 6a69 7474 2c20 6d6f 645f 6172 7261 795b  jitt, mod_array[
+00018ad0: 706f 735d 2c20 7368 6170 655f 7374 7265  pos], shape_stre
+00018ae0: 7463 6829 5b3a 2c20 3a64 6966 665d 2e54  tch)[:, :diff].T
+00018af0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00018b00: 2020 2020 2072 6563 6f72 6469 6e67 735b       recordings[
+00018b10: 7370 6f73 202d 2063 7574 5f6f 7574 5b30  spos - cut_out[0
+00018b20: 5d20 3a2c 2065 6c65 635f 6964 7873 5d20  ] :, elec_idxs] 
+00018b30: 2b3d 2073 6e69 7070 6574 2e61 7374 7970  += snippet.astyp
+00018b40: 6528 6474 7970 6529 0a20 2020 2020 2020  e(dtype).       
+00018b50: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+00018b60: 2020 2069 6620 6e6f 7420 6973 696e 7374     if not isinst
+00018b70: 616e 6365 286d 6f64 5f61 7272 6179 5b30  ance(mod_array[0
+00018b80: 5d2c 2028 6c69 7374 2c20 7475 706c 652c  ], (list, tuple,
+00018b90: 206e 702e 6e64 6172 7261 7929 293a 0a20   np.ndarray)):. 
+00018ba0: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+00018bb0: 2074 656d 706c 6174 6520 2b20 6e6f 6e65   template + none
+00018bc0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00018bd0: 2069 6620 7370 6f73 202d 2063 7574 5f6f   if spos - cut_o
+00018be0: 7574 5b30 5d20 3e3d 2030 2061 6e64 2073  ut[0] >= 0 and s
+00018bf0: 706f 7320 2b20 6375 745f 6f75 745b 315d  pos + cut_out[1]
+00018c00: 203c 3d20 6e5f 7361 6d70 6c65 733a 0a20   <= n_samples:. 
+00018c10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018c20: 2020 2073 6e69 7070 6574 203d 206d 6f64     snippet = mod
+00018c30: 5f61 7272 6179 5b70 6f73 5d20 2a20 7465  _array[pos] * te
+00018c40: 6d70 5f6a 6974 742e 540a 2020 2020 2020  mp_jitt.T.      
+00018c50: 2020 2020 2020 2020 2020 2020 2020 7265                re
+00018c60: 636f 7264 696e 6773 5b73 706f 7320 2d20  cordings[spos - 
+00018c70: 6375 745f 6f75 745b 305d 203a 2073 706f  cut_out[0] : spo
+00018c80: 7320 2b20 6375 745f 6f75 745b 315d 2c20  s + cut_out[1], 
+00018c90: 656c 6563 5f69 6478 735d 202b 3d20 736e  elec_idxs] += sn
+00018ca0: 6970 7065 742e 6173 7479 7065 2864 7479  ippet.astype(dty
+00018cb0: 7065 290a 2020 2020 2020 2020 2020 2020  pe).            
+00018cc0: 2020 2020 656c 6966 2073 706f 7320 2d20      elif spos - 
+00018cd0: 6375 745f 6f75 745b 305d 203c 2030 3a0a  cut_out[0] < 0:.
+00018ce0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018cf0: 2020 2020 6469 6666 203d 202d 2873 706f      diff = -(spo
+00018d00: 7320 2d20 6375 745f 6f75 745b 305d 290a  s - cut_out[0]).
+00018d10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018d20: 2020 2020 736e 6970 7065 7420 3d20 6d6f      snippet = mo
+00018d30: 645f 6172 7261 795b 706f 735d 202a 2074  d_array[pos] * t
+00018d40: 656d 705f 6a69 7474 5b3a 2c20 6469 6666  emp_jitt[:, diff
+00018d50: 3a5d 2e54 0a20 2020 2020 2020 2020 2020  :].T.           
+00018d60: 2020 2020 2020 2020 2072 6563 6f72 6469           recordi
+00018d70: 6e67 735b 3a20 7370 6f73 202b 2063 7574  ngs[: spos + cut
+00018d80: 5f6f 7574 5b31 5d2c 2065 6c65 635f 6964  _out[1], elec_id
+00018d90: 7873 5d20 2b3d 2073 6e69 7070 6574 2e61  xs] += snippet.a
+00018da0: 7374 7970 6528 6474 7970 6529 0a20 2020  stype(dtype).   
+00018db0: 2020 2020 2020 2020 2020 2020 2065 6c73               els
+00018dc0: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+00018dd0: 2020 2020 2020 2064 6966 6620 3d20 6e5f         diff = n_
+00018de0: 7361 6d70 6c65 7320 2d20 2873 706f 7320  samples - (spos 
+00018df0: 2d20 6375 745f 6f75 745b 305d 290a 2020  - cut_out[0]).  
 00018e00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018e10: 2020 7265 636f 7264 696e 6773 5b73 706f    recordings[spo
-00018e20: 7320 2d20 6375 745f 6f75 745b 305d 3a2c  s - cut_out[0]:,
-00018e30: 2065 6c65 635f 6964 7873 5d20 2b3d 2073   elec_idxs] += s
-00018e40: 6e69 7070 6574 2e61 7374 7970 6528 6474  nippet.astype(dt
-00018e50: 7970 6529 0a0a 2020 2020 7265 7475 726e  ype)..    return
-00018e60: 2072 6563 6f72 6469 6e67 730a 0a0a 6465   recordings...de
-00018e70: 6620 636f 6d70 7574 655f 6472 6966 745f  f compute_drift_
-00018e80: 6964 7873 5f66 726f 6d5f 6472 6966 745f  idxs_from_drift_
-00018e90: 6c69 7374 2873 7069 6b65 5f69 6e64 6578  list(spike_index
-00018ea0: 2c20 7370 696b 655f 7472 6169 6e5f 6672  , spike_train_fr
-00018eb0: 616d 6573 2c20 6472 6966 745f 6c69 7374  ames, drift_list
-00018ec0: 2c20 6673 293a 0a20 2020 2023 2070 7265  , fs):.    # pre
-00018ed0: 2d63 6f6d 7075 7465 2064 7269 6674 2069  -compute drift i
-00018ee0: 6478 730a 2020 2020 6472 6966 745f 6964  dxs.    drift_id
-00018ef0: 7873 203d 206e 702e 7a65 726f 7328 6c65  xs = np.zeros(le
-00018f00: 6e28 7370 696b 655f 7472 6169 6e5f 6672  n(spike_train_fr
-00018f10: 616d 6573 292c 2064 7479 7065 3d22 7569  ames), dtype="ui
-00018f20: 6e74 3136 2229 0a20 2020 2066 6f72 2064  nt16").    for d
-00018f30: 7269 6674 5f64 6963 7420 696e 2064 7269  rift_dict in dri
-00018f40: 6674 5f6c 6973 743a 0a20 2020 2020 2020  ft_list:.       
-00018f50: 2064 7269 6674 5f76 6563 746f 7220 3d20   drift_vector = 
-00018f60: 6e70 2e61 7272 6179 2864 7269 6674 5f64  np.array(drift_d
-00018f70: 6963 745b 2264 7269 6674 5f76 6563 746f  ict["drift_vecto
-00018f80: 725f 6964 7873 225d 290a 2020 2020 2020  r_idxs"]).      
-00018f90: 2020 6472 6966 745f 6673 203d 2064 7269    drift_fs = dri
-00018fa0: 6674 5f64 6963 745b 2264 7269 6674 5f66  ft_dict["drift_f
-00018fb0: 7322 5d0a 2020 2020 2020 2020 6472 6966  s"].        drif
-00018fc0: 745f 6661 6374 6f72 7320 3d20 6472 6966  t_factors = drif
-00018fd0: 745f 6469 6374 5b22 6472 6966 745f 6661  t_dict["drift_fa
-00018fe0: 6374 6f72 7322 5d0a 2020 2020 2020 2020  ctors"].        
-00018ff0: 0a20 2020 2020 2020 2064 7269 6674 5f73  .        drift_s
-00019000: 7069 6b65 5f69 6478 7320 3d20 2873 7069  pike_idxs = (spi
-00019010: 6b65 5f74 7261 696e 5f66 7261 6d65 7320  ke_train_frames 
-00019020: 2f20 6673 202a 2064 7269 6674 5f66 7329  / fs * drift_fs)
-00019030: 2e61 7374 7970 6528 2269 6e74 2229 0a20  .astype("int"). 
-00019040: 2020 2020 2020 2064 7269 6674 5f69 6478         drift_idx
-00019050: 735f 6920 3d20 6472 6966 745f 7665 6374  s_i = drift_vect
-00019060: 6f72 5b64 7269 6674 5f73 7069 6b65 5f69  or[drift_spike_i
-00019070: 6478 735d 0a20 2020 2020 2020 2064 7269  dxs].        dri
-00019080: 6674 5f69 6478 7320 2b3d 2028 6472 6966  ft_idxs += (drif
-00019090: 745f 6964 7873 5f69 202a 2064 7269 6674  t_idxs_i * drift
-000190a0: 5f66 6163 746f 7273 5b73 7069 6b65 5f69  _factors[spike_i
-000190b0: 6e64 6578 5d29 2e61 7374 7970 6528 2275  ndex]).astype("u
-000190c0: 696e 7431 3622 290a 2020 2020 7265 7475  int16").    retu
-000190d0: 726e 2064 7269 6674 5f69 6478 730a 0a0a  rn drift_idxs...
-000190e0: 2323 2320 5245 434f 5244 494e 4720 4f50  ### RECORDING OP
-000190f0: 4552 4154 494f 4e20 2323 230a 6465 6620  ERATION ###.def 
-00019100: 6578 7472 6163 745f 7766 2873 7069 6b65  extract_wf(spike
-00019110: 7472 6169 6e73 2c20 7265 636f 7264 696e  trains, recordin
-00019120: 6773 2c20 6673 2c20 6375 745f 6f75 743d  gs, fs, cut_out=
-00019130: 322c 2074 696d 6573 7461 6d70 733d 4e6f  2, timestamps=No
-00019140: 6e65 293a 0a20 2020 2022 2222 0a20 2020  ne):.    """.   
-00019150: 2045 7874 7261 6374 2077 6176 6566 6f72   Extract wavefor
-00019160: 6d73 2066 726f 6d20 7265 636f 7264 696e  ms from recordin
-00019170: 6773 2061 6e64 206c 6f61 6420 6974 2069  gs and load it i
-00019180: 6e20 7761 7665 666f 726d 2066 6965 6c64  n waveform field
-00019190: 206f 6620 6e65 6f20 7370 696b 6520 7472   of neo spike tr
-000191a0: 6169 6e73 2e0a 0a20 2020 2050 6172 616d  ains...    Param
-000191b0: 6574 6572 730a 2020 2020 2d2d 2d2d 2d2d  eters.    ------
-000191c0: 2d2d 2d2d 0a20 2020 2073 7069 6b65 7472  ----.    spiketr
-000191d0: 6169 6e73 203a 206c 6973 740a 2020 2020  ains : list.    
-000191e0: 2020 2020 4c69 7374 206f 6620 6e65 6f20      List of neo 
-000191f0: 7370 696b 6520 7472 6169 6e73 0a20 2020  spike trains.   
-00019200: 2072 6563 6f72 6469 6e67 7320 3a20 6e70   recordings : np
-00019210: 2e61 7272 6179 0a20 2020 2020 2020 2041  .array.        A
-00019220: 7272 6179 2077 6974 6820 7265 636f 7264  rray with record
-00019230: 696e 6773 2028 6e5f 7361 6d70 6c65 732c  ings (n_samples,
-00019240: 206e 5f65 6c65 6329 0a20 2020 2066 7320   n_elec).    fs 
-00019250: 3a20 5175 616e 7469 7479 0a20 2020 2020  : Quantity.     
-00019260: 2020 2053 616d 706c 696e 6720 6672 6571     Sampling freq
-00019270: 7565 6e63 790a 2020 2020 6375 745f 6f75  uency.    cut_ou
-00019280: 7420 3a20 666c 6f61 7420 6f72 206c 6973  t : float or lis
-00019290: 740a 2020 2020 2020 2020 204c 656e 6774  t.         Lengt
-000192a0: 6820 696e 206d 7320 746f 2063 7574 2062  h in ms to cut b
-000192b0: 6566 6f72 6520 616e 6420 6166 7465 7220  efore and after 
-000192c0: 7370 696b 6520 7065 616b 2e20 4966 2061  spike peak. If a
-000192d0: 2073 696e 676c 6520 7661 6c75 6520 7468   single value th
-000192e0: 6520 6375 7420 6973 2073 796d 6d65 7472  e cut is symmetr
-000192f0: 6963 616c 0a20 2020 2074 696d 6573 7461  ical.    timesta
-00019300: 6d70 7320 3a20 5175 616e 7469 7479 2061  mps : Quantity a
-00019310: 7272 6179 2028 6f70 7469 6f6e 616c 290a  rray (optional).
-00019320: 2020 2020 2020 2020 4172 7261 7920 7769          Array wi
-00019330: 7468 2072 6563 6f72 6469 6e67 7320 7469  th recordings ti
-00019340: 6d65 7374 616d 7073 0a20 2020 2022 2222  mestamps.    """
-00019350: 0a20 2020 2069 6620 6375 745f 6f75 7420  .    if cut_out 
-00019360: 6973 204e 6f6e 653a 0a20 2020 2020 2020  is None:.       
-00019370: 2063 7574 5f6f 7574 203d 2032 0a20 2020   cut_out = 2.   
-00019380: 2069 6620 6e6f 7420 6973 696e 7374 616e   if not isinstan
-00019390: 6365 2863 7574 5f6f 7574 2c20 6c69 7374  ce(cut_out, list
-000193a0: 293a 0a20 2020 2020 2020 206e 5f70 6164  ):.        n_pad
-000193b0: 203d 2069 6e74 2863 7574 5f6f 7574 202a   = int(cut_out *
-000193c0: 2070 712e 6d73 202a 2066 732e 7265 7363   pq.ms * fs.resc
-000193d0: 616c 6528 276b 487a 2729 290a 2020 2020  ale('kHz')).    
-000193e0: 2020 2020 6e5f 7061 6420 3d20 5b6e 5f70      n_pad = [n_p
-000193f0: 6164 2c20 6e5f 7061 645d 0a20 2020 2065  ad, n_pad].    e
-00019400: 6c73 653a 0a20 2020 2020 2020 206e 5f70  lse:.        n_p
-00019410: 6164 203d 205b 696e 7428 7020 2a20 7071  ad = [int(p * pq
-00019420: 2e6d 7320 2a20 6673 2e72 6573 6361 6c65  .ms * fs.rescale
-00019430: 2827 6b48 7a27 2929 2066 6f72 2070 2069  ('kHz')) for p i
-00019440: 6e20 6375 745f 6f75 745d 0a0a 2020 2020  n cut_out]..    
-00019450: 6e5f 7361 6d70 6c65 732c 206e 5f65 6c65  n_samples, n_ele
-00019460: 6320 3d20 7265 636f 7264 696e 6773 2e73  c = recordings.s
-00019470: 6861 7065 0a20 2020 2069 6620 7469 6d65  hape.    if time
-00019480: 7374 616d 7073 2069 7320 4e6f 6e65 3a0a  stamps is None:.
-00019490: 2020 2020 2020 2020 7469 6d65 7374 616d          timestam
-000194a0: 7073 203d 206e 702e 6172 616e 6765 286e  ps = np.arange(n
-000194b0: 5f73 616d 706c 6573 2920 2f20 6673 2e72  _samples) / fs.r
-000194c0: 6573 6361 6c65 2827 487a 2729 0a20 2020  escale('Hz').   
-000194d0: 2075 6e69 7420 3d20 7469 6d65 7374 616d   unit = timestam
-000194e0: 7073 5b30 5d2e 7265 7363 616c 6528 276d  ps[0].rescale('m
-000194f0: 7327 292e 756e 6974 730a 0a20 2020 2066  s').units..    f
-00019500: 6f72 2073 7420 696e 2073 7069 6b65 7472  or st in spiketr
-00019510: 6169 6e73 3a0a 2020 2020 2020 2020 7370  ains:.        sp
-00019520: 5f72 6563 5f77 6620 3d20 5b5d 0a20 2020  _rec_wf = [].   
-00019530: 2020 2020 2073 705f 616d 7020 3d20 5b5d       sp_amp = []
-00019540: 0a20 2020 2020 2020 2066 6f72 2074 2069  .        for t i
-00019550: 6e20 7374 3a0a 2020 2020 2020 2020 2020  n st:.          
-00019560: 2020 6964 7820 3d20 6e70 2e77 6865 7265    idx = np.where
-00019570: 2874 696d 6573 7461 6d70 7320 3e3d 2074  (timestamps >= t
-00019580: 295b 305d 0a20 2020 2020 2020 2020 2020  )[0].           
-00019590: 2069 6620 6c65 6e28 6964 7829 203e 2030   if len(idx) > 0
-000195a0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-000195b0: 2020 6964 7820 3d20 6964 785b 305d 0a20    idx = idx[0]. 
-000195c0: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
-000195d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000195e0: 2069 6478 203d 206c 656e 2874 696d 6573   idx = len(times
-000195f0: 7461 6d70 7329 202d 2031 0a20 2020 2020  tamps) - 1.     
-00019600: 2020 2020 2020 2023 2066 696e 6420 7369         # find si
-00019610: 6e67 6c65 2077 6176 6566 6f72 6d73 2063  ngle waveforms c
-00019620: 726f 7373 696e 6720 7468 7265 7368 6f6c  rossing threshol
-00019630: 6473 0a20 2020 2020 2020 2020 2020 2069  ds.            i
-00019640: 6620 6964 7820 2d20 6e5f 7061 645b 305d  f idx - n_pad[0]
-00019650: 203e 2030 2061 6e64 2069 6478 202b 206e   > 0 and idx + n
-00019660: 5f70 6164 5b31 5d20 3c20 6e5f 7361 6d70  _pad[1] < n_samp
-00019670: 6c65 733a 0a20 2020 2020 2020 2020 2020  les:.           
-00019680: 2020 2020 2073 7069 6b65 5f72 6563 203d       spike_rec =
-00019690: 2072 6563 6f72 6469 6e67 735b 6964 7820   recordings[idx 
-000196a0: 2d20 6e5f 7061 645b 305d 3a69 6478 202b  - n_pad[0]:idx +
-000196b0: 206e 5f70 6164 5b31 5d5d 0a20 2020 2020   n_pad[1]].     
-000196c0: 2020 2020 2020 2065 6c69 6620 6964 7820         elif idx 
-000196d0: 2d20 6e5f 7061 645b 305d 203c 2030 3a0a  - n_pad[0] < 0:.
-000196e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000196f0: 7370 696b 655f 7265 6320 3d20 7265 636f  spike_rec = reco
-00019700: 7264 696e 6773 5b3a 6964 7820 2b20 6e5f  rdings[:idx + n_
-00019710: 7061 645b 315d 5d0a 2020 2020 2020 2020  pad[1]].        
-00019720: 2020 2020 2020 2020 7370 696b 655f 7265          spike_re
-00019730: 6320 3d20 6e70 2e70 6164 2873 7069 6b65  c = np.pad(spike
-00019740: 5f72 6563 2c20 2828 6e70 2e61 6273 2869  _rec, ((np.abs(i
-00019750: 6478 202d 206e 5f70 6164 5b30 5d29 2c20  dx - n_pad[0]), 
-00019760: 3029 2c20 2830 2c20 3029 292c 2027 636f  0), (0, 0)), 'co
-00019770: 6e73 7461 6e74 2729 0a20 2020 2020 2020  nstant').       
-00019780: 2020 2020 2065 6c69 6620 6964 7820 2b20       elif idx + 
-00019790: 6e5f 7061 645b 315d 203e 206e 5f73 616d  n_pad[1] > n_sam
-000197a0: 706c 6573 3a0a 2020 2020 2020 2020 2020  ples:.          
-000197b0: 2020 2020 2020 7370 696b 655f 7265 6320        spike_rec 
-000197c0: 3d20 7265 636f 7264 696e 6773 5b69 6478  = recordings[idx
-000197d0: 202d 206e 5f70 6164 5b30 5d3a 5d0a 2020   - n_pad[0]:].  
-000197e0: 2020 2020 2020 2020 2020 2020 2020 7370                sp
-000197f0: 696b 655f 7265 6320 3d20 6e70 2e70 6164  ike_rec = np.pad
-00019800: 2873 7069 6b65 5f72 6563 2c20 2828 302c  (spike_rec, ((0,
-00019810: 2069 6478 202b 206e 5f70 6164 5b31 5d20   idx + n_pad[1] 
-00019820: 2d20 6e5f 7361 6d70 6c65 7329 2c20 2830  - n_samples), (0
-00019830: 2c20 3029 292c 2027 636f 6e73 7461 6e74  , 0)), 'constant
-00019840: 2729 0a20 2020 2020 2020 2020 2020 2073  ').            s
-00019850: 705f 7265 635f 7766 2e61 7070 656e 6428  p_rec_wf.append(
-00019860: 7370 696b 655f 7265 632e 5429 0a20 2020  spike_rec.T).   
-00019870: 2020 2020 2073 742e 7761 7665 666f 726d       st.waveform
-00019880: 7320 3d20 6e70 2e61 7272 6179 2873 705f  s = np.array(sp_
-00019890: 7265 635f 7766 290a 0a0a 6465 6620 6669  rec_wf)...def fi
-000198a0: 6c74 6572 5f61 6e61 6c6f 675f 7369 676e  lter_analog_sign
-000198b0: 616c 7328 7369 676e 616c 732c 2066 7265  als(signals, fre
-000198c0: 712c 2066 732c 2066 696c 7465 725f 7479  q, fs, filter_ty
-000198d0: 7065 3d27 6261 6e64 7061 7373 272c 206f  pe='bandpass', o
-000198e0: 7264 6572 3d33 293a 0a20 2020 2022 2222  rder=3):.    """
-000198f0: 0a20 2020 2046 696c 7465 7220 616e 616c  .    Filter anal
-00019900: 6f67 2073 6967 6e61 6c73 2077 6974 6820  og signals with 
-00019910: 7a65 726f 2d70 6861 7365 2042 7574 7465  zero-phase Butte
-00019920: 7277 6f72 7468 2066 696c 7465 722e 0a20  rworth filter.. 
-00019930: 2020 2054 6865 2066 756e 6374 696f 6e20     The function 
-00019940: 7261 6973 6573 2061 6e20 4578 6365 7074  raises an Except
-00019950: 696f 6e20 6966 2074 6865 2072 6571 7569  ion if the requi
-00019960: 7265 6420 6669 6c74 6572 2069 7320 6e6f  red filter is no
-00019970: 7420 7374 6162 6c65 2e0a 0a20 2020 2050  t stable...    P
-00019980: 6172 616d 6574 6572 730a 2020 2020 2d2d  arameters.    --
-00019990: 2d2d 2d2d 2d2d 2d2d 0a20 2020 2073 6967  --------.    sig
-000199a0: 6e61 6c73 203a 206e 702e 6172 7261 790a  nals : np.array.
-000199b0: 2020 2020 2020 2020 4172 7261 7920 6f66          Array of
-000199c0: 2061 6e61 6c6f 6720 7369 676e 616c 7320   analog signals 
-000199d0: 286e 5f73 616d 706c 6573 2c20 6e5f 656c  (n_samples, n_el
-000199e0: 6563 290a 2020 2020 6672 6571 203a 206c  ec).    freq : l
-000199f0: 6973 7420 6f72 2066 6c6f 6174 0a20 2020  ist or float.   
-00019a00: 2020 2020 2043 7574 6f66 6620 6672 6571       Cutoff freq
-00019a10: 7565 6e63 792d 6965 7320 696e 2048 7a0a  uency-ies in Hz.
-00019a20: 2020 2020 6673 203a 2051 7561 6e74 6974      fs : Quantit
-00019a30: 790a 2020 2020 2020 2020 5361 6d70 6c69  y.        Sampli
-00019a40: 6e67 2066 7265 7175 656e 6379 0a20 2020  ng frequency.   
-00019a50: 2066 696c 7465 725f 7479 7065 203a 2073   filter_type : s
-00019a60: 7472 696e 670a 2020 2020 2020 2020 4669  tring.        Fi
-00019a70: 6c74 6572 2074 7970 6520 2827 6c6f 7770  lter type ('lowp
-00019a80: 6173 7327 2c20 2768 6967 6870 6173 7327  ass', 'highpass'
-00019a90: 2c20 2762 616e 6470 6173 7327 2c20 2762  , 'bandpass', 'b
-00019aa0: 616e 6473 746f 7027 290a 2020 2020 6f72  andstop').    or
-00019ab0: 6465 7220 3a20 696e 740a 2020 2020 2020  der : int.      
-00019ac0: 2020 4669 6c74 6572 206f 7264 6572 0a0a    Filter order..
-00019ad0: 2020 2020 5265 7475 726e 730a 2020 2020      Returns.    
-00019ae0: 2d2d 2d2d 2d2d 2d0a 2020 2020 7369 676e  -------.    sign
-00019af0: 616c 735f 6669 6c74 203a 206e 702e 6172  als_filt : np.ar
-00019b00: 7261 790a 2020 2020 2020 2020 4669 6c74  ray.        Filt
-00019b10: 6572 6564 2073 6967 6e61 6c73 0a20 2020  ered signals.   
-00019b20: 2022 2222 0a20 2020 2066 726f 6d20 7363   """.    from sc
-00019b30: 6970 792e 7369 676e 616c 2069 6d70 6f72  ipy.signal impor
-00019b40: 7420 6275 7474 6572 2c20 6669 6c74 6669  t butter, filtfi
-00019b50: 6c74 0a20 2020 2066 6e20 3d20 6673 202f  lt.    fn = fs /
-00019b60: 2032 2e0a 2020 2020 2320 666e 203d 2066   2..    # fn = f
-00019b70: 6e2e 7265 7363 616c 6528 7071 2e48 7a29  n.rescale(pq.Hz)
-00019b80: 0a20 2020 2066 7265 7120 3d20 6672 6571  .    freq = freq
-00019b90: 2e72 6573 6361 6c65 2870 712e 487a 290a  .rescale(pq.Hz).
-00019ba0: 2020 2020 6261 6e64 203d 2066 7265 7120      band = freq 
-00019bb0: 2f20 666e 0a0a 2020 2020 622c 2061 203d  / fn..    b, a =
-00019bc0: 2062 7574 7465 7228 6f72 6465 722c 2062   butter(order, b
-00019bd0: 616e 642c 2062 7479 7065 3d66 696c 7465  and, btype=filte
-00019be0: 725f 7479 7065 290a 0a20 2020 2069 6620  r_type)..    if 
-00019bf0: 6e70 2e61 6c6c 286e 702e 6162 7328 6e70  np.all(np.abs(np
-00019c00: 2e72 6f6f 7473 2861 2929 203c 2031 2920  .roots(a)) < 1) 
-00019c10: 616e 6420 6e70 2e61 6c6c 286e 702e 6162  and np.all(np.ab
-00019c20: 7328 6e70 2e72 6f6f 7473 2861 2929 203c  s(np.roots(a)) <
-00019c30: 2031 293a 0a20 2020 2020 2020 2023 2070   1):.        # p
-00019c40: 7269 6e74 2827 4669 6c74 6572 696e 6720  rint('Filtering 
-00019c50: 7369 676e 616c 7320 7769 7468 2027 2c20  signals with ', 
-00019c60: 6669 6c74 6572 5f74 7970 652c 2027 2066  filter_type, ' f
-00019c70: 696c 7465 7220 6174 2027 2c20 6672 6571  ilter at ', freq
-00019c80: 2c20 272e 2e2e 2729 0a20 2020 2020 2020  , '...').       
-00019c90: 2069 6620 6c65 6e28 7369 676e 616c 732e   if len(signals.
-00019ca0: 7368 6170 6529 203d 3d20 323a 0a20 2020  shape) == 2:.   
-00019cb0: 2020 2020 2020 2020 2073 6967 6e61 6c73           signals
-00019cc0: 5f66 696c 7420 3d20 6669 6c74 6669 6c74  _filt = filtfilt
-00019cd0: 2862 2c20 612c 2073 6967 6e61 6c73 2c20  (b, a, signals, 
-00019ce0: 6178 6973 3d30 290a 2020 2020 2020 2020  axis=0).        
-00019cf0: 656c 6966 206c 656e 2873 6967 6e61 6c73  elif len(signals
-00019d00: 2e73 6861 7065 2920 3d3d 2031 3a0a 2020  .shape) == 1:.  
-00019d10: 2020 2020 2020 2020 2020 7369 676e 616c            signal
-00019d20: 735f 6669 6c74 203d 2066 696c 7466 696c  s_filt = filtfil
-00019d30: 7428 622c 2061 2c20 7369 676e 616c 7329  t(b, a, signals)
-00019d40: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00019d50: 7369 676e 616c 735f 6669 6c74 0a20 2020  signals_filt.   
-00019d60: 2065 6c73 653a 0a20 2020 2020 2020 2072   else:.        r
-00019d70: 6169 7365 2056 616c 7565 4572 726f 7228  aise ValueError(
-00019d80: 2746 696c 7465 7220 6973 206e 6f74 2073  'Filter is not s
-00019d90: 7461 626c 6527 290a 0a0a 2323 2320 504c  table')...### PL
-00019da0: 4f54 5449 4e47 2023 2323 0a64 6566 2070  OTTING ###.def p
-00019db0: 6c6f 745f 7261 7374 6572 7328 7370 696b  lot_rasters(spik
-00019dc0: 6574 7261 696e 732c 2063 656c 6c5f 7479  etrains, cell_ty
-00019dd0: 7065 3d46 616c 7365 2c20 6178 3d4e 6f6e  pe=False, ax=Non
-00019de0: 652c 206f 7665 726c 6170 3d46 616c 7365  e, overlap=False
-00019df0: 2c20 636f 6c6f 723d 4e6f 6e65 2c20 6673  , color=None, fs
-00019e00: 3d31 302c 0a20 2020 2020 2020 2020 2020  =10,.           
-00019e10: 2020 2020 2020 6d61 726b 6572 3d27 7c27        marker='|'
-00019e20: 2c20 6d65 773d 322c 206d 6172 6b65 7273  , mew=2, markers
-00019e30: 697a 653d 3529 3a0a 2020 2020 2222 220a  ize=5):.    """.
-00019e40: 2020 2020 506c 6f74 2072 6173 7465 7220      Plot raster 
-00019e50: 666f 7220 7370 696b 6520 7472 6169 6e73  for spike trains
-00019e60: 2e0a 0a20 2020 2050 6172 616d 6574 6572  ...    Parameter
-00019e70: 730a 2020 2020 2d2d 2d2d 2d2d 2d2d 2d2d  s.    ----------
-00019e80: 0a20 2020 2073 7069 6b65 7472 6169 6e73  .    spiketrains
-00019e90: 203a 206c 6973 740a 2020 2020 2020 2020   : list.        
-00019ea0: 4c69 7374 206f 6620 6e65 6f20 7370 696b  List of neo spik
-00019eb0: 6520 7472 6169 6e73 0a20 2020 2063 656c  e trains.    cel
-00019ec0: 6c5f 7479 7065 203a 2062 6f6f 6c0a 2020  l_type : bool.  
-00019ed0: 2020 2020 2020 4966 2054 7275 6520 616e        If True an
-00019ee0: 6420 2762 696e 7479 7065 2720 696e 2073  d 'bintype' in s
-00019ef0: 7069 6b65 2074 7261 696e 2061 6e6e 6f74  pike train annot
-00019f00: 6174 696f 6e20 7370 696b 6520 7472 6169  ation spike trai
-00019f10: 6e73 2061 7265 2070 6c6f 7474 6564 2062  ns are plotted b
-00019f20: 6173 6564 206f 6e20 7468 6569 7220 7479  ased on their ty
-00019f30: 7065 0a20 2020 2061 7820 3a20 6178 6573  pe.    ax : axes
-00019f40: 0a20 2020 2020 2020 2050 6c6f 7420 6f6e  .        Plot on
-00019f50: 2074 6865 2067 6976 656e 2061 7865 730a   the given axes.
-00019f60: 2020 2020 6f76 6572 6c61 7020 3a20 626f      overlap : bo
-00019f70: 6f6c 0a20 2020 2020 2020 2050 6c6f 7420  ol.        Plot 
-00019f80: 7370 696b 6520 636f 6c6f 7273 2062 6173  spike colors bas
-00019f90: 6564 206f 6e20 6f76 6572 6c61 700a 2020  ed on overlap.  
-00019fa0: 2020 6c61 6265 6c73 203a 2062 6f6f 6c0a    labels : bool.
-00019fb0: 2020 2020 2020 2020 506c 6f74 2073 7069          Plot spi
-00019fc0: 6b65 2063 6f6c 6f72 7320 6261 7365 6420  ke colors based 
-00019fd0: 6f6e 206c 6162 656c 730a 2020 2020 636f  on labels.    co
-00019fe0: 6c6f 7220 3a20 6d61 7470 6c6f 746c 6962  lor : matplotlib
-00019ff0: 2063 6f6c 6f72 2028 7369 6e67 6c65 206f   color (single o
-0001a000: 7220 6c69 7374 290a 2020 2020 2020 2020  r list).        
-0001a010: 436f 6c6f 7220 6f72 2063 6f6c 6f72 206c  Color or color l
-0001a020: 6973 740a 2020 2020 6673 203a 2069 6e74  ist.    fs : int
-0001a030: 0a20 2020 2020 2020 2046 6f6e 7420 7369  .        Font si
-0001a040: 7a65 0a20 2020 206d 6172 6b65 7220 3a20  ze.    marker : 
-0001a050: 6d61 7470 6c6f 746c 6962 2061 7267 0a20  matplotlib arg. 
-0001a060: 2020 2020 2020 204d 6172 6b65 7220 7479         Marker ty
-0001a070: 7065 0a20 2020 206d 6577 203a 206d 6174  pe.    mew : mat
-0001a080: 706c 6f74 6c69 6220 6172 670a 2020 2020  plotlib arg.    
-0001a090: 2020 2020 5769 6474 6820 6f66 206d 6172      Width of mar
-0001a0a0: 6b65 720a 2020 2020 6d61 726b 6572 7369  ker.    markersi
-0001a0b0: 7a65 203a 2069 6e74 0a20 2020 2020 2020  ze : int.       
-0001a0c0: 204d 6172 6b65 7220 7369 7a65 0a0a 2020   Marker size..  
-0001a0d0: 2020 5265 7475 726e 730a 2020 2020 2d2d    Returns.    --
-0001a0e0: 2d2d 2d2d 2d0a 2020 2020 6178 203a 2061  -----.    ax : a
-0001a0f0: 7869 730a 2020 2020 2020 2020 4d61 7470  xis.        Matp
-0001a100: 6c6f 746c 6962 2061 7869 730a 2020 2020  lotlib axis.    
-0001a110: 2222 220a 0a20 2020 2069 6d70 6f72 7420  """..    import 
-0001a120: 6d61 7470 6c6f 746c 6962 2e70 796c 6162  matplotlib.pylab
-0001a130: 2061 7320 706c 740a 2020 2020 6966 206e   as plt.    if n
-0001a140: 6f74 2061 783a 0a20 2020 2020 2020 2066  ot ax:.        f
-0001a150: 6967 203d 2070 6c74 2e66 6967 7572 6528  ig = plt.figure(
-0001a160: 290a 2020 2020 2020 2020 6178 203d 2066  ).        ax = f
-0001a170: 6967 2e61 6464 5f73 7562 706c 6f74 2831  ig.add_subplot(1
-0001a180: 3131 290a 2020 2020 6966 206f 7665 726c  11).    if overl
-0001a190: 6170 3a0a 2020 2020 2020 2020 6966 2027  ap:.        if '
-0001a1a0: 6f76 6572 6c61 7027 206e 6f74 2069 6e20  overlap' not in 
-0001a1b0: 7370 696b 6574 7261 696e 735b 305d 2e61  spiketrains[0].a
-0001a1c0: 6e6e 6f74 6174 696f 6e73 2e6b 6579 7328  nnotations.keys(
-0001a1d0: 293a 0a20 2020 2020 2020 2020 2020 2072  ):.            r
-0001a1e0: 6169 7365 2045 7863 6570 7469 6f6e 2829  aise Exception()
-0001a1f0: 0a20 2020 2066 6f72 2069 2c20 7370 696b  .    for i, spik
-0001a200: 6574 7261 696e 2069 6e20 656e 756d 6572  etrain in enumer
-0001a210: 6174 6528 7370 696b 6574 7261 696e 7329  ate(spiketrains)
-0001a220: 3a0a 2020 2020 2020 2020 7420 3d20 7370  :.        t = sp
-0001a230: 696b 6574 7261 696e 2e72 6573 6361 6c65  iketrain.rescale
-0001a240: 2870 712e 7329 0a20 2020 2020 2020 2069  (pq.s).        i
-0001a250: 6620 6365 6c6c 5f74 7970 653a 0a20 2020  f cell_type:.   
-0001a260: 2020 2020 2020 2020 2069 6620 2763 656c           if 'cel
-0001a270: 6c5f 7479 7065 2720 696e 2073 7069 6b65  l_type' in spike
-0001a280: 7472 6169 6e2e 616e 6e6f 7461 7469 6f6e  train.annotation
-0001a290: 732e 6b65 7973 2829 3a0a 2020 2020 2020  s.keys():.      
-0001a2a0: 2020 2020 2020 2020 2020 6966 2073 7069            if spi
-0001a2b0: 6b65 7472 6169 6e2e 616e 6e6f 7461 7469  ketrain.annotati
-0001a2c0: 6f6e 735b 2763 656c 6c5f 7479 7065 275d  ons['cell_type']
-0001a2d0: 203d 3d20 2745 273a 0a20 2020 2020 2020   == 'E':.       
-0001a2e0: 2020 2020 2020 2020 2020 2020 2061 782e               ax.
-0001a2f0: 706c 6f74 2874 2c20 6920 2a20 6e70 2e6f  plot(t, i * np.o
-0001a300: 6e65 735f 6c69 6b65 2874 292c 2027 6227  nes_like(t), 'b'
-0001a310: 2c20 6d61 726b 6572 3d6d 6172 6b65 722c  , marker=marker,
-0001a320: 206d 6577 3d6d 6577 2c20 6d61 726b 6572   mew=mew, marker
-0001a330: 7369 7a65 3d6d 6172 6b65 7273 697a 652c  size=markersize,
-0001a340: 206c 733d 2727 290a 2020 2020 2020 2020   ls='').        
-0001a350: 2020 2020 2020 2020 656c 6966 2073 7069          elif spi
-0001a360: 6b65 7472 6169 6e2e 616e 6e6f 7461 7469  ketrain.annotati
-0001a370: 6f6e 735b 2763 656c 6c5f 7479 7065 275d  ons['cell_type']
-0001a380: 203d 3d20 2749 273a 0a20 2020 2020 2020   == 'I':.       
-0001a390: 2020 2020 2020 2020 2020 2020 2061 782e               ax.
-0001a3a0: 706c 6f74 2874 2c20 6920 2a20 6e70 2e6f  plot(t, i * np.o
-0001a3b0: 6e65 735f 6c69 6b65 2874 292c 2027 7227  nes_like(t), 'r'
-0001a3c0: 2c20 6d61 726b 6572 3d6d 6172 6b65 722c  , marker=marker,
-0001a3d0: 206d 6577 3d6d 6577 2c20 6d61 726b 6572   mew=mew, marker
-0001a3e0: 7369 7a65 3d6d 6172 6b65 7273 697a 652c  size=markersize,
-0001a3f0: 206c 733d 2727 290a 2020 2020 2020 2020   ls='').        
-0001a400: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-0001a410: 2020 2020 2020 2020 2020 6966 2063 6f6c            if col
-0001a420: 6f72 2069 7320 6e6f 7420 4e6f 6e65 3a0a  or is not None:.
-0001a430: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001a440: 2020 2020 6966 2069 7369 6e73 7461 6e63      if isinstanc
-0001a450: 6528 636f 6c6f 722c 206c 6973 7429 206f  e(color, list) o
-0001a460: 7220 6973 696e 7374 616e 6365 2863 6f6c  r isinstance(col
-0001a470: 6f72 2c20 6e70 2e6e 6461 7272 6179 293a  or, np.ndarray):
-0001a480: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001a490: 2020 2020 2020 2020 2061 782e 706c 6f74           ax.plot
-0001a4a0: 2874 2c20 6920 2a20 6e70 2e6f 6e65 735f  (t, i * np.ones_
-0001a4b0: 6c69 6b65 2874 292c 2063 6f6c 6f72 3d63  like(t), color=c
-0001a4c0: 6f6c 6f72 5b69 5d2c 206d 6172 6b65 723d  olor[i], marker=
-0001a4d0: 6d61 726b 6572 2c20 6d65 773d 6d65 772c  marker, mew=mew,
-0001a4e0: 206d 6172 6b65 7273 697a 653d 6d61 726b   markersize=mark
-0001a4f0: 6572 7369 7a65 2c0a 2020 2020 2020 2020  ersize,.        
-0001a500: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001a510: 2020 2020 2020 2020 6c73 3d27 2729 0a20          ls=''). 
-0001a520: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001a530: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-0001a540: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001a550: 2061 782e 706c 6f74 2874 2c20 6920 2a20   ax.plot(t, i * 
-0001a560: 6e70 2e6f 6e65 735f 6c69 6b65 2874 292c  np.ones_like(t),
-0001a570: 2063 6f6c 6f72 3d63 6f6c 6f72 2c20 6d61   color=color, ma
-0001a580: 726b 6572 3d6d 6172 6b65 722c 206d 6577  rker=marker, mew
-0001a590: 3d6d 6577 2c20 6d61 726b 6572 7369 7a65  =mew, markersize
-0001a5a0: 3d6d 6172 6b65 7273 697a 652c 0a20 2020  =markersize,.   
-0001a5b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001a5c0: 2020 2020 2020 2020 2020 2020 206c 733d               ls=
-0001a5d0: 2727 290a 2020 2020 2020 2020 2020 2020  '').            
-0001a5e0: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-0001a5f0: 2020 2020 2020 2020 2020 2020 2020 6178                ax
-0001a600: 2e70 6c6f 7428 742c 2069 202a 206e 702e  .plot(t, i * np.
-0001a610: 6f6e 6573 5f6c 696b 6528 7429 2c20 276b  ones_like(t), 'k
-0001a620: 272c 206d 6172 6b65 723d 6d61 726b 6572  ', marker=marker
-0001a630: 2c20 6d65 773d 6d65 772c 206d 6172 6b65  , mew=mew, marke
-0001a640: 7273 697a 653d 6d61 726b 6572 7369 7a65  rsize=markersize
-0001a650: 2c20 6c73 3d27 2729 0a20 2020 2020 2020  , ls='').       
-0001a660: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
-0001a670: 2020 2069 6620 6e6f 7420 6f76 6572 6c61     if not overla
-0001a680: 703a 0a20 2020 2020 2020 2020 2020 2020  p:.             
-0001a690: 2020 2069 6620 636f 6c6f 7220 6973 206e     if color is n
-0001a6a0: 6f74 204e 6f6e 653a 0a20 2020 2020 2020  ot None:.       
-0001a6b0: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-0001a6c0: 6973 696e 7374 616e 6365 2863 6f6c 6f72  isinstance(color
-0001a6d0: 2c20 6c69 7374 2920 6f72 2069 7369 6e73  , list) or isins
-0001a6e0: 7461 6e63 6528 636f 6c6f 722c 206e 702e  tance(color, np.
-0001a6f0: 6e64 6172 7261 7929 3a0a 2020 2020 2020  ndarray):.      
-0001a700: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001a710: 2020 6178 2e70 6c6f 7428 742c 2069 202a    ax.plot(t, i *
-0001a720: 206e 702e 6f6e 6573 5f6c 696b 6528 7429   np.ones_like(t)
-0001a730: 2c20 636f 6c6f 723d 636f 6c6f 725b 695d  , color=color[i]
-0001a740: 2c20 6d61 726b 6572 3d6d 6172 6b65 722c  , marker=marker,
-0001a750: 206d 6577 3d6d 6577 2c20 6d61 726b 6572   mew=mew, marker
-0001a760: 7369 7a65 3d6d 6172 6b65 7273 697a 652c  size=markersize,
-0001a770: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001a780: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001a790: 206c 733d 2727 290a 2020 2020 2020 2020   ls='').        
-0001a7a0: 2020 2020 2020 2020 2020 2020 656c 7365              else
-0001a7b0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0001a7c0: 2020 2020 2020 2020 2020 6178 2e70 6c6f            ax.plo
-0001a7d0: 7428 742c 2069 202a 206e 702e 6f6e 6573  t(t, i * np.ones
-0001a7e0: 5f6c 696b 6528 7429 2c20 636f 6c6f 723d  _like(t), color=
-0001a7f0: 636f 6c6f 722c 206d 6172 6b65 723d 6d61  color, marker=ma
-0001a800: 726b 6572 2c20 6d65 773d 6d65 772c 206d  rker, mew=mew, m
-0001a810: 6172 6b65 7273 697a 653d 6d61 726b 6572  arkersize=marker
-0001a820: 7369 7a65 2c0a 2020 2020 2020 2020 2020  size,.          
-0001a830: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001a840: 2020 2020 2020 6c73 3d27 2729 0a20 2020        ls='').   
-0001a850: 2020 2020 2020 2020 2020 2020 2065 6c73               els
-0001a860: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-0001a870: 2020 2020 2020 2061 782e 706c 6f74 2874         ax.plot(t
-0001a880: 2c20 6920 2a20 6e70 2e6f 6e65 735f 6c69  , i * np.ones_li
-0001a890: 6b65 2874 292c 2027 6b27 2c20 6d61 726b  ke(t), 'k', mark
-0001a8a0: 6572 3d6d 6172 6b65 722c 206d 6577 3d6d  er=marker, mew=m
-0001a8b0: 6577 2c20 6d61 726b 6572 7369 7a65 3d6d  ew, markersize=m
-0001a8c0: 6172 6b65 7273 697a 652c 206c 733d 2727  arkersize, ls=''
-0001a8d0: 290a 2020 2020 2020 2020 2020 2020 656c  ).            el
-0001a8e0: 6966 206f 7665 726c 6170 3a0a 2020 2020  if overlap:.    
-0001a8f0: 2020 2020 2020 2020 2020 2020 666f 7220              for 
-0001a900: 6a2c 2074 5f73 7020 696e 2065 6e75 6d65  j, t_sp in enume
-0001a910: 7261 7465 2873 7069 6b65 7472 6169 6e29  rate(spiketrain)
-0001a920: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0001a930: 2020 2020 2020 6966 2073 7069 6b65 7472        if spiketr
-0001a940: 6169 6e2e 616e 6e6f 7461 7469 6f6e 735b  ain.annotations[
-0001a950: 276f 7665 726c 6170 275d 5b6a 5d20 3d3d  'overlap'][j] ==
-0001a960: 2027 5354 4f27 3a0a 2020 2020 2020 2020   'STO':.        
-0001a970: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001a980: 6178 2e70 6c6f 7428 745f 7370 2c20 692c  ax.plot(t_sp, i,
-0001a990: 2027 7227 2c20 6d61 726b 6572 3d6d 6172   'r', marker=mar
-0001a9a0: 6b65 722c 206d 6577 3d6d 6577 2c20 6d61  ker, mew=mew, ma
-0001a9b0: 726b 6572 7369 7a65 3d6d 6172 6b65 7273  rkersize=markers
-0001a9c0: 697a 652c 206c 733d 2727 290a 2020 2020  ize, ls='').    
-0001a9d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001a9e0: 656c 6966 2073 7069 6b65 7472 6169 6e2e  elif spiketrain.
-0001a9f0: 616e 6e6f 7461 7469 6f6e 735b 276f 7665  annotations['ove
-0001aa00: 726c 6170 275d 5b6a 5d20 3d3d 2027 544f  rlap'][j] == 'TO
-0001aa10: 273a 0a20 2020 2020 2020 2020 2020 2020  ':.             
-0001aa20: 2020 2020 2020 2020 2020 2061 782e 706c             ax.pl
-0001aa30: 6f74 2874 5f73 702c 2069 2c20 2767 272c  ot(t_sp, i, 'g',
-0001aa40: 206d 6172 6b65 723d 6d61 726b 6572 2c20   marker=marker, 
-0001aa50: 6d65 773d 6d65 772c 206d 6172 6b65 7273  mew=mew, markers
-0001aa60: 697a 653d 6d61 726b 6572 7369 7a65 2c20  ize=markersize, 
-0001aa70: 6c73 3d27 2729 0a20 2020 2020 2020 2020  ls='').         
-0001aa80: 2020 2020 2020 2020 2020 2065 6c69 6620             elif 
-0001aa90: 7370 696b 6574 7261 696e 2e61 6e6e 6f74  spiketrain.annot
-0001aaa0: 6174 696f 6e73 5b27 6f76 6572 6c61 7027  ations['overlap'
-0001aab0: 5d5b 6a5d 203d 3d20 274e 4f27 3a0a 2020  ][j] == 'NO':.  
-0001aac0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001aad0: 2020 2020 2020 6178 2e70 6c6f 7428 745f        ax.plot(t_
-0001aae0: 7370 2c20 692c 2027 6b27 2c20 6d61 726b  sp, i, 'k', mark
-0001aaf0: 6572 3d6d 6172 6b65 722c 206d 6577 3d6d  er=marker, mew=m
-0001ab00: 6577 2c20 6d61 726b 6572 7369 7a65 3d6d  ew, markersize=m
-0001ab10: 6172 6b65 7273 697a 652c 206c 733d 2727  arkersize, ls=''
-0001ab20: 290a 0a20 2020 2061 782e 6178 6973 2827  )..    ax.axis('
-0001ab30: 7469 6768 7427 290a 2020 2020 6178 2e73  tight').    ax.s
-0001ab40: 6574 5f78 6c69 6d28 5b73 7069 6b65 7472  et_xlim([spiketr
-0001ab50: 6169 6e73 5b30 5d2e 745f 7374 6172 742e  ains[0].t_start.
-0001ab60: 7265 7363 616c 6528 7071 2e73 292c 2073  rescale(pq.s), s
-0001ab70: 7069 6b65 7472 6169 6e73 5b30 5d2e 745f  piketrains[0].t_
-0001ab80: 7374 6f70 2e72 6573 6361 6c65 2870 712e  stop.rescale(pq.
-0001ab90: 7329 5d29 0a20 2020 2061 782e 7365 745f  s)]).    ax.set_
-0001aba0: 786c 6162 656c 2827 5469 6d65 2028 7329  xlabel('Time (s)
-0001abb0: 272c 2066 6f6e 7473 697a 653d 6673 290a  ', fontsize=fs).
-0001abc0: 2020 2020 6178 2e73 6574 5f79 6c61 6265      ax.set_ylabe
-0001abd0: 6c28 2753 7069 6b65 2054 7261 696e 2049  l('Spike Train I
-0001abe0: 6e64 6578 272c 2066 6f6e 7473 697a 653d  ndex', fontsize=
-0001abf0: 6673 290a 2020 2020 6178 2e73 6574 5f79  fs).    ax.set_y
-0001ac00: 7469 636b 7328 6e70 2e61 7261 6e67 6528  ticks(np.arange(
-0001ac10: 6c65 6e28 7370 696b 6574 7261 696e 7329  len(spiketrains)
-0001ac20: 2929 0a20 2020 2061 782e 7365 745f 7974  )).    ax.set_yt
-0001ac30: 6963 6b6c 6162 656c 7328 6e70 2e61 7261  icklabels(np.ara
-0001ac40: 6e67 6528 6c65 6e28 7370 696b 6574 7261  nge(len(spiketra
-0001ac50: 696e 7329 2929 0a0a 2020 2020 7265 7475  ins)))..    retu
-0001ac60: 726e 2061 780a 0a0a 6465 6620 706c 6f74  rn ax...def plot
-0001ac70: 5f74 656d 706c 6174 6573 2867 656e 2c20  _templates(gen, 
-0001ac80: 7465 6d70 6c61 7465 5f69 6473 3d4e 6f6e  template_ids=Non
-0001ac90: 652c 2073 696e 676c 655f 6a69 7474 6572  e, single_jitter
-0001aca0: 3d54 7275 652c 2061 783d 4e6f 6e65 2c20  =True, ax=None, 
-0001acb0: 7369 6e67 6c65 5f61 7865 733d 4661 6c73  single_axes=Fals
-0001acc0: 652c 206d 6178 5f74 656d 706c 6174 6573  e, max_templates
-0001acd0: 3d4e 6f6e 652c 0a20 2020 2020 2020 2020  =None,.         
-0001ace0: 2020 2020 2020 2020 2020 6472 6966 7469            drifti
-0001acf0: 6e67 3d46 616c 7365 2c20 636d 6170 3d4e  ng=False, cmap=N
-0001ad00: 6f6e 652c 206e 636f 6c73 3d36 2c20 2a2a  one, ncols=6, **
-0001ad10: 6b77 6172 6773 293a 0a20 2020 2022 2222  kwargs):.    """
-0001ad20: 0a20 2020 2050 6c6f 7420 7465 6d70 6c61  .    Plot templa
-0001ad30: 7465 732e 0a0a 2020 2020 5061 7261 6d65  tes...    Parame
-0001ad40: 7465 7273 0a20 2020 202d 2d2d 2d2d 2d2d  ters.    -------
-0001ad50: 2d2d 2d0a 2020 2020 6765 6e20 3a20 5465  ---.    gen : Te
-0001ad60: 6d70 6c61 7465 4765 6e65 7261 746f 7220  mplateGenerator 
-0001ad70: 6f72 2052 6563 6f72 6469 6e67 4765 6e65  or RecordingGene
-0001ad80: 7261 746f 720a 2020 2020 2020 2020 4765  rator.        Ge
-0001ad90: 6e65 7261 746f 7220 6f62 6a65 6374 2063  nerator object c
-0001ada0: 6f6e 7461 696e 696e 6720 7465 6d70 6c61  ontaining templa
-0001adb0: 7465 730a 2020 2020 7465 6d70 6c61 7465  tes.    template
-0001adc0: 5f69 6473 203a 2069 6e74 206f 7220 6c69  _ids : int or li
-0001add0: 7374 0a20 2020 2020 2020 2054 6865 2074  st.        The t
-0001ade0: 656d 706c 6174 6528 7329 2074 6f20 706c  emplate(s) to pl
-0001adf0: 6f74 0a20 2020 2073 696e 676c 655f 6178  ot.    single_ax
-0001ae00: 6573 203a 2062 6f6f 6c0a 2020 2020 2020  es : bool.      
-0001ae10: 2020 4966 2054 7275 6520 616c 6c20 7465    If True all te
-0001ae20: 6d70 6c61 7465 7320 6172 6520 706c 6f74  mplates are plot
-0001ae30: 7465 6420 6f6e 2074 6865 2073 616d 6520  ted on the same 
-0001ae40: 6178 6973 0a20 2020 2061 7820 3a20 6178  axis.    ax : ax
-0001ae50: 6973 0a20 2020 2020 2020 204d 6174 706c  is.        Matpl
-0001ae60: 6f74 6c69 6220 2061 7869 730a 2020 2020  otlib  axis.    
-0001ae70: 7369 6e67 6c65 5f6a 6974 7465 723a 2062  single_jitter: b
-0001ae80: 6f6f 6c0a 2020 2020 2020 2020 4966 2054  ool.        If T
-0001ae90: 7275 6520 616e 6420 6a69 7474 6572 6564  rue and jittered
-0001aea0: 2074 656d 706c 6174 6573 2061 7265 2070   templates are p
-0001aeb0: 7265 7365 6e74 2c20 6120 7369 6e67 6c65  resent, a single
-0001aec0: 206a 6974 7465 7265 6420 7465 6d70 6c61   jittered templa
-0001aed0: 7465 2069 7320 706c 6f74 7465 640a 2020  te is plotted.  
-0001aee0: 2020 6d61 785f 7465 6d70 6c61 7465 733a    max_templates:
-0001aef0: 2069 6e74 0a20 2020 2020 2020 204d 6178   int.        Max
-0001af00: 696d 756d 206e 756d 6265 7220 6f66 2074  imum number of t
-0001af10: 656d 706c 6174 6573 2074 6f20 6265 2070  emplates to be p
-0001af20: 6c6f 7474 6564 0a20 2020 2064 7269 6674  lotted.    drift
-0001af30: 696e 673a 2062 6f6f 6c0a 2020 2020 2020  ing: bool.      
-0001af40: 2020 4966 2054 7275 6520 616e 6420 7465    If True and te
-0001af50: 6d70 6c61 7465 7320 6172 6520 6472 6966  mplates are drif
-0001af60: 7469 6e67 2c20 6472 6966 7469 6e67 2074  ting, drifting t
-0001af70: 656d 706c 6174 6573 2061 7265 2064 6973  emplates are dis
-0001af80: 706c 6179 6564 0a20 2020 2063 6d61 7020  played.    cmap 
-0001af90: 3a20 6d61 7470 6c6f 746c 6962 2063 6f6c  : matplotlib col
-0001afa0: 6f72 6d61 700a 2020 2020 2020 2020 436f  ormap.        Co
-0001afb0: 6c6f 726d 6170 2074 6f20 6265 2075 7365  lormap to be use
-0001afc0: 640a 2020 2020 6e63 6f6c 7320 3a20 2069  d.    ncols :  i
-0001afd0: 6e74 0a20 2020 2020 2020 204e 756d 6265  nt.        Numbe
-0001afe0: 7220 6f66 2063 6f6c 756d 6e73 2066 6f72  r of columns for
-0001aff0: 2073 7562 706c 6f74 730a 0a20 2020 2052   subplots..    R
-0001b000: 6574 7572 6e73 0a20 2020 202d 2d2d 2d2d  eturns.    -----
-0001b010: 2d2d 0a20 2020 2061 7820 3a20 6178 0a20  --.    ax : ax. 
-0001b020: 2020 2020 2020 204d 6174 706c 6f74 6c69         Matplotli
-0001b030: 6220 6178 6573 0a0a 2020 2020 2222 220a  b axes..    """.
-0001b040: 2020 2020 696d 706f 7274 206d 6174 706c      import matpl
-0001b050: 6f74 6c69 622e 7079 6c61 6220 6173 2070  otlib.pylab as p
-0001b060: 6c74 0a20 2020 2066 726f 6d20 6d61 7470  lt.    from matp
-0001b070: 6c6f 746c 6962 2069 6d70 6f72 7420 6772  lotlib import gr
-0001b080: 6964 7370 6563 0a0a 2020 2020 7465 6d70  idspec..    temp
-0001b090: 6c61 7465 7320 3d20 6765 6e2e 7465 6d70  lates = gen.temp
-0001b0a0: 6c61 7465 730a 2020 2020 6d65 6120 3d20  lates.    mea = 
-0001b0b0: 6d75 2e72 6574 7572 6e5f 6d65 6128 696e  mu.return_mea(in
-0001b0c0: 666f 3d67 656e 2e69 6e66 6f5b 2765 6c65  fo=gen.info['ele
-0001b0d0: 6374 726f 6465 7327 5d29 0a0a 2020 2020  ctrodes'])..    
-0001b0e0: 6966 2027 7061 7261 6d73 2720 696e 2067  if 'params' in g
-0001b0f0: 656e 2e69 6e66 6f2e 6b65 7973 2829 3a0a  en.info.keys():.
-0001b100: 2020 2020 2020 2020 6966 2067 656e 2e69          if gen.i
-0001b110: 6e66 6f5b 2770 6172 616d 7327 5d5b 2764  nfo['params']['d
-0001b120: 7269 6674 696e 6727 5d3a 0a20 2020 2020  rifting']:.     
-0001b130: 2020 2020 2020 2069 6620 6e6f 7420 6472         if not dr
-0001b140: 6966 7469 6e67 3a0a 2020 2020 2020 2020  ifting:.        
-0001b150: 2020 2020 2020 2020 7465 6d70 6c61 7465          template
-0001b160: 7320 3d20 7465 6d70 6c61 7465 735b 3a2c  s = templates[:,
-0001b170: 2030 5d0a 2020 2020 6966 2027 7265 636f   0].    if 'reco
-0001b180: 7264 696e 6773 2720 696e 2067 656e 2e69  rdings' in gen.i
-0001b190: 6e66 6f2e 6b65 7973 2829 3a0a 2020 2020  nfo.keys():.    
-0001b1a0: 2020 2020 6966 2067 656e 2e69 6e66 6f5b      if gen.info[
-0001b1b0: 2772 6563 6f72 6469 6e67 7327 5d5b 2764  'recordings']['d
-0001b1c0: 7269 6674 696e 6727 5d3a 0a20 2020 2020  rifting']:.     
-0001b1d0: 2020 2020 2020 2069 6620 7369 6e67 6c65         if single
-0001b1e0: 5f6a 6974 7465 723a 0a20 2020 2020 2020  _jitter:.       
-0001b1f0: 2020 2020 2020 2020 2069 6620 6e6f 7420           if not 
-0001b200: 6472 6966 7469 6e67 3a0a 2020 2020 2020  drifting:.      
-0001b210: 2020 2020 2020 2020 2020 2020 2020 6966                if
-0001b220: 206c 656e 2874 656d 706c 6174 6573 2e73   len(templates.s
-0001b230: 6861 7065 2920 3d3d 2035 3a0a 2020 2020  hape) == 5:.    
-0001b240: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b250: 2020 2020 7465 6d70 6c61 7465 7320 3d20      templates = 
-0001b260: 7465 6d70 6c61 7465 735b 3a2c 2030 2c20  templates[:, 0, 
-0001b270: 305d 0a20 2020 2020 2020 2020 2020 2020  0].             
-0001b280: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-0001b290: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b2a0: 2020 2020 2074 656d 706c 6174 6573 203d       templates =
-0001b2b0: 2074 656d 706c 6174 6573 5b3a 2c20 305d   templates[:, 0]
-0001b2c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001b2d0: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
-0001b2e0: 2020 2020 2020 2020 2020 2069 6620 6c65             if le
-0001b2f0: 6e28 7465 6d70 6c61 7465 732e 7368 6170  n(templates.shap
-0001b300: 6529 203d 3d20 353a 0a20 2020 2020 2020  e) == 5:.       
-0001b310: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b320: 2074 656d 706c 6174 6573 203d 2074 656d   templates = tem
-0001b330: 706c 6174 6573 5b3a 2c20 3a2c 2030 5d0a  plates[:, :, 0].
-0001b340: 2020 2020 2020 2020 2020 2020 656c 7365              else
-0001b350: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0001b360: 2020 6966 206e 6f74 2064 7269 6674 696e    if not driftin
-0001b370: 673a 0a20 2020 2020 2020 2020 2020 2020  g:.             
-0001b380: 2020 2020 2020 2069 6620 6c65 6e28 7465         if len(te
-0001b390: 6d70 6c61 7465 732e 7368 6170 6529 203d  mplates.shape) =
-0001b3a0: 3d20 353a 0a20 2020 2020 2020 2020 2020  = 5:.           
-0001b3b0: 2020 2020 2020 2020 2020 2020 2074 656d               tem
-0001b3c0: 706c 6174 6573 203d 2074 656d 706c 6174  plates = templat
-0001b3d0: 6573 5b3a 2c20 305d 0a20 2020 2020 2020  es[:, 0].       
-0001b3e0: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
-0001b3f0: 2020 2069 6620 7369 6e67 6c65 5f6a 6974     if single_jit
-0001b400: 7465 723a 0a20 2020 2020 2020 2020 2020  ter:.           
-0001b410: 2020 2020 2069 6620 6c65 6e28 7465 6d70       if len(temp
-0001b420: 6c61 7465 732e 7368 6170 6529 203d 3d20  lates.shape) == 
-0001b430: 343a 0a20 2020 2020 2020 2020 2020 2020  4:.             
-0001b440: 2020 2020 2020 2074 656d 706c 6174 6573         templates
-0001b450: 203d 2074 656d 706c 6174 6573 5b3a 2c20   = templates[:, 
-0001b460: 305d 0a0a 2020 2020 6966 2064 7269 6674  0]..    if drift
-0001b470: 696e 673a 0a20 2020 2020 2020 2061 7373  ing:.        ass
-0001b480: 6572 7420 6973 696e 7374 616e 6365 2874  ert isinstance(t
-0001b490: 656d 706c 6174 655f 6964 732c 2028 696e  emplate_ids, (in
-0001b4a0: 742c 206e 702e 696e 7465 6765 7229 292c  t, np.integer)),
-0001b4b0: 2022 5768 656e 2070 6c6f 7474 696e 6720   "When plotting 
-0001b4c0: 6472 6966 7469 6e67 2074 656d 706c 6174  drifting templat
-0001b4d0: 6573 2c20 2774 656d 706c 6174 655f 6964  es, 'template_id
-0001b4e0: 7327 2073 686f 756c 6420 2220 5c0a 2020  s' should " \.  
-0001b4f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b500: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b510: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b520: 2020 2020 2020 2020 2020 2262 6520 6120            "be a 
-0001b530: 7369 6e67 6c65 2069 6e64 6578 2028 696e  single index (in
-0001b540: 7429 220a 2020 2020 2020 2020 7369 6e67  t)".        sing
-0001b550: 6c65 5f61 7865 7320 3d20 5472 7565 0a0a  le_axes = True..
-0001b560: 2020 2020 6966 2074 656d 706c 6174 655f      if template_
-0001b570: 6964 7320 6973 206e 6f74 204e 6f6e 653a  ids is not None:
-0001b580: 0a20 2020 2020 2020 2069 6620 6973 696e  .        if isin
-0001b590: 7374 616e 6365 2874 656d 706c 6174 655f  stance(template_
-0001b5a0: 6964 732c 2028 696e 742c 206e 702e 696e  ids, (int, np.in
-0001b5b0: 7465 6765 7229 293a 0a20 2020 2020 2020  teger)):.       
-0001b5c0: 2020 2020 2074 656d 706c 6174 655f 6964       template_id
-0001b5d0: 7320 3d20 6c69 7374 286e 702e 6172 7261  s = list(np.arra
-0001b5e0: 7928 5b74 656d 706c 6174 655f 6964 735d  y([template_ids]
-0001b5f0: 2929 0a20 2020 2020 2020 2065 6c69 6620  )).        elif 
-0001b600: 6973 696e 7374 616e 6365 2874 656d 706c  isinstance(templ
-0001b610: 6174 655f 6964 732c 206c 6973 7429 3a0a  ate_ids, list):.
-0001b620: 2020 2020 2020 2020 2020 2020 7465 6d70              temp
-0001b630: 6c61 7465 5f69 6473 203d 206c 6973 7428  late_ids = list(
-0001b640: 6e70 2e61 7272 6179 2874 656d 706c 6174  np.array(templat
-0001b650: 655f 6964 7329 290a 2020 2020 656c 7365  e_ids)).    else
-0001b660: 3a0a 2020 2020 2020 2020 7465 6d70 6c61  :.        templa
-0001b670: 7465 5f69 6473 203d 206c 6973 7428 6e70  te_ids = list(np
-0001b680: 2e61 7261 6e67 6528 7465 6d70 6c61 7465  .arange(template
-0001b690: 732e 7368 6170 655b 305d 2929 0a0a 2020  s.shape[0]))..  
-0001b6a0: 2020 6966 206d 6178 5f74 656d 706c 6174    if max_templat
-0001b6b0: 6573 2069 7320 6e6f 7420 4e6f 6e65 3a0a  es is not None:.
-0001b6c0: 2020 2020 2020 2020 6966 206d 6178 5f74          if max_t
-0001b6d0: 656d 706c 6174 6573 203c 206c 656e 2874  emplates < len(t
-0001b6e0: 656d 706c 6174 6573 293a 0a20 2020 2020  emplates):.     
-0001b6f0: 2020 2020 2020 2072 616e 646f 6d5f 6964         random_id
-0001b700: 7873 203d 206e 702e 7261 6e64 6f6d 2e70  xs = np.random.p
-0001b710: 6572 6d75 7461 7469 6f6e 286c 656e 2874  ermutation(len(t
-0001b720: 656d 706c 6174 6573 2929 0a20 2020 2020  emplates)).     
-0001b730: 2020 2020 2020 2074 656d 706c 6174 655f         template_
-0001b740: 6964 7320 3d20 6e70 2e61 7261 6e67 6528  ids = np.arange(
-0001b750: 7465 6d70 6c61 7465 732e 7368 6170 655b  templates.shape[
-0001b760: 305d 295b 7261 6e64 6f6d 5f69 6478 735d  0])[random_idxs]
-0001b770: 5b3a 6d61 785f 7465 6d70 6c61 7465 735d  [:max_templates]
-0001b780: 0a20 2020 2020 2020 2020 2020 2023 2074  .            # t
-0001b790: 656d 706c 6174 6573 203d 2074 656d 706c  emplates = templ
-0001b7a0: 6174 6573 5b72 616e 646f 6d5f 6964 7873  ates[random_idxs
-0001b7b0: 5d5b 3a6d 6178 5f74 656d 706c 6174 6573  ][:max_templates
-0001b7c0: 5d0a 0a20 2020 206e 5f73 6f75 7263 6573  ]..    n_sources
-0001b7d0: 203d 206c 656e 2874 656d 706c 6174 655f   = len(template_
-0001b7e0: 6964 7329 0a20 2020 2069 6620 6178 2069  ids).    if ax i
-0001b7f0: 7320 4e6f 6e65 3a0a 2020 2020 2020 2020  s None:.        
-0001b800: 6669 6720 3d20 706c 742e 6669 6775 7265  fig = plt.figure
-0001b810: 2829 0a20 2020 2020 2020 2061 7820 3d20  ().        ax = 
-0001b820: 6669 672e 6164 645f 7375 6270 6c6f 7428  fig.add_subplot(
-0001b830: 3131 3129 0a20 2020 2065 6c73 653a 0a20  111).    else:. 
-0001b840: 2020 2020 2020 2066 6967 203d 2061 782e         fig = ax.
-0001b850: 6765 745f 6669 6775 7265 2829 0a0a 2020  get_figure()..  
-0001b860: 2020 6966 2027 7673 6361 6c65 2720 6e6f    if 'vscale' no
-0001b870: 7420 696e 206b 7761 7267 732e 6b65 7973  t in kwargs.keys
-0001b880: 2829 3a0a 2020 2020 2020 2020 6b77 6172  ():.        kwar
-0001b890: 6773 5b27 7673 6361 6c65 275d 203d 2031  gs['vscale'] = 1
-0001b8a0: 2e35 202a 206e 702e 6d61 7828 6e70 2e61  .5 * np.max(np.a
-0001b8b0: 6273 2874 656d 706c 6174 6573 5b74 656d  bs(templates[tem
-0001b8c0: 706c 6174 655f 6964 735d 2929 0a0a 2020  plate_ids]))..  
-0001b8d0: 2020 6966 2073 696e 676c 655f 6178 6573    if single_axes
-0001b8e0: 3a0a 2020 2020 2020 2020 6966 2063 6d61  :.        if cma
-0001b8f0: 7020 6973 206e 6f74 204e 6f6e 653a 0a20  p is not None:. 
-0001b900: 2020 2020 2020 2020 2020 2063 6d20 3d20             cm = 
-0001b910: 706c 742e 6765 745f 636d 6170 2863 6d61  plt.get_cmap(cma
-0001b920: 7029 0a20 2020 2020 2020 2020 2020 2063  p).            c
-0001b930: 6f6c 6f72 7320 3d20 5b63 6d28 6920 2f20  olors = [cm(i / 
-0001b940: 6c65 6e28 7465 6d70 6c61 7465 5f69 6473  len(template_ids
-0001b950: 2929 2066 6f72 2069 2069 6e20 6e70 2e61  )) for i in np.a
-0001b960: 7261 6e67 6528 6c65 6e28 7465 6d70 6c61  range(len(templa
-0001b970: 7465 5f69 6473 2929 5d0a 2020 2020 2020  te_ids))].      
-0001b980: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
-0001b990: 2020 2020 636f 6c6f 7273 203d 2070 6c74      colors = plt
-0001b9a0: 2e72 6350 6172 616d 735b 2761 7865 732e  .rcParams['axes.
-0001b9b0: 7072 6f70 5f63 7963 6c65 275d 2e62 795f  prop_cycle'].by_
-0001b9c0: 6b65 7928 295b 2763 6f6c 6f72 275d 0a0a  key()['color']..
-0001b9d0: 2020 2020 2020 2020 666f 7220 6e2c 2074          for n, t
-0001b9e0: 2069 6e20 656e 756d 6572 6174 6528 7465   in enumerate(te
-0001b9f0: 6d70 6c61 7465 7329 3a0a 2020 2020 2020  mplates):.      
-0001ba00: 2020 2020 2020 6966 206e 2069 6e20 7465        if n in te
-0001ba10: 6d70 6c61 7465 5f69 6473 3a0a 2020 2020  mplate_ids:.    
-0001ba20: 2020 2020 2020 2020 2020 2020 6966 206c              if l
-0001ba30: 656e 2874 2e73 6861 7065 2920 3d3d 2033  en(t.shape) == 3
-0001ba40: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0001ba50: 2020 2020 2020 6966 206e 6f74 2064 7269        if not dri
-0001ba60: 6674 696e 673a 0a20 2020 2020 2020 2020  fting:.         
-0001ba70: 2020 2020 2020 2020 2020 2020 2020 206d                 m
-0001ba80: 752e 706c 6f74 5f6d 6561 5f72 6563 6f72  u.plot_mea_recor
-0001ba90: 6469 6e67 2874 2e6d 6561 6e28 6178 6973  ding(t.mean(axis
-0001baa0: 3d30 292c 206d 6561 2c20 636f 6c6f 7273  =0), mea, colors
-0001bab0: 3d63 6f6c 6f72 735b 6e70 2e6d 6f64 286e  =colors[np.mod(n
-0001bac0: 2c20 6c65 6e28 636f 6c6f 7273 2929 5d2c  , len(colors))],
-0001bad0: 2061 783d 6178 2c0a 2020 2020 2020 2020   ax=ax,.        
+00018e10: 2020 736e 6970 7065 7420 3d20 6d6f 645f    snippet = mod_
+00018e20: 6172 7261 795b 706f 735d 202a 2074 656d  array[pos] * tem
+00018e30: 705f 6a69 7474 5b3a 2c20 3a64 6966 665d  p_jitt[:, :diff]
+00018e40: 2e54 0a20 2020 2020 2020 2020 2020 2020  .T.             
+00018e50: 2020 2020 2020 2072 6563 6f72 6469 6e67         recording
+00018e60: 735b 7370 6f73 202d 2063 7574 5f6f 7574  s[spos - cut_out
+00018e70: 5b30 5d20 3a2c 2065 6c65 635f 6964 7873  [0] :, elec_idxs
+00018e80: 5d20 2b3d 2073 6e69 7070 6574 2e61 7374  ] += snippet.ast
+00018e90: 7970 6528 6474 7970 6529 0a20 2020 2020  ype(dtype).     
+00018ea0: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+00018eb0: 2020 2020 2020 2020 2020 2020 2023 2065               # e
+00018ec0: 6c65 6374 726f 6465 0a20 2020 2020 2020  lectrode.       
+00018ed0: 2020 2020 2020 2020 2069 6620 7370 6f73           if spos
+00018ee0: 202d 2063 7574 5f6f 7574 5b30 5d20 3e3d   - cut_out[0] >=
+00018ef0: 2030 2061 6e64 2073 706f 7320 2b20 6375   0 and spos + cu
+00018f00: 745f 6f75 745b 315d 203c 3d20 6e5f 7361  t_out[1] <= n_sa
+00018f10: 6d70 6c65 733a 0a20 2020 2020 2020 2020  mples:.         
+00018f20: 2020 2020 2020 2020 2020 2073 6e69 7070             snipp
+00018f30: 6574 203d 206e 702e 6172 7261 7928 5b61  et = np.array([a
+00018f40: 202a 2074 2066 6f72 2028 612c 2074 2920   * t for (a, t) 
+00018f50: 696e 207a 6970 286d 6f64 5f61 7272 6179  in zip(mod_array
+00018f60: 5b70 6f73 5d2c 2074 656d 705f 6a69 7474  [pos], temp_jitt
+00018f70: 295d 292e 540a 2020 2020 2020 2020 2020  )]).T.          
+00018f80: 2020 2020 2020 2020 2020 7265 636f 7264            record
+00018f90: 696e 6773 5b73 706f 7320 2d20 6375 745f  ings[spos - cut_
+00018fa0: 6f75 745b 305d 203a 2073 706f 7320 2b20  out[0] : spos + 
+00018fb0: 6375 745f 6f75 745b 315d 2c20 656c 6563  cut_out[1], elec
+00018fc0: 5f69 6478 735d 202b 3d20 736e 6970 7065  _idxs] += snippe
+00018fd0: 742e 6173 7479 7065 2864 7479 7065 290a  t.astype(dtype).
+00018fe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018ff0: 656c 6966 2073 706f 7320 2d20 6375 745f  elif spos - cut_
+00019000: 6f75 745b 305d 203c 2030 3a0a 2020 2020  out[0] < 0:.    
+00019010: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00019020: 6469 6666 203d 202d 2873 706f 7320 2d20  diff = -(spos - 
+00019030: 6375 745f 6f75 745b 305d 290a 2020 2020  cut_out[0]).    
+00019040: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00019050: 736e 6970 7065 7420 3d20 6e70 2e61 7272  snippet = np.arr
+00019060: 6179 285b 6120 2a20 7420 666f 7220 2861  ay([a * t for (a
+00019070: 2c20 7429 2069 6e20 7a69 7028 6d6f 645f  , t) in zip(mod_
+00019080: 6172 7261 795b 706f 735d 2c20 7465 6d70  array[pos], temp
+00019090: 5f6a 6974 745b 3a2c 2064 6966 663a 5d29  _jitt[:, diff:])
+000190a0: 5d29 2e54 0a20 2020 2020 2020 2020 2020  ]).T.           
+000190b0: 2020 2020 2020 2020 2072 6563 6f72 6469           recordi
+000190c0: 6e67 735b 3a20 7370 6f73 202b 2063 7574  ngs[: spos + cut
+000190d0: 5f6f 7574 5b31 5d2c 2065 6c65 635f 6964  _out[1], elec_id
+000190e0: 7873 5d20 2b3d 2073 6e69 7070 6574 2e61  xs] += snippet.a
+000190f0: 7374 7970 6528 6474 7970 6529 0a20 2020  stype(dtype).   
+00019100: 2020 2020 2020 2020 2020 2020 2065 6c73               els
+00019110: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+00019120: 2020 2020 2020 2064 6966 6620 3d20 6e5f         diff = n_
+00019130: 7361 6d70 6c65 7320 2d20 2873 706f 7320  samples - (spos 
+00019140: 2d20 6375 745f 6f75 745b 305d 290a 2020  - cut_out[0]).  
+00019150: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00019160: 2020 736e 6970 7065 7420 3d20 6e70 2e61    snippet = np.a
+00019170: 7272 6179 285b 6120 2a20 7420 666f 7220  rray([a * t for 
+00019180: 2861 2c20 7429 2069 6e20 7a69 7028 6d6f  (a, t) in zip(mo
+00019190: 645f 6172 7261 795b 706f 735d 2c20 7465  d_array[pos], te
+000191a0: 6d70 5f6a 6974 745b 3a2c 203a 6469 6666  mp_jitt[:, :diff
+000191b0: 5d29 5d29 2e54 0a20 2020 2020 2020 2020  ])]).T.         
+000191c0: 2020 2020 2020 2020 2020 2072 6563 6f72             recor
+000191d0: 6469 6e67 735b 7370 6f73 202d 2063 7574  dings[spos - cut
+000191e0: 5f6f 7574 5b30 5d20 3a2c 2065 6c65 635f  _out[0] :, elec_
+000191f0: 6964 7873 5d20 2b3d 2073 6e69 7070 6574  idxs] += snippet
+00019200: 2e61 7374 7970 6528 6474 7970 6529 0a0a  .astype(dtype)..
+00019210: 2020 2020 7265 7475 726e 2072 6563 6f72      return recor
+00019220: 6469 6e67 730a 0a0a 6465 6620 636f 6d70  dings...def comp
+00019230: 7574 655f 6472 6966 745f 6964 7873 5f66  ute_drift_idxs_f
+00019240: 726f 6d5f 6472 6966 745f 6c69 7374 2873  rom_drift_list(s
+00019250: 7069 6b65 5f69 6e64 6578 2c20 7370 696b  pike_index, spik
+00019260: 655f 7472 6169 6e5f 6672 616d 6573 2c20  e_train_frames, 
+00019270: 6472 6966 745f 6c69 7374 2c20 6673 293a  drift_list, fs):
+00019280: 0a20 2020 2023 2070 7265 2d63 6f6d 7075  .    # pre-compu
+00019290: 7465 2064 7269 6674 2069 6478 730a 2020  te drift idxs.  
+000192a0: 2020 6472 6966 745f 6964 7873 5f64 6973    drift_idxs_dis
+000192b0: 706c 6163 656d 656e 7473 203d 206e 702e  placements = np.
+000192c0: 7a65 726f 7328 6c65 6e28 7370 696b 655f  zeros(len(spike_
+000192d0: 7472 6169 6e5f 6672 616d 6573 292c 2064  train_frames), d
+000192e0: 7479 7065 3d22 696e 7431 3622 290a 2020  type="int16").  
+000192f0: 2020 7370 696b 655f 7469 6d65 7320 3d20    spike_times = 
+00019300: 7370 696b 655f 7472 6169 6e5f 6672 616d  spike_train_fram
+00019310: 6573 202f 2066 730a 2020 2020 6d69 645f  es / fs.    mid_
+00019320: 706f 696e 745f 6964 7820 3d20 6472 6966  point_idx = drif
+00019330: 745f 6c69 7374 5b30 5d5b 2264 7269 6674  t_list[0]["drift
+00019340: 5f73 7465 7073 225d 202f 2f20 320a 0a20  _steps"] // 2.. 
+00019350: 2020 2066 6f72 2064 7269 6674 5f64 6963     for drift_dic
+00019360: 7420 696e 2064 7269 6674 5f6c 6973 743a  t in drift_list:
+00019370: 0a20 2020 2020 2020 2064 7269 6674 5f76  .        drift_v
+00019380: 6563 746f 725f 6964 7873 203d 206e 702e  ector_idxs = np.
+00019390: 6172 7261 7928 6472 6966 745f 6469 6374  array(drift_dict
+000193a0: 5b22 6472 6966 745f 7665 6374 6f72 5f69  ["drift_vector_i
+000193b0: 6478 7322 5d29 2020 2320 3020 2d20 6e75  dxs"])  # 0 - nu
+000193c0: 6d5f 7374 6570 730a 2020 2020 2020 2020  m_steps.        
+000193d0: 6472 6966 745f 6673 203d 2064 7269 6674  drift_fs = drift
+000193e0: 5f64 6963 745b 2264 7269 6674 5f66 7322  _dict["drift_fs"
+000193f0: 5d0a 2020 2020 2020 2020 6472 6966 745f  ].        drift_
+00019400: 6661 6374 6f72 7320 3d20 6472 6966 745f  factors = drift_
+00019410: 6469 6374 5b22 6472 6966 745f 6661 6374  dict["drift_fact
+00019420: 6f72 7322 5d0a 0a20 2020 2020 2020 2064  ors"]..        d
+00019430: 7269 6674 5f74 696d 6573 203d 2064 7269  rift_times = dri
+00019440: 6674 5f64 6963 745b 2264 7269 6674 5f74  ft_dict["drift_t
+00019450: 696d 6573 225d 0a20 2020 2020 2020 2069  imes"].        i
+00019460: 6620 6472 6966 745f 7469 6d65 7320 6973  f drift_times is
+00019470: 206e 6f74 204e 6f6e 653a 0a20 2020 2020   not None:.     
+00019480: 2020 2020 2020 2023 2064 7269 6674 2069         # drift i
+00019490: 7320 6f6e 6c79 2069 6e20 6120 7065 7269  s only in a peri
+000194a0: 6f64 0a20 2020 2020 2020 2020 2020 2073  od.            s
+000194b0: 7069 6b65 5f6d 6173 6b20 3d20 6e70 2e6c  pike_mask = np.l
+000194c0: 6f67 6963 616c 5f61 6e64 2873 7069 6b65  ogical_and(spike
+000194d0: 5f74 696d 6573 203e 3d20 6472 6966 745f  _times >= drift_
+000194e0: 7469 6d65 735b 305d 2c20 7370 696b 655f  times[0], spike_
+000194f0: 7469 6d65 7320 3c3d 2064 7269 6674 5f74  times <= drift_t
+00019500: 696d 6573 5b2d 315d 290a 2020 2020 2020  imes[-1]).      
+00019510: 2020 2020 2020 6472 6966 745f 7370 696b        drift_spik
+00019520: 655f 6964 7873 203d 206e 702e 7365 6172  e_idxs = np.sear
+00019530: 6368 736f 7274 6564 2864 7269 6674 5f74  chsorted(drift_t
+00019540: 696d 6573 2c20 7370 696b 655f 7469 6d65  imes, spike_time
+00019550: 735b 7370 696b 655f 6d61 736b 5d29 0a20  s[spike_mask]). 
+00019560: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+00019570: 2020 2020 2020 2020 2023 2064 7269 6674           # drift
+00019580: 2076 6563 746f 7220 636f 7665 7273 2065   vector covers e
+00019590: 6e74 6972 6520 7265 636f 7264 696e 670a  ntire recording.
+000195a0: 2020 2020 2020 2020 2020 2020 7370 696b              spik
+000195b0: 655f 6d61 736b 203d 206e 702e 6f6e 6573  e_mask = np.ones
+000195c0: 286c 656e 2873 7069 6b65 5f74 696d 6573  (len(spike_times
+000195d0: 292c 2064 7479 7065 3d62 6f6f 6c29 0a20  ), dtype=bool). 
+000195e0: 2020 2020 2020 2020 2020 2064 7269 6674             drift
+000195f0: 5f73 7069 6b65 5f69 6478 7320 3d20 2873  _spike_idxs = (s
+00019600: 7069 6b65 5f74 696d 6573 202a 2064 7269  pike_times * dri
+00019610: 6674 5f66 7329 2e61 7374 7970 6528 2269  ft_fs).astype("i
+00019620: 6e74 2229 0a0a 2020 2020 2020 2020 6472  nt")..        dr
+00019630: 6966 745f 6964 7873 5f64 6973 705f 6920  ift_idxs_disp_i 
+00019640: 3d20 6472 6966 745f 7665 6374 6f72 5f69  = drift_vector_i
+00019650: 6478 735b 6472 6966 745f 7370 696b 655f  dxs[drift_spike_
+00019660: 6964 7873 5d0a 2020 2020 2020 2020 6472  idxs].        dr
+00019670: 6966 745f 6964 7873 5f64 6973 706c 6163  ift_idxs_displac
+00019680: 656d 656e 7473 5b73 7069 6b65 5f6d 6173  ements[spike_mas
+00019690: 6b5d 202b 3d20 2864 7269 6674 5f69 6478  k] += (drift_idx
+000196a0: 735f 6469 7370 5f69 202a 2064 7269 6674  s_disp_i * drift
+000196b0: 5f66 6163 746f 7273 5b73 7069 6b65 5f69  _factors[spike_i
+000196c0: 6e64 6578 5d29 2e61 7374 7970 6528 2269  ndex]).astype("i
+000196d0: 6e74 3136 2229 0a20 2020 2064 7269 6674  nt16").    drift
+000196e0: 5f69 6478 7320 3d20 2864 7269 6674 5f69  _idxs = (drift_i
+000196f0: 6478 735f 6469 7370 6c61 6365 6d65 6e74  dxs_displacement
+00019700: 7320 2b20 6d69 645f 706f 696e 745f 6964  s + mid_point_id
+00019710: 7829 2e61 7374 7970 6528 2275 696e 7431  x).astype("uint1
+00019720: 3622 290a 2020 2020 7265 7475 726e 2064  6").    return d
+00019730: 7269 6674 5f69 6478 730a 0a0a 6465 6620  rift_idxs...def 
+00019740: 6578 7472 6163 745f 756e 6974 735f 6472  extract_units_dr
+00019750: 6966 745f 7665 6374 6f72 286d 6561 7265  ift_vector(meare
+00019760: 635f 6669 6c65 3d4e 6f6e 652c 2072 6563  c_file=None, rec
+00019770: 6765 6e3d 4e6f 6e65 2c20 7469 6d65 5f76  gen=None, time_v
+00019780: 6563 746f 723d 4e6f 6e65 293a 0a20 2020  ector=None):.   
+00019790: 2022 2222 0a20 2020 2052 6574 7269 6576   """.    Retriev
+000197a0: 6520 6472 6966 7420 7665 6374 6f72 2070  e drift vector p
+000197b0: 6572 2075 6e69 7473 2e0a 0a20 2020 2049  er units...    I
+000197c0: 6e74 6572 6e61 6c6c 7920 7665 6374 6f72  nternally vector
+000197d0: 2064 7269 6674 2076 6563 746f 7220 7065   drift vector pe
+000197e0: 7220 756e 6974 7320 6973 2063 6f6e 7374  r units is const
+000197f0: 7275 6374 6564 2077 6974 6820 6120 6c69  ructed with a li
+00019800: 6e65 6172 2073 756d 206f 660a 2020 2020  near sum of.    
+00019810: 6f66 2064 7269 6674 2069 6e64 6578 206d  of drift index m
+00019820: 756c 7469 706c 6965 6420 6279 2061 2066  ultiplied by a f
+00019830: 6163 746f 7220 7065 7220 6365 6c6c 2e0a  actor per cell..
+00019840: 2020 2020 5468 656e 2074 6869 7320 6472      Then this dr
+00019850: 6966 7420 696e 6465 7820 6973 2063 6f6e  ift index is con
+00019860: 7665 7274 6564 2074 6f20 6d69 6372 6f6d  verted to microm
+00019870: 6574 6572 2067 6976 656e 2074 6865 2063  eter given the c
+00019880: 656c 6c20 6c6f 6361 7469 6f6e 732e 0a0a  ell locations...
+00019890: 2020 2020 4865 7265 2060 7469 6d65 5f76      Here `time_v
+000198a0: 6563 746f 7260 2069 7320 6173 7375 6d65  ector` is assume
+000198b0: 6420 746f 2062 6520 7468 6520 6365 6e74  d to be the cent
+000198c0: 6572 206f 6620 7468 6520 6269 6e73 2028  er of the bins (
+000198d0: 6576 656e 2069 6620 696e 7465 726e 616c  even if internal
+000198e0: 6c79 2065 7672 6579 7468 696e 6720 6973  ly evreything is
+000198f0: 2066 6c6f 6f72 6564 2074 6f20 7468 6520   floored to the 
+00019900: 6c65 6674 206f 6620 7468 6520 6269 6e29  left of the bin)
+00019910: 0a0a 2020 2020 5061 7261 6d65 7465 7273  ..    Parameters
+00019920: 0a20 2020 202d 2d2d 2d2d 2d2d 2d2d 2d0a  .    ----------.
+00019930: 2020 2020 6d65 6172 6563 5f66 696c 653a      mearec_file:
+00019940: 2073 7472 206f 7220 4e6f 6e65 0a20 2020   str or None.   
+00019950: 2020 2020 2054 6865 204d 4541 7265 6320       The MEArec 
+00019960: 6669 6c65 6e61 6d65 0a20 2020 2072 6563  filename.    rec
+00019970: 6765 6e3a 2052 6563 6f72 6469 6e67 4765  gen: RecordingGe
+00019980: 6e65 7261 746f 7220 6f72 204e 6f6e 650a  nerator or None.
+00019990: 2020 2020 2020 2020 5468 6520 5265 636f          The Reco
+000199a0: 7264 696e 6747 656e 6572 6174 6f72 0a20  rdingGenerator. 
+000199b0: 2020 2074 696d 655f 7665 6374 6f72 3a20     time_vector: 
+000199c0: 6172 7261 7920 6f72 204e 6f6e 650a 2020  array or None.  
+000199d0: 2020 2020 2020 416e 2065 7874 6572 6e61        An externa
+000199e0: 6c20 7469 6d65 2076 6563 746f 7220 746f  l time vector to
+000199f0: 2069 6e74 6572 706f 6c61 7465 2064 6972   interpolate dir
+00019a00: 6674 2e0a 2020 2020 2020 2020 4966 204e  ft..        If N
+00019a10: 6f6e 6520 7468 6520 696e 7465 726e 616c  one the internal
+00019a20: 2064 7269 6674 2076 6563 746f 7220 7769   drift vector wi
+00019a30: 7468 2068 6968 6573 7420 6673 2069 7320  th hihest fs is 
+00019a40: 7573 6564 2e0a 0a20 2020 2052 6574 7572  used...    Retur
+00019a50: 6e73 0a20 2020 202d 2d2d 2d2d 2d2d 0a20  ns.    -------. 
+00019a60: 2020 2075 6e69 7473 5f64 7269 6674 5f76     units_drift_v
+00019a70: 6563 746f 7273 3a20 6172 7261 790a 2020  ectors: array.  
+00019a80: 2020 2020 2020 7468 6520 6472 6966 7420        the drift 
+00019a90: 7665 6374 6f72 2069 6e20 6d69 6372 6f20  vector in micro 
+00019aa0: 6d65 7465 7273 0a20 2020 2020 2020 2073  meters.        s
+00019ab0: 6861 7065 2028 6e5f 7469 6d65 5f62 696e  hape (n_time_bin
+00019ac0: 2c20 6e5f 756e 6974 7329 0a20 2020 2074  , n_units).    t
+00019ad0: 696d 655f 7665 6374 6f72 3a20 6172 7261  ime_vector: arra
+00019ae0: 790a 2020 2020 2020 2020 7469 6d65 2076  y.        time v
+00019af0: 6563 746f 7220 696e 2073 6563 6f6e 640a  ector in second.
+00019b00: 2020 2020 2020 2020 7368 6170 6520 286e          shape (n
+00019b10: 5f74 696d 655f 6269 6e2c 206e 5f75 6e69  _time_bin, n_uni
+00019b20: 7473 290a 2020 2020 2222 220a 2020 2020  ts).    """.    
+00019b30: 696d 706f 7274 2073 6369 7079 2e69 6e74  import scipy.int
+00019b40: 6572 706f 6c61 7465 0a0a 2020 2020 6966  erpolate..    if
+00019b50: 206d 6561 7265 635f 6669 6c65 2069 7320   mearec_file is 
+00019b60: 6e6f 7420 4e6f 6e65 3a0a 2020 2020 2020  not None:.      
+00019b70: 2020 7265 6367 656e 203d 206c 6f61 645f    recgen = load_
+00019b80: 7265 636f 7264 696e 6773 286d 6561 7265  recordings(meare
+00019b90: 635f 6669 6c65 290a 0a20 2020 2064 7269  c_file)..    dri
+00019ba0: 6674 5f6c 6973 7420 3d20 7265 6367 656e  ft_list = recgen
+00019bb0: 2e64 7269 6674 5f6c 6973 740a 2020 2020  .drift_list.    
+00019bc0: 6c6f 6361 7469 6f6e 7320 3d20 6e70 2e61  locations = np.a
+00019bd0: 7272 6179 2872 6563 6765 6e2e 7465 6d70  rray(recgen.temp
+00019be0: 6c61 7465 5f6c 6f63 6174 696f 6e73 290a  late_locations).
+00019bf0: 0a20 2020 2069 6620 7469 6d65 5f76 6563  .    if time_vec
+00019c00: 746f 7220 6973 204e 6f6e 653a 0a20 2020  tor is None:.   
+00019c10: 2020 2020 2023 2074 6865 206d 6169 6e20       # the main 
+00019c20: 7469 6d65 7320 636f 6e73 7472 7563 7465  times constructe
+00019c30: 6420 6672 6f6d 2074 6865 2066 6972 7374  d from the first
+00019c40: 2064 7269 6674 0a20 2020 2020 2020 2062   drift.        b
+00019c50: 6573 7420 3d20 6e70 2e61 7267 6d61 7828  est = np.argmax(
+00019c60: 5b64 5b22 6472 6966 745f 6673 225d 2066  [d["drift_fs"] f
+00019c70: 6f72 2064 2069 6e20 6472 6966 745f 6c69  or d in drift_li
+00019c80: 7374 5d29 0a20 2020 2020 2020 2064 7269  st]).        dri
+00019c90: 6674 5f64 6963 7420 3d20 6472 6966 745f  ft_dict = drift_
+00019ca0: 6c69 7374 5b62 6573 745d 0a20 2020 2020  list[best].     
+00019cb0: 2020 206d 6169 6e5f 6673 203d 2064 7269     main_fs = dri
+00019cc0: 6674 5f64 6963 745b 2264 7269 6674 5f66  ft_dict["drift_f
+00019cd0: 7322 5d0a 2020 2020 2020 2020 6c65 6e67  s"].        leng
+00019ce0: 7468 203d 206c 656e 2864 7269 6674 5f6c  th = len(drift_l
+00019cf0: 6973 745b 6265 7374 5d5b 2264 7269 6674  ist[best]["drift
+00019d00: 5f76 6563 746f 725f 6964 7873 225d 290a  _vector_idxs"]).
+00019d10: 2020 2020 2020 2020 7469 6d65 5f76 6563          time_vec
+00019d20: 746f 7220 3d20 6e70 2e61 7261 6e67 6528  tor = np.arange(
+00019d30: 6c65 6e67 7468 2920 2f20 6d61 696e 5f66  length) / main_f
+00019d40: 730a 2020 2020 656c 7365 3a0a 2020 2020  s.    else:.    
+00019d50: 2020 2020 6d61 696e 5f66 7320 3d20 6e70      main_fs = np
+00019d60: 2e6d 6564 6961 6e28 6e70 2e64 6966 6628  .median(np.diff(
+00019d70: 7469 6d65 5f76 6563 746f 7229 290a 0a20  time_vector)).. 
+00019d80: 2020 2023 2069 6e74 6572 706f 6c61 7465     # interpolate
+00019d90: 2064 7269 6674 5f76 6563 746f 725f 6964   drift_vector_id
+00019da0: 7873 206f 6e20 7468 6520 7361 6d65 2063  xs on the same c
+00019db0: 6c6f 636b 0a20 2020 2066 6f72 2064 7269  lock.    for dri
+00019dc0: 6674 5f64 6963 7420 696e 2064 7269 6674  ft_dict in drift
+00019dd0: 5f6c 6973 743a 0a20 2020 2020 2020 2064  _list:.        d
+00019de0: 7269 6674 5f76 6563 746f 725f 6964 7873  rift_vector_idxs
+00019df0: 203d 206e 702e 6172 7261 7928 6472 6966   = np.array(drif
+00019e00: 745f 6469 6374 5b22 6472 6966 745f 7665  t_dict["drift_ve
+00019e10: 6374 6f72 5f69 6478 7322 5d29 0a20 2020  ctor_idxs"]).   
+00019e20: 2020 2020 2064 7269 6674 5f66 7320 3d20       drift_fs = 
+00019e30: 6472 6966 745f 6469 6374 5b22 6472 6966  drift_dict["drif
+00019e40: 745f 6673 225d 0a20 2020 2020 2020 2069  t_fs"].        i
+00019e50: 6620 6472 6966 745f 6673 203d 3d20 6d61  f drift_fs == ma
+00019e60: 696e 5f66 7320 616e 6420 6472 6966 745f  in_fs and drift_
+00019e70: 7665 6374 6f72 5f69 6478 732e 7368 6170  vector_idxs.shap
+00019e80: 655b 305d 203d 3d20 7469 6d65 5f76 6563  e[0] == time_vec
+00019e90: 746f 722e 7368 6170 655b 305d 3a0a 2020  tor.shape[0]:.  
+00019ea0: 2020 2020 2020 2020 2020 2320 6e6f 2069            # no i
+00019eb0: 6e74 6572 706f 6c61 7469 6f6e 206e 6565  nterpolation nee
+00019ec0: 6465 640a 2020 2020 2020 2020 2020 2020  ded.            
+00019ed0: 696e 7465 7270 6f6c 6174 6564 5f64 7269  interpolated_dri
+00019ee0: 6674 5f76 6563 746f 725f 6964 7873 203d  ft_vector_idxs =
+00019ef0: 2064 7269 6674 5f76 6563 746f 725f 6964   drift_vector_id
+00019f00: 7873 0a20 2020 2020 2020 2065 6c73 653a  xs.        else:
+00019f10: 0a20 2020 2020 2020 2020 2020 2023 206c  .            # l
+00019f20: 696e 6561 7220 696e 7465 7270 6f6c 6174  inear interpolat
+00019f30: 696f 6e20 6f6e 2074 6865 2074 696d 6576  ion on the timev
+00019f40: 6563 746f 720a 2020 2020 2020 2020 2020  ector.          
+00019f50: 2020 2320 6e6f 7465 2074 6861 7420 7765    # note that we
+00019f60: 2075 7365 2074 6865 2063 656e 7465 7220   use the center 
+00019f70: 6f66 2074 6865 2062 696e 7320 6865 7265  of the bins here
+00019f80: 0a20 2020 2020 2020 2020 2020 206c 6f63  .            loc
+00019f90: 616c 5f74 696d 6573 203d 206e 702e 6172  al_times = np.ar
+00019fa0: 616e 6765 2864 7269 6674 5f76 6563 746f  ange(drift_vecto
+00019fb0: 725f 6964 7873 2e73 6861 7065 5b30 5d29  r_idxs.shape[0])
+00019fc0: 202f 2064 7269 6674 5f66 7320 2b20 302e   / drift_fs + 0.
+00019fd0: 3520 2f20 6472 6966 745f 6673 0a20 2020  5 / drift_fs.   
+00019fe0: 2020 2020 2020 2020 2066 203d 2073 6369           f = sci
+00019ff0: 7079 2e69 6e74 6572 706f 6c61 7465 2e69  py.interpolate.i
+0001a000: 6e74 6572 7031 6428 6c6f 6361 6c5f 7469  nterp1d(local_ti
+0001a010: 6d65 732c 2064 7269 6674 5f76 6563 746f  mes, drift_vecto
+0001a020: 725f 6964 7873 290a 2020 2020 2020 2020  r_idxs).        
+0001a030: 2020 2020 696e 7465 7270 6f6c 6174 6564      interpolated
+0001a040: 5f64 7269 6674 5f76 6563 746f 725f 6964  _drift_vector_id
+0001a050: 7873 203d 2066 2874 696d 655f 7665 6374  xs = f(time_vect
+0001a060: 6f72 290a 2020 2020 2020 2020 6472 6966  or).        drif
+0001a070: 745f 6469 6374 5b22 696e 7465 7270 6f6c  t_dict["interpol
+0001a080: 6174 6564 5f64 7269 6674 5f76 6563 746f  ated_drift_vecto
+0001a090: 725f 6964 7873 225d 203d 2069 6e74 6572  r_idxs"] = inter
+0001a0a0: 706f 6c61 7465 645f 6472 6966 745f 7665  polated_drift_ve
+0001a0b0: 6374 6f72 5f69 6478 730a 0a20 2020 206e  ctor_idxs..    n
+0001a0c0: 5f75 6e69 7473 203d 206c 656e 2872 6563  _units = len(rec
+0001a0d0: 6765 6e2e 7370 696b 6574 7261 696e 7329  gen.spiketrains)
+0001a0e0: 0a20 2020 2075 6e69 7473 5f64 7269 6674  .    units_drift
+0001a0f0: 5f76 6563 746f 7273 203d 206e 702e 7a65  _vectors = np.ze
+0001a100: 726f 7328 2874 696d 655f 7665 6374 6f72  ros((time_vector
+0001a110: 2e73 697a 652c 206e 5f75 6e69 7473 292c  .size, n_units),
+0001a120: 2064 7479 7065 3d22 666c 6f61 7433 3222   dtype="float32"
+0001a130: 290a 2020 2020 6d69 645f 706f 696e 745f  ).    mid_point_
+0001a140: 6964 7820 3d20 6472 6966 745f 6c69 7374  idx = drift_list
+0001a150: 5b30 5d5b 2264 7269 6674 5f73 7465 7073  [0]["drift_steps
+0001a160: 225d 202f 2f20 320a 2020 2020 666f 7220  "] // 2.    for 
+0001a170: 756e 6974 5f69 6e64 6578 2069 6e20 7261  unit_index in ra
+0001a180: 6e67 6528 6e5f 756e 6974 7329 3a0a 2020  nge(n_units):.  
+0001a190: 2020 2020 2020 7375 6d6d 6564 5f64 7269        summed_dri
+0001a1a0: 6674 5f69 6478 7320 3d20 6e70 2e7a 6572  ft_idxs = np.zer
+0001a1b0: 6f73 2874 696d 655f 7665 6374 6f72 2e73  os(time_vector.s
+0001a1c0: 697a 652c 2064 7479 7065 3d22 696e 7431  ize, dtype="int1
+0001a1d0: 3622 290a 2020 2020 2020 2020 666f 7220  6").        for 
+0001a1e0: 6472 6966 745f 6469 6374 2069 6e20 6472  drift_dict in dr
+0001a1f0: 6966 745f 6c69 7374 3a0a 2020 2020 2020  ift_list:.      
+0001a200: 2020 2020 2020 696e 7465 7270 6f6c 6174        interpolat
+0001a210: 6564 5f64 7269 6674 5f76 6563 746f 725f  ed_drift_vector_
+0001a220: 6964 7873 203d 2064 7269 6674 5f64 6963  idxs = drift_dic
+0001a230: 745b 2269 6e74 6572 706f 6c61 7465 645f  t["interpolated_
+0001a240: 6472 6966 745f 7665 6374 6f72 5f69 6478  drift_vector_idx
+0001a250: 7322 5d0a 2020 2020 2020 2020 2020 2020  s"].            
+0001a260: 6472 6966 745f 6661 6374 6f72 7320 3d20  drift_factors = 
+0001a270: 6472 6966 745f 6469 6374 5b22 6472 6966  drift_dict["drif
+0001a280: 745f 6661 6374 6f72 7322 5d0a 2020 2020  t_factors"].    
+0001a290: 2020 2020 2020 2020 7375 6d6d 6564 5f64          summed_d
+0001a2a0: 7269 6674 5f69 6478 7320 2b3d 2028 2869  rift_idxs += ((i
+0001a2b0: 6e74 6572 706f 6c61 7465 645f 6472 6966  nterpolated_drif
+0001a2c0: 745f 7665 6374 6f72 5f69 6478 7329 202a  t_vector_idxs) *
+0001a2d0: 2064 7269 6674 5f66 6163 746f 7273 5b75   drift_factors[u
+0001a2e0: 6e69 745f 696e 6465 785d 292e 6173 7479  nit_index]).asty
+0001a2f0: 7065 2822 696e 7431 3622 290a 2020 2020  pe("int16").    
+0001a300: 2020 2020 7375 6d6d 6564 5f64 7269 6674      summed_drift
+0001a310: 5f69 6478 7320 3d20 2873 756d 6d65 645f  _idxs = (summed_
+0001a320: 6472 6966 745f 6964 7873 202b 206d 6964  drift_idxs + mid
+0001a330: 5f70 6f69 6e74 5f69 6478 292e 6173 7479  _point_idx).asty
+0001a340: 7065 2822 7569 6e74 3136 2229 0a20 2020  pe("uint16").   
+0001a350: 2020 2020 206c 6f63 7320 3d20 6c6f 6361       locs = loca
+0001a360: 7469 6f6e 735b 756e 6974 5f69 6e64 6578  tions[unit_index
+0001a370: 2c20 3a2c 2032 5d0a 2020 2020 2020 2020  , :, 2].        
+0001a380: 756e 6974 735f 6472 6966 745f 7665 6374  units_drift_vect
+0001a390: 6f72 735b 3a2c 2075 6e69 745f 696e 6465  ors[:, unit_inde
+0001a3a0: 785d 203d 206c 6f63 735b 7375 6d6d 6564  x] = locs[summed
+0001a3b0: 5f64 7269 6674 5f69 6478 735d 0a0a 2020  _drift_idxs]..  
+0001a3c0: 2020 7265 7475 726e 2075 6e69 7473 5f64    return units_d
+0001a3d0: 7269 6674 5f76 6563 746f 7273 2c20 7469  rift_vectors, ti
+0001a3e0: 6d65 5f76 6563 746f 720a 0a0a 2323 2320  me_vector...### 
+0001a3f0: 5245 434f 5244 494e 4720 4f50 4552 4154  RECORDING OPERAT
+0001a400: 494f 4e20 2323 230a 6465 6620 6578 7472  ION ###.def extr
+0001a410: 6163 745f 7766 2873 7069 6b65 7472 6169  act_wf(spiketrai
+0001a420: 6e73 2c20 7265 636f 7264 696e 6773 2c20  ns, recordings, 
+0001a430: 6673 2c20 6375 745f 6f75 743d 322c 2074  fs, cut_out=2, t
+0001a440: 696d 6573 7461 6d70 733d 4e6f 6e65 293a  imestamps=None):
+0001a450: 0a20 2020 2022 2222 0a20 2020 2045 7874  .    """.    Ext
+0001a460: 7261 6374 2077 6176 6566 6f72 6d73 2066  ract waveforms f
+0001a470: 726f 6d20 7265 636f 7264 696e 6773 2061  rom recordings a
+0001a480: 6e64 206c 6f61 6420 6974 2069 6e20 7761  nd load it in wa
+0001a490: 7665 666f 726d 2066 6965 6c64 206f 6620  veform field of 
+0001a4a0: 6e65 6f20 7370 696b 6520 7472 6169 6e73  neo spike trains
+0001a4b0: 2e0a 0a20 2020 2050 6172 616d 6574 6572  ...    Parameter
+0001a4c0: 730a 2020 2020 2d2d 2d2d 2d2d 2d2d 2d2d  s.    ----------
+0001a4d0: 0a20 2020 2073 7069 6b65 7472 6169 6e73  .    spiketrains
+0001a4e0: 203a 206c 6973 740a 2020 2020 2020 2020   : list.        
+0001a4f0: 4c69 7374 206f 6620 6e65 6f20 7370 696b  List of neo spik
+0001a500: 6520 7472 6169 6e73 0a20 2020 2072 6563  e trains.    rec
+0001a510: 6f72 6469 6e67 7320 3a20 6e70 2e61 7272  ordings : np.arr
+0001a520: 6179 0a20 2020 2020 2020 2041 7272 6179  ay.        Array
+0001a530: 2077 6974 6820 7265 636f 7264 696e 6773   with recordings
+0001a540: 2028 6e5f 7361 6d70 6c65 732c 206e 5f65   (n_samples, n_e
+0001a550: 6c65 6329 0a20 2020 2066 7320 3a20 5175  lec).    fs : Qu
+0001a560: 616e 7469 7479 0a20 2020 2020 2020 2053  antity.        S
+0001a570: 616d 706c 696e 6720 6672 6571 7565 6e63  ampling frequenc
+0001a580: 790a 2020 2020 6375 745f 6f75 7420 3a20  y.    cut_out : 
+0001a590: 666c 6f61 7420 6f72 206c 6973 740a 2020  float or list.  
+0001a5a0: 2020 2020 2020 204c 656e 6774 6820 696e         Length in
+0001a5b0: 206d 7320 746f 2063 7574 2062 6566 6f72   ms to cut befor
+0001a5c0: 6520 616e 6420 6166 7465 7220 7370 696b  e and after spik
+0001a5d0: 6520 7065 616b 2e20 4966 2061 2073 696e  e peak. If a sin
+0001a5e0: 676c 6520 7661 6c75 6520 7468 6520 6375  gle value the cu
+0001a5f0: 7420 6973 2073 796d 6d65 7472 6963 616c  t is symmetrical
+0001a600: 0a20 2020 2074 696d 6573 7461 6d70 7320  .    timestamps 
+0001a610: 3a20 5175 616e 7469 7479 2061 7272 6179  : Quantity array
+0001a620: 2028 6f70 7469 6f6e 616c 290a 2020 2020   (optional).    
+0001a630: 2020 2020 4172 7261 7920 7769 7468 2072      Array with r
+0001a640: 6563 6f72 6469 6e67 7320 7469 6d65 7374  ecordings timest
+0001a650: 616d 7073 0a20 2020 2022 2222 0a20 2020  amps.    """.   
+0001a660: 2069 6620 6375 745f 6f75 7420 6973 204e   if cut_out is N
+0001a670: 6f6e 653a 0a20 2020 2020 2020 2063 7574  one:.        cut
+0001a680: 5f6f 7574 203d 2032 0a20 2020 2069 6620  _out = 2.    if 
+0001a690: 6e6f 7420 6973 696e 7374 616e 6365 2863  not isinstance(c
+0001a6a0: 7574 5f6f 7574 2c20 6c69 7374 293a 0a20  ut_out, list):. 
+0001a6b0: 2020 2020 2020 206e 5f70 6164 203d 2069         n_pad = i
+0001a6c0: 6e74 2863 7574 5f6f 7574 202a 2070 712e  nt(cut_out * pq.
+0001a6d0: 6d73 202a 2066 732e 7265 7363 616c 6528  ms * fs.rescale(
+0001a6e0: 226b 487a 2229 290a 2020 2020 2020 2020  "kHz")).        
+0001a6f0: 6e5f 7061 6420 3d20 5b6e 5f70 6164 2c20  n_pad = [n_pad, 
+0001a700: 6e5f 7061 645d 0a20 2020 2065 6c73 653a  n_pad].    else:
+0001a710: 0a20 2020 2020 2020 206e 5f70 6164 203d  .        n_pad =
+0001a720: 205b 696e 7428 7020 2a20 7071 2e6d 7320   [int(p * pq.ms 
+0001a730: 2a20 6673 2e72 6573 6361 6c65 2822 6b48  * fs.rescale("kH
+0001a740: 7a22 2929 2066 6f72 2070 2069 6e20 6375  z")) for p in cu
+0001a750: 745f 6f75 745d 0a0a 2020 2020 6e5f 7361  t_out]..    n_sa
+0001a760: 6d70 6c65 732c 206e 5f65 6c65 6320 3d20  mples, n_elec = 
+0001a770: 7265 636f 7264 696e 6773 2e73 6861 7065  recordings.shape
+0001a780: 0a20 2020 2069 6620 7469 6d65 7374 616d  .    if timestam
+0001a790: 7073 2069 7320 4e6f 6e65 3a0a 2020 2020  ps is None:.    
+0001a7a0: 2020 2020 7469 6d65 7374 616d 7073 203d      timestamps =
+0001a7b0: 206e 702e 6172 616e 6765 286e 5f73 616d   np.arange(n_sam
+0001a7c0: 706c 6573 2920 2f20 6673 2e72 6573 6361  ples) / fs.resca
+0001a7d0: 6c65 2822 487a 2229 0a20 2020 2075 6e69  le("Hz").    uni
+0001a7e0: 7420 3d20 7469 6d65 7374 616d 7073 5b30  t = timestamps[0
+0001a7f0: 5d2e 7265 7363 616c 6528 226d 7322 292e  ].rescale("ms").
+0001a800: 756e 6974 730a 0a20 2020 2066 6f72 2073  units..    for s
+0001a810: 7420 696e 2073 7069 6b65 7472 6169 6e73  t in spiketrains
+0001a820: 3a0a 2020 2020 2020 2020 7370 5f72 6563  :.        sp_rec
+0001a830: 5f77 6620 3d20 5b5d 0a20 2020 2020 2020  _wf = [].       
+0001a840: 2073 705f 616d 7020 3d20 5b5d 0a20 2020   sp_amp = [].   
+0001a850: 2020 2020 2066 6f72 2074 2069 6e20 7374       for t in st
+0001a860: 3a0a 2020 2020 2020 2020 2020 2020 6964  :.            id
+0001a870: 7820 3d20 6e70 2e77 6865 7265 2874 696d  x = np.where(tim
+0001a880: 6573 7461 6d70 7320 3e3d 2074 295b 305d  estamps >= t)[0]
+0001a890: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+0001a8a0: 6c65 6e28 6964 7829 203e 2030 3a0a 2020  len(idx) > 0:.  
+0001a8b0: 2020 2020 2020 2020 2020 2020 2020 6964                id
+0001a8c0: 7820 3d20 6964 785b 305d 0a20 2020 2020  x = idx[0].     
+0001a8d0: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+0001a8e0: 2020 2020 2020 2020 2020 2020 2069 6478               idx
+0001a8f0: 203d 206c 656e 2874 696d 6573 7461 6d70   = len(timestamp
+0001a900: 7329 202d 2031 0a20 2020 2020 2020 2020  s) - 1.         
+0001a910: 2020 2023 2066 696e 6420 7369 6e67 6c65     # find single
+0001a920: 2077 6176 6566 6f72 6d73 2063 726f 7373   waveforms cross
+0001a930: 696e 6720 7468 7265 7368 6f6c 6473 0a20  ing thresholds. 
+0001a940: 2020 2020 2020 2020 2020 2069 6620 6964             if id
+0001a950: 7820 2d20 6e5f 7061 645b 305d 203e 2030  x - n_pad[0] > 0
+0001a960: 2061 6e64 2069 6478 202b 206e 5f70 6164   and idx + n_pad
+0001a970: 5b31 5d20 3c20 6e5f 7361 6d70 6c65 733a  [1] < n_samples:
+0001a980: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001a990: 2073 7069 6b65 5f72 6563 203d 2072 6563   spike_rec = rec
+0001a9a0: 6f72 6469 6e67 735b 6964 7820 2d20 6e5f  ordings[idx - n_
+0001a9b0: 7061 645b 305d 203a 2069 6478 202b 206e  pad[0] : idx + n
+0001a9c0: 5f70 6164 5b31 5d5d 0a20 2020 2020 2020  _pad[1]].       
+0001a9d0: 2020 2020 2065 6c69 6620 6964 7820 2d20       elif idx - 
+0001a9e0: 6e5f 7061 645b 305d 203c 2030 3a0a 2020  n_pad[0] < 0:.  
+0001a9f0: 2020 2020 2020 2020 2020 2020 2020 7370                sp
+0001aa00: 696b 655f 7265 6320 3d20 7265 636f 7264  ike_rec = record
+0001aa10: 696e 6773 5b3a 2069 6478 202b 206e 5f70  ings[: idx + n_p
+0001aa20: 6164 5b31 5d5d 0a20 2020 2020 2020 2020  ad[1]].         
+0001aa30: 2020 2020 2020 2073 7069 6b65 5f72 6563         spike_rec
+0001aa40: 203d 206e 702e 7061 6428 7370 696b 655f   = np.pad(spike_
+0001aa50: 7265 632c 2028 286e 702e 6162 7328 6964  rec, ((np.abs(id
+0001aa60: 7820 2d20 6e5f 7061 645b 305d 292c 2030  x - n_pad[0]), 0
+0001aa70: 292c 2028 302c 2030 2929 2c20 2263 6f6e  ), (0, 0)), "con
+0001aa80: 7374 616e 7422 290a 2020 2020 2020 2020  stant").        
+0001aa90: 2020 2020 656c 6966 2069 6478 202b 206e      elif idx + n
+0001aaa0: 5f70 6164 5b31 5d20 3e20 6e5f 7361 6d70  _pad[1] > n_samp
+0001aab0: 6c65 733a 0a20 2020 2020 2020 2020 2020  les:.           
+0001aac0: 2020 2020 2073 7069 6b65 5f72 6563 203d       spike_rec =
+0001aad0: 2072 6563 6f72 6469 6e67 735b 6964 7820   recordings[idx 
+0001aae0: 2d20 6e5f 7061 645b 305d 203a 5d0a 2020  - n_pad[0] :].  
+0001aaf0: 2020 2020 2020 2020 2020 2020 2020 7370                sp
+0001ab00: 696b 655f 7265 6320 3d20 6e70 2e70 6164  ike_rec = np.pad
+0001ab10: 2873 7069 6b65 5f72 6563 2c20 2828 302c  (spike_rec, ((0,
+0001ab20: 2069 6478 202b 206e 5f70 6164 5b31 5d20   idx + n_pad[1] 
+0001ab30: 2d20 6e5f 7361 6d70 6c65 7329 2c20 2830  - n_samples), (0
+0001ab40: 2c20 3029 292c 2022 636f 6e73 7461 6e74  , 0)), "constant
+0001ab50: 2229 0a20 2020 2020 2020 2020 2020 2073  ").            s
+0001ab60: 705f 7265 635f 7766 2e61 7070 656e 6428  p_rec_wf.append(
+0001ab70: 7370 696b 655f 7265 632e 5429 0a20 2020  spike_rec.T).   
+0001ab80: 2020 2020 2073 742e 7761 7665 666f 726d       st.waveform
+0001ab90: 7320 3d20 6e70 2e61 7272 6179 2873 705f  s = np.array(sp_
+0001aba0: 7265 635f 7766 290a 0a0a 6465 6620 6669  rec_wf)...def fi
+0001abb0: 6c74 6572 5f61 6e61 6c6f 675f 7369 676e  lter_analog_sign
+0001abc0: 616c 7328 7369 676e 616c 732c 2066 7265  als(signals, fre
+0001abd0: 712c 2066 732c 2066 696c 7465 725f 7479  q, fs, filter_ty
+0001abe0: 7065 3d22 6261 6e64 7061 7373 222c 206d  pe="bandpass", m
+0001abf0: 6f64 653d 2266 696c 7466 696c 7422 2c20  ode="filtfilt", 
+0001ac00: 6f72 6465 723d 3329 3a0a 2020 2020 2222  order=3):.    ""
+0001ac10: 220a 2020 2020 4669 6c74 6572 2061 6e61  ".    Filter ana
+0001ac20: 6c6f 6720 7369 676e 616c 7320 7769 7468  log signals with
+0001ac30: 207a 6572 6f2d 7068 6173 6520 4275 7474   zero-phase Butt
+0001ac40: 6572 776f 7274 6820 6669 6c74 6572 2e0a  erworth filter..
+0001ac50: 2020 2020 5468 6520 6675 6e63 7469 6f6e      The function
+0001ac60: 2072 6169 7365 7320 616e 2045 7863 6570   raises an Excep
+0001ac70: 7469 6f6e 2069 6620 7468 6520 7265 7175  tion if the requ
+0001ac80: 6972 6564 2066 696c 7465 7220 6973 206e  ired filter is n
+0001ac90: 6f74 2073 7461 626c 652e 0a0a 2020 2020  ot stable...    
+0001aca0: 5061 7261 6d65 7465 7273 0a20 2020 202d  Parameters.    -
+0001acb0: 2d2d 2d2d 2d2d 2d2d 2d0a 2020 2020 7369  ---------.    si
+0001acc0: 676e 616c 7320 3a20 6e70 2e61 7272 6179  gnals : np.array
+0001acd0: 0a20 2020 2020 2020 2041 7272 6179 206f  .        Array o
+0001ace0: 6620 616e 616c 6f67 2073 6967 6e61 6c73  f analog signals
+0001acf0: 2028 6e5f 7361 6d70 6c65 732c 206e 5f65   (n_samples, n_e
+0001ad00: 6c65 6329 0a20 2020 2066 7265 7120 3a20  lec).    freq : 
+0001ad10: 6c69 7374 206f 7220 666c 6f61 740a 2020  list or float.  
+0001ad20: 2020 2020 2020 4375 746f 6666 2066 7265        Cutoff fre
+0001ad30: 7175 656e 6379 2d69 6573 2069 6e20 487a  quency-ies in Hz
+0001ad40: 0a20 2020 2066 7320 3a20 5175 616e 7469  .    fs : Quanti
+0001ad50: 7479 0a20 2020 2020 2020 2053 616d 706c  ty.        Sampl
+0001ad60: 696e 6720 6672 6571 7565 6e63 790a 2020  ing frequency.  
+0001ad70: 2020 6669 6c74 6572 5f74 7970 6520 3a20    filter_type : 
+0001ad80: 7374 720a 2020 2020 2020 2020 4669 6c74  str.        Filt
+0001ad90: 6572 2074 7970 6520 2827 6c6f 7770 6173  er type ('lowpas
+0001ada0: 7327 2c20 2768 6967 6870 6173 7327 2c20  s', 'highpass', 
+0001adb0: 2762 616e 6470 6173 7327 2c20 2762 616e  'bandpass', 'ban
+0001adc0: 6473 746f 7027 290a 2020 2020 6d6f 6465  dstop').    mode
+0001add0: 203a 2073 7472 0a20 2020 2020 2020 2046   : str.        F
+0001ade0: 696c 7465 7269 6e67 206d 6f64 6520 2827  iltering mode ('
+0001adf0: 6669 6c74 6669 6c74 272c 2027 6c66 696c  filtfilt', 'lfil
+0001ae00: 7465 7227 290a 2020 2020 6f72 6465 7220  ter').    order 
+0001ae10: 3a20 696e 740a 2020 2020 2020 2020 4669  : int.        Fi
+0001ae20: 6c74 6572 206f 7264 6572 0a0a 2020 2020  lter order..    
+0001ae30: 5265 7475 726e 730a 2020 2020 2d2d 2d2d  Returns.    ----
+0001ae40: 2d2d 2d0a 2020 2020 7369 676e 616c 735f  ---.    signals_
+0001ae50: 6669 6c74 203a 206e 702e 6172 7261 790a  filt : np.array.
+0001ae60: 2020 2020 2020 2020 4669 6c74 6572 6564          Filtered
+0001ae70: 2073 6967 6e61 6c73 0a20 2020 2022 2222   signals.    """
+0001ae80: 0a20 2020 2066 726f 6d20 7363 6970 792e  .    from scipy.
+0001ae90: 7369 676e 616c 2069 6d70 6f72 7420 6275  signal import bu
+0001aea0: 7474 6572 2c20 6669 6c74 6669 6c74 2c20  tter, filtfilt, 
+0001aeb0: 6c66 696c 7465 720a 0a20 2020 2066 6e20  lfilter..    fn 
+0001aec0: 3d20 6673 202f 2032 2e30 0a20 2020 2066  = fs / 2.0.    f
+0001aed0: 7265 7120 3d20 6672 6571 2e72 6573 6361  req = freq.resca
+0001aee0: 6c65 2870 712e 487a 290a 2020 2020 6261  le(pq.Hz).    ba
+0001aef0: 6e64 203d 2066 7265 7120 2f20 666e 0a0a  nd = freq / fn..
+0001af00: 2020 2020 6173 7365 7274 206d 6f64 6520      assert mode 
+0001af10: 696e 205b 2266 696c 7466 696c 7422 2c20  in ["filtfilt", 
+0001af20: 226c 6669 6c74 6572 225d 2c20 2246 696c  "lfilter"], "Fil
+0001af30: 7465 7269 6e67 206d 6f64 6520 6e6f 7420  tering mode not 
+0001af40: 7265 636f 676e 697a 6564 220a 2020 2020  recognized".    
+0001af50: 6966 206d 6f64 6520 3d3d 2022 6669 6c74  if mode == "filt
+0001af60: 6669 6c74 223a 0a20 2020 2020 2020 2066  filt":.        f
+0001af70: 696c 7465 725f 6675 6e63 203d 2066 696c  ilter_func = fil
+0001af80: 7466 696c 740a 2020 2020 656c 6966 206d  tfilt.    elif m
+0001af90: 6f64 6520 3d3d 2022 6c66 696c 7465 7222  ode == "lfilter"
+0001afa0: 3a0a 2020 2020 2020 2020 6669 6c74 6572  :.        filter
+0001afb0: 5f66 756e 6320 3d20 6c66 696c 7465 720a  _func = lfilter.
+0001afc0: 0a20 2020 2062 2c20 6120 3d20 6275 7474  .    b, a = butt
+0001afd0: 6572 286f 7264 6572 2c20 6261 6e64 2c20  er(order, band, 
+0001afe0: 6274 7970 653d 6669 6c74 6572 5f74 7970  btype=filter_typ
+0001aff0: 6529 0a0a 2020 2020 6966 206e 702e 616c  e)..    if np.al
+0001b000: 6c28 6e70 2e61 6273 286e 702e 726f 6f74  l(np.abs(np.root
+0001b010: 7328 6129 2920 3c20 3129 2061 6e64 206e  s(a)) < 1) and n
+0001b020: 702e 616c 6c28 6e70 2e61 6273 286e 702e  p.all(np.abs(np.
+0001b030: 726f 6f74 7328 6129 2920 3c20 3129 3a0a  roots(a)) < 1):.
+0001b040: 2020 2020 2020 2020 2320 7072 696e 7428          # print(
+0001b050: 2746 696c 7465 7269 6e67 2073 6967 6e61  'Filtering signa
+0001b060: 6c73 2077 6974 6820 272c 2066 696c 7465  ls with ', filte
+0001b070: 725f 7479 7065 2c20 2720 6669 6c74 6572  r_type, ' filter
+0001b080: 2061 7420 272c 2066 7265 712c 2027 2e2e   at ', freq, '..
+0001b090: 2e27 290a 2020 2020 2020 2020 6966 206c  .').        if l
+0001b0a0: 656e 2873 6967 6e61 6c73 2e73 6861 7065  en(signals.shape
+0001b0b0: 2920 3d3d 2032 3a0a 2020 2020 2020 2020  ) == 2:.        
+0001b0c0: 2020 2020 7369 676e 616c 735f 6669 6c74      signals_filt
+0001b0d0: 203d 2066 696c 7465 725f 6675 6e63 2862   = filter_func(b
+0001b0e0: 2c20 612c 2073 6967 6e61 6c73 2c20 6178  , a, signals, ax
+0001b0f0: 6973 3d30 290a 2020 2020 2020 2020 656c  is=0).        el
+0001b100: 6966 206c 656e 2873 6967 6e61 6c73 2e73  if len(signals.s
+0001b110: 6861 7065 2920 3d3d 2031 3a0a 2020 2020  hape) == 1:.    
+0001b120: 2020 2020 2020 2020 7369 676e 616c 735f          signals_
+0001b130: 6669 6c74 203d 2066 696c 7465 725f 6675  filt = filter_fu
+0001b140: 6e63 2862 2c20 612c 2073 6967 6e61 6c73  nc(b, a, signals
+0001b150: 290a 2020 2020 2020 2020 7265 7475 726e  ).        return
+0001b160: 2073 6967 6e61 6c73 5f66 696c 740a 2020   signals_filt.  
+0001b170: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+0001b180: 7261 6973 6520 5661 6c75 6545 7272 6f72  raise ValueError
+0001b190: 2822 4669 6c74 6572 2069 7320 6e6f 7420  ("Filter is not 
+0001b1a0: 7374 6162 6c65 2229 0a0a 0a23 2323 2050  stable")...### P
+0001b1b0: 4c4f 5454 494e 4720 2323 230a 6465 6620  LOTTING ###.def 
+0001b1c0: 706c 6f74 5f72 6173 7465 7273 280a 2020  plot_rasters(.  
+0001b1d0: 2020 7370 696b 6574 7261 696e 732c 2063    spiketrains, c
+0001b1e0: 656c 6c5f 7479 7065 3d46 616c 7365 2c20  ell_type=False, 
+0001b1f0: 6178 3d4e 6f6e 652c 206f 7665 726c 6170  ax=None, overlap
+0001b200: 3d46 616c 7365 2c20 636f 6c6f 723d 4e6f  =False, color=No
+0001b210: 6e65 2c20 6673 3d31 302c 206d 6172 6b65  ne, fs=10, marke
+0001b220: 723d 227c 222c 206d 6577 3d32 2c20 6d61  r="|", mew=2, ma
+0001b230: 726b 6572 7369 7a65 3d35 0a29 3a0a 2020  rkersize=5.):.  
+0001b240: 2020 2222 220a 2020 2020 506c 6f74 2072    """.    Plot r
+0001b250: 6173 7465 7220 666f 7220 7370 696b 6520  aster for spike 
+0001b260: 7472 6169 6e73 2e0a 0a20 2020 2050 6172  trains...    Par
+0001b270: 616d 6574 6572 730a 2020 2020 2d2d 2d2d  ameters.    ----
+0001b280: 2d2d 2d2d 2d2d 0a20 2020 2073 7069 6b65  ------.    spike
+0001b290: 7472 6169 6e73 203a 206c 6973 740a 2020  trains : list.  
+0001b2a0: 2020 2020 2020 4c69 7374 206f 6620 6e65        List of ne
+0001b2b0: 6f20 7370 696b 6520 7472 6169 6e73 0a20  o spike trains. 
+0001b2c0: 2020 2063 656c 6c5f 7479 7065 203a 2062     cell_type : b
+0001b2d0: 6f6f 6c0a 2020 2020 2020 2020 4966 2054  ool.        If T
+0001b2e0: 7275 6520 616e 6420 2762 696e 7479 7065  rue and 'bintype
+0001b2f0: 2720 696e 2073 7069 6b65 2074 7261 696e  ' in spike train
+0001b300: 2061 6e6e 6f74 6174 696f 6e20 7370 696b   annotation spik
+0001b310: 6520 7472 6169 6e73 2061 7265 2070 6c6f  e trains are plo
+0001b320: 7474 6564 2062 6173 6564 206f 6e20 7468  tted based on th
+0001b330: 6569 7220 7479 7065 0a20 2020 2061 7820  eir type.    ax 
+0001b340: 3a20 6178 6573 0a20 2020 2020 2020 2050  : axes.        P
+0001b350: 6c6f 7420 6f6e 2074 6865 2067 6976 656e  lot on the given
+0001b360: 2061 7865 730a 2020 2020 6f76 6572 6c61   axes.    overla
+0001b370: 7020 3a20 626f 6f6c 0a20 2020 2020 2020  p : bool.       
+0001b380: 2050 6c6f 7420 7370 696b 6520 636f 6c6f   Plot spike colo
+0001b390: 7273 2062 6173 6564 206f 6e20 6f76 6572  rs based on over
+0001b3a0: 6c61 700a 2020 2020 6c61 6265 6c73 203a  lap.    labels :
+0001b3b0: 2062 6f6f 6c0a 2020 2020 2020 2020 506c   bool.        Pl
+0001b3c0: 6f74 2073 7069 6b65 2063 6f6c 6f72 7320  ot spike colors 
+0001b3d0: 6261 7365 6420 6f6e 206c 6162 656c 730a  based on labels.
+0001b3e0: 2020 2020 636f 6c6f 7220 3a20 6d61 7470      color : matp
+0001b3f0: 6c6f 746c 6962 2063 6f6c 6f72 2028 7369  lotlib color (si
+0001b400: 6e67 6c65 206f 7220 6c69 7374 290a 2020  ngle or list).  
+0001b410: 2020 2020 2020 436f 6c6f 7220 6f72 2063        Color or c
+0001b420: 6f6c 6f72 206c 6973 740a 2020 2020 6673  olor list.    fs
+0001b430: 203a 2069 6e74 0a20 2020 2020 2020 2046   : int.        F
+0001b440: 6f6e 7420 7369 7a65 0a20 2020 206d 6172  ont size.    mar
+0001b450: 6b65 7220 3a20 6d61 7470 6c6f 746c 6962  ker : matplotlib
+0001b460: 2061 7267 0a20 2020 2020 2020 204d 6172   arg.        Mar
+0001b470: 6b65 7220 7479 7065 0a20 2020 206d 6577  ker type.    mew
+0001b480: 203a 206d 6174 706c 6f74 6c69 6220 6172   : matplotlib ar
+0001b490: 670a 2020 2020 2020 2020 5769 6474 6820  g.        Width 
+0001b4a0: 6f66 206d 6172 6b65 720a 2020 2020 6d61  of marker.    ma
+0001b4b0: 726b 6572 7369 7a65 203a 2069 6e74 0a20  rkersize : int. 
+0001b4c0: 2020 2020 2020 204d 6172 6b65 7220 7369         Marker si
+0001b4d0: 7a65 0a0a 2020 2020 5265 7475 726e 730a  ze..    Returns.
+0001b4e0: 2020 2020 2d2d 2d2d 2d2d 2d0a 2020 2020      -------.    
+0001b4f0: 6178 203a 2061 7869 730a 2020 2020 2020  ax : axis.      
+0001b500: 2020 4d61 7470 6c6f 746c 6962 2061 7869    Matplotlib axi
+0001b510: 730a 2020 2020 2222 220a 0a20 2020 2069  s.    """..    i
+0001b520: 6d70 6f72 7420 6d61 7470 6c6f 746c 6962  mport matplotlib
+0001b530: 2e70 796c 6162 2061 7320 706c 740a 0a20  .pylab as plt.. 
+0001b540: 2020 2069 6620 6e6f 7420 6178 3a0a 2020     if not ax:.  
+0001b550: 2020 2020 2020 6669 6720 3d20 706c 742e        fig = plt.
+0001b560: 6669 6775 7265 2829 0a20 2020 2020 2020  figure().       
+0001b570: 2061 7820 3d20 6669 672e 6164 645f 7375   ax = fig.add_su
+0001b580: 6270 6c6f 7428 3131 3129 0a20 2020 2069  bplot(111).    i
+0001b590: 6620 6f76 6572 6c61 703a 0a20 2020 2020  f overlap:.     
+0001b5a0: 2020 2069 6620 226f 7665 726c 6170 2220     if "overlap" 
+0001b5b0: 6e6f 7420 696e 2073 7069 6b65 7472 6169  not in spiketrai
+0001b5c0: 6e73 5b30 5d2e 616e 6e6f 7461 7469 6f6e  ns[0].annotation
+0001b5d0: 732e 6b65 7973 2829 3a0a 2020 2020 2020  s.keys():.      
+0001b5e0: 2020 2020 2020 7261 6973 6520 4578 6365        raise Exce
+0001b5f0: 7074 696f 6e28 290a 2020 2020 666f 7220  ption().    for 
+0001b600: 692c 2073 7069 6b65 7472 6169 6e20 696e  i, spiketrain in
+0001b610: 2065 6e75 6d65 7261 7465 2873 7069 6b65   enumerate(spike
+0001b620: 7472 6169 6e73 293a 0a20 2020 2020 2020  trains):.       
+0001b630: 2074 203d 2073 7069 6b65 7472 6169 6e2e   t = spiketrain.
+0001b640: 7265 7363 616c 6528 7071 2e73 290a 2020  rescale(pq.s).  
+0001b650: 2020 2020 2020 6966 2063 656c 6c5f 7479        if cell_ty
+0001b660: 7065 3a0a 2020 2020 2020 2020 2020 2020  pe:.            
+0001b670: 6966 2022 6365 6c6c 5f74 7970 6522 2069  if "cell_type" i
+0001b680: 6e20 7370 696b 6574 7261 696e 2e61 6e6e  n spiketrain.ann
+0001b690: 6f74 6174 696f 6e73 2e6b 6579 7328 293a  otations.keys():
+0001b6a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001b6b0: 2069 6620 7370 696b 6574 7261 696e 2e61   if spiketrain.a
+0001b6c0: 6e6e 6f74 6174 696f 6e73 5b22 6365 6c6c  nnotations["cell
+0001b6d0: 5f74 7970 6522 5d20 3d3d 2022 4522 3a0a  _type"] == "E":.
+0001b6e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001b6f0: 2020 2020 6178 2e70 6c6f 7428 742c 2069      ax.plot(t, i
+0001b700: 202a 206e 702e 6f6e 6573 5f6c 696b 6528   * np.ones_like(
+0001b710: 7429 2c20 2262 222c 206d 6172 6b65 723d  t), "b", marker=
+0001b720: 6d61 726b 6572 2c20 6d65 773d 6d65 772c  marker, mew=mew,
+0001b730: 206d 6172 6b65 7273 697a 653d 6d61 726b   markersize=mark
+0001b740: 6572 7369 7a65 2c20 6c73 3d22 2229 0a20  ersize, ls=""). 
+0001b750: 2020 2020 2020 2020 2020 2020 2020 2065                 e
+0001b760: 6c69 6620 7370 696b 6574 7261 696e 2e61  lif spiketrain.a
+0001b770: 6e6e 6f74 6174 696f 6e73 5b22 6365 6c6c  nnotations["cell
+0001b780: 5f74 7970 6522 5d20 3d3d 2022 4922 3a0a  _type"] == "I":.
+0001b790: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001b7a0: 2020 2020 6178 2e70 6c6f 7428 742c 2069      ax.plot(t, i
+0001b7b0: 202a 206e 702e 6f6e 6573 5f6c 696b 6528   * np.ones_like(
+0001b7c0: 7429 2c20 2272 222c 206d 6172 6b65 723d  t), "r", marker=
+0001b7d0: 6d61 726b 6572 2c20 6d65 773d 6d65 772c  marker, mew=mew,
+0001b7e0: 206d 6172 6b65 7273 697a 653d 6d61 726b   markersize=mark
+0001b7f0: 6572 7369 7a65 2c20 6c73 3d22 2229 0a20  ersize, ls=""). 
+0001b800: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
+0001b810: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001b820: 2069 6620 636f 6c6f 7220 6973 206e 6f74   if color is not
+0001b830: 204e 6f6e 653a 0a20 2020 2020 2020 2020   None:.         
+0001b840: 2020 2020 2020 2020 2020 2069 6620 6973             if is
+0001b850: 696e 7374 616e 6365 2863 6f6c 6f72 2c20  instance(color, 
+0001b860: 6c69 7374 2920 6f72 2069 7369 6e73 7461  list) or isinsta
+0001b870: 6e63 6528 636f 6c6f 722c 206e 702e 6e64  nce(color, np.nd
+0001b880: 6172 7261 7929 3a0a 2020 2020 2020 2020  array):.        
+0001b890: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001b8a0: 6178 2e70 6c6f 7428 0a20 2020 2020 2020  ax.plot(.       
+0001b8b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001b8c0: 2020 2020 2074 2c20 6920 2a20 6e70 2e6f       t, i * np.o
+0001b8d0: 6e65 735f 6c69 6b65 2874 292c 2063 6f6c  nes_like(t), col
+0001b8e0: 6f72 3d63 6f6c 6f72 5b69 5d2c 206d 6172  or=color[i], mar
+0001b8f0: 6b65 723d 6d61 726b 6572 2c20 6d65 773d  ker=marker, mew=
+0001b900: 6d65 772c 206d 6172 6b65 7273 697a 653d  mew, markersize=
+0001b910: 6d61 726b 6572 7369 7a65 2c20 6c73 3d22  markersize, ls="
+0001b920: 220a 2020 2020 2020 2020 2020 2020 2020  ".              
+0001b930: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
+0001b940: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001b950: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+0001b960: 2020 2020 2020 2020 2020 2020 2020 6178                ax
+0001b970: 2e70 6c6f 7428 0a20 2020 2020 2020 2020  .plot(.         
+0001b980: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001b990: 2020 2074 2c20 6920 2a20 6e70 2e6f 6e65     t, i * np.one
+0001b9a0: 735f 6c69 6b65 2874 292c 2063 6f6c 6f72  s_like(t), color
+0001b9b0: 3d63 6f6c 6f72 2c20 6d61 726b 6572 3d6d  =color, marker=m
+0001b9c0: 6172 6b65 722c 206d 6577 3d6d 6577 2c20  arker, mew=mew, 
+0001b9d0: 6d61 726b 6572 7369 7a65 3d6d 6172 6b65  markersize=marke
+0001b9e0: 7273 697a 652c 206c 733d 2222 0a20 2020  rsize, ls="".   
+0001b9f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001ba00: 2020 2020 2029 0a20 2020 2020 2020 2020       ).         
+0001ba10: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+0001ba20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001ba30: 2061 782e 706c 6f74 2874 2c20 6920 2a20   ax.plot(t, i * 
+0001ba40: 6e70 2e6f 6e65 735f 6c69 6b65 2874 292c  np.ones_like(t),
+0001ba50: 2022 6b22 2c20 6d61 726b 6572 3d6d 6172   "k", marker=mar
+0001ba60: 6b65 722c 206d 6577 3d6d 6577 2c20 6d61  ker, mew=mew, ma
+0001ba70: 726b 6572 7369 7a65 3d6d 6172 6b65 7273  rkersize=markers
+0001ba80: 697a 652c 206c 733d 2222 290a 2020 2020  ize, ls="").    
+0001ba90: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+0001baa0: 2020 2020 2020 6966 206e 6f74 206f 7665        if not ove
+0001bab0: 726c 6170 3a0a 2020 2020 2020 2020 2020  rlap:.          
+0001bac0: 2020 2020 2020 6966 2063 6f6c 6f72 2069        if color i
+0001bad0: 7320 6e6f 7420 4e6f 6e65 3a0a 2020 2020  s not None:.    
 0001bae0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001baf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001bb00: 2020 2020 2020 2a2a 6b77 6172 6773 290a        **kwargs).
-0001bb10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001bb20: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+0001baf0: 6966 2069 7369 6e73 7461 6e63 6528 636f  if isinstance(co
+0001bb00: 6c6f 722c 206c 6973 7429 206f 7220 6973  lor, list) or is
+0001bb10: 696e 7374 616e 6365 2863 6f6c 6f72 2c20  instance(color, 
+0001bb20: 6e70 2e6e 6461 7272 6179 293a 0a20 2020  np.ndarray):.   
 0001bb30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001bb40: 2020 6966 2063 6d61 7020 6973 204e 6f6e    if cmap is Non
-0001bb50: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-0001bb60: 2020 2020 2020 2020 2020 2020 2020 2063                 c
-0001bb70: 6d61 7020 3d20 2752 6564 7327 0a20 2020  map = 'Reds'.   
-0001bb80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001bb90: 2020 2020 2063 6d20 3d20 706c 742e 6765       cm = plt.ge
-0001bba0: 745f 636d 6170 2863 6d61 7029 0a20 2020  t_cmap(cmap).   
-0001bbb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001bbc0: 2020 2020 2063 6f6c 6f72 7320 3d20 5b63       colors = [c
-0001bbd0: 6d28 6920 2f20 742e 7368 6170 655b 305d  m(i / t.shape[0]
-0001bbe0: 2920 666f 7220 6920 696e 206e 702e 6172  ) for i in np.ar
-0001bbf0: 616e 6765 2874 2e73 6861 7065 5b30 5d29  ange(t.shape[0])
-0001bc00: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
-0001bc10: 2020 2020 2020 2020 2020 6d75 2e70 6c6f            mu.plo
-0001bc20: 745f 6d65 615f 7265 636f 7264 696e 6728  t_mea_recording(
-0001bc30: 742c 206d 6561 2c20 636f 6c6f 7273 3d63  t, mea, colors=c
-0001bc40: 6f6c 6f72 732c 2061 783d 6178 2c0a 2020  olors, ax=ax,.  
-0001bc50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001bc60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001bc70: 2020 2020 2020 2020 2020 2020 2a2a 6b77              **kw
-0001bc80: 6172 6773 290a 2020 2020 2020 2020 2020  args).          
-0001bc90: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
-0001bca0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001bcb0: 6d75 2e70 6c6f 745f 6d65 615f 7265 636f  mu.plot_mea_reco
-0001bcc0: 7264 696e 6728 742c 206d 6561 2c20 636f  rding(t, mea, co
-0001bcd0: 6c6f 7273 3d63 6f6c 6f72 735b 6e70 2e6d  lors=colors[np.m
-0001bce0: 6f64 286e 2c20 6c65 6e28 636f 6c6f 7273  od(n, len(colors
-0001bcf0: 2929 5d2c 2061 783d 6178 2c20 2a2a 6b77  ))], ax=ax, **kw
-0001bd00: 6172 6773 290a 2020 2020 656c 7365 3a0a  args).    else:.
-0001bd10: 2020 2020 2020 2020 6966 206e 5f73 6f75          if n_sou
-0001bd20: 7263 6573 203e 206e 636f 6c73 3a0a 2020  rces > ncols:.  
-0001bd30: 2020 2020 2020 2020 2020 6e72 6f77 7320            nrows 
-0001bd40: 3d20 696e 7428 6e70 2e63 6569 6c28 6c65  = int(np.ceil(le
-0001bd50: 6e28 7465 6d70 6c61 7465 5f69 6473 2920  n(template_ids) 
-0001bd60: 2f20 6e63 6f6c 7329 290a 2020 2020 2020  / ncols)).      
-0001bd70: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
-0001bd80: 2020 2020 6e72 6f77 7320 3d20 310a 2020      nrows = 1.  
-0001bd90: 2020 2020 2020 2020 2020 6e63 6f6c 7320            ncols 
-0001bda0: 3d20 6e5f 736f 7572 6365 730a 0a20 2020  = n_sources..   
-0001bdb0: 2020 2020 2069 6620 636d 6170 2069 7320       if cmap is 
-0001bdc0: 6e6f 7420 4e6f 6e65 3a0a 2020 2020 2020  not None:.      
-0001bdd0: 2020 2020 2020 636d 203d 2070 6c74 2e67        cm = plt.g
-0001bde0: 6574 5f63 6d61 7028 636d 6170 290a 2020  et_cmap(cmap).  
-0001bdf0: 2020 2020 2020 2020 2020 636f 6c6f 7273            colors
-0001be00: 203d 205b 636d 2869 202f 206c 656e 2874   = [cm(i / len(t
-0001be10: 656d 706c 6174 655f 6964 7329 2920 666f  emplate_ids)) fo
-0001be20: 7220 6920 696e 206e 702e 6172 616e 6765  r i in np.arange
-0001be30: 286c 656e 2874 656d 706c 6174 655f 6964  (len(template_id
-0001be40: 7329 295d 0a20 2020 2020 2020 2065 6c73  s))].        els
-0001be50: 653a 0a20 2020 2020 2020 2020 2020 2063  e:.            c
-0001be60: 6f6c 6f72 7320 3d20 706c 742e 7263 5061  olors = plt.rcPa
-0001be70: 7261 6d73 5b27 6178 6573 2e70 726f 705f  rams['axes.prop_
-0001be80: 6379 636c 6527 5d2e 6279 5f6b 6579 2829  cycle'].by_key()
-0001be90: 5b27 636f 6c6f 7227 5d0a 0a20 2020 2020  ['color']..     
-0001bea0: 2020 2067 7320 3d20 6772 6964 7370 6563     gs = gridspec
-0001beb0: 2e47 7269 6453 7065 6346 726f 6d53 7562  .GridSpecFromSub
-0001bec0: 706c 6f74 5370 6563 286e 726f 7773 2c20  plotSpec(nrows, 
-0001bed0: 6e63 6f6c 732c 2073 7562 706c 6f74 5f73  ncols, subplot_s
-0001bee0: 7065 633d 6178 290a 0a20 2020 2020 2020  pec=ax)..       
-0001bef0: 2066 6f72 2069 5f6e 2c20 6e20 696e 2065   for i_n, n in e
-0001bf00: 6e75 6d65 7261 7465 2874 656d 706c 6174  numerate(templat
-0001bf10: 655f 6964 7329 3a0a 2020 2020 2020 2020  e_ids):.        
-0001bf20: 2020 2020 7220 3d20 695f 6e20 2f2f 206e      r = i_n // n
-0001bf30: 636f 6c73 0a20 2020 2020 2020 2020 2020  cols.           
-0001bf40: 2063 203d 206e 702e 6d6f 6428 695f 6e2c   c = np.mod(i_n,
-0001bf50: 206e 636f 6c73 290a 2020 2020 2020 2020   ncols).        
-0001bf60: 2020 2020 6773 5f73 656c 203d 2067 735b      gs_sel = gs[
-0001bf70: 722c 2063 5d0a 2020 2020 2020 2020 2020  r, c].          
-0001bf80: 2020 6178 5f74 203d 2066 6967 2e61 6464    ax_t = fig.add
-0001bf90: 5f73 7562 706c 6f74 2867 735f 7365 6c29  _subplot(gs_sel)
-0001bfa0: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-0001bfb0: 636d 6170 2069 7320 6e6f 7420 4e6f 6e65  cmap is not None
-0001bfc0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0001bfd0: 2020 6d75 2e70 6c6f 745f 6d65 615f 7265    mu.plot_mea_re
-0001bfe0: 636f 7264 696e 6728 7465 6d70 6c61 7465  cording(template
-0001bff0: 735b 6e5d 2c20 6d65 612c 2061 783d 6178  s[n], mea, ax=ax
-0001c000: 5f74 2c20 636f 6c6f 7273 3d63 6f6c 6f72  _t, colors=color
-0001c010: 735b 695f 6e5d 2c20 2a2a 6b77 6172 6773  s[i_n], **kwargs
-0001c020: 290a 2020 2020 2020 2020 2020 2020 656c  ).            el
-0001c030: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-0001c040: 2020 2020 6d75 2e70 6c6f 745f 6d65 615f      mu.plot_mea_
-0001c050: 7265 636f 7264 696e 6728 7465 6d70 6c61  recording(templa
-0001c060: 7465 735b 6e5d 2c20 6d65 612c 2061 783d  tes[n], mea, ax=
-0001c070: 6178 5f74 2c20 636f 6c6f 7273 3d63 6f6c  ax_t, colors=col
-0001c080: 6f72 735b 6e70 2e6d 6f64 2869 5f6e 2c20  ors[np.mod(i_n, 
-0001c090: 6c65 6e28 636f 6c6f 7273 2929 5d2c 202a  len(colors))], *
-0001c0a0: 2a6b 7761 7267 7329 0a20 2020 2020 2020  *kwargs).       
-0001c0b0: 2061 782e 6178 6973 2827 6f66 6627 290a   ax.axis('off').
-0001c0c0: 0a20 2020 2072 6574 7572 6e20 6178 0a0a  .    return ax..
-0001c0d0: 0a64 6566 2070 6c6f 745f 7265 636f 7264  .def plot_record
-0001c0e0: 696e 6773 2872 6563 6765 6e2c 2061 783d  ings(recgen, ax=
-0001c0f0: 4e6f 6e65 2c20 7374 6172 745f 7469 6d65  None, start_time
-0001c100: 3d4e 6f6e 652c 2065 6e64 5f74 696d 653d  =None, end_time=
-0001c110: 4e6f 6e65 2c20 6f76 6572 6c61 795f 7465  None, overlay_te
-0001c120: 6d70 6c61 7465 733d 4661 6c73 652c 206e  mplates=False, n
-0001c130: 5f74 656d 706c 6174 6573 3d4e 6f6e 652c  _templates=None,
-0001c140: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001c150: 2020 2020 206d 6178 5f63 6861 6e6e 656c       max_channel
-0001c160: 735f 7065 725f 7465 6d70 6c61 7465 3d31  s_per_template=1
-0001c170: 362c 2063 6d61 703d 4e6f 6e65 2c20 7465  6, cmap=None, te
-0001c180: 6d70 6c61 7465 735f 6c77 3d31 2c20 2a2a  mplates_lw=1, **
-0001c190: 6b77 6172 6773 293a 0a20 2020 2022 2222  kwargs):.    """
-0001c1a0: 0a20 2020 2050 6c6f 7420 7265 636f 7264  .    Plot record
-0001c1b0: 696e 6773 2e0a 0a20 2020 2050 6172 616d  ings...    Param
-0001c1c0: 6574 6572 730a 2020 2020 2d2d 2d2d 2d2d  eters.    ------
-0001c1d0: 2d2d 2d2d 0a20 2020 2072 6563 6765 6e20  ----.    recgen 
-0001c1e0: 3a20 5265 636f 7264 696e 6747 656e 6572  : RecordingGener
-0001c1f0: 6174 6f72 0a20 2020 2020 2020 2052 6563  ator.        Rec
-0001c200: 6f72 6469 6e67 2067 656e 6572 6174 6f72  ording generator
-0001c210: 206f 626a 6563 7420 746f 2070 6c6f 740a   object to plot.
-0001c220: 2020 2020 6178 203a 2061 7869 730a 2020      ax : axis.  
-0001c230: 2020 2020 2020 4d61 7470 6c6f 746c 6962        Matplotlib
-0001c240: 2020 6178 6973 0a20 2020 2073 7461 7274    axis.    start
-0001c250: 5f74 696d 6520 3a20 666c 6f61 740a 2020  _time : float.  
-0001c260: 2020 2020 2020 5374 6172 7420 7469 6d65        Start time
-0001c270: 2074 6f20 706c 6f74 2072 6563 6f72 6469   to plot recordi
-0001c280: 6e67 7320 696e 2073 0a20 2020 2065 6e64  ngs in s.    end
-0001c290: 5f74 696d 6520 3a20 666c 6f61 740a 2020  _time : float.  
-0001c2a0: 2020 2020 2020 456e 6420 7469 6d65 2074        End time t
-0001c2b0: 6f20 706c 6f74 2072 6563 6f72 6469 6e67  o plot recording
-0001c2c0: 7320 696e 2073 0a20 2020 206f 7665 726c  s in s.    overl
-0001c2d0: 6179 5f74 656d 706c 6174 6573 203a 2062  ay_templates : b
-0001c2e0: 6f6f 6c0a 2020 2020 2020 2020 4966 2054  ool.        If T
-0001c2f0: 7275 652c 2074 656d 706c 6174 6573 2061  rue, templates a
-0001c300: 7265 206f 7665 726c 6169 6420 6f6e 2074  re overlaid on t
-0001c310: 6865 2072 6563 6f72 6469 6e67 730a 2020  he recordings.  
-0001c320: 2020 6e5f 7465 6d70 6c61 7465 7320 3a20    n_templates : 
-0001c330: 696e 740a 2020 2020 2020 2020 4e75 6d62  int.        Numb
-0001c340: 6572 206f 6620 7465 6d70 6c61 7465 7320  er of templates 
-0001c350: 746f 206f 7665 726c 6179 2028 6966 206f  to overlay (if o
-0001c360: 7665 726c 6179 5f74 656d 706c 6174 6573  verlay_templates
-0001c370: 2069 7320 5472 7565 290a 2020 2020 6d61   is True).    ma
-0001c380: 785f 6368 616e 6e65 6c73 5f70 6572 5f74  x_channels_per_t
-0001c390: 656d 706c 6174 6520 3a20 696e 740a 2020  emplate : int.  
-0001c3a0: 2020 2020 2020 4e75 6d62 6572 206f 6620        Number of 
-0001c3b0: 6d61 7869 6d75 6d20 6368 616e 6e65 6c73  maximum channels
-0001c3c0: 2069 6e20 7768 6963 6820 7468 6520 7465   in which the te
-0001c3d0: 6d70 6c61 7465 2069 7320 6f76 6572 6c61  mplate is overla
-0001c3e0: 6964 0a20 2020 2063 6d61 7020 3a20 6d61  id.    cmap : ma
-0001c3f0: 7470 6c6f 746c 6962 2063 6f6c 6f72 6d61  tplotlib colorma
-0001c400: 700a 2020 2020 2020 2020 436f 6c6f 726d  p.        Colorm
-0001c410: 6170 2074 6f20 6265 2075 7365 640a 2020  ap to be used.  
-0001c420: 2020 5265 7475 726e 730a 2020 2020 2d2d    Returns.    --
-0001c430: 2d2d 2d2d 2d0a 2020 2020 6178 203a 2061  -----.    ax : a
-0001c440: 7869 730a 2020 2020 2020 2020 4d61 7470  xis.        Matp
-0001c450: 6c6f 746c 6962 2061 7869 730a 2020 2020  lotlib axis.    
-0001c460: 2222 220a 2020 2020 696d 706f 7274 206d  """.    import m
-0001c470: 6174 706c 6f74 6c69 622e 7079 6c61 6220  atplotlib.pylab 
-0001c480: 6173 2070 6c74 0a0a 2020 2020 7265 636f  as plt..    reco
-0001c490: 7264 696e 6773 203d 2072 6563 6765 6e2e  rdings = recgen.
-0001c4a0: 7265 636f 7264 696e 6773 0a20 2020 206d  recordings.    m
-0001c4b0: 6561 203d 206d 752e 7265 7475 726e 5f6d  ea = mu.return_m
-0001c4c0: 6561 2869 6e66 6f3d 7265 6367 656e 2e69  ea(info=recgen.i
-0001c4d0: 6e66 6f5b 2765 6c65 6374 726f 6465 7327  nfo['electrodes'
-0001c4e0: 5d29 0a20 2020 2066 7320 3d20 7265 6367  ]).    fs = recg
-0001c4f0: 656e 2e69 6e66 6f5b 2772 6563 6f72 6469  en.info['recordi
-0001c500: 6e67 7327 5d5b 2766 7327 5d0a 2020 2020  ngs']['fs'].    
-0001c510: 6966 2061 7820 6973 204e 6f6e 653a 0a20  if ax is None:. 
-0001c520: 2020 2020 2020 2066 6967 203d 2070 6c74         fig = plt
-0001c530: 2e66 6967 7572 6528 290a 2020 2020 2020  .figure().      
-0001c540: 2020 6178 203d 2066 6967 2e61 6464 5f73    ax = fig.add_s
-0001c550: 7562 706c 6f74 2831 3131 290a 2020 2020  ubplot(111).    
-0001c560: 6966 2073 7461 7274 5f74 696d 6520 6973  if start_time is
-0001c570: 204e 6f6e 653a 0a20 2020 2020 2020 2073   None:.        s
-0001c580: 7461 7274 5f66 7261 6d65 203d 2030 0a20  tart_frame = 0. 
-0001c590: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-0001c5a0: 2073 7461 7274 5f66 7261 6d65 203d 2069   start_frame = i
-0001c5b0: 6e74 2873 7461 7274 5f74 696d 6520 2a20  nt(start_time * 
-0001c5c0: 6673 290a 2020 2020 6966 2065 6e64 5f74  fs).    if end_t
-0001c5d0: 696d 6520 6973 204e 6f6e 653a 0a20 2020  ime is None:.   
-0001c5e0: 2020 2020 2065 6e64 5f66 7261 6d65 203d       end_frame =
-0001c5f0: 2072 6563 6f72 6469 6e67 732e 7368 6170   recordings.shap
-0001c600: 655b 305d 0a20 2020 2065 6c73 653a 0a20  e[0].    else:. 
-0001c610: 2020 2020 2020 2065 6e64 5f66 7261 6d65         end_frame
-0001c620: 203d 2069 6e74 2865 6e64 5f74 696d 6520   = int(end_time 
-0001c630: 2a20 6673 290a 0a20 2020 2069 6620 6d61  * fs)..    if ma
-0001c640: 785f 6368 616e 6e65 6c73 5f70 6572 5f74  x_channels_per_t
-0001c650: 656d 706c 6174 6520 6973 204e 6f6e 653a  emplate is None:
-0001c660: 0a20 2020 2020 2020 206d 6178 5f63 6861  .        max_cha
-0001c670: 6e6e 656c 735f 7065 725f 7465 6d70 6c61  nnels_per_templa
-0001c680: 7465 203d 206c 656e 2872 6563 6f72 6469  te = len(recordi
-0001c690: 6e67 7329 0a0a 2020 2020 6966 2027 7673  ngs)..    if 'vs
-0001c6a0: 6361 6c65 2720 6e6f 7420 696e 206b 7761  cale' not in kwa
-0001c6b0: 7267 732e 6b65 7973 2829 3a0a 2020 2020  rgs.keys():.    
-0001c6c0: 2020 2020 6b77 6172 6773 5b27 7673 6361      kwargs['vsca
-0001c6d0: 6c65 275d 203d 2031 2e35 202a 206e 702e  le'] = 1.5 * np.
-0001c6e0: 6d61 7828 6e70 2e61 6273 2872 6563 6f72  max(np.abs(recor
-0001c6f0: 6469 6e67 7329 290a 0a20 2020 206d 752e  dings))..    mu.
-0001c700: 706c 6f74 5f6d 6561 5f72 6563 6f72 6469  plot_mea_recordi
-0001c710: 6e67 2872 6563 6f72 6469 6e67 735b 7374  ng(recordings[st
-0001c720: 6172 745f 6672 616d 653a 656e 645f 6672  art_frame:end_fr
-0001c730: 616d 652c 203a 5d2e 542c 206d 6561 2c20  ame, :].T, mea, 
-0001c740: 6178 3d61 782c 202a 2a6b 7761 7267 7329  ax=ax, **kwargs)
-0001c750: 0a0a 2020 2020 6966 206f 7665 726c 6179  ..    if overlay
-0001c760: 5f74 656d 706c 6174 6573 3a0a 2020 2020  _templates:.    
-0001c770: 2020 2020 6966 2027 6c77 2720 696e 206b      if 'lw' in k
-0001c780: 7761 7267 732e 6b65 7973 2829 3a0a 2020  wargs.keys():.  
-0001c790: 2020 2020 2020 2020 2020 6b77 6172 6773            kwargs
-0001c7a0: 5b27 6c77 275d 203d 2074 656d 706c 6174  ['lw'] = templat
-0001c7b0: 6573 5f6c 770a 2020 2020 2020 2020 6673  es_lw.        fs
-0001c7c0: 203d 2072 6563 6765 6e2e 696e 666f 5b27   = recgen.info['
-0001c7d0: 7265 636f 7264 696e 6773 275d 5b27 6673  recordings']['fs
-0001c7e0: 275d 202a 2070 712e 487a 0a20 2020 2020  '] * pq.Hz.     
-0001c7f0: 2020 2069 6620 6e5f 7465 6d70 6c61 7465     if n_template
-0001c800: 7320 6973 204e 6f6e 653a 0a20 2020 2020  s is None:.     
-0001c810: 2020 2020 2020 2074 656d 706c 6174 655f         template_
-0001c820: 6964 7320 3d20 6e70 2e61 7261 6e67 6528  ids = np.arange(
-0001c830: 6c65 6e28 7265 6367 656e 2e74 656d 706c  len(recgen.templ
-0001c840: 6174 6573 2929 0a20 2020 2020 2020 2065  ates)).        e
-0001c850: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
-0001c860: 2074 656d 706c 6174 655f 6964 7320 3d20   template_ids = 
-0001c870: 6e70 2e72 616e 646f 6d2e 7065 726d 7574  np.random.permut
-0001c880: 6174 696f 6e28 6c65 6e28 7265 6367 656e  ation(len(recgen
-0001c890: 2e74 656d 706c 6174 6573 2929 5b3a 6e5f  .templates))[:n_
-0001c8a0: 7465 6d70 6c61 7465 735d 0a0a 2020 2020  templates]..    
-0001c8b0: 2020 2020 6375 745f 6f75 745f 7361 6d70      cut_out_samp
-0001c8c0: 6c65 7320 3d20 5b69 6e74 2828 6320 2b20  les = [int((c + 
-0001c8d0: 7029 202a 2066 732e 7265 7363 616c 6528  p) * fs.rescale(
-0001c8e0: 276b 487a 2729 2e6d 6167 6e69 7475 6465  'kHz').magnitude
-0001c8f0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-0001c900: 2020 2020 2020 2020 2020 2020 2066 6f72               for
-0001c910: 2028 632c 2070 2920 696e 207a 6970 2872   (c, p) in zip(r
-0001c920: 6563 6765 6e2e 696e 666f 5b27 7465 6d70  ecgen.info['temp
-0001c930: 6c61 7465 7327 5d5b 2763 7574 5f6f 7574  lates']['cut_out
-0001c940: 275d 2c20 7265 6367 656e 2e69 6e66 6f5b  '], recgen.info[
-0001c950: 2774 656d 706c 6174 6573 275d 5b27 7061  'templates']['pa
-0001c960: 645f 6c65 6e27 5d29 5d0a 0a20 2020 2020  d_len'])]..     
-0001c970: 2020 2073 7069 6b65 5f69 6478 7320 3d20     spike_idxs = 
-0001c980: 5b5d 0a20 2020 2020 2020 2066 6f72 2073  [].        for s
-0001c990: 7420 696e 2072 6563 6765 6e2e 7370 696b  t in recgen.spik
-0001c9a0: 6574 7261 696e 733a 0a20 2020 2020 2020  etrains:.       
-0001c9b0: 2020 2020 2073 7069 6b65 5f69 6478 732e       spike_idxs.
-0001c9c0: 6170 7065 6e64 2828 7374 2e74 696d 6573  append((st.times
-0001c9d0: 202a 2066 7329 2e6d 6167 6e69 7475 6465   * fs).magnitude
-0001c9e0: 2e61 7374 7970 6528 2769 6e74 2729 290a  .astype('int')).
-0001c9f0: 2020 2020 2020 2020 6e5f 7361 6d70 6c65          n_sample
-0001ca00: 7320 3d20 7265 636f 7264 696e 6773 2e73  s = recordings.s
-0001ca10: 6861 7065 5b30 5d0a 0a20 2020 2020 2020  hape[0]..       
-0001ca20: 2069 6620 636d 6170 2069 7320 6e6f 7420   if cmap is not 
-0001ca30: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
-0001ca40: 2020 636d 203d 2070 6c74 2e67 6574 5f63    cm = plt.get_c
-0001ca50: 6d61 7028 636d 6170 290a 2020 2020 2020  map(cmap).      
-0001ca60: 2020 2020 2020 636f 6c6f 7273 5f74 203d        colors_t =
-0001ca70: 205b 636d 2869 202f 206c 656e 2874 656d   [cm(i / len(tem
-0001ca80: 706c 6174 655f 6964 7329 2920 666f 7220  plate_ids)) for 
-0001ca90: 6920 696e 206e 702e 6172 616e 6765 286c  i in np.arange(l
-0001caa0: 656e 2874 656d 706c 6174 655f 6964 7329  en(template_ids)
-0001cab0: 295d 0a20 2020 2020 2020 2065 6c73 653a  )].        else:
-0001cac0: 0a20 2020 2020 2020 2020 2020 2063 6f6c  .            col
-0001cad0: 6f72 735f 7420 3d20 706c 742e 7263 5061  ors_t = plt.rcPa
-0001cae0: 7261 6d73 5b27 6178 6573 2e70 726f 705f  rams['axes.prop_
-0001caf0: 6379 636c 6527 5d2e 6279 5f6b 6579 2829  cycle'].by_key()
-0001cb00: 5b27 636f 6c6f 7227 5d0a 2020 2020 2020  ['color'].      
-0001cb10: 2020 695f 636f 6c20 3d20 300a 2020 2020    i_col = 0.    
-0001cb20: 2020 2020 6966 2027 6c77 2720 6e6f 7420      if 'lw' not 
-0001cb30: 696e 206b 7761 7267 732e 6b65 7973 2829  in kwargs.keys()
-0001cb40: 3a0a 2020 2020 2020 2020 2020 2020 6b77  :.            kw
-0001cb50: 6172 6773 5b27 6c77 275d 203d 2031 0a20  args['lw'] = 1. 
-0001cb60: 2020 2020 2020 2069 6620 2763 6f6c 6f72         if 'color
-0001cb70: 7327 2069 6e20 6b77 6172 6773 2e6b 6579  s' in kwargs.key
-0001cb80: 7328 293a 0a20 2020 2020 2020 2020 2020  s():.           
-0001cb90: 2064 656c 206b 7761 7267 735b 2763 6f6c   del kwargs['col
-0001cba0: 6f72 7327 5d0a 0a20 2020 2020 2020 2023  ors']..        #
-0001cbb0: c2a0 666f 7220 692c 2028 7370 2c20 7429  ..for i, (sp, t)
-0001cbc0: 2069 6e20 656e 756d 6572 6174 6528 7a69   in enumerate(zi
-0001cbd0: 7028 7370 696b 655f 6964 7873 2c20 7265  p(spike_idxs, re
-0001cbe0: 6367 656e 2e74 656d 706c 6174 6573 2929  cgen.templates))
-0001cbf0: 3a0a 2020 2020 2020 2020 666f 7220 692c  :.        for i,
-0001cc00: 2073 7020 696e 2065 6e75 6d65 7261 7465   sp in enumerate
-0001cc10: 2873 7069 6b65 5f69 6478 7329 3a0a 2020  (spike_idxs):.  
-0001cc20: 2020 2020 2020 2020 2020 6966 2069 2069            if i i
-0001cc30: 6e20 7465 6d70 6c61 7465 5f69 6473 3a0a  n template_ids:.
-0001cc40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001cc50: 7465 6d70 6c61 7465 203d 2072 6563 6765  template = recge
-0001cc60: 6e2e 7465 6d70 6c61 7465 735b 695d 0a20  n.templates[i]. 
-0001cc70: 2020 2020 2020 2020 2020 2020 2020 200a                 .
-0001cc80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001cc90: 7370 5f66 7261 6d65 7320 3d20 7370 202a  sp_frames = sp *
-0001cca0: 2066 730a 2020 2020 2020 2020 2020 2020   fs.            
-0001ccb0: 2020 2020 0a20 2020 2020 2020 2020 2020      .           
-0001ccc0: 2020 2020 2069 6620 7265 6367 656e 2e64       if recgen.d
-0001ccd0: 7269 6674 5f6c 6973 7420 6973 204e 6f6e  rift_list is Non
-0001cce0: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-0001ccf0: 2020 2020 2020 2064 7269 6674 5f69 6478         drift_idx
-0001cd00: 7320 3d20 4e6f 6e65 0a20 2020 2020 2020  s = None.       
-0001cd10: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
-0001cd20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001cd30: 2020 2064 7269 6674 5f69 6478 7320 3d20     drift_idxs = 
-0001cd40: 636f 6d70 7574 655f 6472 6966 745f 6964  compute_drift_id
-0001cd50: 7873 5f66 726f 6d5f 6472 6966 745f 6c69  xs_from_drift_li
-0001cd60: 7374 2869 2c20 7370 5f66 7261 6d65 732c  st(i, sp_frames,
-0001cd70: 2072 6563 6765 6e2e 6472 6966 745f 6c69   recgen.drift_li
-0001cd80: 7374 2c20 6673 290a 2020 2020 2020 2020  st, fs).        
-0001cd90: 2020 2020 2020 2020 7265 635f 7420 3d20          rec_t = 
-0001cda0: 636f 6e76 6f6c 7665 5f74 656d 706c 6174  convolve_templat
-0001cdb0: 6573 5f73 7069 6b65 7472 6169 6e73 2869  es_spiketrains(i
-0001cdc0: 2c20 7370 2c0a 2020 2020 2020 2020 2020  , sp,.          
-0001cdd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001cde0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001cdf0: 2020 2020 2020 2020 2020 2020 2074 656d               tem
-0001ce00: 706c 6174 652c 206e 5f73 616d 706c 6573  plate, n_samples
-0001ce10: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-0001ce20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001ce30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001ce40: 2020 2020 2020 2020 206d 6178 5f63 6861           max_cha
-0001ce50: 6e6e 656c 735f 7065 725f 7465 6d70 6c61  nnels_per_templa
-0001ce60: 7465 3d6d 6178 5f63 6861 6e6e 656c 735f  te=max_channels_
-0001ce70: 7065 725f 7465 6d70 6c61 7465 2c0a 2020  per_template,.  
-0001ce80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001ce90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001cea0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001ceb0: 2020 2020 2063 7574 5f6f 7574 3d63 7574       cut_out=cut
-0001cec0: 5f6f 7574 5f73 616d 706c 6573 2c0a 2020  _out_samples,.  
-0001ced0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001cee0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001bb40: 2020 2020 2061 782e 706c 6f74 280a 2020       ax.plot(.  
+0001bb50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001bb60: 2020 2020 2020 2020 2020 742c 2069 202a            t, i *
+0001bb70: 206e 702e 6f6e 6573 5f6c 696b 6528 7429   np.ones_like(t)
+0001bb80: 2c20 636f 6c6f 723d 636f 6c6f 725b 695d  , color=color[i]
+0001bb90: 2c20 6d61 726b 6572 3d6d 6172 6b65 722c  , marker=marker,
+0001bba0: 206d 6577 3d6d 6577 2c20 6d61 726b 6572   mew=mew, marker
+0001bbb0: 7369 7a65 3d6d 6172 6b65 7273 697a 652c  size=markersize,
+0001bbc0: 206c 733d 2222 0a20 2020 2020 2020 2020   ls="".         
+0001bbd0: 2020 2020 2020 2020 2020 2020 2020 2029                 )
+0001bbe0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001bbf0: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+0001bc00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001bc10: 2020 2061 782e 706c 6f74 280a 2020 2020     ax.plot(.    
+0001bc20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001bc30: 2020 2020 2020 2020 742c 2069 202a 206e          t, i * n
+0001bc40: 702e 6f6e 6573 5f6c 696b 6528 7429 2c20  p.ones_like(t), 
+0001bc50: 636f 6c6f 723d 636f 6c6f 722c 206d 6172  color=color, mar
+0001bc60: 6b65 723d 6d61 726b 6572 2c20 6d65 773d  ker=marker, mew=
+0001bc70: 6d65 772c 206d 6172 6b65 7273 697a 653d  mew, markersize=
+0001bc80: 6d61 726b 6572 7369 7a65 2c20 6c73 3d22  markersize, ls="
+0001bc90: 220a 2020 2020 2020 2020 2020 2020 2020  ".              
+0001bca0: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
+0001bcb0: 2020 2020 2020 2020 2020 2020 656c 7365              else
+0001bcc0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0001bcd0: 2020 2020 2020 6178 2e70 6c6f 7428 742c        ax.plot(t,
+0001bce0: 2069 202a 206e 702e 6f6e 6573 5f6c 696b   i * np.ones_lik
+0001bcf0: 6528 7429 2c20 226b 222c 206d 6172 6b65  e(t), "k", marke
+0001bd00: 723d 6d61 726b 6572 2c20 6d65 773d 6d65  r=marker, mew=me
+0001bd10: 772c 206d 6172 6b65 7273 697a 653d 6d61  w, markersize=ma
+0001bd20: 726b 6572 7369 7a65 2c20 6c73 3d22 2229  rkersize, ls="")
+0001bd30: 0a20 2020 2020 2020 2020 2020 2065 6c69  .            eli
+0001bd40: 6620 6f76 6572 6c61 703a 0a20 2020 2020  f overlap:.     
+0001bd50: 2020 2020 2020 2020 2020 2066 6f72 206a             for j
+0001bd60: 2c20 745f 7370 2069 6e20 656e 756d 6572  , t_sp in enumer
+0001bd70: 6174 6528 7370 696b 6574 7261 696e 293a  ate(spiketrain):
+0001bd80: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001bd90: 2020 2020 2069 6620 7370 696b 6574 7261       if spiketra
+0001bda0: 696e 2e61 6e6e 6f74 6174 696f 6e73 5b22  in.annotations["
+0001bdb0: 6f76 6572 6c61 7022 5d5b 6a5d 203d 3d20  overlap"][j] == 
+0001bdc0: 2253 544f 223a 0a20 2020 2020 2020 2020  "STO":.         
+0001bdd0: 2020 2020 2020 2020 2020 2020 2020 2061                 a
+0001bde0: 782e 706c 6f74 2874 5f73 702c 2069 2c20  x.plot(t_sp, i, 
+0001bdf0: 2272 222c 206d 6172 6b65 723d 6d61 726b  "r", marker=mark
+0001be00: 6572 2c20 6d65 773d 6d65 772c 206d 6172  er, mew=mew, mar
+0001be10: 6b65 7273 697a 653d 6d61 726b 6572 7369  kersize=markersi
+0001be20: 7a65 2c20 6c73 3d22 2229 0a20 2020 2020  ze, ls="").     
+0001be30: 2020 2020 2020 2020 2020 2020 2020 2065                 e
+0001be40: 6c69 6620 7370 696b 6574 7261 696e 2e61  lif spiketrain.a
+0001be50: 6e6e 6f74 6174 696f 6e73 5b22 6f76 6572  nnotations["over
+0001be60: 6c61 7022 5d5b 6a5d 203d 3d20 2254 4f22  lap"][j] == "TO"
+0001be70: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0001be80: 2020 2020 2020 2020 2020 6178 2e70 6c6f            ax.plo
+0001be90: 7428 745f 7370 2c20 692c 2022 6722 2c20  t(t_sp, i, "g", 
+0001bea0: 6d61 726b 6572 3d6d 6172 6b65 722c 206d  marker=marker, m
+0001beb0: 6577 3d6d 6577 2c20 6d61 726b 6572 7369  ew=mew, markersi
+0001bec0: 7a65 3d6d 6172 6b65 7273 697a 652c 206c  ze=markersize, l
+0001bed0: 733d 2222 290a 2020 2020 2020 2020 2020  s="").          
+0001bee0: 2020 2020 2020 2020 2020 656c 6966 2073            elif s
+0001bef0: 7069 6b65 7472 6169 6e2e 616e 6e6f 7461  piketrain.annota
+0001bf00: 7469 6f6e 735b 226f 7665 726c 6170 225d  tions["overlap"]
+0001bf10: 5b6a 5d20 3d3d 2022 4e4f 223a 0a20 2020  [j] == "NO":.   
+0001bf20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001bf30: 2020 2020 2061 782e 706c 6f74 2874 5f73       ax.plot(t_s
+0001bf40: 702c 2069 2c20 226b 222c 206d 6172 6b65  p, i, "k", marke
+0001bf50: 723d 6d61 726b 6572 2c20 6d65 773d 6d65  r=marker, mew=me
+0001bf60: 772c 206d 6172 6b65 7273 697a 653d 6d61  w, markersize=ma
+0001bf70: 726b 6572 7369 7a65 2c20 6c73 3d22 2229  rkersize, ls="")
+0001bf80: 0a0a 2020 2020 6178 2e61 7869 7328 2274  ..    ax.axis("t
+0001bf90: 6967 6874 2229 0a20 2020 2061 782e 7365  ight").    ax.se
+0001bfa0: 745f 786c 696d 285b 7370 696b 6574 7261  t_xlim([spiketra
+0001bfb0: 696e 735b 305d 2e74 5f73 7461 7274 2e72  ins[0].t_start.r
+0001bfc0: 6573 6361 6c65 2870 712e 7329 2c20 7370  escale(pq.s), sp
+0001bfd0: 696b 6574 7261 696e 735b 305d 2e74 5f73  iketrains[0].t_s
+0001bfe0: 746f 702e 7265 7363 616c 6528 7071 2e73  top.rescale(pq.s
+0001bff0: 295d 290a 2020 2020 6178 2e73 6574 5f78  )]).    ax.set_x
+0001c000: 6c61 6265 6c28 2254 696d 6520 2873 2922  label("Time (s)"
+0001c010: 2c20 666f 6e74 7369 7a65 3d66 7329 0a20  , fontsize=fs). 
+0001c020: 2020 2061 782e 7365 745f 796c 6162 656c     ax.set_ylabel
+0001c030: 2822 5370 696b 6520 5472 6169 6e20 496e  ("Spike Train In
+0001c040: 6465 7822 2c20 666f 6e74 7369 7a65 3d66  dex", fontsize=f
+0001c050: 7329 0a20 2020 2061 782e 7365 745f 7974  s).    ax.set_yt
+0001c060: 6963 6b73 286e 702e 6172 616e 6765 286c  icks(np.arange(l
+0001c070: 656e 2873 7069 6b65 7472 6169 6e73 2929  en(spiketrains))
+0001c080: 290a 2020 2020 6178 2e73 6574 5f79 7469  ).    ax.set_yti
+0001c090: 636b 6c61 6265 6c73 286e 702e 6172 616e  cklabels(np.aran
+0001c0a0: 6765 286c 656e 2873 7069 6b65 7472 6169  ge(len(spiketrai
+0001c0b0: 6e73 2929 290a 0a20 2020 2072 6574 7572  ns)))..    retur
+0001c0c0: 6e20 6178 0a0a 0a64 6566 2070 6c6f 745f  n ax...def plot_
+0001c0d0: 7465 6d70 6c61 7465 7328 0a20 2020 2067  templates(.    g
+0001c0e0: 656e 2c0a 2020 2020 7465 6d70 6c61 7465  en,.    template
+0001c0f0: 5f69 6473 3d4e 6f6e 652c 0a20 2020 2073  _ids=None,.    s
+0001c100: 696e 676c 655f 6a69 7474 6572 3d54 7275  ingle_jitter=Tru
+0001c110: 652c 0a20 2020 2061 783d 4e6f 6e65 2c0a  e,.    ax=None,.
+0001c120: 2020 2020 7369 6e67 6c65 5f61 7865 733d      single_axes=
+0001c130: 4661 6c73 652c 0a20 2020 206d 6178 5f74  False,.    max_t
+0001c140: 656d 706c 6174 6573 3d4e 6f6e 652c 0a20  emplates=None,. 
+0001c150: 2020 2064 7269 6674 696e 673d 4661 6c73     drifting=Fals
+0001c160: 652c 0a20 2020 2063 6d61 703d 4e6f 6e65  e,.    cmap=None
+0001c170: 2c0a 2020 2020 6e63 6f6c 733d 362c 0a20  ,.    ncols=6,. 
+0001c180: 2020 202a 2a6b 7761 7267 732c 0a29 3a0a     **kwargs,.):.
+0001c190: 2020 2020 2222 220a 2020 2020 506c 6f74      """.    Plot
+0001c1a0: 2074 656d 706c 6174 6573 2e0a 0a20 2020   templates...   
+0001c1b0: 2050 6172 616d 6574 6572 730a 2020 2020   Parameters.    
+0001c1c0: 2d2d 2d2d 2d2d 2d2d 2d2d 0a20 2020 2067  ----------.    g
+0001c1d0: 656e 203a 2054 656d 706c 6174 6547 656e  en : TemplateGen
+0001c1e0: 6572 6174 6f72 206f 7220 5265 636f 7264  erator or Record
+0001c1f0: 696e 6747 656e 6572 6174 6f72 0a20 2020  ingGenerator.   
+0001c200: 2020 2020 2047 656e 6572 6174 6f72 206f       Generator o
+0001c210: 626a 6563 7420 636f 6e74 6169 6e69 6e67  bject containing
+0001c220: 2074 656d 706c 6174 6573 0a20 2020 2074   templates.    t
+0001c230: 656d 706c 6174 655f 6964 7320 3a20 696e  emplate_ids : in
+0001c240: 7420 6f72 206c 6973 740a 2020 2020 2020  t or list.      
+0001c250: 2020 5468 6520 7465 6d70 6c61 7465 2873    The template(s
+0001c260: 2920 746f 2070 6c6f 740a 2020 2020 7369  ) to plot.    si
+0001c270: 6e67 6c65 5f61 7865 7320 3a20 626f 6f6c  ngle_axes : bool
+0001c280: 0a20 2020 2020 2020 2049 6620 5472 7565  .        If True
+0001c290: 2061 6c6c 2074 656d 706c 6174 6573 2061   all templates a
+0001c2a0: 7265 2070 6c6f 7474 6564 206f 6e20 7468  re plotted on th
+0001c2b0: 6520 7361 6d65 2061 7869 730a 2020 2020  e same axis.    
+0001c2c0: 6178 203a 2061 7869 730a 2020 2020 2020  ax : axis.      
+0001c2d0: 2020 4d61 7470 6c6f 746c 6962 2020 6178    Matplotlib  ax
+0001c2e0: 6973 0a20 2020 2073 696e 676c 655f 6a69  is.    single_ji
+0001c2f0: 7474 6572 3a20 626f 6f6c 0a20 2020 2020  tter: bool.     
+0001c300: 2020 2049 6620 5472 7565 2061 6e64 206a     If True and j
+0001c310: 6974 7465 7265 6420 7465 6d70 6c61 7465  ittered template
+0001c320: 7320 6172 6520 7072 6573 656e 742c 2061  s are present, a
+0001c330: 2073 696e 676c 6520 6a69 7474 6572 6564   single jittered
+0001c340: 2074 656d 706c 6174 6520 6973 2070 6c6f   template is plo
+0001c350: 7474 6564 0a20 2020 206d 6178 5f74 656d  tted.    max_tem
+0001c360: 706c 6174 6573 3a20 696e 740a 2020 2020  plates: int.    
+0001c370: 2020 2020 4d61 7869 6d75 6d20 6e75 6d62      Maximum numb
+0001c380: 6572 206f 6620 7465 6d70 6c61 7465 7320  er of templates 
+0001c390: 746f 2062 6520 706c 6f74 7465 640a 2020  to be plotted.  
+0001c3a0: 2020 6472 6966 7469 6e67 3a20 626f 6f6c    drifting: bool
+0001c3b0: 0a20 2020 2020 2020 2049 6620 5472 7565  .        If True
+0001c3c0: 2061 6e64 2074 656d 706c 6174 6573 2061   and templates a
+0001c3d0: 7265 2064 7269 6674 696e 672c 2064 7269  re drifting, dri
+0001c3e0: 6674 696e 6720 7465 6d70 6c61 7465 7320  fting templates 
+0001c3f0: 6172 6520 6469 7370 6c61 7965 640a 2020  are displayed.  
+0001c400: 2020 636d 6170 203a 206d 6174 706c 6f74    cmap : matplot
+0001c410: 6c69 6220 636f 6c6f 726d 6170 0a20 2020  lib colormap.   
+0001c420: 2020 2020 2043 6f6c 6f72 6d61 7020 746f       Colormap to
+0001c430: 2062 6520 7573 6564 0a20 2020 206e 636f   be used.    nco
+0001c440: 6c73 203a 2020 696e 740a 2020 2020 2020  ls :  int.      
+0001c450: 2020 4e75 6d62 6572 206f 6620 636f 6c75    Number of colu
+0001c460: 6d6e 7320 666f 7220 7375 6270 6c6f 7473  mns for subplots
+0001c470: 0a0a 2020 2020 5265 7475 726e 730a 2020  ..    Returns.  
+0001c480: 2020 2d2d 2d2d 2d2d 2d0a 2020 2020 6178    -------.    ax
+0001c490: 203a 2061 780a 2020 2020 2020 2020 4d61   : ax.        Ma
+0001c4a0: 7470 6c6f 746c 6962 2061 7865 730a 0a20  tplotlib axes.. 
+0001c4b0: 2020 2022 2222 0a20 2020 2069 6d70 6f72     """.    impor
+0001c4c0: 7420 6d61 7470 6c6f 746c 6962 2e70 796c  t matplotlib.pyl
+0001c4d0: 6162 2061 7320 706c 740a 2020 2020 6672  ab as plt.    fr
+0001c4e0: 6f6d 206d 6174 706c 6f74 6c69 6220 696d  om matplotlib im
+0001c4f0: 706f 7274 2067 7269 6473 7065 630a 0a20  port gridspec.. 
+0001c500: 2020 2074 656d 706c 6174 6573 203d 2067     templates = g
+0001c510: 656e 2e74 656d 706c 6174 6573 0a20 2020  en.templates.   
+0001c520: 206d 6561 203d 206d 752e 7265 7475 726e   mea = mu.return
+0001c530: 5f6d 6561 2869 6e66 6f3d 6765 6e2e 696e  _mea(info=gen.in
+0001c540: 666f 5b22 656c 6563 7472 6f64 6573 225d  fo["electrodes"]
+0001c550: 290a 0a20 2020 2069 6620 2270 6172 616d  )..    if "param
+0001c560: 7322 2069 6e20 6765 6e2e 696e 666f 2e6b  s" in gen.info.k
+0001c570: 6579 7328 293a 0a20 2020 2020 2020 2069  eys():.        i
+0001c580: 6620 6765 6e2e 696e 666f 5b22 7061 7261  f gen.info["para
+0001c590: 6d73 225d 5b22 6472 6966 7469 6e67 225d  ms"]["drifting"]
+0001c5a0: 3a0a 2020 2020 2020 2020 2020 2020 6966  :.            if
+0001c5b0: 206e 6f74 2064 7269 6674 696e 673a 0a20   not drifting:. 
+0001c5c0: 2020 2020 2020 2020 2020 2020 2020 2074                 t
+0001c5d0: 656d 706c 6174 6573 203d 2074 656d 706c  emplates = templ
+0001c5e0: 6174 6573 5b3a 2c20 305d 0a20 2020 2069  ates[:, 0].    i
+0001c5f0: 6620 2272 6563 6f72 6469 6e67 7322 2069  f "recordings" i
+0001c600: 6e20 6765 6e2e 696e 666f 2e6b 6579 7328  n gen.info.keys(
+0001c610: 293a 0a20 2020 2020 2020 2069 6620 6765  ):.        if ge
+0001c620: 6e2e 696e 666f 5b22 7265 636f 7264 696e  n.info["recordin
+0001c630: 6773 225d 5b22 6472 6966 7469 6e67 225d  gs"]["drifting"]
+0001c640: 3a0a 2020 2020 2020 2020 2020 2020 6966  :.            if
+0001c650: 2073 696e 676c 655f 6a69 7474 6572 3a0a   single_jitter:.
+0001c660: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c670: 6966 206e 6f74 2064 7269 6674 696e 673a  if not drifting:
+0001c680: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001c690: 2020 2020 2069 6620 6c65 6e28 7465 6d70       if len(temp
+0001c6a0: 6c61 7465 732e 7368 6170 6529 203d 3d20  lates.shape) == 
+0001c6b0: 353a 0a20 2020 2020 2020 2020 2020 2020  5:.             
+0001c6c0: 2020 2020 2020 2020 2020 2074 656d 706c             templ
+0001c6d0: 6174 6573 203d 2074 656d 706c 6174 6573  ates = templates
+0001c6e0: 5b3a 2c20 302c 2030 5d0a 2020 2020 2020  [:, 0, 0].      
+0001c6f0: 2020 2020 2020 2020 2020 2020 2020 656c                el
+0001c700: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+0001c710: 2020 2020 2020 2020 2020 2020 7465 6d70              temp
+0001c720: 6c61 7465 7320 3d20 7465 6d70 6c61 7465  lates = template
+0001c730: 735b 3a2c 2030 5d0a 2020 2020 2020 2020  s[:, 0].        
+0001c740: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+0001c750: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c760: 2020 6966 206c 656e 2874 656d 706c 6174    if len(templat
+0001c770: 6573 2e73 6861 7065 2920 3d3d 2035 3a0a  es.shape) == 5:.
+0001c780: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c790: 2020 2020 2020 2020 7465 6d70 6c61 7465          template
+0001c7a0: 7320 3d20 7465 6d70 6c61 7465 735b 3a2c  s = templates[:,
+0001c7b0: 203a 2c20 305d 0a20 2020 2020 2020 2020   :, 0].         
+0001c7c0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+0001c7d0: 2020 2020 2020 2020 2069 6620 6e6f 7420           if not 
+0001c7e0: 6472 6966 7469 6e67 3a0a 2020 2020 2020  drifting:.      
+0001c7f0: 2020 2020 2020 2020 2020 2020 2020 6966                if
+0001c800: 206c 656e 2874 656d 706c 6174 6573 2e73   len(templates.s
+0001c810: 6861 7065 2920 3d3d 2035 3a0a 2020 2020  hape) == 5:.    
+0001c820: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c830: 2020 2020 7465 6d70 6c61 7465 7320 3d20      templates = 
+0001c840: 7465 6d70 6c61 7465 735b 3a2c 2030 5d0a  templates[:, 0].
+0001c850: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+0001c860: 2020 2020 2020 2020 2020 6966 2073 696e            if sin
+0001c870: 676c 655f 6a69 7474 6572 3a0a 2020 2020  gle_jitter:.    
+0001c880: 2020 2020 2020 2020 2020 2020 6966 206c              if l
+0001c890: 656e 2874 656d 706c 6174 6573 2e73 6861  en(templates.sha
+0001c8a0: 7065 2920 3d3d 2034 3a0a 2020 2020 2020  pe) == 4:.      
+0001c8b0: 2020 2020 2020 2020 2020 2020 2020 7465                te
+0001c8c0: 6d70 6c61 7465 7320 3d20 7465 6d70 6c61  mplates = templa
+0001c8d0: 7465 735b 3a2c 2030 5d0a 0a20 2020 2069  tes[:, 0]..    i
+0001c8e0: 6620 6472 6966 7469 6e67 3a0a 2020 2020  f drifting:.    
+0001c8f0: 2020 2020 6173 7365 7274 2069 7369 6e73      assert isins
+0001c900: 7461 6e63 6528 7465 6d70 6c61 7465 5f69  tance(template_i
+0001c910: 6473 2c20 2869 6e74 2c20 6e70 2e69 6e74  ds, (int, np.int
+0001c920: 6567 6572 2929 2c20 280a 2020 2020 2020  eger)), (.      
+0001c930: 2020 2020 2020 2257 6865 6e20 706c 6f74        "When plot
+0001c940: 7469 6e67 2064 7269 6674 696e 6720 7465  ting drifting te
+0001c950: 6d70 6c61 7465 732c 2027 7465 6d70 6c61  mplates, 'templa
+0001c960: 7465 5f69 6473 2720 7368 6f75 6c64 2022  te_ids' should "
+0001c970: 2022 6265 2061 2073 696e 676c 6520 696e   "be a single in
+0001c980: 6465 7820 2869 6e74 2922 0a20 2020 2020  dex (int)".     
+0001c990: 2020 2029 0a20 2020 2020 2020 2073 696e     ).        sin
+0001c9a0: 676c 655f 6178 6573 203d 2054 7275 650a  gle_axes = True.
+0001c9b0: 0a20 2020 2069 6620 7465 6d70 6c61 7465  .    if template
+0001c9c0: 5f69 6473 2069 7320 6e6f 7420 4e6f 6e65  _ids is not None
+0001c9d0: 3a0a 2020 2020 2020 2020 6966 2069 7369  :.        if isi
+0001c9e0: 6e73 7461 6e63 6528 7465 6d70 6c61 7465  nstance(template
+0001c9f0: 5f69 6473 2c20 2869 6e74 2c20 6e70 2e69  _ids, (int, np.i
+0001ca00: 6e74 6567 6572 2929 3a0a 2020 2020 2020  nteger)):.      
+0001ca10: 2020 2020 2020 7465 6d70 6c61 7465 5f69        template_i
+0001ca20: 6473 203d 206c 6973 7428 6e70 2e61 7272  ds = list(np.arr
+0001ca30: 6179 285b 7465 6d70 6c61 7465 5f69 6473  ay([template_ids
+0001ca40: 5d29 290a 2020 2020 2020 2020 656c 6966  ])).        elif
+0001ca50: 2069 7369 6e73 7461 6e63 6528 7465 6d70   isinstance(temp
+0001ca60: 6c61 7465 5f69 6473 2c20 6c69 7374 293a  late_ids, list):
+0001ca70: 0a20 2020 2020 2020 2020 2020 2074 656d  .            tem
+0001ca80: 706c 6174 655f 6964 7320 3d20 6c69 7374  plate_ids = list
+0001ca90: 286e 702e 6172 7261 7928 7465 6d70 6c61  (np.array(templa
+0001caa0: 7465 5f69 6473 2929 0a20 2020 2065 6c73  te_ids)).    els
+0001cab0: 653a 0a20 2020 2020 2020 2074 656d 706c  e:.        templ
+0001cac0: 6174 655f 6964 7320 3d20 6c69 7374 286e  ate_ids = list(n
+0001cad0: 702e 6172 616e 6765 2874 656d 706c 6174  p.arange(templat
+0001cae0: 6573 2e73 6861 7065 5b30 5d29 290a 0a20  es.shape[0])).. 
+0001caf0: 2020 2069 6620 6d61 785f 7465 6d70 6c61     if max_templa
+0001cb00: 7465 7320 6973 206e 6f74 204e 6f6e 653a  tes is not None:
+0001cb10: 0a20 2020 2020 2020 2069 6620 6d61 785f  .        if max_
+0001cb20: 7465 6d70 6c61 7465 7320 3c20 6c65 6e28  templates < len(
+0001cb30: 7465 6d70 6c61 7465 7329 3a0a 2020 2020  templates):.    
+0001cb40: 2020 2020 2020 2020 7261 6e64 6f6d 5f69          random_i
+0001cb50: 6478 7320 3d20 6e70 2e72 616e 646f 6d2e  dxs = np.random.
+0001cb60: 7065 726d 7574 6174 696f 6e28 6c65 6e28  permutation(len(
+0001cb70: 7465 6d70 6c61 7465 7329 290a 2020 2020  templates)).    
+0001cb80: 2020 2020 2020 2020 7465 6d70 6c61 7465          template
+0001cb90: 5f69 6473 203d 206e 702e 6172 616e 6765  _ids = np.arange
+0001cba0: 2874 656d 706c 6174 6573 2e73 6861 7065  (templates.shape
+0001cbb0: 5b30 5d29 5b72 616e 646f 6d5f 6964 7873  [0])[random_idxs
+0001cbc0: 5d5b 3a6d 6178 5f74 656d 706c 6174 6573  ][:max_templates
+0001cbd0: 5d0a 2020 2020 2020 2020 2020 2020 2320  ].            # 
+0001cbe0: 7465 6d70 6c61 7465 7320 3d20 7465 6d70  templates = temp
+0001cbf0: 6c61 7465 735b 7261 6e64 6f6d 5f69 6478  lates[random_idx
+0001cc00: 735d 5b3a 6d61 785f 7465 6d70 6c61 7465  s][:max_template
+0001cc10: 735d 0a0a 2020 2020 6e5f 736f 7572 6365  s]..    n_source
+0001cc20: 7320 3d20 6c65 6e28 7465 6d70 6c61 7465  s = len(template
+0001cc30: 5f69 6473 290a 2020 2020 6966 2061 7820  _ids).    if ax 
+0001cc40: 6973 204e 6f6e 653a 0a20 2020 2020 2020  is None:.       
+0001cc50: 2066 6967 203d 2070 6c74 2e66 6967 7572   fig = plt.figur
+0001cc60: 6528 290a 2020 2020 2020 2020 6178 203d  e().        ax =
+0001cc70: 2066 6967 2e61 6464 5f73 7562 706c 6f74   fig.add_subplot
+0001cc80: 2831 3131 290a 2020 2020 656c 7365 3a0a  (111).    else:.
+0001cc90: 2020 2020 2020 2020 6669 6720 3d20 6178          fig = ax
+0001cca0: 2e67 6574 5f66 6967 7572 6528 290a 0a20  .get_figure().. 
+0001ccb0: 2020 2069 6620 2276 7363 616c 6522 206e     if "vscale" n
+0001ccc0: 6f74 2069 6e20 6b77 6172 6773 2e6b 6579  ot in kwargs.key
+0001ccd0: 7328 293a 0a20 2020 2020 2020 206b 7761  s():.        kwa
+0001cce0: 7267 735b 2276 7363 616c 6522 5d20 3d20  rgs["vscale"] = 
+0001ccf0: 312e 3520 2a20 6e70 2e6d 6178 286e 702e  1.5 * np.max(np.
+0001cd00: 6162 7328 7465 6d70 6c61 7465 735b 7465  abs(templates[te
+0001cd10: 6d70 6c61 7465 5f69 6473 5d29 290a 0a20  mplate_ids])).. 
+0001cd20: 2020 2069 6620 7369 6e67 6c65 5f61 7865     if single_axe
+0001cd30: 733a 0a20 2020 2020 2020 2069 6620 636d  s:.        if cm
+0001cd40: 6170 2069 7320 6e6f 7420 4e6f 6e65 3a0a  ap is not None:.
+0001cd50: 2020 2020 2020 2020 2020 2020 636d 203d              cm =
+0001cd60: 2070 6c74 2e67 6574 5f63 6d61 7028 636d   plt.get_cmap(cm
+0001cd70: 6170 290a 2020 2020 2020 2020 2020 2020  ap).            
+0001cd80: 636f 6c6f 7273 203d 205b 636d 2869 202f  colors = [cm(i /
+0001cd90: 206c 656e 2874 656d 706c 6174 655f 6964   len(template_id
+0001cda0: 7329 2920 666f 7220 6920 696e 206e 702e  s)) for i in np.
+0001cdb0: 6172 616e 6765 286c 656e 2874 656d 706c  arange(len(templ
+0001cdc0: 6174 655f 6964 7329 295d 0a20 2020 2020  ate_ids))].     
+0001cdd0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+0001cde0: 2020 2020 2063 6f6c 6f72 7320 3d20 706c       colors = pl
+0001cdf0: 742e 7263 5061 7261 6d73 5b22 6178 6573  t.rcParams["axes
+0001ce00: 2e70 726f 705f 6379 636c 6522 5d2e 6279  .prop_cycle"].by
+0001ce10: 5f6b 6579 2829 5b22 636f 6c6f 7222 5d0a  _key()["color"].
+0001ce20: 0a20 2020 2020 2020 2066 6f72 206e 2c20  .        for n, 
+0001ce30: 7420 696e 2065 6e75 6d65 7261 7465 2874  t in enumerate(t
+0001ce40: 656d 706c 6174 6573 293a 0a20 2020 2020  emplates):.     
+0001ce50: 2020 2020 2020 2069 6620 6e20 696e 2074         if n in t
+0001ce60: 656d 706c 6174 655f 6964 733a 0a20 2020  emplate_ids:.   
+0001ce70: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+0001ce80: 6c65 6e28 742e 7368 6170 6529 203d 3d20  len(t.shape) == 
+0001ce90: 333a 0a20 2020 2020 2020 2020 2020 2020  3:.             
+0001cea0: 2020 2020 2020 2069 6620 6e6f 7420 6472         if not dr
+0001ceb0: 6966 7469 6e67 3a0a 2020 2020 2020 2020  ifting:.        
+0001cec0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001ced0: 6d75 2e70 6c6f 745f 6d65 615f 7265 636f  mu.plot_mea_reco
+0001cee0: 7264 696e 6728 0a20 2020 2020 2020 2020  rding(.         
 0001cef0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001cf00: 2020 2020 2064 7269 6674 5f69 6478 733d       drift_idxs=
-0001cf10: 6472 6966 745f 6964 7873 2c0a 2020 2020  drift_idxs,.    
-0001cf20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001cf30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001cf40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001cf50: 2020 2029 2e54 0a0a 2020 2020 2020 2020     ).T..        
-0001cf60: 2020 2020 2020 2020 7265 635f 745b 6e70          rec_t[np
-0001cf70: 2e61 6273 2872 6563 5f74 2920 3c20 3165  .abs(rec_t) < 1e
-0001cf80: 2d34 5d20 3d20 6e70 2e6e 616e 0a20 2020  -4] = np.nan.   
-0001cf90: 2020 2020 2020 2020 2020 2020 206d 752e               mu.
-0001cfa0: 706c 6f74 5f6d 6561 5f72 6563 6f72 6469  plot_mea_recordi
-0001cfb0: 6e67 2872 6563 5f74 5b3a 2c20 7374 6172  ng(rec_t[:, star
-0001cfc0: 745f 6672 616d 653a 656e 645f 6672 616d  t_frame:end_fram
-0001cfd0: 655d 2c20 6d65 612c 2061 783d 6178 2c0a  e], mea, ax=ax,.
-0001cfe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001cff0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001d000: 2020 2020 2020 636f 6c6f 7273 3d63 6f6c        colors=col
-0001d010: 6f72 735f 745b 6e70 2e6d 6f64 2869 5f63  ors_t[np.mod(i_c
-0001d020: 6f6c 2c20 6c65 6e28 636f 6c6f 7273 5f74  ol, len(colors_t
-0001d030: 2929 5d2c 202a 2a6b 7761 7267 7329 0a20  ))], **kwargs). 
-0001d040: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-0001d050: 5f63 6f6c 202b 3d20 310a 2020 2020 2020  _col += 1.      
-0001d060: 2020 2020 2020 2020 2020 6465 6c20 7265            del re
-0001d070: 635f 740a 2020 2020 7265 7475 726e 2061  c_t.    return a
-0001d080: 780a 0a0a 6465 6620 706c 6f74 5f77 6176  x...def plot_wav
-0001d090: 6566 6f72 6d73 2872 6563 6765 6e2c 2073  eforms(recgen, s
-0001d0a0: 7069 6b65 7472 6169 6e5f 6964 3d4e 6f6e  piketrain_id=Non
-0001d0b0: 652c 2061 783d 4e6f 6e65 2c20 636f 6c6f  e, ax=None, colo
-0001d0c0: 723d 4e6f 6e65 2c20 636d 6170 3d4e 6f6e  r=None, cmap=Non
-0001d0d0: 652c 2065 6c65 6374 726f 6465 3d4e 6f6e  e, electrode=Non
-0001d0e0: 652c 0a20 2020 2020 2020 2020 2020 2020  e,.             
-0001d0f0: 2020 2020 2020 6d61 785f 7761 7665 666f        max_wavefo
-0001d100: 726d 733d 4e6f 6e65 2c20 6e63 6f6c 733d  rms=None, ncols=
-0001d110: 362c 2063 7574 5f6f 7574 3d32 293a 0a20  6, cut_out=2):. 
-0001d120: 2020 2022 2222 0a20 2020 2050 6c6f 7420     """.    Plot 
-0001d130: 7761 7665 666f 726d 7320 6f66 2061 2073  waveforms of a s
-0001d140: 7069 6b65 2074 7261 696e 2e0a 0a20 2020  pike train...   
-0001d150: 2050 6172 616d 6574 6572 730a 2020 2020   Parameters.    
-0001d160: 2d2d 2d2d 2d2d 2d2d 2d2d 0a20 2020 2072  ----------.    r
-0001d170: 6563 6765 6e20 3a20 5265 636f 7264 696e  ecgen : Recordin
-0001d180: 6747 656e 6572 6174 6f72 0a20 2020 2020  gGenerator.     
-0001d190: 2020 2052 6563 6f72 6469 6e67 2067 656e     Recording gen
-0001d1a0: 6572 6174 6f72 206f 626a 6563 7420 746f  erator object to
-0001d1b0: 2070 6c6f 7420 7370 696b 6520 7472 6169   plot spike trai
-0001d1c0: 6e20 7761 7665 666f 726d 2066 726f 6d0a  n waveform from.
-0001d1d0: 2020 2020 7370 696b 6574 7261 696e 5f69      spiketrain_i
-0001d1e0: 6420 3a20 696e 7420 6f72 206c 6973 740a  d : int or list.
-0001d1f0: 2020 2020 2020 2020 496e 6465 7865 7320          Indexes 
-0001d200: 6f66 2073 7069 6b65 2074 7261 696e 730a  of spike trains.
-0001d210: 2020 2020 6178 203a 2061 7869 730a 2020      ax : axis.  
-0001d220: 2020 2020 2020 4d61 7470 6c6f 746c 6962        Matplotlib
-0001d230: 2020 6178 6973 0a20 2020 2063 6f6c 6f72    axis.    color
-0001d240: 203a 206d 6174 706c 6f74 6c69 6220 636f   : matplotlib co
-0001d250: 6c6f 720a 2020 2020 2020 2020 436f 6c6f  lor.        Colo
-0001d260: 7220 6f66 2074 6865 2077 6176 6566 6f72  r of the wavefor
-0001d270: 6d73 0a20 2020 2063 6d61 7020 3a20 6d61  ms.    cmap : ma
-0001d280: 7470 6c6f 746c 6962 2063 6f6c 6f72 6d61  tplotlib colorma
-0001d290: 700a 2020 2020 2020 2020 436f 6c6f 726d  p.        Colorm
-0001d2a0: 6170 2074 6f20 6265 2075 7365 640a 2020  ap to be used.  
-0001d2b0: 2020 656c 6563 7472 6f64 6520 3a20 696e    electrode : in
-0001d2c0: 7420 6f72 2027 6d61 7827 0a20 2020 2020  t or 'max'.     
-0001d2d0: 2020 2045 6c65 6374 726f 6465 2069 6420     Electrode id 
-0001d2e0: 6f72 2027 6d61 7827 0a20 2020 206e 636f  or 'max'.    nco
-0001d2f0: 6c73 203a 2020 696e 740a 2020 2020 2020  ls :  int.      
-0001d300: 2020 4e75 6d62 6572 206f 6620 636f 6c75    Number of colu
-0001d310: 6d6e 7320 666f 7220 7375 6270 6c6f 7473  mns for subplots
-0001d320: 0a20 2020 2063 7574 5f6f 7574 203a 2066  .    cut_out : f
-0001d330: 6c6f 6174 206f 7220 6c69 7374 0a20 2020  loat or list.   
-0001d340: 2020 2020 2043 7574 206f 7574 7320 696e       Cut outs in
-0001d350: 206d 7320 666f 7220 7761 7665 666f 726d   ms for waveform
-0001d360: 7320 2869 6620 6e6f 7420 636f 6d70 7574  s (if not comput
-0001d370: 6564 292e 2049 6620 666c 6f61 7420 7468  ed). If float th
-0001d380: 6520 6375 7420 6f75 7420 6973 2073 796d  e cut out is sym
-0001d390: 6d65 7472 6963 616c 2e0a 0a20 2020 2052  metrical...    R
-0001d3a0: 6574 7572 6e73 0a20 2020 202d 2d2d 2d2d  eturns.    -----
-0001d3b0: 2d2d 0a20 2020 2061 7820 3a20 6178 6973  --.    ax : axis
-0001d3c0: 0a20 2020 2020 2020 204d 6174 706c 6f74  .        Matplot
-0001d3d0: 6c69 6220 6178 6973 0a0a 2020 2020 2222  lib axis..    ""
-0001d3e0: 220a 2020 2020 696d 706f 7274 206d 6174  ".    import mat
-0001d3f0: 706c 6f74 6c69 622e 7079 6c61 6220 6173  plotlib.pylab as
-0001d400: 2070 6c74 0a20 2020 2069 6d70 6f72 7420   plt.    import 
-0001d410: 6d61 7470 6c6f 746c 6962 2e67 7269 6473  matplotlib.grids
-0001d420: 7065 6320 6173 2067 7269 6473 7065 630a  pec as gridspec.
-0001d430: 0a20 2020 2069 6620 7370 696b 6574 7261  .    if spiketra
-0001d440: 696e 5f69 6420 6973 204e 6f6e 653a 0a20  in_id is None:. 
-0001d450: 2020 2020 2020 2073 7069 6b65 7472 6169         spiketrai
-0001d460: 6e5f 6964 203d 206e 702e 6172 616e 6765  n_id = np.arange
-0001d470: 286c 656e 2872 6563 6765 6e2e 7370 696b  (len(recgen.spik
-0001d480: 6574 7261 696e 7329 290a 2020 2020 656c  etrains)).    el
-0001d490: 6966 2069 7369 6e73 7461 6e63 6528 7370  if isinstance(sp
-0001d4a0: 696b 6574 7261 696e 5f69 642c 2028 696e  iketrain_id, (in
-0001d4b0: 742c 206e 702e 696e 7465 6765 7229 293a  t, np.integer)):
-0001d4c0: 0a20 2020 2020 2020 2073 7069 6b65 7472  .        spiketr
-0001d4d0: 6169 6e5f 6964 203d 205b 7370 696b 6574  ain_id = [spiket
-0001d4e0: 7261 696e 5f69 645d 0a0a 2020 2020 6e5f  rain_id]..    n_
-0001d4f0: 756e 6974 7320 3d20 6c65 6e28 7370 696b  units = len(spik
-0001d500: 6574 7261 696e 5f69 6429 0a0a 2020 2020  etrain_id)..    
-0001d510: 7761 7665 666f 726d 7320 3d20 5b5d 0a20  waveforms = []. 
-0001d520: 2020 2066 6f72 2073 7020 696e 2073 7069     for sp in spi
-0001d530: 6b65 7472 6169 6e5f 6964 3a0a 2020 2020  ketrain_id:.    
-0001d540: 2020 2020 7766 203d 2072 6563 6765 6e2e      wf = recgen.
-0001d550: 7370 696b 6574 7261 696e 735b 7370 5d2e  spiketrains[sp].
-0001d560: 7761 7665 666f 726d 730a 2020 2020 2020  waveforms.      
-0001d570: 2020 6966 2077 6620 6973 204e 6f6e 653a    if wf is None:
-0001d580: 0a20 2020 2020 2020 2020 2020 2066 7320  .            fs 
-0001d590: 3d20 7265 6367 656e 2e69 6e66 6f5b 2772  = recgen.info['r
-0001d5a0: 6563 6f72 6469 6e67 7327 5d5b 2766 7327  ecordings']['fs'
-0001d5b0: 5d20 2a20 7071 2e48 7a0a 2020 2020 2020  ] * pq.Hz.      
-0001d5c0: 2020 2020 2020 6578 7472 6163 745f 7766        extract_wf
-0001d5d0: 285b 7265 6367 656e 2e73 7069 6b65 7472  ([recgen.spiketr
-0001d5e0: 6169 6e73 5b73 705d 5d2c 2072 6563 6765  ains[sp]], recge
-0001d5f0: 6e2e 7265 636f 7264 696e 6773 2c20 6673  n.recordings, fs
-0001d600: 2c20 6375 745f 6f75 743d 6375 745f 6f75  , cut_out=cut_ou
-0001d610: 7429 0a20 2020 2020 2020 2020 2020 2077  t).            w
-0001d620: 6620 3d20 7265 6367 656e 2e73 7069 6b65  f = recgen.spike
-0001d630: 7472 6169 6e73 5b73 705d 2e77 6176 6566  trains[sp].wavef
-0001d640: 6f72 6d73 0a20 2020 2020 2020 2077 6176  orms.        wav
-0001d650: 6566 6f72 6d73 2e61 7070 656e 6428 7766  eforms.append(wf
-0001d660: 290a 0a20 2020 206d 6561 203d 206d 752e  )..    mea = mu.
-0001d670: 7265 7475 726e 5f6d 6561 2869 6e66 6f3d  return_mea(info=
-0001d680: 7265 6367 656e 2e69 6e66 6f5b 2765 6c65  recgen.info['ele
-0001d690: 6374 726f 6465 7327 5d29 0a20 2020 2069  ctrodes']).    i
-0001d6a0: 6620 6d61 785f 7761 7665 666f 726d 7320  f max_waveforms 
-0001d6b0: 6973 206e 6f74 204e 6f6e 653a 0a20 2020  is not None:.   
-0001d6c0: 2020 2020 2066 6f72 2069 2c20 7766 2069       for i, wf i
-0001d6d0: 6e20 656e 756d 6572 6174 6528 7761 7665  n enumerate(wave
-0001d6e0: 666f 726d 7329 3a0a 2020 2020 2020 2020  forms):.        
-0001d6f0: 2020 2020 6966 206c 656e 2877 6629 203e      if len(wf) >
-0001d700: 206d 6178 5f77 6176 6566 6f72 6d73 3a0a   max_waveforms:.
-0001d710: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001d720: 7761 7665 666f 726d 735b 695d 203d 2077  waveforms[i] = w
-0001d730: 665b 6e70 2e72 616e 646f 6d2e 7065 726d  f[np.random.perm
-0001d740: 7574 6174 696f 6e28 6c65 6e28 7766 2929  utation(len(wf))
-0001d750: 5d5b 3a6d 6178 5f77 6176 6566 6f72 6d73  ][:max_waveforms
-0001d760: 5d0a 0a20 2020 2069 6620 6e5f 756e 6974  ]..    if n_unit
-0001d770: 7320 3e20 313a 0a20 2020 2020 2020 2069  s > 1:.        i
-0001d780: 6620 636f 6c6f 7220 6973 204e 6f6e 653a  f color is None:
-0001d790: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-0001d7a0: 636d 6170 2069 7320 6e6f 7420 4e6f 6e65  cmap is not None
-0001d7b0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0001d7c0: 2020 636d 203d 2070 6c74 2e67 6574 5f63    cm = plt.get_c
-0001d7d0: 6d61 7028 636d 6170 290a 2020 2020 2020  map(cmap).      
-0001d7e0: 2020 2020 2020 2020 2020 636f 6c6f 7273            colors
-0001d7f0: 203d 205b 636d 2869 202f 206e 5f75 6e69   = [cm(i / n_uni
-0001d800: 7473 2920 666f 7220 6920 696e 206e 702e  ts) for i in np.
-0001d810: 6172 616e 6765 286e 5f75 6e69 7473 295d  arange(n_units)]
-0001d820: 0a20 2020 2020 2020 2020 2020 2065 6c73  .            els
-0001d830: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-0001d840: 2020 2063 6f6c 6f72 7320 3d20 706c 742e     colors = plt.
-0001d850: 7263 5061 7261 6d73 5b27 6178 6573 2e70  rcParams['axes.p
-0001d860: 726f 705f 6379 636c 6527 5d2e 6279 5f6b  rop_cycle'].by_k
-0001d870: 6579 2829 5b27 636f 6c6f 7227 5d0a 2020  ey()['color'].  
-0001d880: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
-0001d890: 2020 2020 2020 2020 636f 6c6f 7273 203d          colors =
-0001d8a0: 205b 636f 6c6f 725d 202a 206e 5f75 6e69   [color] * n_uni
-0001d8b0: 7473 0a20 2020 2065 6c73 653a 0a20 2020  ts.    else:.   
-0001d8c0: 2020 2020 2063 6f6c 6f72 7320 3d20 276b       colors = 'k
-0001d8d0: 270a 0a20 2020 2069 6620 6178 2069 7320  '..    if ax is 
-0001d8e0: 4e6f 6e65 3a0a 2020 2020 2020 2020 6669  None:.        fi
-0001d8f0: 6720 3d20 706c 742e 6669 6775 7265 2829  g = plt.figure()
-0001d900: 0a20 2020 2020 2020 2061 7820 3d20 6669  .        ax = fi
-0001d910: 672e 6164 645f 7375 6270 6c6f 7428 3131  g.add_subplot(11
-0001d920: 3129 0a20 2020 2065 6c73 653a 0a20 2020  1).    else:.   
-0001d930: 2020 2020 2066 6967 203d 2061 782e 6765       fig = ax.ge
-0001d940: 745f 6669 6775 7265 2829 0a0a 2020 2020  t_figure()..    
-0001d950: 6966 2065 6c65 6374 726f 6465 2069 7320  if electrode is 
-0001d960: 4e6f 6e65 3a0a 2020 2020 2020 2020 6966  None:.        if
-0001d970: 206e 5f75 6e69 7473 203e 206e 636f 6c73   n_units > ncols
-0001d980: 3a0a 2020 2020 2020 2020 2020 2020 6e72  :.            nr
-0001d990: 6f77 7320 3d20 696e 7428 6e70 2e63 6569  ows = int(np.cei
-0001d9a0: 6c28 6e5f 756e 6974 7320 2f20 6e63 6f6c  l(n_units / ncol
-0001d9b0: 7329 290a 2020 2020 2020 2020 656c 7365  s)).        else
-0001d9c0: 3a0a 2020 2020 2020 2020 2020 2020 6e72  :.            nr
-0001d9d0: 6f77 7320 3d20 310a 2020 2020 2020 2020  ows = 1.        
-0001d9e0: 2020 2020 6e63 6f6c 7320 3d20 6e5f 756e      ncols = n_un
-0001d9f0: 6974 730a 0a20 2020 2020 2020 2067 7320  its..        gs 
-0001da00: 3d20 6772 6964 7370 6563 2e47 7269 6453  = gridspec.GridS
-0001da10: 7065 6346 726f 6d53 7562 706c 6f74 5370  pecFromSubplotSp
-0001da20: 6563 286e 726f 7773 2c20 6e63 6f6c 732c  ec(nrows, ncols,
-0001da30: 2073 7562 706c 6f74 5f73 7065 633d 6178   subplot_spec=ax
-0001da40: 290a 0a20 2020 2020 2020 2066 6f72 2069  )..        for i
-0001da50: 2c20 7766 2069 6e20 656e 756d 6572 6174  , wf in enumerat
-0001da60: 6528 7761 7665 666f 726d 7329 3a0a 2020  e(waveforms):.  
-0001da70: 2020 2020 2020 2020 2020 7220 3d20 6920            r = i 
-0001da80: 2f2f 206e 636f 6c73 0a20 2020 2020 2020  // ncols.       
-0001da90: 2020 2020 2063 203d 206e 702e 6d6f 6428       c = np.mod(
-0001daa0: 692c 206e 636f 6c73 290a 2020 2020 2020  i, ncols).      
-0001dab0: 2020 2020 2020 6773 5f73 656c 203d 2067        gs_sel = g
-0001dac0: 735b 722c 2063 5d0a 2020 2020 2020 2020  s[r, c].        
-0001dad0: 2020 2020 6178 5f74 203d 2066 6967 2e61      ax_t = fig.a
-0001dae0: 6464 5f73 7562 706c 6f74 2867 735f 7365  dd_subplot(gs_se
-0001daf0: 6c29 0a20 2020 2020 2020 2020 2020 2076  l).            v
-0001db00: 7363 616c 6520 3d20 312e 3520 2a20 6e70  scale = 1.5 * np
-0001db10: 2e6d 6178 286e 702e 6162 7328 7766 2929  .max(np.abs(wf))
-0001db20: 0a20 2020 2020 2020 2020 2020 2061 785f  .            ax_
-0001db30: 7420 3d20 6d75 2e70 6c6f 745f 6d65 615f  t = mu.plot_mea_
-0001db40: 7265 636f 7264 696e 6728 7766 2c20 6d65  recording(wf, me
-0001db50: 612c 2063 6f6c 6f72 733d 636f 6c6f 7273  a, colors=colors
-0001db60: 5b69 5d2c 2061 783d 6178 5f74 2c20 6c77  [i], ax=ax_t, lw
-0001db70: 3d30 2e31 2c20 7673 6361 6c65 3d76 7363  =0.1, vscale=vsc
-0001db80: 616c 6529 0a20 2020 2020 2020 2020 2020  ale).           
-0001db90: 2061 785f 7420 3d20 6d75 2e70 6c6f 745f   ax_t = mu.plot_
-0001dba0: 6d65 615f 7265 636f 7264 696e 6728 7766  mea_recording(wf
-0001dbb0: 2e6d 6561 6e28 6178 6973 3d30 292c 206d  .mean(axis=0), m
-0001dbc0: 6561 2c20 636f 6c6f 7273 3d63 6f6c 6f72  ea, colors=color
-0001dbd0: 735b 695d 2c20 6178 3d61 785f 742c 206c  s[i], ax=ax_t, l
-0001dbe0: 773d 322c 2076 7363 616c 653d 7673 6361  w=2, vscale=vsca
-0001dbf0: 6c65 290a 2020 2020 656c 7365 3a0a 2020  le).    else:.  
-0001dc00: 2020 2020 2020 6173 7365 7274 2069 7369        assert isi
-0001dc10: 6e73 7461 6e63 6528 656c 6563 7472 6f64  nstance(electrod
-0001dc20: 652c 2028 696e 742c 206e 702e 696e 7465  e, (int, np.inte
-0001dc30: 6765 7229 2920 6f72 2065 6c65 6374 726f  ger)) or electro
-0001dc40: 6465 203d 3d20 276d 6178 272c 2022 656c  de == 'max', "el
-0001dc50: 6563 7472 6f64 6520 6d75 7374 2062 6520  ectrode must be 
-0001dc60: 696e 7420 6f72 2027 6d61 7827 220a 2020  int or 'max'".  
-0001dc70: 2020 2020 2020 6966 206c 656e 2873 7069        if len(spi
-0001dc80: 6b65 7472 6169 6e5f 6964 2920 3e20 6e63  ketrain_id) > nc
-0001dc90: 6f6c 733a 0a20 2020 2020 2020 2020 2020  ols:.           
-0001dca0: 206e 726f 7773 203d 2069 6e74 286e 702e   nrows = int(np.
-0001dcb0: 6365 696c 286c 656e 2873 7069 6b65 7472  ceil(len(spiketr
-0001dcc0: 6169 6e5f 6964 2920 2f20 6e63 6f6c 7329  ain_id) / ncols)
-0001dcd0: 290a 2020 2020 2020 2020 656c 7365 3a0a  ).        else:.
-0001dce0: 2020 2020 2020 2020 2020 2020 6e72 6f77              nrow
-0001dcf0: 7320 3d20 310a 2020 2020 2020 2020 2020  s = 1.          
-0001dd00: 2020 6e63 6f6c 7320 3d20 6c65 6e28 7370    ncols = len(sp
-0001dd10: 696b 6574 7261 696e 5f69 6429 0a0a 2020  iketrain_id)..  
-0001dd20: 2020 2020 2020 6773 203d 2067 7269 6473        gs = grids
-0001dd30: 7065 632e 4772 6964 5370 6563 4672 6f6d  pec.GridSpecFrom
-0001dd40: 5375 6270 6c6f 7453 7065 6328 6e72 6f77  SubplotSpec(nrow
-0001dd50: 732c 206e 636f 6c73 2c20 7375 6270 6c6f  s, ncols, subplo
-0001dd60: 745f 7370 6563 3d61 7829 0a0a 2020 2020  t_spec=ax)..    
-0001dd70: 2020 2020 2320 6669 6e64 2079 6c69 6d0a      # find ylim.
-0001dd80: 2020 2020 2020 2020 6d69 6e5f 7766 203d          min_wf =
-0001dd90: 2030 0a20 2020 2020 2020 206d 6178 5f77   0.        max_w
-0001dda0: 6620 3d20 300a 0a20 2020 2020 2020 2066  f = 0..        f
-0001ddb0: 6f72 2077 6620 696e 2077 6176 6566 6f72  or wf in wavefor
-0001ddc0: 6d73 3a0a 2020 2020 2020 2020 2020 2020  ms:.            
-0001ddd0: 7766 5f6d 6561 6e20 3d20 7766 2e6d 6561  wf_mean = wf.mea
-0001dde0: 6e28 6178 6973 3d30 290a 2020 2020 2020  n(axis=0).      
-0001ddf0: 2020 2020 2020 6966 206e 702e 6d69 6e28        if np.min(
-0001de00: 7766 5f6d 6561 6e29 203c 206d 696e 5f77  wf_mean) < min_w
-0001de10: 663a 0a20 2020 2020 2020 2020 2020 2020  f:.             
-0001de20: 2020 206d 696e 5f77 6620 3d20 6e70 2e6d     min_wf = np.m
-0001de30: 696e 2877 665f 6d65 616e 290a 2020 2020  in(wf_mean).    
-0001de40: 2020 2020 2020 2020 6966 206e 702e 6d61          if np.ma
-0001de50: 7828 7766 5f6d 6561 6e29 203e 206d 6178  x(wf_mean) > max
-0001de60: 5f77 663a 0a20 2020 2020 2020 2020 2020  _wf:.           
-0001de70: 2020 2020 206d 6178 5f77 6620 3d20 6e70       max_wf = np
-0001de80: 2e6d 6178 2877 665f 6d65 616e 290a 0a20  .max(wf_mean).. 
-0001de90: 2020 2020 2020 2079 6c69 6d20 3d20 5b6d         ylim = [m
-0001dea0: 696e 5f77 6620 2d20 302e 3220 2a20 6162  in_wf - 0.2 * ab
-0001deb0: 7328 6d69 6e5f 7766 292c 206d 6178 5f77  s(min_wf), max_w
-0001dec0: 6620 2b20 302e 3220 2a20 6162 7328 6d69  f + 0.2 * abs(mi
-0001ded0: 6e5f 7766 295d 0a0a 2020 2020 2020 2020  n_wf)]..        
-0001dee0: 666f 7220 692c 2077 6620 696e 2065 6e75  for i, wf in enu
-0001def0: 6d65 7261 7465 2877 6176 6566 6f72 6d73  merate(waveforms
-0001df00: 293a 0a20 2020 2020 2020 2020 2020 2072  ):.            r
-0001df10: 203d 2069 202f 2f20 6e63 6f6c 730a 2020   = i // ncols.  
-0001df20: 2020 2020 2020 2020 2020 6320 3d20 6e70            c = np
-0001df30: 2e6d 6f64 2869 2c20 6e63 6f6c 7329 0a20  .mod(i, ncols). 
-0001df40: 2020 2020 2020 2020 2020 2067 735f 7365             gs_se
-0001df50: 6c20 3d20 6773 5b72 2c20 635d 0a20 2020  l = gs[r, c].   
-0001df60: 2020 2020 2020 2020 2061 785f 7365 6c20           ax_sel 
-0001df70: 3d20 6669 672e 6164 645f 7375 6270 6c6f  = fig.add_subplo
-0001df80: 7428 6773 5f73 656c 290a 2020 2020 2020  t(gs_sel).      
-0001df90: 2020 2020 2020 6966 2065 6c65 6374 726f        if electro
-0001dfa0: 6465 203d 3d20 276d 6178 273a 0a20 2020  de == 'max':.   
-0001dfb0: 2020 2020 2020 2020 2020 2020 2065 6c65               ele
-0001dfc0: 6374 726f 6465 5f69 6478 203d 206e 702e  ctrode_idx = np.
-0001dfd0: 756e 7261 7665 6c5f 696e 6465 7828 6e70  unravel_index(np
-0001dfe0: 2e61 7267 6d69 6e28 7766 2e6d 6561 6e28  .argmin(wf.mean(
-0001dff0: 6178 6973 3d30 2929 2c20 7766 2e6d 6561  axis=0)), wf.mea
-0001e000: 6e28 6178 6973 3d30 292e 7368 6170 6529  n(axis=0).shape)
-0001e010: 5b30 5d0a 2020 2020 2020 2020 2020 2020  [0].            
-0001e020: 2020 2020 7072 696e 7428 276d 6178 2065      print('max e
-0001e030: 6c65 6374 726f 6465 3a20 272c 2065 6c65  lectrode: ', ele
-0001e040: 6374 726f 6465 5f69 6478 290a 2020 2020  ctrode_idx).    
-0001e050: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
-0001e060: 2020 2020 2020 2020 2020 2020 2020 656c                el
-0001e070: 6563 7472 6f64 655f 6964 7820 3d20 656c  ectrode_idx = el
-0001e080: 6563 7472 6f64 650a 2020 2020 2020 2020  ectrode.        
-0001e090: 2020 2020 6966 2069 203d 3d20 303a 0a20      if i == 0:. 
-0001e0a0: 2020 2020 2020 2020 2020 2020 2020 2061                 a
-0001e0b0: 785f 7365 6c2e 7365 745f 796c 6162 656c  x_sel.set_ylabel
-0001e0c0: 2827 766f 6c74 6167 6520 2824 5c6d 7524  ('voltage ($\mu$
-0001e0d0: 5629 272c 2066 6f6e 7473 697a 653d 3135  V)', fontsize=15
-0001e0e0: 290a 2020 2020 2020 2020 2020 2020 6178  ).            ax
-0001e0f0: 5f73 656c 2e70 6c6f 7428 7766 5b3a 2c20  _sel.plot(wf[:, 
-0001e100: 656c 6563 7472 6f64 655f 6964 785d 2e54  electrode_idx].T
-0001e110: 2c20 636f 6c6f 723d 636f 6c6f 7273 5b6e  , color=colors[n
-0001e120: 702e 6d6f 6428 692c 206c 656e 2863 6f6c  p.mod(i, len(col
-0001e130: 6f72 7329 295d 2c20 6c77 3d30 2e31 290a  ors))], lw=0.1).
-0001e140: 2020 2020 2020 2020 2020 2020 6178 5f73              ax_s
-0001e150: 656c 2e70 6c6f 7428 7766 5b3a 2c20 656c  el.plot(wf[:, el
-0001e160: 6563 7472 6f64 655f 6964 785d 2e6d 6561  ectrode_idx].mea
-0001e170: 6e28 6178 6973 3d30 292c 2063 6f6c 6f72  n(axis=0), color
-0001e180: 3d27 6b27 2c20 6c77 3d31 290a 2020 2020  ='k', lw=1).    
-0001e190: 2020 2020 2020 2020 6178 5f73 656c 2e73          ax_sel.s
-0001e1a0: 6574 5f74 6974 6c65 2827 556e 6974 2027  et_title('Unit '
-0001e1b0: 202b 2073 7472 2869 2920 2b20 2720 2d20   + str(i) + ' - 
-0001e1c0: 4368 2e20 2720 2b20 7374 7228 656c 6563  Ch. ' + str(elec
-0001e1d0: 7472 6f64 655f 6964 7829 2c20 666f 6e74  trode_idx), font
-0001e1e0: 7369 7a65 3d31 3229 0a20 2020 2020 2020  size=12).       
-0001e1f0: 2020 2020 2061 785f 7365 6c2e 7365 745f       ax_sel.set_
-0001e200: 796c 696d 2879 6c69 6d29 0a20 2020 2020  ylim(ylim).     
-0001e210: 2020 2020 2020 2069 6620 6320 213d 2030         if c != 0
-0001e220: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0001e230: 2020 6178 5f73 656c 2e73 7069 6e65 735b    ax_sel.spines[
-0001e240: 276c 6566 7427 5d2e 7365 745f 7669 7369  'left'].set_visi
-0001e250: 626c 6528 4661 6c73 6529 0a20 2020 2020  ble(False).     
-0001e260: 2020 2020 2020 2020 2020 2061 785f 7365             ax_se
-0001e270: 6c2e 7365 745f 7974 6963 6b73 285b 5d29  l.set_yticks([])
-0001e280: 0a20 2020 2020 2020 2020 2020 2061 785f  .            ax_
-0001e290: 7365 6c2e 7370 696e 6573 5b27 7269 6768  sel.spines['righ
-0001e2a0: 7427 5d2e 7365 745f 7669 7369 626c 6528  t'].set_visible(
-0001e2b0: 4661 6c73 6529 0a20 2020 2020 2020 2020  False).         
-0001e2c0: 2020 2061 785f 7365 6c2e 7370 696e 6573     ax_sel.spines
-0001e2d0: 5b27 746f 7027 5d2e 7365 745f 7669 7369  ['top'].set_visi
-0001e2e0: 626c 6528 4661 6c73 6529 0a20 2020 2061  ble(False).    a
-0001e2f0: 782e 6178 6973 2827 6f66 6627 290a 0a20  x.axis('off').. 
-0001e300: 2020 2072 6574 7572 6e20 6178 0a0a 0a64     return ax...d
-0001e310: 6566 2070 6c6f 745f 616d 706c 6974 7564  ef plot_amplitud
-0001e320: 6573 2872 6563 6765 6e2c 2073 7069 6b65  es(recgen, spike
-0001e330: 7472 6169 6e5f 6964 3d4e 6f6e 652c 2065  train_id=None, e
-0001e340: 6c65 6374 726f 6465 3d4e 6f6e 652c 2061  lectrode=None, a
-0001e350: 783d 4e6f 6e65 2c20 636f 6c6f 723d 4e6f  x=None, color=No
-0001e360: 6e65 2c20 636d 6170 3d4e 6f6e 652c 2073  ne, cmap=None, s
-0001e370: 696e 676c 655f 6178 6573 3d54 7275 652c  ingle_axes=True,
-0001e380: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001e390: 2020 2020 206d 6172 6b65 723d 272a 272c       marker='*',
-0001e3a0: 206d 733d 352c 206e 636f 6c73 3d36 293a   ms=5, ncols=6):
-0001e3b0: 0a20 2020 2022 2222 0a20 2020 2050 6c6f  .    """.    Plo
-0001e3c0: 7420 7761 7665 666f 726d 2061 6d70 6c69  t waveform ampli
-0001e3d0: 7475 6465 7320 6f76 6572 2074 696d 652e  tudes over time.
-0001e3e0: 0a0a 2020 2020 5061 7261 6d65 7465 7273  ..    Parameters
-0001e3f0: 0a20 2020 202d 2d2d 2d2d 2d2d 2d2d 2d0a  .    ----------.
-0001e400: 2020 2020 7265 6367 656e 203a 2052 6563      recgen : Rec
-0001e410: 6f72 6469 6e67 4765 6e65 7261 746f 720a  ordingGenerator.
-0001e420: 2020 2020 2020 2020 5265 636f 7264 696e          Recordin
-0001e430: 6720 6765 6e65 7261 746f 7220 6f62 6a65  g generator obje
-0001e440: 6374 2074 6f20 706c 6f74 2073 7069 6b65  ct to plot spike
-0001e450: 2074 7261 696e 2077 6176 6566 6f72 6d20   train waveform 
-0001e460: 6672 6f6d 0a20 2020 2073 7069 6b65 7472  from.    spiketr
-0001e470: 6169 6e5f 6964 203a 2069 6e74 206f 7220  ain_id : int or 
-0001e480: 6c69 7374 0a20 2020 2020 2020 2049 6e64  list.        Ind
-0001e490: 6578 6573 206f 6620 7370 696b 6520 7472  exes of spike tr
-0001e4a0: 6169 6e73 0a20 2020 2065 6c65 6374 726f  ains.    electro
-0001e4b0: 6465 203a 2069 6e74 206f 7220 276d 6178  de : int or 'max
-0001e4c0: 270a 2020 2020 2020 2020 456c 6563 7472  '.        Electr
-0001e4d0: 6f64 6520 6964 206f 7220 276d 6178 270a  ode id or 'max'.
-0001e4e0: 2020 2020 6178 203a 2061 7869 730a 2020      ax : axis.  
-0001e4f0: 2020 2020 2020 4d61 7470 6c6f 746c 6962        Matplotlib
-0001e500: 2020 6178 6973 0a20 2020 2063 6f6c 6f72    axis.    color
-0001e510: 203a 206d 6174 706c 6f74 6c69 6220 636f   : matplotlib co
-0001e520: 6c6f 720a 2020 2020 2020 2020 436f 6c6f  lor.        Colo
-0001e530: 7220 6f66 2074 6865 2077 6176 6566 6f72  r of the wavefor
-0001e540: 6d20 616d 706c 6974 7564 6573 0a20 2020  m amplitudes.   
-0001e550: 2063 6d61 7020 3a20 6d61 7470 6c6f 746c   cmap : matplotl
-0001e560: 6962 2063 6f6c 6f72 6d61 700a 2020 2020  ib colormap.    
-0001e570: 2020 2020 436f 6c6f 726d 6170 2074 6f20      Colormap to 
-0001e580: 6265 2075 7365 640a 2020 2020 7369 6e67  be used.    sing
-0001e590: 6c65 5f61 7865 7320 3a20 626f 6f6c 0a20  le_axes : bool. 
-0001e5a0: 2020 2020 2020 2049 6620 5472 7565 2061         If True a
-0001e5b0: 6c6c 2074 656d 706c 6174 6573 2061 7265  ll templates are
-0001e5c0: 2070 6c6f 7474 6564 206f 6e20 7468 6520   plotted on the 
-0001e5d0: 7361 6d65 2061 7869 730a 2020 2020 6d61  same axis.    ma
-0001e5e0: 726b 6572 203a 2073 7472 0a20 2020 2020  rker : str.     
-0001e5f0: 2020 204d 6174 706c 6f74 6c69 6220 6d61     Matplotlib ma
-0001e600: 726b 6572 2028 6465 6661 756c 7420 272a  rker (default '*
-0001e610: 2729 0a20 2020 206d 7320 3a20 696e 740a  ').    ms : int.
-0001e620: 2020 2020 2020 2020 4d61 726b 6572 7369          Markersi
-0001e630: 7a65 2028 6465 6661 756c 7420 3529 0a20  ze (default 5). 
-0001e640: 2020 206e 636f 6c73 203a 2020 696e 740a     ncols :  int.
-0001e650: 2020 2020 2020 2020 4e75 6d62 6572 206f          Number o
-0001e660: 6620 636f 6c75 6d6e 7320 666f 7220 7375  f columns for su
-0001e670: 6270 6c6f 7473 0a20 2020 200a 2020 2020  bplots.    .    
-0001e680: 5265 7475 726e 730a 2020 2020 2d2d 2d2d  Returns.    ----
-0001e690: 2d2d 2d0a 2020 2020 6178 203a 2061 7869  ---.    ax : axi
-0001e6a0: 730a 2020 2020 2020 2020 4d61 7470 6c6f  s.        Matplo
-0001e6b0: 746c 6962 2061 7869 730a 0a20 2020 2022  tlib axis..    "
-0001e6c0: 2222 0a20 2020 2069 6d70 6f72 7420 6d61  "".    import ma
-0001e6d0: 7470 6c6f 746c 6962 2e70 796c 6162 2061  tplotlib.pylab a
-0001e6e0: 7320 706c 740a 2020 2020 696d 706f 7274  s plt.    import
-0001e6f0: 206d 6174 706c 6f74 6c69 622e 6772 6964   matplotlib.grid
-0001e700: 7370 6563 2061 7320 6772 6964 7370 6563  spec as gridspec
-0001e710: 0a0a 2020 2020 6966 2073 7069 6b65 7472  ..    if spiketr
-0001e720: 6169 6e5f 6964 2069 7320 4e6f 6e65 3a0a  ain_id is None:.
-0001e730: 2020 2020 2020 2020 7370 696b 6574 7261          spiketra
-0001e740: 696e 5f69 6420 3d20 6e70 2e61 7261 6e67  in_id = np.arang
-0001e750: 6528 6c65 6e28 7265 6367 656e 2e73 7069  e(len(recgen.spi
-0001e760: 6b65 7472 6169 6e73 2929 0a20 2020 2065  ketrains)).    e
-0001e770: 6c69 6620 6973 696e 7374 616e 6365 2873  lif isinstance(s
-0001e780: 7069 6b65 7472 6169 6e5f 6964 2c20 2869  piketrain_id, (i
-0001e790: 6e74 2c20 6e70 2e69 6e74 6567 6572 2929  nt, np.integer))
-0001e7a0: 3a0a 2020 2020 2020 2020 7370 696b 6574  :.        spiket
-0001e7b0: 7261 696e 5f69 6420 3d20 5b73 7069 6b65  rain_id = [spike
-0001e7c0: 7472 6169 6e5f 6964 5d0a 0a20 2020 206e  train_id]..    n
-0001e7d0: 5f75 6e69 7473 203d 206c 656e 2873 7069  _units = len(spi
-0001e7e0: 6b65 7472 6169 6e5f 6964 290a 0a20 2020  ketrain_id)..   
-0001e7f0: 2069 6620 656c 6563 7472 6f64 6520 6973   if electrode is
-0001e800: 204e 6f6e 653a 0a20 2020 2020 2020 2065   None:.        e
-0001e810: 6c65 6374 726f 6465 203d 2027 6d61 7827  lectrode = 'max'
-0001e820: 0a20 2020 2077 6176 6566 6f72 6d73 203d  .    waveforms =
-0001e830: 205b 5d0a 2020 2020 666f 7220 7370 2069   [].    for sp i
-0001e840: 6e20 7370 696b 6574 7261 696e 5f69 643a  n spiketrain_id:
-0001e850: 0a20 2020 2020 2020 2077 6620 3d20 7265  .        wf = re
-0001e860: 6367 656e 2e73 7069 6b65 7472 6169 6e73  cgen.spiketrains
-0001e870: 5b73 705d 2e77 6176 6566 6f72 6d73 0a20  [sp].waveforms. 
-0001e880: 2020 2020 2020 2069 6620 7766 2069 7320         if wf is 
-0001e890: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
-0001e8a0: 2020 6673 203d 2072 6563 6765 6e2e 696e    fs = recgen.in
-0001e8b0: 666f 5b27 7265 636f 7264 696e 6773 275d  fo['recordings']
-0001e8c0: 5b27 6673 275d 202a 2070 712e 487a 0a20  ['fs'] * pq.Hz. 
-0001e8d0: 2020 2020 2020 2020 2020 2065 7874 7261             extra
-0001e8e0: 6374 5f77 6628 5b72 6563 6765 6e2e 7370  ct_wf([recgen.sp
-0001e8f0: 696b 6574 7261 696e 735b 7370 5d5d 2c20  iketrains[sp]], 
-0001e900: 7265 6367 656e 2e72 6563 6f72 6469 6e67  recgen.recording
-0001e910: 732c 2066 7329 0a20 2020 2020 2020 2020  s, fs).         
-0001e920: 2020 2077 6620 3d20 7265 6367 656e 2e73     wf = recgen.s
-0001e930: 7069 6b65 7472 6169 6e73 5b73 705d 2e77  piketrains[sp].w
-0001e940: 6176 6566 6f72 6d73 0a20 2020 2020 2020  aveforms.       
-0001e950: 2077 6176 6566 6f72 6d73 2e61 7070 656e   waveforms.appen
-0001e960: 6428 7766 290a 0a20 2020 2069 6620 6e5f  d(wf)..    if n_
-0001e970: 756e 6974 7320 3e20 313a 0a20 2020 2020  units > 1:.     
-0001e980: 2020 2069 6620 636f 6c6f 7220 6973 204e     if color is N
-0001e990: 6f6e 653a 0a20 2020 2020 2020 2020 2020  one:.           
-0001e9a0: 2069 6620 636d 6170 2069 7320 6e6f 7420   if cmap is not 
-0001e9b0: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
-0001e9c0: 2020 2020 2020 636d 203d 2070 6c74 2e67        cm = plt.g
-0001e9d0: 6574 5f63 6d61 7028 636d 6170 290a 2020  et_cmap(cmap).  
-0001e9e0: 2020 2020 2020 2020 2020 2020 2020 636f                co
-0001e9f0: 6c6f 7273 203d 205b 636d 2869 202f 206e  lors = [cm(i / n
-0001ea00: 5f75 6e69 7473 2920 666f 7220 6920 696e  _units) for i in
-0001ea10: 206e 702e 6172 616e 6765 286e 5f75 6e69   np.arange(n_uni
-0001ea20: 7473 295d 0a20 2020 2020 2020 2020 2020  ts)].           
-0001ea30: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
-0001ea40: 2020 2020 2020 2063 6f6c 6f72 7320 3d20         colors = 
-0001ea50: 706c 742e 7263 5061 7261 6d73 5b27 6178  plt.rcParams['ax
-0001ea60: 6573 2e70 726f 705f 6379 636c 6527 5d2e  es.prop_cycle'].
-0001ea70: 6279 5f6b 6579 2829 5b27 636f 6c6f 7227  by_key()['color'
-0001ea80: 5d0a 2020 2020 2020 2020 656c 7365 3a0a  ].        else:.
-0001ea90: 2020 2020 2020 2020 2020 2020 636f 6c6f              colo
-0001eaa0: 7273 203d 2070 6c74 2e72 6350 6172 616d  rs = plt.rcParam
-0001eab0: 735b 2761 7865 732e 7072 6f70 5f63 7963  s['axes.prop_cyc
-0001eac0: 6c65 275d 2e62 795f 6b65 7928 295b 2763  le'].by_key()['c
-0001ead0: 6f6c 6f72 275d 0a20 2020 2065 6c73 653a  olor'].    else:
-0001eae0: 0a20 2020 2020 2020 2069 6620 636f 6c6f  .        if colo
-0001eaf0: 7220 6973 204e 6f6e 653a 0a20 2020 2020  r is None:.     
-0001eb00: 2020 2020 2020 2063 6f6c 6f72 7320 3d20         colors = 
-0001eb10: 276b 270a 2020 2020 2020 2020 656c 7365  'k'.        else
-0001eb20: 3a0a 2020 2020 2020 2020 2020 2020 636f  :.            co
-0001eb30: 6c6f 7273 203d 2063 6f6c 6f72 0a0a 2020  lors = color..  
-0001eb40: 2020 6966 2061 7820 6973 204e 6f6e 653a    if ax is None:
-0001eb50: 0a20 2020 2020 2020 2066 6967 203d 2070  .        fig = p
-0001eb60: 6c74 2e66 6967 7572 6528 290a 2020 2020  lt.figure().    
-0001eb70: 2020 2020 6178 203d 2066 6967 2e61 6464      ax = fig.add
-0001eb80: 5f73 7562 706c 6f74 2831 3131 290a 2020  _subplot(111).  
-0001eb90: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
-0001eba0: 6669 6720 3d20 6178 2e67 6574 5f66 6967  fig = ax.get_fig
-0001ebb0: 7572 6528 290a 0a20 2020 2061 6d70 7320  ure()..    amps 
-0001ebc0: 3d20 5b5d 0a20 2020 2066 6f72 2069 2c20  = [].    for i, 
-0001ebd0: 6964 2069 6e20 656e 756d 6572 6174 6528  id in enumerate(
-0001ebe0: 7370 696b 6574 7261 696e 5f69 6429 3a0a  spiketrain_id):.
-0001ebf0: 2020 2020 2020 2020 7374 203d 2072 6563          st = rec
-0001ec00: 6765 6e2e 7370 696b 6574 7261 696e 735b  gen.spiketrains[
-0001ec10: 6964 5d0a 2020 2020 2020 2020 7766 203d  id].        wf =
-0001ec20: 2073 742e 7761 7665 666f 726d 730a 2020   st.waveforms.  
-0001ec30: 2020 2020 2020 6d77 6620 3d20 6e70 2e6d        mwf = np.m
-0001ec40: 6561 6e28 7766 2c20 6178 6973 3d30 290a  ean(wf, axis=0).
-0001ec50: 2020 2020 2020 2020 6966 2065 6c65 6374          if elect
-0001ec60: 726f 6465 203d 3d20 276d 6178 273a 0a20  rode == 'max':. 
-0001ec70: 2020 2020 2020 2020 2020 206d 6178 5f65             max_e
-0001ec80: 6c65 6320 3d20 6e70 2e75 6e72 6176 656c  lec = np.unravel
-0001ec90: 5f69 6e64 6578 286e 702e 6172 676d 696e  _index(np.argmin
-0001eca0: 286d 7766 292c 206d 7766 2e73 6861 7065  (mwf), mwf.shape
-0001ecb0: 295b 305d 0a20 2020 2020 2020 2020 2020  )[0].           
-0001ecc0: 2070 7269 6e74 2827 4d61 7820 656c 6563   print('Max elec
-0001ecd0: 7472 6f64 6527 2c20 6d61 785f 656c 6563  trode', max_elec
-0001ece0: 290a 2020 2020 2020 2020 656c 7365 3a0a  ).        else:.
-0001ecf0: 2020 2020 2020 2020 2020 2020 6173 7365              asse
-0001ed00: 7274 2069 7369 6e73 7461 6e63 6528 656c  rt isinstance(el
-0001ed10: 6563 7472 6f64 652c 2028 696e 742c 206e  ectrode, (int, n
-0001ed20: 702e 696e 7465 6765 7229 292c 2022 2765  p.integer)), "'e
-0001ed30: 6c65 6374 726f 6465 2720 6361 6e20 6265  lectrode' can be
-0001ed40: 2027 6d61 7827 206f 7220 7479 7065 2069   'max' or type i
-0001ed50: 6e74 220a 2020 2020 2020 2020 2020 2020  nt".            
-0001ed60: 6d61 785f 656c 6563 203d 2065 6c65 6374  max_elec = elect
-0001ed70: 726f 6465 0a20 2020 2020 2020 2061 6d70  rode.        amp
-0001ed80: 732e 6170 7065 6e64 286e 702e 6172 7261  s.append(np.arra
-0001ed90: 7928 5b6e 702e 6d69 6e28 775b 6d61 785f  y([np.min(w[max_
-0001eda0: 656c 6563 5d29 2066 6f72 2077 2069 6e20  elec]) for w in 
-0001edb0: 7766 5d29 290a 0a20 2020 2069 6620 7369  wf]))..    if si
-0001edc0: 6e67 6c65 5f61 7865 733a 0a20 2020 2020  ngle_axes:.     
-0001edd0: 2020 2066 6f72 2069 5f6e 2c20 6e20 696e     for i_n, n in
-0001ede0: 2065 6e75 6d65 7261 7465 2873 7069 6b65   enumerate(spike
-0001edf0: 7472 6169 6e5f 6964 293a 0a20 2020 2020  train_id):.     
-0001ee00: 2020 2020 2020 2061 6d70 203d 2061 6d70         amp = amp
-0001ee10: 735b 695f 6e5d 0a20 2020 2020 2020 2020  s[i_n].         
-0001ee20: 2020 2073 7420 3d20 7265 6367 656e 2e73     st = recgen.s
-0001ee30: 7069 6b65 7472 6169 6e73 5b6e 5d0a 2020  piketrains[n].  
-0001ee40: 2020 2020 2020 2020 2020 6178 2e70 6c6f            ax.plo
-0001ee50: 7428 7374 2c20 616d 702c 206d 6172 6b65  t(st, amp, marke
-0001ee60: 723d 6d61 726b 6572 2c20 6d73 3d6d 732c  r=marker, ms=ms,
-0001ee70: 2063 6f6c 6f72 3d63 6f6c 6f72 735b 695f   color=colors[i_
-0001ee80: 6e5d 2c20 6c73 3d27 2729 0a20 2020 2065  n], ls='').    e
-0001ee90: 6c73 653a 0a20 2020 2020 2020 2069 6620  lse:.        if 
-0001eea0: 6e5f 756e 6974 7320 3e20 6e63 6f6c 733a  n_units > ncols:
-0001eeb0: 0a20 2020 2020 2020 2020 2020 206e 726f  .            nro
-0001eec0: 7773 203d 2069 6e74 286e 702e 6365 696c  ws = int(np.ceil
-0001eed0: 286c 656e 2873 7069 6b65 7472 6169 6e5f  (len(spiketrain_
-0001eee0: 6964 2920 2f20 6e63 6f6c 7329 290a 2020  id) / ncols)).  
-0001eef0: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
-0001ef00: 2020 2020 2020 2020 6e72 6f77 7320 3d20          nrows = 
-0001ef10: 310a 2020 2020 2020 2020 2020 2020 6e63  1.            nc
-0001ef20: 6f6c 7320 3d20 6e5f 756e 6974 730a 0a20  ols = n_units.. 
-0001ef30: 2020 2020 2020 2067 7320 3d20 6772 6964         gs = grid
-0001ef40: 7370 6563 2e47 7269 6453 7065 6346 726f  spec.GridSpecFro
-0001ef50: 6d53 7562 706c 6f74 5370 6563 286e 726f  mSubplotSpec(nro
-0001ef60: 7773 2c20 6e63 6f6c 732c 2073 7562 706c  ws, ncols, subpl
-0001ef70: 6f74 5f73 7065 633d 6178 290a 0a20 2020  ot_spec=ax)..   
-0001ef80: 2020 2020 2066 6f72 2069 5f6e 2c20 6e20       for i_n, n 
-0001ef90: 696e 2065 6e75 6d65 7261 7465 2873 7069  in enumerate(spi
-0001efa0: 6b65 7472 6169 6e5f 6964 293a 0a20 2020  ketrain_id):.   
-0001efb0: 2020 2020 2020 2020 2072 203d 2069 5f6e           r = i_n
-0001efc0: 202f 2f20 6e63 6f6c 730a 2020 2020 2020   // ncols.      
-0001efd0: 2020 2020 2020 6320 3d20 6e70 2e6d 6f64        c = np.mod
-0001efe0: 2869 5f6e 2c20 6e63 6f6c 7329 0a20 2020  (i_n, ncols).   
-0001eff0: 2020 2020 2020 2020 2067 735f 7365 6c20           gs_sel 
-0001f000: 3d20 6773 5b72 2c20 635d 0a20 2020 2020  = gs[r, c].     
-0001f010: 2020 2020 2020 2061 785f 616d 7020 3d20         ax_amp = 
-0001f020: 6669 672e 6164 645f 7375 6270 6c6f 7428  fig.add_subplot(
-0001f030: 6773 5f73 656c 290a 2020 2020 2020 2020  gs_sel).        
-0001f040: 2020 2020 616d 7020 3d20 616d 7073 5b69      amp = amps[i
-0001f050: 5f6e 5d0a 2020 2020 2020 2020 2020 2020  _n].            
-0001f060: 7374 203d 2072 6563 6765 6e2e 7370 696b  st = recgen.spik
-0001f070: 6574 7261 696e 735b 6e5d 0a20 2020 2020  etrains[n].     
-0001f080: 2020 2020 2020 2061 785f 616d 702e 706c         ax_amp.pl
-0001f090: 6f74 2873 742c 2061 6d70 2c20 6d61 726b  ot(st, amp, mark
-0001f0a0: 6572 3d6d 6172 6b65 722c 206d 733d 6d73  er=marker, ms=ms
-0001f0b0: 2c20 636f 6c6f 723d 636f 6c6f 7273 5b69  , color=colors[i
-0001f0c0: 5f6e 5d2c 206c 733d 2727 290a 2020 2020  _n], ls='').    
-0001f0d0: 2020 2020 6178 2e61 7869 7328 276f 6666      ax.axis('off
-0001f0e0: 2729 0a0a 2020 2020 7265 7475 726e 2061  ')..    return a
-0001f0f0: 780a 0a0a 6465 6620 706c 6f74 5f70 6361  x...def plot_pca
-0001f100: 5f6d 6170 2872 6563 6765 6e2c 206e 5f70  _map(recgen, n_p
-0001f110: 633d 322c 206d 6178 5f65 6c65 633d 4e6f  c=2, max_elec=No
-0001f120: 6e65 2c20 636d 6170 3d27 7261 696e 626f  ne, cmap='rainbo
-0001f130: 7727 2c20 6375 745f 6f75 743d 322c 206e  w', cut_out=2, n
-0001f140: 5f75 6e69 7473 3d4e 6f6e 652c 2061 783d  _units=None, ax=
-0001f150: 4e6f 6e65 2c0a 2020 2020 2020 2020 2020  None,.          
-0001f160: 2020 2020 2020 2077 6869 7465 6e3d 4661         whiten=Fa
-0001f170: 6c73 652c 2070 635f 636f 6d70 3d4e 6f6e  lse, pc_comp=Non
-0001f180: 6529 3a0a 2020 2020 2222 220a 2020 2020  e):.    """.    
-0001f190: 506c 6f74 7320 6120 5043 4120 6d61 7020  Plots a PCA map 
-0001f1a0: 6f66 2074 6865 2077 6176 6566 6f72 6d73  of the waveforms
-0001f1b0: 2e0a 0a20 2020 2050 6172 616d 6574 6572  ...    Parameter
-0001f1c0: 730a 2020 2020 2d2d 2d2d 2d2d 2d2d 2d2d  s.    ----------
-0001f1d0: 0a20 2020 2072 6563 6765 6e20 3a20 5265  .    recgen : Re
-0001f1e0: 636f 7264 696e 6747 656e 6572 6174 6f72  cordingGenerator
-0001f1f0: 0a20 2020 2020 2020 2052 6563 6f72 6469  .        Recordi
-0001f200: 6e67 2067 656e 6572 6174 6f72 206f 626a  ng generator obj
-0001f210: 6563 7420 746f 2070 6c6f 7420 5043 4120  ect to plot PCA 
-0001f220: 7363 6f72 6573 206f 660a 2020 2020 6178  scores of.    ax
-0001f230: 203a 2061 7869 730a 2020 2020 2020 2020   : axis.        
-0001f240: 4d61 7470 6c6f 746c 6962 2020 6178 6973  Matplotlib  axis
-0001f250: 0a20 2020 206e 5f70 6320 3a20 696e 740a  .    n_pc : int.
-0001f260: 2020 2020 2020 2020 4e75 6d62 6572 206f          Number o
-0001f270: 6620 7072 696e 6369 7061 6c20 636f 6d70  f principal comp
-0001f280: 6f6e 656e 7473 2028 6465 6661 756c 7420  onents (default 
-0001f290: 3229 0a20 2020 206d 6178 5f65 6c65 6320  2).    max_elec 
-0001f2a0: 3a20 2069 6e74 0a20 2020 2020 2020 204d  :  int.        M
-0001f2b0: 6178 206e 756d 6265 7220 6f66 2065 6c65  ax number of ele
-0001f2c0: 6374 726f 6465 7320 746f 2070 6c6f 740a  ctrodes to plot.
-0001f2d0: 2020 2020 636d 6170 203a 206d 6174 706c      cmap : matpl
-0001f2e0: 6f74 6c69 6220 636f 6c6f 726d 6170 0a20  otlib colormap. 
-0001f2f0: 2020 2020 2020 2043 6f6c 6f72 6d61 7020         Colormap 
-0001f300: 746f 2062 6520 7573 6564 0a20 2020 2063  to be used.    c
-0001f310: 7574 5f6f 7574 203a 2066 6c6f 6174 206f  ut_out : float o
-0001f320: 7220 6c69 7374 0a20 2020 2020 2020 2043  r list.        C
-0001f330: 7574 206f 7574 7320 696e 206d 7320 666f  ut outs in ms fo
-0001f340: 7220 7761 7665 666f 726d 7320 2869 6620  r waveforms (if 
-0001f350: 6e6f 7420 636f 6d70 7574 6564 292e 2049  not computed). I
-0001f360: 6620 666c 6f61 7420 7468 6520 6375 7420  f float the cut 
-0001f370: 6f75 7420 6973 2073 796d 6d65 7472 6963  out is symmetric
-0001f380: 616c 2e20 2020 206e 5f75 6e69 7473 0a20  al.    n_units. 
-0001f390: 2020 2077 6869 7465 6e20 3a20 2062 6f6f     whiten :  boo
-0001f3a0: 6c0a 2020 2020 2020 2020 4966 2054 7275  l.        If Tru
-0001f3b0: 652c 2050 4341 2073 636f 7265 7320 6172  e, PCA scores ar
-0001f3c0: 6520 7768 6974 656e 6564 0a20 2020 2070  e whitened.    p
-0001f3d0: 635f 636f 6d70 203a 206e 702e 6172 7261  c_comp : np.arra
-0001f3e0: 790a 2020 2020 2020 2020 5043 2063 6f6d  y.        PC com
-0001f3f0: 706f 6e65 6e74 206d 6174 7269 7820 746f  ponent matrix to
-0001f400: 2062 6520 7573 6564 2e0a 0a20 2020 2052   be used...    R
-0001f410: 6574 7572 6e73 0a20 2020 202d 2d2d 2d2d  eturns.    -----
-0001f420: 2d2d 0a20 2020 2061 7820 3a20 6178 6973  --.    ax : axis
-0001f430: 0a20 2020 2020 2020 204d 6174 706c 6f74  .        Matplot
-0001f440: 6c69 6220 6178 6973 0a20 2020 2070 6361  lib axis.    pca
-0001f450: 5f73 636f 7265 7320 3a20 6c69 7374 0a20  _scores : list. 
-0001f460: 2020 2020 2020 204c 6973 7420 6f66 206e         List of n
-0001f470: 702e 6172 7261 7973 2077 6974 6820 7063  p.arrays with pc
-0001f480: 6120 7363 6f72 6573 2066 6f72 2074 6865  a scores for the
-0001f490: 2064 6966 6665 7265 6e74 2075 6e69 7473   different units
-0001f4a0: 0a20 2020 2070 6361 5f63 6f6d 706f 6e65  .    pca_compone
-0001f4b0: 6e74 203a 206e 702e 6172 7261 790a 2020  nt : np.array.  
-0001f4c0: 2020 2020 2020 5043 4120 636f 6d70 6f6e        PCA compon
-0001f4d0: 656e 7473 206d 6174 7269 7820 286e 5f70  ents matrix (n_p
-0001f4e0: 632c 206e 5f77 6176 6566 6f72 6d5f 7469  c, n_waveform_ti
-0001f4f0: 6d65 706f 696e 7473 290a 0a20 2020 2022  mepoints)..    "
-0001f500: 2222 0a20 2020 2074 7279 3a0a 2020 2020  "".    try:.    
-0001f510: 2020 2020 6672 6f6d 2073 6b6c 6561 726e      from sklearn
-0001f520: 2e64 6563 6f6d 706f 7369 7469 6f6e 2069  .decomposition i
-0001f530: 6d70 6f72 7420 5043 410a 2020 2020 6578  mport PCA.    ex
-0001f540: 6365 7074 3a0a 2020 2020 2020 2020 7261  cept:.        ra
-0001f550: 6973 6520 4578 6365 7074 696f 6e28 2227  ise Exception("'
-0001f560: 706c 6f74 5f70 6361 5f6d 6170 2720 7265  plot_pca_map' re
-0001f570: 7175 6972 6573 2073 6369 6b69 742d 6c65  quires scikit-le
-0001f580: 6172 6e20 7061 636b 6167 6522 290a 0a20  arn package").. 
-0001f590: 2020 2069 6d70 6f72 7420 6d61 7470 6c6f     import matplo
-0001f5a0: 746c 6962 2e70 796c 6162 2061 7320 706c  tlib.pylab as pl
-0001f5b0: 740a 2020 2020 696d 706f 7274 206d 6174  t.    import mat
-0001f5c0: 706c 6f74 6c69 622e 6772 6964 7370 6563  plotlib.gridspec
-0001f5d0: 2061 7320 6772 6964 7370 6563 0a0a 2020   as gridspec..  
-0001f5e0: 2020 7761 7665 666f 726d 7320 3d20 5b5d    waveforms = []
-0001f5f0: 0a20 2020 206e 5f73 7069 6b65 7320 3d20  .    n_spikes = 
-0001f600: 5b5d 0a0a 2020 2020 6966 206e 5f75 6e69  []..    if n_uni
-0001f610: 7473 2069 7320 4e6f 6e65 3a0a 2020 2020  ts is None:.    
-0001f620: 2020 2020 6e5f 756e 6974 7320 3d20 6c65      n_units = le
-0001f630: 6e28 7265 6367 656e 2e73 7069 6b65 7472  n(recgen.spiketr
-0001f640: 6169 6e73 290a 0a20 2020 2069 6620 7265  ains)..    if re
-0001f650: 6367 656e 2e73 7069 6b65 7472 6169 6e73  cgen.spiketrains
-0001f660: 5b30 5d2e 7761 7665 666f 726d 7320 6973  [0].waveforms is
-0001f670: 204e 6f6e 653a 0a20 2020 2020 2020 2070   None:.        p
-0001f680: 7269 6e74 2827 436f 6d70 7574 696e 6720  rint('Computing 
-0001f690: 7761 7665 666f 726d 7327 290a 2020 2020  waveforms').    
-0001f6a0: 2020 2020 7265 6367 656e 2e65 7874 7261      recgen.extra
-0001f6b0: 6374 5f77 6176 6566 6f72 6d73 2863 7574  ct_waveforms(cut
-0001f6c0: 5f6f 7574 3d63 7574 5f6f 7574 290a 0a20  _out=cut_out).. 
-0001f6d0: 2020 2066 6f72 2073 7420 696e 2072 6563     for st in rec
-0001f6e0: 6765 6e2e 7370 696b 6574 7261 696e 733a  gen.spiketrains:
-0001f6f0: 0a20 2020 2020 2020 2077 6620 3d20 7374  .        wf = st
-0001f700: 2e77 6176 6566 6f72 6d73 0a20 2020 2020  .waveforms.     
-0001f710: 2020 2077 6176 6566 6f72 6d73 2e61 7070     waveforms.app
-0001f720: 656e 6428 7766 290a 2020 2020 6e5f 656c  end(wf).    n_el
-0001f730: 6563 203d 2077 6176 6566 6f72 6d73 5b30  ec = waveforms[0
-0001f740: 5d2e 7368 6170 655b 315d 0a0a 2020 2020  ].shape[1]..    
-0001f750: 6966 206e 5f70 6320 3d3d 2031 3a0a 2020  if n_pc == 1:.  
-0001f760: 2020 2020 2020 7063 5f64 696d 7320 3d20        pc_dims = 
-0001f770: 5b30 5d0a 2020 2020 656c 6966 206e 5f70  [0].    elif n_p
-0001f780: 6320 3e20 313a 0a20 2020 2020 2020 2070  c > 1:.        p
-0001f790: 635f 6469 6d73 203d 206e 702e 6172 616e  c_dims = np.aran
-0001f7a0: 6765 286e 5f70 6329 0a20 2020 2065 6c73  ge(n_pc).    els
-0001f7b0: 653a 0a20 2020 2020 2020 2070 635f 6469  e:.        pc_di
-0001f7c0: 6d73 203d 205b 305d 0a0a 2020 2020 6966  ms = [0]..    if
-0001f7d0: 206d 6178 5f65 6c65 6320 6973 206e 6f74   max_elec is not
-0001f7e0: 204e 6f6e 6520 616e 6420 6d61 785f 656c   None and max_el
-0001f7f0: 6563 203c 206e 5f65 6c65 633a 0a20 2020  ec < n_elec:.   
-0001f800: 2020 2020 2069 6620 6d61 785f 656c 6563       if max_elec
-0001f810: 203d 3d20 313a 0a20 2020 2020 2020 2020   == 1:.         
-0001f820: 2020 2065 6c65 635f 6469 6d73 203d 205b     elec_dims = [
-0001f830: 6e70 2e72 616e 646f 6d2e 7261 6e64 696e  np.random.randin
-0001f840: 7428 6e5f 656c 6563 295d 0a20 2020 2020  t(n_elec)].     
-0001f850: 2020 2065 6c69 6620 6d61 785f 656c 6563     elif max_elec
-0001f860: 203e 2031 3a0a 2020 2020 2020 2020 2020   > 1:.          
-0001f870: 2020 656c 6563 5f64 696d 7320 3d20 6e70    elec_dims = np
-0001f880: 2e72 616e 646f 6d2e 7065 726d 7574 6174  .random.permutat
-0001f890: 696f 6e28 6e70 2e61 7261 6e67 6528 6e5f  ion(np.arange(n_
-0001f8a0: 656c 6563 2929 5b3a 6d61 785f 656c 6563  elec))[:max_elec
-0001f8b0: 5d0a 2020 2020 2020 2020 656c 7365 3a0a  ].        else:.
-0001f8c0: 2020 2020 2020 2020 2020 2020 656c 6563              elec
-0001f8d0: 5f64 696d 7320 3d20 5b6e 702e 7261 6e64  _dims = [np.rand
-0001f8e0: 6f6d 2e72 616e 6469 6e74 286e 5f65 6c65  om.randint(n_ele
-0001f8f0: 6329 5d0a 2020 2020 656c 7365 3a0a 2020  c)].    else:.  
-0001f900: 2020 2020 2020 656c 6563 5f64 696d 7320        elec_dims 
-0001f910: 3d20 6e70 2e61 7261 6e67 6528 6e5f 656c  = np.arange(n_el
-0001f920: 6563 290a 0a20 2020 2066 6f72 2069 5f77  ec)..    for i_w
-0001f930: 2c20 7766 2069 6e20 656e 756d 6572 6174  , wf in enumerat
-0001f940: 6528 7761 7665 666f 726d 7329 3a0a 2020  e(waveforms):.  
-0001f950: 2020 2020 2020 2320 7766 5f72 6573 6861        # wf_resha
-0001f960: 7065 6420 3d20 7766 2e72 6573 6861 7065  ped = wf.reshape
-0001f970: 2828 7766 2e73 6861 7065 5b30 5d20 2a20  ((wf.shape[0] * 
-0001f980: 7766 2e73 6861 7065 5b31 5d2c 2077 662e  wf.shape[1], wf.
-0001f990: 7368 6170 655b 325d 2929 0a20 2020 2020  shape[2])).     
-0001f9a0: 2020 2077 665f 7265 7368 6170 6564 203d     wf_reshaped =
-0001f9b0: 2077 662e 7265 7368 6170 6528 2877 662e   wf.reshape((wf.
-0001f9c0: 7368 6170 655b 305d 202a 2077 662e 7368  shape[0] * wf.sh
-0001f9d0: 6170 655b 315d 2c20 7766 2e73 6861 7065  ape[1], wf.shape
-0001f9e0: 5b32 5d29 290a 2020 2020 2020 2020 6e5f  [2])).        n_
-0001f9f0: 7370 696b 6573 2e61 7070 656e 6428 6c65  spikes.append(le
-0001fa00: 6e28 7766 2920 2a20 6e5f 656c 6563 290a  n(wf) * n_elec).
-0001fa10: 0a20 2020 2020 2020 2069 6620 695f 7720  .        if i_w 
-0001fa20: 3d3d 2030 3a0a 2020 2020 2020 2020 2020  == 0:.          
-0001fa30: 2020 616c 6c5f 7761 7665 666f 726d 7320    all_waveforms 
-0001fa40: 3d20 7766 5f72 6573 6861 7065 640a 2020  = wf_reshaped.  
-0001fa50: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
-0001fa60: 2020 2020 2020 2020 616c 6c5f 7761 7665          all_wave
-0001fa70: 666f 726d 7320 3d20 6e70 2e76 7374 6163  forms = np.vstac
-0001fa80: 6b28 2861 6c6c 5f77 6176 6566 6f72 6d73  k((all_waveforms
-0001fa90: 2c20 7766 5f72 6573 6861 7065 6429 290a  , wf_reshaped)).
-0001faa0: 0a20 2020 2069 6620 7063 5f63 6f6d 7020  .    if pc_comp 
-0001fab0: 6973 204e 6f6e 653a 0a20 2020 2020 2020  is None:.       
-0001fac0: 2063 6f6d 7075 7465 5f70 6361 203d 2054   compute_pca = T
-0001fad0: 7275 650a 2020 2020 656c 6966 2070 635f  rue.    elif pc_
-0001fae0: 636f 6d70 2e73 6861 7065 203d 3d20 286e  comp.shape == (n
-0001faf0: 5f70 632c 2061 6c6c 5f77 6176 6566 6f72  _pc, all_wavefor
-0001fb00: 6d73 2e73 6861 7065 5b31 5d29 3a0a 2020  ms.shape[1]):.  
-0001fb10: 2020 2020 2020 636f 6d70 7574 655f 7063        compute_pc
-0001fb20: 6120 3d20 4661 6c73 650a 2020 2020 656c  a = False.    el
-0001fb30: 7365 3a0a 2020 2020 2020 2020 7072 696e  se:.        prin
-0001fb40: 7428 2227 7063 5f63 6f6d 7027 2068 6173  t("'pc_comp' has
-0001fb50: 2077 726f 6e67 2064 696d 656e 7369 6f6e   wrong dimension
-0001fb60: 732e 2052 6563 6f6d 7075 7469 6e67 2050  s. Recomputing P
-0001fb70: 4341 2229 0a20 2020 2020 2020 2063 6f6d  CA").        com
-0001fb80: 7075 7465 5f70 6361 203d 2054 7275 650a  pute_pca = True.
-0001fb90: 0a20 2020 2069 6620 636f 6d70 7574 655f  .    if compute_
-0001fba0: 7063 613a 0a20 2020 2020 2020 2070 7269  pca:.        pri
-0001fbb0: 6e74 2822 4669 7474 696e 6720 5043 4120  nt("Fitting PCA 
-0001fbc0: 6f66 2025 6420 6469 6d65 6e73 696f 6e73  of %d dimensions
-0001fbd0: 206f 6e20 2564 2077 6176 6566 6f72 6d73   on %d waveforms
-0001fbe0: 2220 2520 286e 5f70 632c 206c 656e 2861  " % (n_pc, len(a
-0001fbf0: 6c6c 5f77 6176 6566 6f72 6d73 2929 290a  ll_waveforms))).
-0001fc00: 0a20 2020 2020 2020 2070 6361 203d 2050  .        pca = P
-0001fc10: 4341 286e 5f63 6f6d 706f 6e65 6e74 733d  CA(n_components=
-0001fc20: 6e5f 7063 2c20 7768 6974 656e 3d77 6869  n_pc, whiten=whi
-0001fc30: 7465 6e29 0a20 2020 2020 2020 2023 2070  ten).        # p
-0001fc40: 6361 2e66 6974 5f74 7261 6e73 666f 726d  ca.fit_transform
-0001fc50: 2861 6c6c 5f77 6176 6566 6f72 6d73 290a  (all_waveforms).
-0001fc60: 2020 2020 2020 2020 7063 612e 6669 7428          pca.fit(
-0001fc70: 616c 6c5f 7761 7665 666f 726d 7329 0a20  all_waveforms). 
-0001fc80: 2020 2020 2020 2070 635f 636f 6d70 203d         pc_comp =
-0001fc90: 2070 6361 2e63 6f6d 706f 6e65 6e74 735f   pca.components_
-0001fca0: 0a0a 2020 2020 7063 615f 7363 6f72 6573  ..    pca_scores
-0001fcb0: 203d 205b 5d0a 2020 2020 666f 7220 7374   = [].    for st
-0001fcc0: 2069 6e20 7265 6367 656e 2e73 7069 6b65   in recgen.spike
-0001fcd0: 7472 6169 6e73 3a0a 2020 2020 2020 2020  trains:.        
-0001fce0: 7063 7420 3d20 6e70 2e64 6f74 2873 742e  pct = np.dot(st.
-0001fcf0: 7761 7665 666f 726d 732c 2070 635f 636f  waveforms, pc_co
-0001fd00: 6d70 2e54 290a 2020 2020 2020 2020 6966  mp.T).        if
-0001fd10: 2077 6869 7465 6e3a 0a20 2020 2020 2020   whiten:.       
-0001fd20: 2020 2020 2070 6374 202f 3d20 6e70 2e73       pct /= np.s
-0001fd30: 7172 7428 7063 612e 6578 706c 6169 6e65  qrt(pca.explaine
-0001fd40: 645f 7661 7269 616e 6365 5f29 0a20 2020  d_variance_).   
-0001fd50: 2020 2020 2070 6361 5f73 636f 7265 732e       pca_scores.
-0001fd60: 6170 7065 6e64 2870 6374 290a 0a20 2020  append(pct)..   
-0001fd70: 2069 6620 6178 2069 7320 4e6f 6e65 3a0a   if ax is None:.
-0001fd80: 2020 2020 2020 2020 6669 6720 3d20 706c          fig = pl
-0001fd90: 742e 6669 6775 7265 2829 0a20 2020 2020  t.figure().     
-0001fda0: 2020 2061 7820 3d20 6669 672e 6164 645f     ax = fig.add_
-0001fdb0: 7375 6270 6c6f 7428 3131 3129 0a20 2020  subplot(111).   
-0001fdc0: 2065 6c73 653a 0a20 2020 2020 2020 2066   else:.        f
-0001fdd0: 6967 203d 2061 782e 6765 745f 6669 6775  ig = ax.get_figu
-0001fde0: 7265 2829 0a20 2020 2061 782e 6178 6973  re().    ax.axis
-0001fdf0: 2827 6f66 6627 290a 0a20 2020 2069 6620  ('off')..    if 
-0001fe00: 636d 6170 2069 7320 6e6f 7420 4e6f 6e65  cmap is not None
-0001fe10: 3a0a 2020 2020 2020 2020 636d 203d 2070  :.        cm = p
-0001fe20: 6c74 2e67 6574 5f63 6d61 7028 636d 6170  lt.get_cmap(cmap
-0001fe30: 290a 2020 2020 2020 2020 636f 6c6f 7273  ).        colors
-0001fe40: 203d 205b 636d 2869 202f 206e 5f75 6e69   = [cm(i / n_uni
-0001fe50: 7473 2920 666f 7220 6920 696e 206e 702e  ts) for i in np.
-0001fe60: 6172 616e 6765 286e 5f75 6e69 7473 295d  arange(n_units)]
-0001fe70: 0a20 2020 2065 6c73 653a 0a20 2020 2020  .    else:.     
-0001fe80: 2020 2063 6f6c 6f72 7320 3d20 706c 742e     colors = plt.
-0001fe90: 7263 5061 7261 6d73 5b27 6178 6573 2e70  rcParams['axes.p
-0001fea0: 726f 705f 6379 636c 6527 5d2e 6279 5f6b  rop_cycle'].by_k
-0001feb0: 6579 2829 5b27 636f 6c6f 7227 5d0a 0a20  ey()['color'].. 
-0001fec0: 2020 206e 726f 7773 203d 206c 656e 2870     nrows = len(p
-0001fed0: 635f 6469 6d73 2920 2a20 6c65 6e28 656c  c_dims) * len(el
-0001fee0: 6563 5f64 696d 7329 0a20 2020 206e 636f  ec_dims).    nco
-0001fef0: 6c73 203d 206e 726f 7773 0a20 2020 2067  ls = nrows.    g
-0001ff00: 7320 3d20 6772 6964 7370 6563 2e47 7269  s = gridspec.Gri
-0001ff10: 6453 7065 6346 726f 6d53 7562 706c 6f74  dSpecFromSubplot
-0001ff20: 5370 6563 286e 726f 7773 2c20 6e63 6f6c  Spec(nrows, ncol
-0001ff30: 732c 2073 7562 706c 6f74 5f73 7065 633d  s, subplot_spec=
-0001ff40: 6178 290a 0a20 2020 2066 6f72 2070 3120  ax)..    for p1 
-0001ff50: 696e 2070 635f 6469 6d73 3a0a 2020 2020  in pc_dims:.    
-0001ff60: 2020 2020 666f 7220 6931 2c20 6368 3120      for i1, ch1 
-0001ff70: 696e 2065 6e75 6d65 7261 7465 2865 6c65  in enumerate(ele
-0001ff80: 635f 6469 6d73 293a 0a20 2020 2020 2020  c_dims):.       
-0001ff90: 2020 2020 2066 6f72 2070 3220 696e 2070       for p2 in p
-0001ffa0: 635f 6469 6d73 3a0a 2020 2020 2020 2020  c_dims:.        
-0001ffb0: 2020 2020 2020 2020 666f 7220 6932 2c20          for i2, 
-0001ffc0: 6368 3220 696e 2065 6e75 6d65 7261 7465  ch2 in enumerate
-0001ffd0: 2865 6c65 635f 6469 6d73 293a 0a20 2020  (elec_dims):.   
-0001ffe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001fff0: 2072 203d 206e 5f70 6320 2a20 6931 202b   r = n_pc * i1 +
-00020000: 2070 310a 2020 2020 2020 2020 2020 2020   p1.            
-00020010: 2020 2020 2020 2020 6320 3d20 6e5f 7063          c = n_pc
-00020020: 202a 2069 3220 2b20 7032 0a20 2020 2020   * i2 + p2.     
-00020030: 2020 2020 2020 2020 2020 2020 2020 2067                 g
-00020040: 735f 7365 6c20 3d20 6773 5b72 2c20 635d  s_sel = gs[r, c]
-00020050: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00020060: 2020 2020 2061 785f 7365 6c20 3d20 6669       ax_sel = fi
-00020070: 672e 6164 645f 7375 6270 6c6f 7428 6773  g.add_subplot(gs
-00020080: 5f73 656c 290a 2020 2020 2020 2020 2020  _sel).          
-00020090: 2020 2020 2020 2020 2020 6966 2063 203c            if c <
-000200a0: 2072 3a0a 2020 2020 2020 2020 2020 2020   r:.            
-000200b0: 2020 2020 2020 2020 2020 2020 6178 5f73              ax_s
-000200c0: 656c 2e61 7869 7328 276f 6666 2729 0a20  el.axis('off'). 
-000200d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000200e0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-000200f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00020100: 2069 6620 7220 3d3d 2030 3a0a 2020 2020   if r == 0:.    
-00020110: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00020120: 2020 2020 2020 2020 6178 5f73 656c 2e73          ax_sel.s
-00020130: 6574 5f78 6c61 6265 6c28 2743 682e 2720  et_xlabel('Ch.' 
-00020140: 2b20 7374 7228 6368 3220 2b20 3129 202b  + str(ch2 + 1) +
-00020150: 2027 3a50 4327 202b 2073 7472 2870 3220   ':PC' + str(p2 
-00020160: 2b20 3129 290a 2020 2020 2020 2020 2020  + 1)).          
-00020170: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00020180: 2020 6178 5f73 656c 2e78 6178 6973 2e73    ax_sel.xaxis.s
-00020190: 6574 5f6c 6162 656c 5f70 6f73 6974 696f  et_label_positio
-000201a0: 6e28 2774 6f70 2729 0a0a 2020 2020 2020  n('top')..      
-000201b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000201c0: 2020 6178 5f73 656c 2e73 6574 5f78 7469    ax_sel.set_xti
-000201d0: 636b 7328 5b5d 290a 2020 2020 2020 2020  cks([]).        
-000201e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000201f0: 6178 5f73 656c 2e73 6574 5f79 7469 636b  ax_sel.set_ytick
-00020200: 7328 5b5d 290a 2020 2020 2020 2020 2020  s([]).          
-00020210: 2020 2020 2020 2020 2020 2020 2020 6178                ax
-00020220: 5f73 656c 2e73 7069 6e65 735b 2772 6967  _sel.spines['rig
-00020230: 6874 275d 2e73 6574 5f76 6973 6962 6c65  ht'].set_visible
-00020240: 2846 616c 7365 290a 2020 2020 2020 2020  (False).        
-00020250: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00020260: 6178 5f73 656c 2e73 7069 6e65 735b 2774  ax_sel.spines['t
-00020270: 6f70 275d 2e73 6574 5f76 6973 6962 6c65  op'].set_visible
-00020280: 2846 616c 7365 290a 2020 2020 2020 2020  (False).        
-00020290: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000202a0: 666f 7220 692c 2070 6320 696e 2065 6e75  for i, pc in enu
-000202b0: 6d65 7261 7465 2870 6361 5f73 636f 7265  merate(pca_score
-000202c0: 7329 3a0a 2020 2020 2020 2020 2020 2020  s):.            
-000202d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000202e0: 6966 2069 3120 3d3d 2069 3220 616e 6420  if i1 == i2 and 
-000202f0: 7031 203d 3d20 7032 3a0a 2020 2020 2020  p1 == p2:.      
-00020300: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00020310: 2020 2020 2020 2020 2020 682c 2062 2c20            h, b, 
-00020320: 5f20 3d20 6178 5f73 656c 2e68 6973 7428  _ = ax_sel.hist(
-00020330: 7063 5b3a 2c20 6931 2c20 7031 5d2c 2062  pc[:, i1, p1], b
-00020340: 696e 733d 3530 2c20 616c 7068 613d 302e  ins=50, alpha=0.
-00020350: 362c 0a20 2020 2020 2020 2020 2020 2020  6,.             
-00020360: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00020370: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00020380: 2020 2020 2020 2020 2063 6f6c 6f72 3d63           color=c
-00020390: 6f6c 6f72 735b 695d 2c20 6465 6e73 6974  olors[i], densit
-000203a0: 793d 5472 7565 290a 2020 2020 2020 2020  y=True).        
-000203b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000203c0: 2020 2020 2020 2020 6178 5f73 656c 2e73          ax_sel.s
-000203d0: 6574 5f79 6c61 6265 6c28 2743 682e 2720  et_ylabel('Ch.' 
-000203e0: 2b20 7374 7228 6368 3120 2b20 3129 202b  + str(ch1 + 1) +
-000203f0: 2027 3a50 4327 202b 2073 7472 2870 3120   ':PC' + str(p1 
-00020400: 2b20 3129 290a 2020 2020 2020 2020 2020  + 1)).          
-00020410: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00020420: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
-00020430: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00020440: 2020 2020 2020 2020 6178 5f73 656c 2e70          ax_sel.p
-00020450: 6c6f 7428 7063 5b3a 2c20 6932 2c20 7032  lot(pc[:, i2, p2
-00020460: 5d2c 2070 635b 3a2c 2069 312c 2070 315d  ], pc[:, i1, p1]
-00020470: 2c20 6d61 726b 6572 3d27 6f27 2c0a 2020  , marker='o',.  
-00020480: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00020490: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000204a0: 2020 2020 2020 2020 2020 6d73 3d31 2c20            ms=1, 
-000204b0: 6c73 3d27 272c 2061 6c70 6861 3d30 2e35  ls='', alpha=0.5
-000204c0: 2c20 636f 6c6f 723d 636f 6c6f 7273 5b69  , color=colors[i
-000204d0: 5d29 0a0a 2020 2020 6669 672e 7375 6270  ])..    fig.subp
-000204e0: 6c6f 7473 5f61 646a 7573 7428 7773 7061  lots_adjust(wspa
-000204f0: 6365 3d30 2e30 322c 2068 7370 6163 653d  ce=0.02, hspace=
-00020500: 302e 3032 290a 2020 2020 7265 7475 726e  0.02).    return
-00020510: 2061 782c 2070 6361 5f73 636f 7265 732c   ax, pca_scores,
-00020520: 2070 635f 636f 6d70 0a0a 0a64 6566 2070   pc_comp...def p
-00020530: 6c6f 745f 6365 6c6c 5f64 7269 6674 7328  lot_cell_drifts(
-00020540: 7265 6367 656e 2c20 6178 3d4e 6f6e 6529  recgen, ax=None)
-00020550: 3a0a 2020 2020 2222 220a 2020 2020 506c  :.    """.    Pl
-00020560: 6f74 2064 7269 6674 696e 6720 706f 7369  ot drifting posi
-00020570: 7469 6f6e 7320 666f 7220 616c 6c20 6365  tions for all ce
-00020580: 6c6c 730a 0a20 2020 2050 6172 616d 6574  lls..    Paramet
-00020590: 6572 730a 2020 2020 2d2d 2d2d 2d2d 2d2d  ers.    --------
-000205a0: 2d2d 0a20 2020 2072 6563 6765 6e20 3a20  --.    recgen : 
-000205b0: 5265 636f 7264 696e 6747 656e 6572 6174  RecordingGenerat
-000205c0: 6f72 0a20 2020 2020 2020 2052 6563 6f72  or.        Recor
-000205d0: 6469 6e67 2067 656e 6572 6174 6f72 206f  ding generator o
-000205e0: 626a 6563 7420 0a20 2020 2061 7820 3a20  bject .    ax : 
-000205f0: 6178 6973 0a20 2020 2020 2020 204d 6174  axis.        Mat
-00020600: 706c 6f74 6c69 6220 2061 7869 730a 2020  plotlib  axis.  
-00020610: 2020 2020 2020 0a20 2020 2052 6574 7572        .    Retur
-00020620: 6e73 0a20 2020 202d 2d2d 2d2d 2d2d 0a20  ns.    -------. 
-00020630: 2020 2061 7820 3a20 6178 6973 0a20 2020     ax : axis.   
-00020640: 2020 2020 204d 6174 706c 6f74 6c69 6220       Matplotlib 
-00020650: 6178 6973 0a20 2020 2022 2222 0a20 2020  axis.    """.   
-00020660: 2069 6d70 6f72 7420 6d61 7470 6c6f 746c   import matplotl
-00020670: 6962 2e70 796c 6162 2061 7320 706c 740a  ib.pylab as plt.
-00020680: 2020 2020 0a20 2020 2069 6620 6178 2069      .    if ax i
-00020690: 7320 4e6f 6e65 3a0a 2020 2020 2020 2020  s None:.        
-000206a0: 6669 6720 3d20 706c 742e 6669 6775 7265  fig = plt.figure
-000206b0: 2829 0a20 2020 2020 2020 2061 7820 3d20  ().        ax = 
-000206c0: 6669 672e 6164 645f 7375 6270 6c6f 7428  fig.add_subplot(
-000206d0: 3131 3129 0a20 2020 2065 6c73 653a 0a20  111).    else:. 
-000206e0: 2020 2020 2020 2066 6967 203d 2061 782e         fig = ax.
-000206f0: 6765 745f 6669 6775 7265 2829 0a20 2020  get_figure().   
-00020700: 2061 7373 6572 7420 7265 6367 656e 2e64   assert recgen.d
-00020710: 7269 6674 5f6c 6973 7420 6973 206e 6f74  rift_list is not
-00020720: 204e 6f6e 652c 2022 4e6f 2064 7269 6674   None, "No drift
-00020730: 2069 6e66 6f20 6973 2061 7661 696c 6162   info is availab
-00020740: 6c65 220a 0a20 2020 2064 7269 6674 5f6c  le"..    drift_l
-00020750: 6973 7420 3d20 7265 6367 656e 2e64 7269  ist = recgen.dri
-00020760: 6674 5f6c 6973 740a 0a20 2020 2066 7320  ft_list..    fs 
-00020770: 3d20 7265 6367 656e 2e69 6e66 6f5b 2272  = recgen.info["r
-00020780: 6563 6f72 6469 6e67 7322 5d5b 2266 7322  ecordings"]["fs"
-00020790: 5d0a 0a20 2020 206c 6f63 6174 696f 6e73  ]..    locations
-000207a0: 203d 2072 6563 6765 6e2e 7465 6d70 6c61   = recgen.templa
-000207b0: 7465 5f6c 6f63 6174 696f 6e73 0a20 2020  te_locations.   
-000207c0: 2064 7269 6674 5f73 7465 7073 203d 206c   drift_steps = l
-000207d0: 6f63 6174 696f 6e73 2e73 6861 7065 5b31  ocations.shape[1
-000207e0: 5d0a 2020 2020 666f 7220 692c 2073 7420  ].    for i, st 
-000207f0: 696e 2065 6e75 6d65 7261 7465 2872 6563  in enumerate(rec
-00020800: 6765 6e2e 7370 696b 6574 7261 696e 7329  gen.spiketrains)
-00020810: 3a0a 2020 2020 2020 2020 7370 696b 655f  :.        spike_
-00020820: 696e 6469 6365 7320 3d20 2873 742e 6d61  indices = (st.ma
-00020830: 676e 6974 7564 6520 2a20 6673 292e 6173  gnitude * fs).as
-00020840: 7479 7065 2822 696e 7422 290a 2020 2020  type("int").    
-00020850: 2020 2020 6472 6966 745f 6964 7873 203d      drift_idxs =
-00020860: 2063 6f6d 7075 7465 5f64 7269 6674 5f69   compute_drift_i
-00020870: 6478 735f 6672 6f6d 5f64 7269 6674 5f6c  dxs_from_drift_l
-00020880: 6973 7428 692c 2073 7069 6b65 5f69 6e64  ist(i, spike_ind
-00020890: 6963 6573 2c20 6472 6966 745f 6c69 7374  ices, drift_list
-000208a0: 2c20 6673 290a 2020 2020 2020 2020 6472  , fs).        dr
-000208b0: 6966 745f 6964 7873 203d 2064 7269 6674  ift_idxs = drift
-000208c0: 5f69 6478 732e 636c 6970 2830 2c20 6472  _idxs.clip(0, dr
-000208d0: 6966 745f 7374 6570 7320 2d20 3129 0a20  ift_steps - 1). 
-000208e0: 2020 2020 2020 206c 6f63 203d 206c 6f63         loc = loc
-000208f0: 6174 696f 6e73 5b69 5d0a 2020 2020 2020  ations[i].      
-00020900: 2020 6472 6966 7469 6e67 203d 2046 616c    drifting = Fal
-00020910: 7365 0a20 2020 2020 2020 2069 6620 2264  se.        if "d
-00020920: 7269 6674 696e 6722 2069 6e20 7374 2e61  rifting" in st.a
-00020930: 6e6e 6f74 6174 696f 6e73 3a0a 2020 2020  nnotations:.    
-00020940: 2020 2020 2020 2020 6966 2073 742e 616e          if st.an
-00020950: 6e6f 7461 7469 6f6e 735b 2264 7269 6674  notations["drift
-00020960: 696e 6722 5d3a 0a20 2020 2020 2020 2020  ing"]:.         
-00020970: 2020 2020 2020 2064 7269 6674 696e 6720         drifting 
-00020980: 3d20 5472 7565 0a20 2020 2020 2020 2069  = True.        i
-00020990: 6620 6472 6966 7469 6e67 3a0a 2020 2020  f drifting:.    
-000209a0: 2020 2020 2020 2020 6c6f 635f 6472 6966          loc_drif
-000209b0: 7420 3d20 6c6f 635b 6472 6966 745f 6964  t = loc[drift_id
-000209c0: 7873 2c20 325d 0a20 2020 2020 2020 2065  xs, 2].        e
-000209d0: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
-000209e0: 206e 5f73 7465 7073 203d 206c 6f63 2e73   n_steps = loc.s
-000209f0: 6861 7065 5b30 5d0a 2020 2020 2020 2020  hape[0].        
-00020a00: 2020 2020 6c6f 635f 6472 6966 7420 3d20      loc_drift = 
-00020a10: 5b6c 6f63 5b6e 5f73 7465 7073 202f 2f20  [loc[n_steps // 
-00020a20: 322c 2032 5d5d 202a 206c 656e 2873 742e  2, 2]] * len(st.
-00020a30: 6d61 676e 6974 7564 6529 0a20 2020 2020  magnitude).     
-00020a40: 2020 2061 782e 706c 6f74 2873 742e 6d61     ax.plot(st.ma
-00020a50: 676e 6974 7564 652c 206c 6f63 5f64 7269  gnitude, loc_dri
-00020a60: 6674 2c20 6c61 6265 6c3d 6622 556e 6974  ft, label=f"Unit
-00020a70: 207b 697d 2229 0a20 2020 2061 782e 6c65   {i}").    ax.le
-00020a80: 6765 6e64 2829 0a20 2020 2072 6574 7572  gend().    retur
-00020a90: 6e20 6178 0a0a 0a23 2323 2323 2323 2323  n ax...#########
-00020aa0: 2048 454c 5045 5220 4655 4e43 5449 4f4e   HELPER FUNCTION
-00020ab0: 5320 2323 2323 2323 2323 230a 6465 6620  S #########.def 
-00020ac0: 5f72 6573 616d 706c 655f 7061 7261 6c6c  _resample_parall
-00020ad0: 656c 2869 2c20 7465 6d70 6c61 7465 2c20  el(i, template, 
-00020ae0: 7570 2c20 646f 776e 2c20 6472 6966 7469  up, down, drifti
-00020af0: 6e67 293a 0a20 2020 2022 2222 0a20 2020  ng):.    """.   
-00020b00: 2052 6573 616d 706c 6573 2061 2074 656d   Resamples a tem
-00020b10: 706c 6174 6520 746f 2061 2073 7065 6369  plate to a speci
-00020b20: 6669 6564 2073 616d 706c 696e 6720 6672  fied sampling fr
-00020b30: 6571 7565 6e63 792e 0a20 2020 2050 6172  equency..    Par
-00020b40: 616d 6574 6572 730a 2020 2020 2d2d 2d2d  ameters.    ----
-00020b50: 2d2d 2d2d 2d2d 0a20 2020 2074 656d 706c  ------.    templ
-00020b60: 6174 6520 3a20 6e70 2e61 7272 6179 0a20  ate : np.array. 
-00020b70: 2020 2020 2020 2041 7272 6179 2077 6974         Array wit
-00020b80: 6820 6f6e 6520 7465 6d70 6c61 7465 2028  h one template (
-00020b90: 6e5f 6368 616e 6e65 6c73 2c20 6e5f 7361  n_channels, n_sa
-00020ba0: 6d70 6c65 7329 206f 7220 286e 5f64 7269  mples) or (n_dri
-00020bb0: 6674 2c20 6e5f 6368 616e 6e65 6c73 2c20  ft, n_channels, 
-00020bc0: 6e5f 7361 6d70 6c65 7329 2069 6620 6472  n_samples) if dr
-00020bd0: 6966 7469 6e67 0a20 2020 2075 7020 3a20  ifting.    up : 
-00020be0: 666c 6f61 740a 2020 2020 2020 2020 5468  float.        Th
-00020bf0: 6520 6f72 6967 696e 616c 2073 616d 706c  e original sampl
-00020c00: 696e 6720 6672 6571 7565 6e63 7920 696e  ing frequency in
-00020c10: 2048 7a0a 2020 2020 646f 776e 203a 2066   Hz.    down : f
-00020c20: 6c6f 6174 0a20 2020 2020 2020 2054 6865  loat.        The
-00020c30: 206e 6577 2073 616d 706c 696e 6720 6672   new sampling fr
-00020c40: 6571 7565 6e63 7920 696e 2048 7a0a 2020  equency in Hz.  
-00020c50: 2020 6472 6966 7469 6e67 203a 2062 6f6f    drifting : boo
-00020c60: 6c0a 2020 2020 2020 2020 4966 2054 7275  l.        If Tru
-00020c70: 6520 7465 6d70 6c61 7465 7320 6172 6520  e templates are 
-00020c80: 6173 7375 6d65 6420 746f 2062 6520 6472  assumed to be dr
-00020c90: 6966 7469 6e67 0a20 2020 2052 6574 7572  ifting.    Retur
-00020ca0: 6e73 0a20 2020 202d 2d2d 2d2d 2d2d 0a20  ns.    -------. 
-00020cb0: 2020 2074 656d 706c 6174 655f 7273 203a     template_rs :
-00020cc0: 206e 702e 6172 7261 790a 2020 2020 2020   np.array.      
-00020cd0: 2020 4172 7261 7920 7769 7468 2072 6573    Array with res
-00020ce0: 616d 706c 6564 2074 656d 706c 6174 6520  ampled template 
-00020cf0: 286e 5f63 6861 6e6e 656c 732c 206e 5f72  (n_channels, n_r
-00020d00: 6573 616d 706c 6529 0a20 2020 2020 2020  esample).       
-00020d10: 206f 7220 286e 5f64 7269 6674 2c20 6e5f   or (n_drift, n_
-00020d20: 6368 616e 6e65 6c73 2c20 6e5f 7265 7361  channels, n_resa
-00020d30: 6d70 6c65 290a 2020 2020 2222 220a 2020  mple).    """.  
-00020d40: 2020 6966 206e 6f74 2064 7269 6674 696e    if not driftin
-00020d50: 673a 0a20 2020 2020 2020 2074 656d 5f70  g:.        tem_p
-00020d60: 6f6c 7920 3d20 7373 2e72 6573 616d 706c  oly = ss.resampl
-00020d70: 655f 706f 6c79 2874 656d 706c 6174 652c  e_poly(template,
-00020d80: 2075 702c 2064 6f77 6e2c 2061 7869 733d   up, down, axis=
-00020d90: 3129 0a20 2020 2065 6c73 653a 0a20 2020  1).    else:.   
-00020da0: 2020 2020 2074 656d 5f70 6f6c 7920 3d20       tem_poly = 
-00020db0: 7373 2e72 6573 616d 706c 655f 706f 6c79  ss.resample_poly
-00020dc0: 2874 656d 706c 6174 652c 2075 702c 2064  (template, up, d
-00020dd0: 6f77 6e2c 2061 7869 733d 3229 0a20 2020  own, axis=2).   
-00020de0: 2072 6574 7572 6e20 7465 6d5f 706f 6c79   return tem_poly
-00020df0: 0a0a 0a64 6566 205f 6a69 7474 6572 5f70  ...def _jitter_p
-00020e00: 6172 616c 6c65 6c28 692c 2074 656d 706c  arallel(i, templ
-00020e10: 6174 652c 2075 7073 616d 706c 652c 2066  ate, upsample, f
-00020e20: 732c 206e 5f6a 6974 7465 7273 2c20 6a69  s, n_jitters, ji
-00020e30: 7474 6572 2c20 6472 6966 7469 6e67 2c20  tter, drifting, 
-00020e40: 7665 7262 6f73 6529 3a0a 2020 2020 2222  verbose):.    ""
-00020e50: 220a 2020 2020 4164 6473 206a 6974 7465  ".    Adds jitte
-00020e60: 7265 6420 7265 706c 6963 6173 2074 6f20  red replicas to 
-00020e70: 6f6e 6520 7465 6d70 6c61 7465 2e0a 2020  one template..  
-00020e80: 2020 5061 7261 6d65 7465 7273 0a20 2020    Parameters.   
-00020e90: 202d 2d2d 2d2d 2d2d 2d2d 2d0a 2020 2020   ----------.    
-00020ea0: 7465 6d70 6c61 7465 203a 206e 702e 6172  template : np.ar
-00020eb0: 7261 790a 2020 2020 2020 2020 4172 7261  ray.        Arra
-00020ec0: 7920 7769 7468 2074 656d 706c 6174 6573  y with templates
-00020ed0: 2028 6e5f 6368 616e 6e65 6c73 2c20 6e5f   (n_channels, n_
-00020ee0: 7361 6d70 6c65 7329 206f 7220 286e 5f64  samples) or (n_d
-00020ef0: 7269 6674 2c20 6e5f 6368 616e 6e65 6c73  rift, n_channels
-00020f00: 2c20 6e5f 7361 6d70 6c65 7329 2069 6620  , n_samples) if 
-00020f10: 6472 6966 7469 6e67 0a20 2020 2075 7073  drifting.    ups
-00020f20: 616d 706c 6520 3a20 696e 740a 2020 2020  ample : int.    
-00020f30: 2020 2020 4661 6374 6f72 2066 6f72 2075      Factor for u
-00020f40: 7073 616d 706c 696e 6720 7468 6520 7465  psampling the te
-00020f50: 6d70 6c61 7465 730a 2020 2020 6e5f 6a69  mplates.    n_ji
-00020f60: 7474 6572 7320 3a20 696e 740a 2020 2020  tters : int.    
-00020f70: 2020 2020 4e75 6d62 6572 206f 6620 6a69      Number of ji
-00020f80: 7474 6572 6564 2063 6f70 6965 7320 666f  ttered copies fo
-00020f90: 7220 6561 6368 2074 656d 706c 6174 650a  r each template.
-00020fa0: 2020 2020 6a69 7474 6572 203a 2071 7561      jitter : qua
-00020fb0: 6e74 6974 790a 2020 2020 2020 2020 4a69  ntity.        Ji
-00020fc0: 7474 6572 2069 6e20 7469 6d65 2066 6f72  tter in time for
-00020fd0: 2073 6869 6674 696e 6720 7468 6520 7465   shifting the te
-00020fe0: 6d70 6c61 7465 0a20 2020 2064 7269 6674  mplate.    drift
-00020ff0: 696e 6720 3a20 626f 6f6c 0a20 2020 2020  ing : bool.     
-00021000: 2020 2049 6620 5472 7565 2074 656d 706c     If True templ
-00021010: 6174 6573 2061 7265 2061 7373 756d 6564  ates are assumed
-00021020: 2074 6f20 6265 2064 7269 6674 696e 670a   to be drifting.
-00021030: 2020 2020 7665 7262 6f73 6520 3a20 626f      verbose : bo
-00021040: 6f6c 0a20 2020 2020 2020 2049 6620 5472  ol.        If Tr
-00021050: 7565 206f 7574 7075 7420 6973 2076 6572  ue output is ver
-00021060: 626f 7365 0a20 2020 2052 6574 7572 6e73  bose.    Returns
-00021070: 0a20 2020 202d 2d2d 2d2d 2d2d 0a20 2020  .    -------.   
-00021080: 2074 656d 706c 6174 655f 6a69 7474 203a   template_jitt :
-00021090: 206e 702e 6172 7261 790a 2020 2020 2020   np.array.      
-000210a0: 2020 4172 7261 7920 7769 7468 206f 6e65    Array with one
-000210b0: 206a 6974 7465 7265 6420 7465 6d70 6c61   jittered templa
-000210c0: 7465 2028 6e5f 6a69 7474 6572 732c 206e  te (n_jitters, n
-000210d0: 5f63 6861 6e6e 656c 732c 206e 5f73 616d  _channels, n_sam
-000210e0: 706c 6573 290a 2020 2020 2020 2020 6f72  ples).        or
-000210f0: 2028 6e5f 6472 6966 742c 206e 5f6a 6974   (n_drift, n_jit
-00021100: 7465 7273 2c20 6e5f 6368 616e 6e65 6c73  ters, n_channels
-00021110: 2c20 6e5f 7361 6d70 6c65 7329 2069 6620  , n_samples) if 
-00021120: 6472 6966 7469 6e67 0a20 2020 2022 2222  drifting.    """
-00021130: 0a20 2020 2069 6620 6e6f 7420 6472 6966  .    if not drif
-00021140: 7469 6e67 3a0a 2020 2020 2020 2020 7465  ting:.        te
-00021150: 6d70 6c61 7465 735f 6a69 7474 6572 203d  mplates_jitter =
-00021160: 206e 702e 7a65 726f 7328 286e 5f6a 6974   np.zeros((n_jit
-00021170: 7465 7273 2c20 7465 6d70 6c61 7465 2e73  ters, template.s
-00021180: 6861 7065 5b30 5d2c 2074 656d 706c 6174  hape[0], templat
-00021190: 652e 7368 6170 655b 315d 2929 0a20 2020  e.shape[1])).   
-000211a0: 2020 2020 2074 656d 705f 7570 203d 2073       temp_up = s
-000211b0: 732e 7265 7361 6d70 6c65 5f70 6f6c 7928  s.resample_poly(
-000211c0: 7465 6d70 6c61 7465 2c20 7570 7361 6d70  template, upsamp
-000211d0: 6c65 2c20 312c 2061 7869 733d 3129 0a20  le, 1, axis=1). 
-000211e0: 2020 2020 2020 206e 7361 6d70 6c65 735f         nsamples_
-000211f0: 7570 203d 2074 656d 705f 7570 2e73 6861  up = temp_up.sha
-00021200: 7065 5b31 5d0a 2020 2020 2020 2020 666f  pe[1].        fo
-00021210: 7220 6e20 696e 206e 702e 6172 616e 6765  r n in np.arange
-00021220: 286e 5f6a 6974 7465 7273 293a 0a20 2020  (n_jitters):.   
-00021230: 2020 2020 2020 2020 2023 2061 6c69 676e           # align
-00021240: 2077 6176 6566 6f72 6d0a 2020 2020 2020   waveform.      
-00021250: 2020 2020 2020 7368 6966 7420 3d20 696e        shift = in
-00021260: 7428 286a 6974 7465 7220 2a20 286e 702e  t((jitter * (np.
-00021270: 7261 6e64 6f6d 2e72 616e 646f 6d28 2920  random.random() 
-00021280: 2d20 302e 3529 202a 2075 7073 616d 706c  - 0.5) * upsampl
-00021290: 6520 2a20 6673 292e 6d61 676e 6974 7564  e * fs).magnitud
-000212a0: 6529 0a20 2020 2020 2020 2020 2020 2069  e).            i
-000212b0: 6620 7368 6966 7420 3e20 303a 0a20 2020  f shift > 0:.   
-000212c0: 2020 2020 2020 2020 2020 2020 2074 5f6a               t_j
-000212d0: 6974 7420 3d20 6e70 2e70 6164 2874 656d  itt = np.pad(tem
-000212e0: 705f 7570 2c20 5b28 302c 2030 292c 2028  p_up, [(0, 0), (
-000212f0: 6e70 2e61 6273 2873 6869 6674 292c 2030  np.abs(shift), 0
-00021300: 295d 2c20 2763 6f6e 7374 616e 7427 295b  )], 'constant')[
-00021310: 3a2c 203a 6e73 616d 706c 6573 5f75 705d  :, :nsamples_up]
-00021320: 0a20 2020 2020 2020 2020 2020 2065 6c69  .            eli
-00021330: 6620 7368 6966 7420 3c20 303a 0a20 2020  f shift < 0:.   
-00021340: 2020 2020 2020 2020 2020 2020 2074 5f6a               t_j
-00021350: 6974 7420 3d20 6e70 2e70 6164 2874 656d  itt = np.pad(tem
-00021360: 705f 7570 2c20 5b28 302c 2030 292c 2028  p_up, [(0, 0), (
-00021370: 302c 206e 702e 6162 7328 7368 6966 7429  0, np.abs(shift)
-00021380: 295d 2c20 2763 6f6e 7374 616e 7427 295b  )], 'constant')[
-00021390: 3a2c 202d 6e73 616d 706c 6573 5f75 703a  :, -nsamples_up:
-000213a0: 5d0a 2020 2020 2020 2020 2020 2020 656c  ].            el
-000213b0: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-000213c0: 2020 2020 745f 6a69 7474 203d 2074 656d      t_jitt = tem
-000213d0: 705f 7570 0a20 2020 2020 2020 2020 2020  p_up.           
-000213e0: 2074 656d 705f 646f 776e 203d 2074 5f6a   temp_down = t_j
-000213f0: 6974 745b 3a2c 203a 3a75 7073 616d 706c  itt[:, ::upsampl
-00021400: 655d 0a20 2020 2020 2020 2020 2020 2074  e].            t
-00021410: 656d 706c 6174 6573 5f6a 6974 7465 725b  emplates_jitter[
-00021420: 6e5d 203d 2074 656d 705f 646f 776e 0a20  n] = temp_down. 
-00021430: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-00021440: 2069 6620 7665 7262 6f73 653a 0a20 2020   if verbose:.   
-00021450: 2020 2020 2020 2020 2070 7269 6e74 2827           print('
-00021460: 4a69 7474 6572 696e 673a 206e 6575 726f  Jittering: neuro
-00021470: 6e20 272c 2069 290a 2020 2020 2020 2020  n ', i).        
-00021480: 7465 6d70 6c61 7465 735f 6a69 7474 6572  templates_jitter
-00021490: 203d 206e 702e 7a65 726f 7328 2874 656d   = np.zeros((tem
-000214a0: 706c 6174 652e 7368 6170 655b 305d 2c20  plate.shape[0], 
-000214b0: 6e5f 6a69 7474 6572 732c 2074 656d 706c  n_jitters, templ
-000214c0: 6174 652e 7368 6170 655b 315d 2c20 7465  ate.shape[1], te
-000214d0: 6d70 6c61 7465 2e73 6861 7065 5b32 5d29  mplate.shape[2])
-000214e0: 290a 2020 2020 2020 2020 666f 7220 7470  ).        for tp
-000214f0: 2c20 7465 6d5f 7020 696e 2065 6e75 6d65  , tem_p in enume
-00021500: 7261 7465 2874 656d 706c 6174 6529 3a0a  rate(template):.
-00021510: 2020 2020 2020 2020 2020 2020 7465 6d70              temp
-00021520: 5f75 7020 3d20 7373 2e72 6573 616d 706c  _up = ss.resampl
-00021530: 655f 706f 6c79 2874 656d 5f70 2c20 7570  e_poly(tem_p, up
-00021540: 7361 6d70 6c65 2c20 312c 2061 7869 733d  sample, 1, axis=
-00021550: 3129 0a20 2020 2020 2020 2020 2020 206e  1).            n
-00021560: 7361 6d70 6c65 735f 7570 203d 2074 656d  samples_up = tem
-00021570: 705f 7570 2e73 6861 7065 5b31 5d0a 2020  p_up.shape[1].  
-00021580: 2020 2020 2020 2020 2020 666f 7220 6e20            for n 
-00021590: 696e 206e 702e 6172 616e 6765 286e 5f6a  in np.arange(n_j
-000215a0: 6974 7465 7273 293a 0a20 2020 2020 2020  itters):.       
-000215b0: 2020 2020 2020 2020 2023 2061 6c69 676e           # align
-000215c0: 2077 6176 6566 6f72 6d0a 2020 2020 2020   waveform.      
-000215d0: 2020 2020 2020 2020 2020 7368 6966 7420            shift 
-000215e0: 3d20 696e 7428 286a 6974 7465 7220 2a20  = int((jitter * 
-000215f0: 6e70 2e72 616e 646f 6d2e 7261 6e64 6e28  np.random.randn(
-00021600: 2920 2a20 7570 7361 6d70 6c65 202a 2066  ) * upsample * f
-00021610: 7329 2e6d 6167 6e69 7475 6465 290a 2020  s).magnitude).  
-00021620: 2020 2020 2020 2020 2020 2020 2020 6966                if
-00021630: 2073 6869 6674 203e 2030 3a0a 2020 2020   shift > 0:.    
-00021640: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021650: 745f 6a69 7474 203d 206e 702e 7061 6428  t_jitt = np.pad(
-00021660: 7465 6d70 5f75 702c 205b 2830 2c20 3029  temp_up, [(0, 0)
-00021670: 2c20 286e 702e 6162 7328 7368 6966 7429  , (np.abs(shift)
-00021680: 2c20 3029 5d2c 2027 636f 6e73 7461 6e74  , 0)], 'constant
-00021690: 2729 5b3a 2c20 3a6e 7361 6d70 6c65 735f  ')[:, :nsamples_
-000216a0: 7570 5d0a 2020 2020 2020 2020 2020 2020  up].            
-000216b0: 2020 2020 656c 6966 2073 6869 6674 203c      elif shift <
-000216c0: 2030 3a0a 2020 2020 2020 2020 2020 2020   0:.            
-000216d0: 2020 2020 2020 2020 745f 6a69 7474 203d          t_jitt =
-000216e0: 206e 702e 7061 6428 7465 6d70 5f75 702c   np.pad(temp_up,
-000216f0: 205b 2830 2c20 3029 2c20 2830 2c20 6e70   [(0, 0), (0, np
-00021700: 2e61 6273 2873 6869 6674 2929 5d2c 2027  .abs(shift))], '
-00021710: 636f 6e73 7461 6e74 2729 5b3a 2c20 2d6e  constant')[:, -n
-00021720: 7361 6d70 6c65 735f 7570 3a5d 0a20 2020  samples_up:].   
-00021730: 2020 2020 2020 2020 2020 2020 2065 6c73               els
-00021740: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-00021750: 2020 2020 2020 2074 5f6a 6974 7420 3d20         t_jitt = 
-00021760: 7465 6d70 5f75 700a 2020 2020 2020 2020  temp_up.        
-00021770: 2020 2020 2020 2020 7465 6d70 5f64 6f77          temp_dow
-00021780: 6e20 3d20 7373 2e64 6563 696d 6174 6528  n = ss.decimate(
-00021790: 745f 6a69 7474 2c20 7570 7361 6d70 6c65  t_jitt, upsample
-000217a0: 2c20 6178 6973 3d31 290a 2020 2020 2020  , axis=1).      
-000217b0: 2020 2020 2020 2020 2020 7465 6d70 6c61            templa
-000217c0: 7465 735f 6a69 7474 6572 5b74 702c 206e  tes_jitter[tp, n
-000217d0: 5d20 3d20 7465 6d70 5f64 6f77 6e0a 2020  ] = temp_down.  
-000217e0: 2020 7265 7475 726e 2074 656d 706c 6174    return templat
-000217f0: 6573 5f6a 6974 7465 720a 0a0a 6465 6620  es_jitter...def 
-00021800: 5f70 6164 5f70 6172 616c 6c65 6c28 692c  _pad_parallel(i,
-00021810: 2074 656d 706c 6174 652c 2070 6164 5f73   template, pad_s
-00021820: 616d 706c 6573 2c20 6472 6966 7469 6e67  amples, drifting
-00021830: 2c20 7665 7262 6f73 6529 3a0a 2020 2020  , verbose):.    
-00021840: 2222 220a 2020 2020 5061 6473 206f 6e65  """.    Pads one
-00021850: 2074 656d 706c 6174 6520 6f6e 2062 6f74   template on bot
-00021860: 6820 656e 6473 2e0a 2020 2020 5061 7261  h ends..    Para
-00021870: 6d65 7465 7273 0a20 2020 202d 2d2d 2d2d  meters.    -----
-00021880: 2d2d 2d2d 2d0a 2020 2020 7465 6d70 6c61  -----.    templa
-00021890: 7465 203a 206e 702e 6172 7261 790a 2020  te : np.array.  
-000218a0: 2020 2020 2020 4172 7261 7920 7769 7468        Array with
-000218b0: 2074 656d 706c 6174 6573 2028 6e5f 6368   templates (n_ch
-000218c0: 616e 6e65 6c73 2c20 6e5f 7361 6d70 6c65  annels, n_sample
-000218d0: 7329 206f 7220 286e 5f64 7269 6674 206e  s) or (n_drift n
-000218e0: 5f63 6861 6e6e 656c 732c 206e 5f73 616d  _channels, n_sam
-000218f0: 706c 6573 2920 6966 2064 7269 6674 696e  ples) if driftin
-00021900: 670a 2020 2020 7061 645f 7361 6d70 6c65  g.    pad_sample
-00021910: 7320 3a20 6c69 7374 0a20 2020 2020 2020  s : list.       
-00021920: 204c 6973 7420 6f66 2032 2069 6e74 7320   List of 2 ints 
-00021930: 7769 7468 206e 756d 6265 7220 6f66 2073  with number of s
-00021940: 616d 706c 6573 2066 6f72 2070 6164 6469  amples for paddi
-00021950: 6e67 2062 6566 6f72 6520 616e 6420 6166  ng before and af
-00021960: 7465 720a 2020 2020 6472 6966 7469 6e67  ter.    drifting
-00021970: 203a 2062 6f6f 6c0a 2020 2020 2020 2020   : bool.        
-00021980: 4966 2054 7275 6520 7465 6d70 6c61 7465  If True template
-00021990: 7320 6172 6520 6173 7375 6d65 6420 746f  s are assumed to
-000219a0: 2062 6520 6472 6966 7469 6e67 0a20 2020   be drifting.   
-000219b0: 2076 6572 626f 7365 203a 2062 6f6f 6c0a   verbose : bool.
-000219c0: 2020 2020 2020 2020 4966 2054 7275 6520          If True 
-000219d0: 6f75 7470 7574 2069 7320 7665 7262 6f73  output is verbos
-000219e0: 650a 2020 2020 5265 7475 726e 730a 2020  e.    Returns.  
-000219f0: 2020 2d2d 2d2d 2d2d 2d0a 2020 2020 7465    -------.    te
-00021a00: 6d70 6c61 7465 5f70 6164 203a 206e 702e  mplate_pad : np.
-00021a10: 6172 7261 790a 2020 2020 2020 2020 4172  array.        Ar
-00021a20: 7261 7920 7769 7468 2070 6164 6465 6420  ray with padded 
-00021a30: 7465 6d70 6c61 7465 2028 6e5f 6368 616e  template (n_chan
-00021a40: 6e65 6c73 2c20 6e5f 7061 6464 6564 5f73  nels, n_padded_s
-00021a50: 616d 706c 6529 0a20 2020 2020 2020 206f  ample).        o
-00021a60: 7220 286e 5f64 7269 6674 2c20 6e5f 6368  r (n_drift, n_ch
-00021a70: 616e 6e65 6c73 2c20 6e5f 7061 6464 6564  annels, n_padded
-00021a80: 5f73 616d 706c 6529 2069 6620 6472 6966  _sample) if drif
-00021a90: 7469 6e67 0a20 2020 2022 2222 0a20 2020  ting.    """.   
-00021aa0: 2069 6620 6e6f 7420 6472 6966 7469 6e67   if not drifting
-00021ab0: 3a0a 2020 2020 2020 2020 7465 6d5f 7061  :.        tem_pa
-00021ac0: 6420 3d20 6375 6269 635f 7061 6464 696e  d = cubic_paddin
-00021ad0: 6728 7465 6d70 6c61 7465 2c20 7061 645f  g(template, pad_
-00021ae0: 7361 6d70 6c65 7329 0a20 2020 2065 6c73  samples).    els
-00021af0: 653a 0a20 2020 2020 2020 2069 6620 7665  e:.        if ve
-00021b00: 7262 6f73 653a 0a20 2020 2020 2020 2020  rbose:.         
-00021b10: 2020 2070 7269 6e74 2827 5061 6464 696e     print('Paddin
-00021b20: 6720 6564 6765 733a 206e 6575 726f 6e20  g edges: neuron 
-00021b30: 272c 2069 290a 2020 2020 2020 2020 7061  ', i).        pa
-00021b40: 6464 6564 5f74 656d 706c 6174 655f 7361  dded_template_sa
-00021b50: 6d70 6c65 7320 3d20 7465 6d70 6c61 7465  mples = template
-00021b60: 2e73 6861 7065 5b2d 315d 202b 206e 702e  .shape[-1] + np.
-00021b70: 7375 6d28 7061 645f 7361 6d70 6c65 7329  sum(pad_samples)
-00021b80: 0a20 2020 2020 2020 2074 656d 5f70 6164  .        tem_pad
-00021b90: 203d 206e 702e 7a65 726f 7328 2874 656d   = np.zeros((tem
-00021ba0: 706c 6174 652e 7368 6170 655b 305d 2c20  plate.shape[0], 
-00021bb0: 7465 6d70 6c61 7465 2e73 6861 7065 5b31  template.shape[1
-00021bc0: 5d2c 2070 6164 6465 645f 7465 6d70 6c61  ], padded_templa
-00021bd0: 7465 5f73 616d 706c 6573 2929 0a20 2020  te_samples)).   
-00021be0: 2020 2020 2066 6f72 2074 702c 2074 656d       for tp, tem
-00021bf0: 5f70 2069 6e20 656e 756d 6572 6174 6528  _p in enumerate(
-00021c00: 7465 6d70 6c61 7465 293a 0a20 2020 2020  template):.     
-00021c10: 2020 2020 2020 2074 656d 5f70 6164 5b74         tem_pad[t
-00021c20: 705d 203d 2063 7562 6963 5f70 6164 6469  p] = cubic_paddi
-00021c30: 6e67 2874 656d 5f70 2c20 7061 645f 7361  ng(tem_p, pad_sa
-00021c40: 6d70 6c65 7329 0a20 2020 2072 6574 7572  mples).    retur
-00021c50: 6e20 7465 6d5f 7061 640a 0a0a 6465 6620  n tem_pad...def 
-00021c60: 5f61 6e6e 6f74 6174 655f 7061 7261 6c6c  _annotate_parall
-00021c70: 656c 2869 2c20 7374 5f69 2c20 7370 696b  el(i, st_i, spik
-00021c80: 6574 7261 696e 732c 2074 5f6a 6974 742c  etrains, t_jitt,
-00021c90: 206f 7665 726c 6170 7069 6e67 5f70 6169   overlapping_pai
-00021ca0: 7273 2c20 7665 7262 6f73 6529 3a0a 2020  rs, verbose):.  
-00021cb0: 2020 2222 220a 2020 2020 4865 6c70 6572    """.    Helper
-00021cc0: 2066 756e 6374 696f 6e20 746f 2061 6e6e   function to ann
-00021cd0: 6f74 6174 6520 7370 696b 6520 7472 6169  otate spike trai
-00021ce0: 6e73 2069 6e20 7061 7261 6c6c 656c 2e0a  ns in parallel..
-00021cf0: 2020 2020 5061 7261 6d65 7465 7273 0a20      Parameters. 
-00021d00: 2020 202d 2d2d 2d2d 2d2d 2d2d 2d0a 2020     ----------.  
-00021d10: 2020 6920 3a20 696e 740a 2020 2020 2020    i : int.      
-00021d20: 2020 496e 6465 7820 6f66 2073 7069 6b65    Index of spike
-00021d30: 2074 7261 696e 0a20 2020 2073 745f 6920   train.    st_i 
-00021d40: 3a20 6e65 6f2e 5370 696b 6554 7261 696e  : neo.SpikeTrain
-00021d50: 0a20 2020 2020 2020 2053 7069 6b65 2074  .        Spike t
-00021d60: 7261 696e 2074 6f20 6265 2070 726f 6365  rain to be proce
-00021d70: 7373 6564 0a20 2020 2073 7069 6b65 7472  ssed.    spiketr
-00021d80: 6169 6e73 203a 206c 6973 740a 2020 2020  ains : list.    
-00021d90: 2020 2020 4c69 7374 206f 6620 6e65 6f20      List of neo 
-00021da0: 7370 696b 6574 7261 696e 730a 2020 2020  spiketrains.    
-00021db0: 745f 6a69 7474 203a 2051 7561 6e74 6974  t_jitt : Quantit
-00021dc0: 790a 2020 2020 2020 2020 5469 6d65 206a  y.        Time j
-00021dd0: 6974 7465 7220 746f 2063 6f6e 7369 6465  itter to conside
-00021de0: 7220 6f76 6572 6c61 7070 696e 6720 7370  r overlapping sp
-00021df0: 696b 6573 2069 6e20 7469 6d65 2028 6465  ikes in time (de
-00021e00: 6661 756c 7420 3120 6d73 290a 2020 2020  fault 1 ms).    
-00021e10: 6f76 6572 6c61 7070 696e 675f 7061 6972  overlapping_pair
-00021e20: 7320 3a20 6e70 2e61 7272 6179 0a20 2020  s : np.array.   
-00021e30: 2020 2020 2041 7272 6179 2077 6974 6820       Array with 
-00021e40: 6f76 6572 6c61 7070 696e 6720 696e 666f  overlapping info
-00021e50: 726d 6174 696f 6e20 6265 7477 6565 6e20  rmation between 
-00021e60: 7370 696b 6520 7472 6169 6e73 2028 6e5f  spike trains (n_
-00021e70: 7370 696b 6574 7261 696e 732c 2032 290a  spiketrains, 2).
-00021e80: 2020 2020 7665 7262 6f73 6520 3a20 626f      verbose : bo
-00021e90: 6f6c 0a20 2020 2020 2020 2049 6620 5472  ol.        If Tr
-00021ea0: 7565 206f 7574 7075 7420 6973 2076 6572  ue output is ver
-00021eb0: 626f 7365 0a20 2020 2022 2222 0a20 2020  bose.    """.   
-00021ec0: 2069 6620 7665 7262 6f73 653a 0a20 2020   if verbose:.   
-00021ed0: 2020 2020 2070 7269 6e74 2827 416e 6e6f       print('Anno
-00021ee0: 7461 7469 6e67 206f 7665 726c 6170 7069  tating overlappi
-00021ef0: 6e67 2073 7069 6b65 2074 7261 696e 2027  ng spike train '
-00021f00: 2c20 6929 0a20 2020 206f 7665 7220 3d20  , i).    over = 
-00021f10: 6e70 2e61 7272 6179 285b 274e 4f4e 4527  np.array(['NONE'
-00021f20: 5d20 2a20 6c65 6e28 7374 5f69 2929 0a20  ] * len(st_i)). 
-00021f30: 2020 2066 6f72 2069 5f73 702c 2074 5f69     for i_sp, t_i
-00021f40: 2069 6e20 656e 756d 6572 6174 6528 7374   in enumerate(st
-00021f50: 5f69 293a 0a20 2020 2020 2020 2066 6f72  _i):.        for
-00021f60: 206a 2c20 7374 5f6a 2069 6e20 656e 756d   j, st_j in enum
-00021f70: 6572 6174 6528 7370 696b 6574 7261 696e  erate(spiketrain
-00021f80: 7329 3a0a 2020 2020 2020 2020 2020 2020  s):.            
-00021f90: 6966 2069 2021 3d20 6a3a 0a20 2020 2020  if i != j:.     
-00021fa0: 2020 2020 2020 2020 2020 2023 2066 696e             # fin
-00021fb0: 6420 6f76 6572 6c61 7070 696e 670a 2020  d overlapping.  
-00021fc0: 2020 2020 2020 2020 2020 2020 2020 6964                id
-00021fd0: 5f6f 7665 7220 3d20 6e70 2e77 6865 7265  _over = np.where
-00021fe0: 2828 7374 5f6a 203e 2074 5f69 202d 2074  ((st_j > t_i - t
-00021ff0: 5f6a 6974 7429 2026 2028 7374 5f6a 203c  _jitt) & (st_j <
-00022000: 2074 5f69 202b 2074 5f6a 6974 7429 295b   t_i + t_jitt))[
-00022010: 305d 0a20 2020 2020 2020 2020 2020 2020  0].             
-00022020: 2020 2069 6620 6e6f 7420 6e70 2e61 6e79     if not np.any
-00022030: 286f 7665 726c 6170 7069 6e67 5f70 6169  (overlapping_pai
-00022040: 7273 293a 0a20 2020 2020 2020 2020 2020  rs):.           
-00022050: 2020 2020 2020 2020 2069 6620 6c65 6e28           if len(
-00022060: 6964 5f6f 7665 7229 2021 3d20 303a 0a20  id_over) != 0:. 
-00022070: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022080: 2020 2020 2020 206f 7665 725b 695f 7370         over[i_sp
-00022090: 5d20 3d20 2754 4f27 0a20 2020 2020 2020  ] = 'TO'.       
-000220a0: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
-000220b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000220c0: 2020 2070 6169 7220 3d20 5b69 2c20 6a5d     pair = [i, j]
-000220d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000220e0: 2020 2020 2070 6169 725f 6920 3d20 5b6a       pair_i = [j
-000220f0: 2c20 695d 0a20 2020 2020 2020 2020 2020  , i].           
-00022100: 2020 2020 2020 2020 2069 6620 6e70 2e61           if np.a
-00022110: 6e79 285b 6e70 2e61 6c6c 2870 6169 7220  ny([np.all(pair 
-00022120: 3d3d 2070 2920 666f 7220 7020 696e 206f  == p) for p in o
-00022130: 7665 726c 6170 7069 6e67 5f70 6169 7273  verlapping_pairs
-00022140: 5d29 206f 7220 5c0a 2020 2020 2020 2020  ]) or \.        
-00022150: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022160: 2020 2020 6e70 2e61 6e79 285b 6e70 2e61      np.any([np.a
-00022170: 6c6c 2870 6169 725f 6920 3d3d 2070 2920  ll(pair_i == p) 
-00022180: 666f 7220 7020 696e 206f 7665 726c 6170  for p in overlap
-00022190: 7069 6e67 5f70 6169 7273 5d29 3a0a 2020  ping_pairs]):.  
-000221a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000221b0: 2020 2020 2020 6966 206c 656e 2869 645f        if len(id_
-000221c0: 6f76 6572 2920 213d 2030 3a0a 2020 2020  over) != 0:.    
-000221d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000221e0: 2020 2020 2020 2020 6f76 6572 5b69 5f73          over[i_s
-000221f0: 705d 203d 2027 5354 4f27 0a20 2020 2020  p] = 'STO'.     
-00022200: 2020 2020 2020 2020 2020 2020 2020 2065                 e
-00022210: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
-00022220: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-00022230: 6c65 6e28 6964 5f6f 7665 7229 2021 3d20  len(id_over) != 
-00022240: 303a 0a20 2020 2020 2020 2020 2020 2020  0:.             
-00022250: 2020 2020 2020 2020 2020 2020 2020 206f                 o
-00022260: 7665 725b 695f 7370 5d20 3d20 2754 4f27  ver[i_sp] = 'TO'
-00022270: 0a20 2020 206f 7665 725b 6f76 6572 203d  .    over[over =
-00022280: 3d20 274e 4f4e 4527 5d20 3d20 274e 4f27  = 'NONE'] = 'NO'
-00022290: 0a20 2020 2073 745f 692e 616e 6e6f 7461  .    st_i.annota
-000222a0: 7465 286f 7665 726c 6170 3d6f 7665 7229  te(overlap=over)
-000222b0: 0a20 2020 2072 6574 7572 6e20 7374 5f69  .    return st_i
-000222c0: 0a                                       .
+0001cf00: 2020 2074 2e6d 6561 6e28 6178 6973 3d30     t.mean(axis=0
+0001cf10: 292c 206d 6561 2c20 636f 6c6f 7273 3d63  ), mea, colors=c
+0001cf20: 6f6c 6f72 735b 6e70 2e6d 6f64 286e 2c20  olors[np.mod(n, 
+0001cf30: 6c65 6e28 636f 6c6f 7273 2929 5d2c 2061  len(colors))], a
+0001cf40: 783d 6178 2c20 2a2a 6b77 6172 6773 0a20  x=ax, **kwargs. 
+0001cf50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001cf60: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+0001cf70: 2020 2020 2020 2020 2020 2020 2065 6c73               els
+0001cf80: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+0001cf90: 2020 2020 2020 2020 2020 2069 6620 636d             if cm
+0001cfa0: 6170 2069 7320 4e6f 6e65 3a0a 2020 2020  ap is None:.    
+0001cfb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001cfc0: 2020 2020 2020 2020 636d 6170 203d 2022          cmap = "
+0001cfd0: 5265 6473 220a 2020 2020 2020 2020 2020  Reds".          
+0001cfe0: 2020 2020 2020 2020 2020 2020 2020 636d                cm
+0001cff0: 203d 2070 6c74 2e67 6574 5f63 6d61 7028   = plt.get_cmap(
+0001d000: 636d 6170 290a 2020 2020 2020 2020 2020  cmap).          
+0001d010: 2020 2020 2020 2020 2020 2020 2020 636f                co
+0001d020: 6c6f 7273 203d 205b 636d 2869 202f 2074  lors = [cm(i / t
+0001d030: 2e73 6861 7065 5b30 5d29 2066 6f72 2069  .shape[0]) for i
+0001d040: 2069 6e20 6e70 2e61 7261 6e67 6528 742e   in np.arange(t.
+0001d050: 7368 6170 655b 305d 295d 0a20 2020 2020  shape[0])].     
+0001d060: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d070: 2020 206d 752e 706c 6f74 5f6d 6561 5f72     mu.plot_mea_r
+0001d080: 6563 6f72 6469 6e67 2874 2c20 6d65 612c  ecording(t, mea,
+0001d090: 2063 6f6c 6f72 733d 636f 6c6f 7273 2c20   colors=colors, 
+0001d0a0: 6178 3d61 782c 202a 2a6b 7761 7267 7329  ax=ax, **kwargs)
+0001d0b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001d0c0: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+0001d0d0: 2020 2020 2020 2020 2020 206d 752e 706c             mu.pl
+0001d0e0: 6f74 5f6d 6561 5f72 6563 6f72 6469 6e67  ot_mea_recording
+0001d0f0: 2874 2c20 6d65 612c 2063 6f6c 6f72 733d  (t, mea, colors=
+0001d100: 636f 6c6f 7273 5b6e 702e 6d6f 6428 6e2c  colors[np.mod(n,
+0001d110: 206c 656e 2863 6f6c 6f72 7329 295d 2c20   len(colors))], 
+0001d120: 6178 3d61 782c 202a 2a6b 7761 7267 7329  ax=ax, **kwargs)
+0001d130: 0a20 2020 2065 6c73 653a 0a20 2020 2020  .    else:.     
+0001d140: 2020 2069 6620 6e5f 736f 7572 6365 7320     if n_sources 
+0001d150: 3e20 6e63 6f6c 733a 0a20 2020 2020 2020  > ncols:.       
+0001d160: 2020 2020 206e 726f 7773 203d 2069 6e74       nrows = int
+0001d170: 286e 702e 6365 696c 286c 656e 2874 656d  (np.ceil(len(tem
+0001d180: 706c 6174 655f 6964 7329 202f 206e 636f  plate_ids) / nco
+0001d190: 6c73 2929 0a20 2020 2020 2020 2065 6c73  ls)).        els
+0001d1a0: 653a 0a20 2020 2020 2020 2020 2020 206e  e:.            n
+0001d1b0: 726f 7773 203d 2031 0a20 2020 2020 2020  rows = 1.       
+0001d1c0: 2020 2020 206e 636f 6c73 203d 206e 5f73       ncols = n_s
+0001d1d0: 6f75 7263 6573 0a0a 2020 2020 2020 2020  ources..        
+0001d1e0: 6966 2063 6d61 7020 6973 206e 6f74 204e  if cmap is not N
+0001d1f0: 6f6e 653a 0a20 2020 2020 2020 2020 2020  one:.           
+0001d200: 2063 6d20 3d20 706c 742e 6765 745f 636d   cm = plt.get_cm
+0001d210: 6170 2863 6d61 7029 0a20 2020 2020 2020  ap(cmap).       
+0001d220: 2020 2020 2063 6f6c 6f72 7320 3d20 5b63       colors = [c
+0001d230: 6d28 6920 2f20 6c65 6e28 7465 6d70 6c61  m(i / len(templa
+0001d240: 7465 5f69 6473 2929 2066 6f72 2069 2069  te_ids)) for i i
+0001d250: 6e20 6e70 2e61 7261 6e67 6528 6c65 6e28  n np.arange(len(
+0001d260: 7465 6d70 6c61 7465 5f69 6473 2929 5d0a  template_ids))].
+0001d270: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+0001d280: 2020 2020 2020 2020 2020 636f 6c6f 7273            colors
+0001d290: 203d 2070 6c74 2e72 6350 6172 616d 735b   = plt.rcParams[
+0001d2a0: 2261 7865 732e 7072 6f70 5f63 7963 6c65  "axes.prop_cycle
+0001d2b0: 225d 2e62 795f 6b65 7928 295b 2263 6f6c  "].by_key()["col
+0001d2c0: 6f72 225d 0a0a 2020 2020 2020 2020 6773  or"]..        gs
+0001d2d0: 203d 2067 7269 6473 7065 632e 4772 6964   = gridspec.Grid
+0001d2e0: 5370 6563 4672 6f6d 5375 6270 6c6f 7453  SpecFromSubplotS
+0001d2f0: 7065 6328 6e72 6f77 732c 206e 636f 6c73  pec(nrows, ncols
+0001d300: 2c20 7375 6270 6c6f 745f 7370 6563 3d61  , subplot_spec=a
+0001d310: 7829 0a0a 2020 2020 2020 2020 666f 7220  x)..        for 
+0001d320: 695f 6e2c 206e 2069 6e20 656e 756d 6572  i_n, n in enumer
+0001d330: 6174 6528 7465 6d70 6c61 7465 5f69 6473  ate(template_ids
+0001d340: 293a 0a20 2020 2020 2020 2020 2020 2072  ):.            r
+0001d350: 203d 2069 5f6e 202f 2f20 6e63 6f6c 730a   = i_n // ncols.
+0001d360: 2020 2020 2020 2020 2020 2020 6320 3d20              c = 
+0001d370: 6e70 2e6d 6f64 2869 5f6e 2c20 6e63 6f6c  np.mod(i_n, ncol
+0001d380: 7329 0a20 2020 2020 2020 2020 2020 2067  s).            g
+0001d390: 735f 7365 6c20 3d20 6773 5b72 2c20 635d  s_sel = gs[r, c]
+0001d3a0: 0a20 2020 2020 2020 2020 2020 2061 785f  .            ax_
+0001d3b0: 7420 3d20 6669 672e 6164 645f 7375 6270  t = fig.add_subp
+0001d3c0: 6c6f 7428 6773 5f73 656c 290a 2020 2020  lot(gs_sel).    
+0001d3d0: 2020 2020 2020 2020 6966 2063 6d61 7020          if cmap 
+0001d3e0: 6973 206e 6f74 204e 6f6e 653a 0a20 2020  is not None:.   
+0001d3f0: 2020 2020 2020 2020 2020 2020 206d 752e               mu.
+0001d400: 706c 6f74 5f6d 6561 5f72 6563 6f72 6469  plot_mea_recordi
+0001d410: 6e67 2874 656d 706c 6174 6573 5b6e 5d2c  ng(templates[n],
+0001d420: 206d 6561 2c20 6178 3d61 785f 742c 2063   mea, ax=ax_t, c
+0001d430: 6f6c 6f72 733d 636f 6c6f 7273 5b69 5f6e  olors=colors[i_n
+0001d440: 5d2c 202a 2a6b 7761 7267 7329 0a20 2020  ], **kwargs).   
+0001d450: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
+0001d460: 2020 2020 2020 2020 2020 2020 2020 206d                 m
+0001d470: 752e 706c 6f74 5f6d 6561 5f72 6563 6f72  u.plot_mea_recor
+0001d480: 6469 6e67 2874 656d 706c 6174 6573 5b6e  ding(templates[n
+0001d490: 5d2c 206d 6561 2c20 6178 3d61 785f 742c  ], mea, ax=ax_t,
+0001d4a0: 2063 6f6c 6f72 733d 636f 6c6f 7273 5b6e   colors=colors[n
+0001d4b0: 702e 6d6f 6428 695f 6e2c 206c 656e 2863  p.mod(i_n, len(c
+0001d4c0: 6f6c 6f72 7329 295d 2c20 2a2a 6b77 6172  olors))], **kwar
+0001d4d0: 6773 290a 2020 2020 2020 2020 6178 2e61  gs).        ax.a
+0001d4e0: 7869 7328 226f 6666 2229 0a0a 2020 2020  xis("off")..    
+0001d4f0: 7265 7475 726e 2061 780a 0a0a 6465 6620  return ax...def 
+0001d500: 706c 6f74 5f72 6563 6f72 6469 6e67 7328  plot_recordings(
+0001d510: 0a20 2020 2072 6563 6765 6e2c 0a20 2020  .    recgen,.   
+0001d520: 2061 783d 4e6f 6e65 2c0a 2020 2020 7374   ax=None,.    st
+0001d530: 6172 745f 7469 6d65 3d4e 6f6e 652c 0a20  art_time=None,. 
+0001d540: 2020 2065 6e64 5f74 696d 653d 4e6f 6e65     end_time=None
+0001d550: 2c0a 2020 2020 6f76 6572 6c61 795f 7465  ,.    overlay_te
+0001d560: 6d70 6c61 7465 733d 4661 6c73 652c 0a20  mplates=False,. 
+0001d570: 2020 206e 5f74 656d 706c 6174 6573 3d4e     n_templates=N
+0001d580: 6f6e 652c 0a20 2020 206d 6178 5f63 6861  one,.    max_cha
+0001d590: 6e6e 656c 735f 7065 725f 7465 6d70 6c61  nnels_per_templa
+0001d5a0: 7465 3d31 362c 0a20 2020 2063 6d61 703d  te=16,.    cmap=
+0001d5b0: 4e6f 6e65 2c0a 2020 2020 7465 6d70 6c61  None,.    templa
+0001d5c0: 7465 735f 6c77 3d31 2c0a 2020 2020 2a2a  tes_lw=1,.    **
+0001d5d0: 6b77 6172 6773 2c0a 293a 0a20 2020 2022  kwargs,.):.    "
+0001d5e0: 2222 0a20 2020 2050 6c6f 7420 7265 636f  "".    Plot reco
+0001d5f0: 7264 696e 6773 2e0a 0a20 2020 2050 6172  rdings...    Par
+0001d600: 616d 6574 6572 730a 2020 2020 2d2d 2d2d  ameters.    ----
+0001d610: 2d2d 2d2d 2d2d 0a20 2020 2072 6563 6765  ------.    recge
+0001d620: 6e20 3a20 5265 636f 7264 696e 6747 656e  n : RecordingGen
+0001d630: 6572 6174 6f72 0a20 2020 2020 2020 2052  erator.        R
+0001d640: 6563 6f72 6469 6e67 2067 656e 6572 6174  ecording generat
+0001d650: 6f72 206f 626a 6563 7420 746f 2070 6c6f  or object to plo
+0001d660: 740a 2020 2020 6178 203a 2061 7869 730a  t.    ax : axis.
+0001d670: 2020 2020 2020 2020 4d61 7470 6c6f 746c          Matplotl
+0001d680: 6962 2020 6178 6973 0a20 2020 2073 7461  ib  axis.    sta
+0001d690: 7274 5f74 696d 6520 3a20 666c 6f61 740a  rt_time : float.
+0001d6a0: 2020 2020 2020 2020 5374 6172 7420 7469          Start ti
+0001d6b0: 6d65 2074 6f20 706c 6f74 2072 6563 6f72  me to plot recor
+0001d6c0: 6469 6e67 7320 696e 2073 0a20 2020 2065  dings in s.    e
+0001d6d0: 6e64 5f74 696d 6520 3a20 666c 6f61 740a  nd_time : float.
+0001d6e0: 2020 2020 2020 2020 456e 6420 7469 6d65          End time
+0001d6f0: 2074 6f20 706c 6f74 2072 6563 6f72 6469   to plot recordi
+0001d700: 6e67 7320 696e 2073 0a20 2020 206f 7665  ngs in s.    ove
+0001d710: 726c 6179 5f74 656d 706c 6174 6573 203a  rlay_templates :
+0001d720: 2062 6f6f 6c0a 2020 2020 2020 2020 4966   bool.        If
+0001d730: 2054 7275 652c 2074 656d 706c 6174 6573   True, templates
+0001d740: 2061 7265 206f 7665 726c 6169 6420 6f6e   are overlaid on
+0001d750: 2074 6865 2072 6563 6f72 6469 6e67 730a   the recordings.
+0001d760: 2020 2020 6e5f 7465 6d70 6c61 7465 7320      n_templates 
+0001d770: 3a20 696e 740a 2020 2020 2020 2020 4e75  : int.        Nu
+0001d780: 6d62 6572 206f 6620 7465 6d70 6c61 7465  mber of template
+0001d790: 7320 746f 206f 7665 726c 6179 2028 6966  s to overlay (if
+0001d7a0: 206f 7665 726c 6179 5f74 656d 706c 6174   overlay_templat
+0001d7b0: 6573 2069 7320 5472 7565 290a 2020 2020  es is True).    
+0001d7c0: 6d61 785f 6368 616e 6e65 6c73 5f70 6572  max_channels_per
+0001d7d0: 5f74 656d 706c 6174 6520 3a20 696e 740a  _template : int.
+0001d7e0: 2020 2020 2020 2020 4e75 6d62 6572 206f          Number o
+0001d7f0: 6620 6d61 7869 6d75 6d20 6368 616e 6e65  f maximum channe
+0001d800: 6c73 2069 6e20 7768 6963 6820 7468 6520  ls in which the 
+0001d810: 7465 6d70 6c61 7465 2069 7320 6f76 6572  template is over
+0001d820: 6c61 6964 0a20 2020 2063 6d61 7020 3a20  laid.    cmap : 
+0001d830: 6d61 7470 6c6f 746c 6962 2063 6f6c 6f72  matplotlib color
+0001d840: 6d61 700a 2020 2020 2020 2020 436f 6c6f  map.        Colo
+0001d850: 726d 6170 2074 6f20 6265 2075 7365 640a  rmap to be used.
+0001d860: 2020 2020 5265 7475 726e 730a 2020 2020      Returns.    
+0001d870: 2d2d 2d2d 2d2d 2d0a 2020 2020 6178 203a  -------.    ax :
+0001d880: 2061 7869 730a 2020 2020 2020 2020 4d61   axis.        Ma
+0001d890: 7470 6c6f 746c 6962 2061 7869 730a 2020  tplotlib axis.  
+0001d8a0: 2020 2222 220a 2020 2020 696d 706f 7274    """.    import
+0001d8b0: 206d 6174 706c 6f74 6c69 622e 7079 6c61   matplotlib.pyla
+0001d8c0: 6220 6173 2070 6c74 0a0a 2020 2020 7265  b as plt..    re
+0001d8d0: 636f 7264 696e 6773 203d 2072 6563 6765  cordings = recge
+0001d8e0: 6e2e 7265 636f 7264 696e 6773 0a20 2020  n.recordings.   
+0001d8f0: 206d 6561 203d 206d 752e 7265 7475 726e   mea = mu.return
+0001d900: 5f6d 6561 2869 6e66 6f3d 7265 6367 656e  _mea(info=recgen
+0001d910: 2e69 6e66 6f5b 2265 6c65 6374 726f 6465  .info["electrode
+0001d920: 7322 5d29 0a20 2020 2066 7320 3d20 7265  s"]).    fs = re
+0001d930: 6367 656e 2e69 6e66 6f5b 2272 6563 6f72  cgen.info["recor
+0001d940: 6469 6e67 7322 5d5b 2266 7322 5d0a 2020  dings"]["fs"].  
+0001d950: 2020 6966 2061 7820 6973 204e 6f6e 653a    if ax is None:
+0001d960: 0a20 2020 2020 2020 2066 6967 203d 2070  .        fig = p
+0001d970: 6c74 2e66 6967 7572 6528 290a 2020 2020  lt.figure().    
+0001d980: 2020 2020 6178 203d 2066 6967 2e61 6464      ax = fig.add
+0001d990: 5f73 7562 706c 6f74 2831 3131 290a 2020  _subplot(111).  
+0001d9a0: 2020 6966 2073 7461 7274 5f74 696d 6520    if start_time 
+0001d9b0: 6973 204e 6f6e 653a 0a20 2020 2020 2020  is None:.       
+0001d9c0: 2073 7461 7274 5f66 7261 6d65 203d 2030   start_frame = 0
+0001d9d0: 0a20 2020 2065 6c73 653a 0a20 2020 2020  .    else:.     
+0001d9e0: 2020 2073 7461 7274 5f66 7261 6d65 203d     start_frame =
+0001d9f0: 2069 6e74 2873 7461 7274 5f74 696d 6520   int(start_time 
+0001da00: 2a20 6673 290a 2020 2020 6966 2065 6e64  * fs).    if end
+0001da10: 5f74 696d 6520 6973 204e 6f6e 653a 0a20  _time is None:. 
+0001da20: 2020 2020 2020 2065 6e64 5f66 7261 6d65         end_frame
+0001da30: 203d 2072 6563 6f72 6469 6e67 732e 7368   = recordings.sh
+0001da40: 6170 655b 305d 0a20 2020 2065 6c73 653a  ape[0].    else:
+0001da50: 0a20 2020 2020 2020 2065 6e64 5f66 7261  .        end_fra
+0001da60: 6d65 203d 2069 6e74 2865 6e64 5f74 696d  me = int(end_tim
+0001da70: 6520 2a20 6673 290a 0a20 2020 2069 6620  e * fs)..    if 
+0001da80: 6d61 785f 6368 616e 6e65 6c73 5f70 6572  max_channels_per
+0001da90: 5f74 656d 706c 6174 6520 6973 204e 6f6e  _template is Non
+0001daa0: 653a 0a20 2020 2020 2020 206d 6178 5f63  e:.        max_c
+0001dab0: 6861 6e6e 656c 735f 7065 725f 7465 6d70  hannels_per_temp
+0001dac0: 6c61 7465 203d 206c 656e 2872 6563 6f72  late = len(recor
+0001dad0: 6469 6e67 7329 0a0a 2020 2020 6966 2022  dings)..    if "
+0001dae0: 7673 6361 6c65 2220 6e6f 7420 696e 206b  vscale" not in k
+0001daf0: 7761 7267 732e 6b65 7973 2829 3a0a 2020  wargs.keys():.  
+0001db00: 2020 2020 2020 6b77 6172 6773 5b22 7673        kwargs["vs
+0001db10: 6361 6c65 225d 203d 2031 2e35 202a 206e  cale"] = 1.5 * n
+0001db20: 702e 6d61 7828 6e70 2e61 6273 2872 6563  p.max(np.abs(rec
+0001db30: 6f72 6469 6e67 7329 290a 0a20 2020 206d  ordings))..    m
+0001db40: 752e 706c 6f74 5f6d 6561 5f72 6563 6f72  u.plot_mea_recor
+0001db50: 6469 6e67 2872 6563 6f72 6469 6e67 735b  ding(recordings[
+0001db60: 7374 6172 745f 6672 616d 653a 656e 645f  start_frame:end_
+0001db70: 6672 616d 652c 203a 5d2e 542c 206d 6561  frame, :].T, mea
+0001db80: 2c20 6178 3d61 782c 202a 2a6b 7761 7267  , ax=ax, **kwarg
+0001db90: 7329 0a0a 2020 2020 6966 206f 7665 726c  s)..    if overl
+0001dba0: 6179 5f74 656d 706c 6174 6573 3a0a 2020  ay_templates:.  
+0001dbb0: 2020 2020 2020 6966 2022 6c77 2220 696e        if "lw" in
+0001dbc0: 206b 7761 7267 732e 6b65 7973 2829 3a0a   kwargs.keys():.
+0001dbd0: 2020 2020 2020 2020 2020 2020 6b77 6172              kwar
+0001dbe0: 6773 5b22 6c77 225d 203d 2074 656d 706c  gs["lw"] = templ
+0001dbf0: 6174 6573 5f6c 770a 2020 2020 2020 2020  ates_lw.        
+0001dc00: 6673 203d 2072 6563 6765 6e2e 696e 666f  fs = recgen.info
+0001dc10: 5b22 7265 636f 7264 696e 6773 225d 5b22  ["recordings"]["
+0001dc20: 6673 225d 202a 2070 712e 487a 0a20 2020  fs"] * pq.Hz.   
+0001dc30: 2020 2020 2069 6620 6e5f 7465 6d70 6c61       if n_templa
+0001dc40: 7465 7320 6973 204e 6f6e 653a 0a20 2020  tes is None:.   
+0001dc50: 2020 2020 2020 2020 2074 656d 706c 6174           templat
+0001dc60: 655f 6964 7320 3d20 6e70 2e61 7261 6e67  e_ids = np.arang
+0001dc70: 6528 6c65 6e28 7265 6367 656e 2e74 656d  e(len(recgen.tem
+0001dc80: 706c 6174 6573 2929 0a20 2020 2020 2020  plates)).       
+0001dc90: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+0001dca0: 2020 2074 656d 706c 6174 655f 6964 7320     template_ids 
+0001dcb0: 3d20 6e70 2e72 616e 646f 6d2e 7065 726d  = np.random.perm
+0001dcc0: 7574 6174 696f 6e28 6c65 6e28 7265 6367  utation(len(recg
+0001dcd0: 656e 2e74 656d 706c 6174 6573 2929 5b3a  en.templates))[:
+0001dce0: 6e5f 7465 6d70 6c61 7465 735d 0a0a 2020  n_templates]..  
+0001dcf0: 2020 2020 2020 6375 745f 6f75 745f 7361        cut_out_sa
+0001dd00: 6d70 6c65 7320 3d20 5b0a 2020 2020 2020  mples = [.      
+0001dd10: 2020 2020 2020 696e 7428 2863 202b 2070        int((c + p
+0001dd20: 2920 2a20 6673 2e72 6573 6361 6c65 2822  ) * fs.rescale("
+0001dd30: 6b48 7a22 292e 6d61 676e 6974 7564 6529  kHz").magnitude)
+0001dd40: 0a20 2020 2020 2020 2020 2020 2066 6f72  .            for
+0001dd50: 2028 632c 2070 2920 696e 207a 6970 2872   (c, p) in zip(r
+0001dd60: 6563 6765 6e2e 696e 666f 5b22 7465 6d70  ecgen.info["temp
+0001dd70: 6c61 7465 7322 5d5b 2263 7574 5f6f 7574  lates"]["cut_out
+0001dd80: 225d 2c20 7265 6367 656e 2e69 6e66 6f5b  "], recgen.info[
+0001dd90: 2274 656d 706c 6174 6573 225d 5b22 7061  "templates"]["pa
+0001dda0: 645f 6c65 6e22 5d29 0a20 2020 2020 2020  d_len"]).       
+0001ddb0: 205d 0a0a 2020 2020 2020 2020 7370 696b   ]..        spik
+0001ddc0: 655f 6964 7873 203d 205b 5d0a 2020 2020  e_idxs = [].    
+0001ddd0: 2020 2020 666f 7220 7374 2069 6e20 7265      for st in re
+0001dde0: 6367 656e 2e73 7069 6b65 7472 6169 6e73  cgen.spiketrains
+0001ddf0: 3a0a 2020 2020 2020 2020 2020 2020 7370  :.            sp
+0001de00: 696b 655f 6964 7873 2e61 7070 656e 6428  ike_idxs.append(
+0001de10: 2873 742e 7469 6d65 7320 2a20 6673 292e  (st.times * fs).
+0001de20: 6d61 676e 6974 7564 652e 6173 7479 7065  magnitude.astype
+0001de30: 2822 696e 7422 2929 0a20 2020 2020 2020  ("int")).       
+0001de40: 206e 5f73 616d 706c 6573 203d 2072 6563   n_samples = rec
+0001de50: 6f72 6469 6e67 732e 7368 6170 655b 305d  ordings.shape[0]
+0001de60: 0a0a 2020 2020 2020 2020 6966 2063 6d61  ..        if cma
+0001de70: 7020 6973 206e 6f74 204e 6f6e 653a 0a20  p is not None:. 
+0001de80: 2020 2020 2020 2020 2020 2063 6d20 3d20             cm = 
+0001de90: 706c 742e 6765 745f 636d 6170 2863 6d61  plt.get_cmap(cma
+0001dea0: 7029 0a20 2020 2020 2020 2020 2020 2063  p).            c
+0001deb0: 6f6c 6f72 735f 7420 3d20 5b63 6d28 6920  olors_t = [cm(i 
+0001dec0: 2f20 6c65 6e28 7465 6d70 6c61 7465 5f69  / len(template_i
+0001ded0: 6473 2929 2066 6f72 2069 2069 6e20 6e70  ds)) for i in np
+0001dee0: 2e61 7261 6e67 6528 6c65 6e28 7465 6d70  .arange(len(temp
+0001def0: 6c61 7465 5f69 6473 2929 5d0a 2020 2020  late_ids))].    
+0001df00: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+0001df10: 2020 2020 2020 636f 6c6f 7273 5f74 203d        colors_t =
+0001df20: 2070 6c74 2e72 6350 6172 616d 735b 2261   plt.rcParams["a
+0001df30: 7865 732e 7072 6f70 5f63 7963 6c65 225d  xes.prop_cycle"]
+0001df40: 2e62 795f 6b65 7928 295b 2263 6f6c 6f72  .by_key()["color
+0001df50: 225d 0a20 2020 2020 2020 2069 5f63 6f6c  "].        i_col
+0001df60: 203d 2030 0a20 2020 2020 2020 2069 6620   = 0.        if 
+0001df70: 226c 7722 206e 6f74 2069 6e20 6b77 6172  "lw" not in kwar
+0001df80: 6773 2e6b 6579 7328 293a 0a20 2020 2020  gs.keys():.     
+0001df90: 2020 2020 2020 206b 7761 7267 735b 226c         kwargs["l
+0001dfa0: 7722 5d20 3d20 310a 2020 2020 2020 2020  w"] = 1.        
+0001dfb0: 6966 2022 636f 6c6f 7273 2220 696e 206b  if "colors" in k
+0001dfc0: 7761 7267 732e 6b65 7973 2829 3a0a 2020  wargs.keys():.  
+0001dfd0: 2020 2020 2020 2020 2020 6465 6c20 6b77            del kw
+0001dfe0: 6172 6773 5b22 636f 6c6f 7273 225d 0a0a  args["colors"]..
+0001dff0: 2020 2020 2020 2020 2320 666f 7220 692c          # for i,
+0001e000: 2028 7370 2c20 7429 2069 6e20 656e 756d   (sp, t) in enum
+0001e010: 6572 6174 6528 7a69 7028 7370 696b 655f  erate(zip(spike_
+0001e020: 6964 7873 2c20 7265 6367 656e 2e74 656d  idxs, recgen.tem
+0001e030: 706c 6174 6573 2929 3a0a 2020 2020 2020  plates)):.      
+0001e040: 2020 666f 7220 692c 2073 7020 696e 2065    for i, sp in e
+0001e050: 6e75 6d65 7261 7465 2873 7069 6b65 5f69  numerate(spike_i
+0001e060: 6478 7329 3a0a 2020 2020 2020 2020 2020  dxs):.          
+0001e070: 2020 6966 2069 2069 6e20 7465 6d70 6c61    if i in templa
+0001e080: 7465 5f69 6473 3a0a 2020 2020 2020 2020  te_ids:.        
+0001e090: 2020 2020 2020 2020 7465 6d70 6c61 7465          template
+0001e0a0: 203d 2072 6563 6765 6e2e 7465 6d70 6c61   = recgen.templa
+0001e0b0: 7465 735b 695d 0a0a 2020 2020 2020 2020  tes[i]..        
+0001e0c0: 2020 2020 2020 2020 7370 5f66 7261 6d65          sp_frame
+0001e0d0: 7320 3d20 7370 202a 2066 730a 0a20 2020  s = sp * fs..   
+0001e0e0: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+0001e0f0: 7265 6367 656e 2e64 7269 6674 5f6c 6973  recgen.drift_lis
+0001e100: 7420 6973 204e 6f6e 653a 0a20 2020 2020  t is None:.     
+0001e110: 2020 2020 2020 2020 2020 2020 2020 2064                 d
+0001e120: 7269 6674 5f69 6478 7320 3d20 4e6f 6e65  rift_idxs = None
+0001e130: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001e140: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+0001e150: 2020 2020 2020 2020 2020 2064 7269 6674             drift
+0001e160: 5f69 6478 7320 3d20 636f 6d70 7574 655f  _idxs = compute_
+0001e170: 6472 6966 745f 6964 7873 5f66 726f 6d5f  drift_idxs_from_
+0001e180: 6472 6966 745f 6c69 7374 2869 2c20 7370  drift_list(i, sp
+0001e190: 5f66 7261 6d65 732c 2072 6563 6765 6e2e  _frames, recgen.
+0001e1a0: 6472 6966 745f 6c69 7374 2c20 6673 290a  drift_list, fs).
+0001e1b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001e1c0: 7265 635f 7420 3d20 636f 6e76 6f6c 7665  rec_t = convolve
+0001e1d0: 5f74 656d 706c 6174 6573 5f73 7069 6b65  _templates_spike
+0001e1e0: 7472 6169 6e73 280a 2020 2020 2020 2020  trains(.        
+0001e1f0: 2020 2020 2020 2020 2020 2020 692c 0a20              i,. 
+0001e200: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001e210: 2020 2073 702c 0a20 2020 2020 2020 2020     sp,.         
+0001e220: 2020 2020 2020 2020 2020 2074 656d 706c             templ
+0001e230: 6174 652c 0a20 2020 2020 2020 2020 2020  ate,.           
+0001e240: 2020 2020 2020 2020 206e 5f73 616d 706c           n_sampl
+0001e250: 6573 2c0a 2020 2020 2020 2020 2020 2020  es,.            
+0001e260: 2020 2020 2020 2020 6d61 785f 6368 616e          max_chan
+0001e270: 6e65 6c73 5f70 6572 5f74 656d 706c 6174  nels_per_templat
+0001e280: 653d 6d61 785f 6368 616e 6e65 6c73 5f70  e=max_channels_p
+0001e290: 6572 5f74 656d 706c 6174 652c 0a20 2020  er_template,.   
+0001e2a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001e2b0: 2063 7574 5f6f 7574 3d63 7574 5f6f 7574   cut_out=cut_out
+0001e2c0: 5f73 616d 706c 6573 2c0a 2020 2020 2020  _samples,.      
+0001e2d0: 2020 2020 2020 2020 2020 2020 2020 6472                dr
+0001e2e0: 6966 745f 6964 7873 3d64 7269 6674 5f69  ift_idxs=drift_i
+0001e2f0: 6478 732c 0a20 2020 2020 2020 2020 2020  dxs,.           
+0001e300: 2020 2020 2029 2e54 0a0a 2020 2020 2020       ).T..      
+0001e310: 2020 2020 2020 2020 2020 7265 635f 745b            rec_t[
+0001e320: 6e70 2e61 6273 2872 6563 5f74 2920 3c20  np.abs(rec_t) < 
+0001e330: 3165 2d34 5d20 3d20 6e70 2e6e 616e 0a20  1e-4] = np.nan. 
+0001e340: 2020 2020 2020 2020 2020 2020 2020 206d                 m
+0001e350: 752e 706c 6f74 5f6d 6561 5f72 6563 6f72  u.plot_mea_recor
+0001e360: 6469 6e67 280a 2020 2020 2020 2020 2020  ding(.          
+0001e370: 2020 2020 2020 2020 2020 7265 635f 745b            rec_t[
+0001e380: 3a2c 2073 7461 7274 5f66 7261 6d65 3a65  :, start_frame:e
+0001e390: 6e64 5f66 7261 6d65 5d2c 206d 6561 2c20  nd_frame], mea, 
+0001e3a0: 6178 3d61 782c 2063 6f6c 6f72 733d 636f  ax=ax, colors=co
+0001e3b0: 6c6f 7273 5f74 5b6e 702e 6d6f 6428 695f  lors_t[np.mod(i_
+0001e3c0: 636f 6c2c 206c 656e 2863 6f6c 6f72 735f  col, len(colors_
+0001e3d0: 7429 295d 2c20 2a2a 6b77 6172 6773 0a20  t))], **kwargs. 
+0001e3e0: 2020 2020 2020 2020 2020 2020 2020 2029                 )
+0001e3f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001e400: 2069 5f63 6f6c 202b 3d20 310a 2020 2020   i_col += 1.    
+0001e410: 2020 2020 2020 2020 2020 2020 6465 6c20              del 
+0001e420: 7265 635f 740a 2020 2020 7265 7475 726e  rec_t.    return
+0001e430: 2061 780a 0a0a 6465 6620 706c 6f74 5f77   ax...def plot_w
+0001e440: 6176 6566 6f72 6d73 280a 2020 2020 7265  aveforms(.    re
+0001e450: 6367 656e 2c20 7370 696b 6574 7261 696e  cgen, spiketrain
+0001e460: 5f69 643d 4e6f 6e65 2c20 6178 3d4e 6f6e  _id=None, ax=Non
+0001e470: 652c 2063 6f6c 6f72 3d4e 6f6e 652c 2063  e, color=None, c
+0001e480: 6d61 703d 4e6f 6e65 2c20 656c 6563 7472  map=None, electr
+0001e490: 6f64 653d 4e6f 6e65 2c20 6d61 785f 7761  ode=None, max_wa
+0001e4a0: 7665 666f 726d 733d 4e6f 6e65 2c20 6e63  veforms=None, nc
+0001e4b0: 6f6c 733d 362c 2063 7574 5f6f 7574 3d32  ols=6, cut_out=2
+0001e4c0: 0a29 3a0a 2020 2020 2222 220a 2020 2020  .):.    """.    
+0001e4d0: 506c 6f74 2077 6176 6566 6f72 6d73 206f  Plot waveforms o
+0001e4e0: 6620 6120 7370 696b 6520 7472 6169 6e2e  f a spike train.
+0001e4f0: 0a0a 2020 2020 5061 7261 6d65 7465 7273  ..    Parameters
+0001e500: 0a20 2020 202d 2d2d 2d2d 2d2d 2d2d 2d0a  .    ----------.
+0001e510: 2020 2020 7265 6367 656e 203a 2052 6563      recgen : Rec
+0001e520: 6f72 6469 6e67 4765 6e65 7261 746f 720a  ordingGenerator.
+0001e530: 2020 2020 2020 2020 5265 636f 7264 696e          Recordin
+0001e540: 6720 6765 6e65 7261 746f 7220 6f62 6a65  g generator obje
+0001e550: 6374 2074 6f20 706c 6f74 2073 7069 6b65  ct to plot spike
+0001e560: 2074 7261 696e 2077 6176 6566 6f72 6d20   train waveform 
+0001e570: 6672 6f6d 0a20 2020 2073 7069 6b65 7472  from.    spiketr
+0001e580: 6169 6e5f 6964 203a 2069 6e74 206f 7220  ain_id : int or 
+0001e590: 6c69 7374 0a20 2020 2020 2020 2049 6e64  list.        Ind
+0001e5a0: 6578 6573 206f 6620 7370 696b 6520 7472  exes of spike tr
+0001e5b0: 6169 6e73 0a20 2020 2061 7820 3a20 6178  ains.    ax : ax
+0001e5c0: 6973 0a20 2020 2020 2020 204d 6174 706c  is.        Matpl
+0001e5d0: 6f74 6c69 6220 2061 7869 730a 2020 2020  otlib  axis.    
+0001e5e0: 636f 6c6f 7220 3a20 6d61 7470 6c6f 746c  color : matplotl
+0001e5f0: 6962 2063 6f6c 6f72 0a20 2020 2020 2020  ib color.       
+0001e600: 2043 6f6c 6f72 206f 6620 7468 6520 7761   Color of the wa
+0001e610: 7665 666f 726d 730a 2020 2020 636d 6170  veforms.    cmap
+0001e620: 203a 206d 6174 706c 6f74 6c69 6220 636f   : matplotlib co
+0001e630: 6c6f 726d 6170 0a20 2020 2020 2020 2043  lormap.        C
+0001e640: 6f6c 6f72 6d61 7020 746f 2062 6520 7573  olormap to be us
+0001e650: 6564 0a20 2020 2065 6c65 6374 726f 6465  ed.    electrode
+0001e660: 203a 2069 6e74 206f 7220 276d 6178 270a   : int or 'max'.
+0001e670: 2020 2020 2020 2020 456c 6563 7472 6f64          Electrod
+0001e680: 6520 6964 206f 7220 276d 6178 270a 2020  e id or 'max'.  
+0001e690: 2020 6e63 6f6c 7320 3a20 2069 6e74 0a20    ncols :  int. 
+0001e6a0: 2020 2020 2020 204e 756d 6265 7220 6f66         Number of
+0001e6b0: 2063 6f6c 756d 6e73 2066 6f72 2073 7562   columns for sub
+0001e6c0: 706c 6f74 730a 2020 2020 6375 745f 6f75  plots.    cut_ou
+0001e6d0: 7420 3a20 666c 6f61 7420 6f72 206c 6973  t : float or lis
+0001e6e0: 740a 2020 2020 2020 2020 4375 7420 6f75  t.        Cut ou
+0001e6f0: 7473 2069 6e20 6d73 2066 6f72 2077 6176  ts in ms for wav
+0001e700: 6566 6f72 6d73 2028 6966 206e 6f74 2063  eforms (if not c
+0001e710: 6f6d 7075 7465 6429 2e20 4966 2066 6c6f  omputed). If flo
+0001e720: 6174 2074 6865 2063 7574 206f 7574 2069  at the cut out i
+0001e730: 7320 7379 6d6d 6574 7269 6361 6c2e 0a0a  s symmetrical...
+0001e740: 2020 2020 5265 7475 726e 730a 2020 2020      Returns.    
+0001e750: 2d2d 2d2d 2d2d 2d0a 2020 2020 6178 203a  -------.    ax :
+0001e760: 2061 7869 730a 2020 2020 2020 2020 4d61   axis.        Ma
+0001e770: 7470 6c6f 746c 6962 2061 7869 730a 0a20  tplotlib axis.. 
+0001e780: 2020 2022 2222 0a20 2020 2069 6d70 6f72     """.    impor
+0001e790: 7420 6d61 7470 6c6f 746c 6962 2e67 7269  t matplotlib.gri
+0001e7a0: 6473 7065 6320 6173 2067 7269 6473 7065  dspec as gridspe
+0001e7b0: 630a 2020 2020 696d 706f 7274 206d 6174  c.    import mat
+0001e7c0: 706c 6f74 6c69 622e 7079 6c61 6220 6173  plotlib.pylab as
+0001e7d0: 2070 6c74 0a0a 2020 2020 6966 2073 7069   plt..    if spi
+0001e7e0: 6b65 7472 6169 6e5f 6964 2069 7320 4e6f  ketrain_id is No
+0001e7f0: 6e65 3a0a 2020 2020 2020 2020 7370 696b  ne:.        spik
+0001e800: 6574 7261 696e 5f69 6420 3d20 6e70 2e61  etrain_id = np.a
+0001e810: 7261 6e67 6528 6c65 6e28 7265 6367 656e  range(len(recgen
+0001e820: 2e73 7069 6b65 7472 6169 6e73 2929 0a20  .spiketrains)). 
+0001e830: 2020 2065 6c69 6620 6973 696e 7374 616e     elif isinstan
+0001e840: 6365 2873 7069 6b65 7472 6169 6e5f 6964  ce(spiketrain_id
+0001e850: 2c20 2869 6e74 2c20 6e70 2e69 6e74 6567  , (int, np.integ
+0001e860: 6572 2929 3a0a 2020 2020 2020 2020 7370  er)):.        sp
+0001e870: 696b 6574 7261 696e 5f69 6420 3d20 5b73  iketrain_id = [s
+0001e880: 7069 6b65 7472 6169 6e5f 6964 5d0a 0a20  piketrain_id].. 
+0001e890: 2020 206e 5f75 6e69 7473 203d 206c 656e     n_units = len
+0001e8a0: 2873 7069 6b65 7472 6169 6e5f 6964 290a  (spiketrain_id).
+0001e8b0: 0a20 2020 2077 6176 6566 6f72 6d73 203d  .    waveforms =
+0001e8c0: 205b 5d0a 2020 2020 666f 7220 7370 2069   [].    for sp i
+0001e8d0: 6e20 7370 696b 6574 7261 696e 5f69 643a  n spiketrain_id:
+0001e8e0: 0a20 2020 2020 2020 2077 6620 3d20 7265  .        wf = re
+0001e8f0: 6367 656e 2e73 7069 6b65 7472 6169 6e73  cgen.spiketrains
+0001e900: 5b73 705d 2e77 6176 6566 6f72 6d73 0a20  [sp].waveforms. 
+0001e910: 2020 2020 2020 2069 6620 7766 2069 7320         if wf is 
+0001e920: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
+0001e930: 2020 6673 203d 2072 6563 6765 6e2e 696e    fs = recgen.in
+0001e940: 666f 5b22 7265 636f 7264 696e 6773 225d  fo["recordings"]
+0001e950: 5b22 6673 225d 202a 2070 712e 487a 0a20  ["fs"] * pq.Hz. 
+0001e960: 2020 2020 2020 2020 2020 2065 7874 7261             extra
+0001e970: 6374 5f77 6628 5b72 6563 6765 6e2e 7370  ct_wf([recgen.sp
+0001e980: 696b 6574 7261 696e 735b 7370 5d5d 2c20  iketrains[sp]], 
+0001e990: 7265 6367 656e 2e72 6563 6f72 6469 6e67  recgen.recording
+0001e9a0: 732c 2066 732c 2063 7574 5f6f 7574 3d63  s, fs, cut_out=c
+0001e9b0: 7574 5f6f 7574 290a 2020 2020 2020 2020  ut_out).        
+0001e9c0: 2020 2020 7766 203d 2072 6563 6765 6e2e      wf = recgen.
+0001e9d0: 7370 696b 6574 7261 696e 735b 7370 5d2e  spiketrains[sp].
+0001e9e0: 7761 7665 666f 726d 730a 2020 2020 2020  waveforms.      
+0001e9f0: 2020 7761 7665 666f 726d 732e 6170 7065    waveforms.appe
+0001ea00: 6e64 2877 6629 0a0a 2020 2020 6d65 6120  nd(wf)..    mea 
+0001ea10: 3d20 6d75 2e72 6574 7572 6e5f 6d65 6128  = mu.return_mea(
+0001ea20: 696e 666f 3d72 6563 6765 6e2e 696e 666f  info=recgen.info
+0001ea30: 5b22 656c 6563 7472 6f64 6573 225d 290a  ["electrodes"]).
+0001ea40: 2020 2020 6966 206d 6178 5f77 6176 6566      if max_wavef
+0001ea50: 6f72 6d73 2069 7320 6e6f 7420 4e6f 6e65  orms is not None
+0001ea60: 3a0a 2020 2020 2020 2020 666f 7220 692c  :.        for i,
+0001ea70: 2077 6620 696e 2065 6e75 6d65 7261 7465   wf in enumerate
+0001ea80: 2877 6176 6566 6f72 6d73 293a 0a20 2020  (waveforms):.   
+0001ea90: 2020 2020 2020 2020 2069 6620 6c65 6e28           if len(
+0001eaa0: 7766 2920 3e20 6d61 785f 7761 7665 666f  wf) > max_wavefo
+0001eab0: 726d 733a 0a20 2020 2020 2020 2020 2020  rms:.           
+0001eac0: 2020 2020 2077 6176 6566 6f72 6d73 5b69       waveforms[i
+0001ead0: 5d20 3d20 7766 5b6e 702e 7261 6e64 6f6d  ] = wf[np.random
+0001eae0: 2e70 6572 6d75 7461 7469 6f6e 286c 656e  .permutation(len
+0001eaf0: 2877 6629 295d 5b3a 6d61 785f 7761 7665  (wf))][:max_wave
+0001eb00: 666f 726d 735d 0a0a 2020 2020 6966 206e  forms]..    if n
+0001eb10: 5f75 6e69 7473 203e 2031 3a0a 2020 2020  _units > 1:.    
+0001eb20: 2020 2020 6966 2063 6f6c 6f72 2069 7320      if color is 
+0001eb30: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
+0001eb40: 2020 6966 2063 6d61 7020 6973 206e 6f74    if cmap is not
+0001eb50: 204e 6f6e 653a 0a20 2020 2020 2020 2020   None:.         
+0001eb60: 2020 2020 2020 2063 6d20 3d20 706c 742e         cm = plt.
+0001eb70: 6765 745f 636d 6170 2863 6d61 7029 0a20  get_cmap(cmap). 
+0001eb80: 2020 2020 2020 2020 2020 2020 2020 2063                 c
+0001eb90: 6f6c 6f72 7320 3d20 5b63 6d28 6920 2f20  olors = [cm(i / 
+0001eba0: 6e5f 756e 6974 7329 2066 6f72 2069 2069  n_units) for i i
+0001ebb0: 6e20 6e70 2e61 7261 6e67 6528 6e5f 756e  n np.arange(n_un
+0001ebc0: 6974 7329 5d0a 2020 2020 2020 2020 2020  its)].          
+0001ebd0: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+0001ebe0: 2020 2020 2020 2020 636f 6c6f 7273 203d          colors =
+0001ebf0: 2070 6c74 2e72 6350 6172 616d 735b 2261   plt.rcParams["a
+0001ec00: 7865 732e 7072 6f70 5f63 7963 6c65 225d  xes.prop_cycle"]
+0001ec10: 2e62 795f 6b65 7928 295b 2263 6f6c 6f72  .by_key()["color
+0001ec20: 225d 0a20 2020 2020 2020 2065 6c73 653a  "].        else:
+0001ec30: 0a20 2020 2020 2020 2020 2020 2063 6f6c  .            col
+0001ec40: 6f72 7320 3d20 5b63 6f6c 6f72 5d20 2a20  ors = [color] * 
+0001ec50: 6e5f 756e 6974 730a 2020 2020 656c 7365  n_units.    else
+0001ec60: 3a0a 2020 2020 2020 2020 636f 6c6f 7273  :.        colors
+0001ec70: 203d 2022 6b22 0a0a 2020 2020 6966 2061   = "k"..    if a
+0001ec80: 7820 6973 204e 6f6e 653a 0a20 2020 2020  x is None:.     
+0001ec90: 2020 2066 6967 203d 2070 6c74 2e66 6967     fig = plt.fig
+0001eca0: 7572 6528 290a 2020 2020 2020 2020 6178  ure().        ax
+0001ecb0: 203d 2066 6967 2e61 6464 5f73 7562 706c   = fig.add_subpl
+0001ecc0: 6f74 2831 3131 290a 2020 2020 656c 7365  ot(111).    else
+0001ecd0: 3a0a 2020 2020 2020 2020 6669 6720 3d20  :.        fig = 
+0001ece0: 6178 2e67 6574 5f66 6967 7572 6528 290a  ax.get_figure().
+0001ecf0: 0a20 2020 2069 6620 656c 6563 7472 6f64  .    if electrod
+0001ed00: 6520 6973 204e 6f6e 653a 0a20 2020 2020  e is None:.     
+0001ed10: 2020 2069 6620 6e5f 756e 6974 7320 3e20     if n_units > 
+0001ed20: 6e63 6f6c 733a 0a20 2020 2020 2020 2020  ncols:.         
+0001ed30: 2020 206e 726f 7773 203d 2069 6e74 286e     nrows = int(n
+0001ed40: 702e 6365 696c 286e 5f75 6e69 7473 202f  p.ceil(n_units /
+0001ed50: 206e 636f 6c73 2929 0a20 2020 2020 2020   ncols)).       
+0001ed60: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+0001ed70: 2020 206e 726f 7773 203d 2031 0a20 2020     nrows = 1.   
+0001ed80: 2020 2020 2020 2020 206e 636f 6c73 203d           ncols =
+0001ed90: 206e 5f75 6e69 7473 0a0a 2020 2020 2020   n_units..      
+0001eda0: 2020 6773 203d 2067 7269 6473 7065 632e    gs = gridspec.
+0001edb0: 4772 6964 5370 6563 4672 6f6d 5375 6270  GridSpecFromSubp
+0001edc0: 6c6f 7453 7065 6328 6e72 6f77 732c 206e  lotSpec(nrows, n
+0001edd0: 636f 6c73 2c20 7375 6270 6c6f 745f 7370  cols, subplot_sp
+0001ede0: 6563 3d61 7829 0a0a 2020 2020 2020 2020  ec=ax)..        
+0001edf0: 666f 7220 692c 2077 6620 696e 2065 6e75  for i, wf in enu
+0001ee00: 6d65 7261 7465 2877 6176 6566 6f72 6d73  merate(waveforms
+0001ee10: 293a 0a20 2020 2020 2020 2020 2020 2072  ):.            r
+0001ee20: 203d 2069 202f 2f20 6e63 6f6c 730a 2020   = i // ncols.  
+0001ee30: 2020 2020 2020 2020 2020 6320 3d20 6e70            c = np
+0001ee40: 2e6d 6f64 2869 2c20 6e63 6f6c 7329 0a20  .mod(i, ncols). 
+0001ee50: 2020 2020 2020 2020 2020 2067 735f 7365             gs_se
+0001ee60: 6c20 3d20 6773 5b72 2c20 635d 0a20 2020  l = gs[r, c].   
+0001ee70: 2020 2020 2020 2020 2061 785f 7420 3d20           ax_t = 
+0001ee80: 6669 672e 6164 645f 7375 6270 6c6f 7428  fig.add_subplot(
+0001ee90: 6773 5f73 656c 290a 2020 2020 2020 2020  gs_sel).        
+0001eea0: 2020 2020 7673 6361 6c65 203d 2031 2e35      vscale = 1.5
+0001eeb0: 202a 206e 702e 6d61 7828 6e70 2e61 6273   * np.max(np.abs
+0001eec0: 2877 6629 290a 2020 2020 2020 2020 2020  (wf)).          
+0001eed0: 2020 6178 5f74 203d 206d 752e 706c 6f74    ax_t = mu.plot
+0001eee0: 5f6d 6561 5f72 6563 6f72 6469 6e67 2877  _mea_recording(w
+0001eef0: 662c 206d 6561 2c20 636f 6c6f 7273 3d63  f, mea, colors=c
+0001ef00: 6f6c 6f72 735b 695d 2c20 6178 3d61 785f  olors[i], ax=ax_
+0001ef10: 742c 206c 773d 302e 312c 2076 7363 616c  t, lw=0.1, vscal
+0001ef20: 653d 7673 6361 6c65 290a 2020 2020 2020  e=vscale).      
+0001ef30: 2020 2020 2020 6178 5f74 203d 206d 752e        ax_t = mu.
+0001ef40: 706c 6f74 5f6d 6561 5f72 6563 6f72 6469  plot_mea_recordi
+0001ef50: 6e67 2877 662e 6d65 616e 2861 7869 733d  ng(wf.mean(axis=
+0001ef60: 3029 2c20 6d65 612c 2063 6f6c 6f72 733d  0), mea, colors=
+0001ef70: 636f 6c6f 7273 5b69 5d2c 2061 783d 6178  colors[i], ax=ax
+0001ef80: 5f74 2c20 6c77 3d32 2c20 7673 6361 6c65  _t, lw=2, vscale
+0001ef90: 3d76 7363 616c 6529 0a20 2020 2065 6c73  =vscale).    els
+0001efa0: 653a 0a20 2020 2020 2020 2061 7373 6572  e:.        asser
+0001efb0: 7420 6973 696e 7374 616e 6365 2865 6c65  t isinstance(ele
+0001efc0: 6374 726f 6465 2c20 2869 6e74 2c20 6e70  ctrode, (int, np
+0001efd0: 2e69 6e74 6567 6572 2929 206f 7220 656c  .integer)) or el
+0001efe0: 6563 7472 6f64 6520 3d3d 2022 6d61 7822  ectrode == "max"
+0001eff0: 2c20 2265 6c65 6374 726f 6465 206d 7573  , "electrode mus
+0001f000: 7420 6265 2069 6e74 206f 7220 276d 6178  t be int or 'max
+0001f010: 2722 0a20 2020 2020 2020 2069 6620 6c65  '".        if le
+0001f020: 6e28 7370 696b 6574 7261 696e 5f69 6429  n(spiketrain_id)
+0001f030: 203e 206e 636f 6c73 3a0a 2020 2020 2020   > ncols:.      
+0001f040: 2020 2020 2020 6e72 6f77 7320 3d20 696e        nrows = in
+0001f050: 7428 6e70 2e63 6569 6c28 6c65 6e28 7370  t(np.ceil(len(sp
+0001f060: 696b 6574 7261 696e 5f69 6429 202f 206e  iketrain_id) / n
+0001f070: 636f 6c73 2929 0a20 2020 2020 2020 2065  cols)).        e
+0001f080: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+0001f090: 206e 726f 7773 203d 2031 0a20 2020 2020   nrows = 1.     
+0001f0a0: 2020 2020 2020 206e 636f 6c73 203d 206c         ncols = l
+0001f0b0: 656e 2873 7069 6b65 7472 6169 6e5f 6964  en(spiketrain_id
+0001f0c0: 290a 0a20 2020 2020 2020 2067 7320 3d20  )..        gs = 
+0001f0d0: 6772 6964 7370 6563 2e47 7269 6453 7065  gridspec.GridSpe
+0001f0e0: 6346 726f 6d53 7562 706c 6f74 5370 6563  cFromSubplotSpec
+0001f0f0: 286e 726f 7773 2c20 6e63 6f6c 732c 2073  (nrows, ncols, s
+0001f100: 7562 706c 6f74 5f73 7065 633d 6178 290a  ubplot_spec=ax).
+0001f110: 0a20 2020 2020 2020 2023 2066 696e 6420  .        # find 
+0001f120: 796c 696d 0a20 2020 2020 2020 206d 696e  ylim.        min
+0001f130: 5f77 6620 3d20 300a 2020 2020 2020 2020  _wf = 0.        
+0001f140: 6d61 785f 7766 203d 2030 0a0a 2020 2020  max_wf = 0..    
+0001f150: 2020 2020 666f 7220 7766 2069 6e20 7761      for wf in wa
+0001f160: 7665 666f 726d 733a 0a20 2020 2020 2020  veforms:.       
+0001f170: 2020 2020 2077 665f 6d65 616e 203d 2077       wf_mean = w
+0001f180: 662e 6d65 616e 2861 7869 733d 3029 0a20  f.mean(axis=0). 
+0001f190: 2020 2020 2020 2020 2020 2069 6620 6e70             if np
+0001f1a0: 2e6d 696e 2877 665f 6d65 616e 2920 3c20  .min(wf_mean) < 
+0001f1b0: 6d69 6e5f 7766 3a0a 2020 2020 2020 2020  min_wf:.        
+0001f1c0: 2020 2020 2020 2020 6d69 6e5f 7766 203d          min_wf =
+0001f1d0: 206e 702e 6d69 6e28 7766 5f6d 6561 6e29   np.min(wf_mean)
+0001f1e0: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+0001f1f0: 6e70 2e6d 6178 2877 665f 6d65 616e 2920  np.max(wf_mean) 
+0001f200: 3e20 6d61 785f 7766 3a0a 2020 2020 2020  > max_wf:.      
+0001f210: 2020 2020 2020 2020 2020 6d61 785f 7766            max_wf
+0001f220: 203d 206e 702e 6d61 7828 7766 5f6d 6561   = np.max(wf_mea
+0001f230: 6e29 0a0a 2020 2020 2020 2020 796c 696d  n)..        ylim
+0001f240: 203d 205b 6d69 6e5f 7766 202d 2030 2e32   = [min_wf - 0.2
+0001f250: 202a 2061 6273 286d 696e 5f77 6629 2c20   * abs(min_wf), 
+0001f260: 6d61 785f 7766 202b 2030 2e32 202a 2061  max_wf + 0.2 * a
+0001f270: 6273 286d 696e 5f77 6629 5d0a 0a20 2020  bs(min_wf)]..   
+0001f280: 2020 2020 2066 6f72 2069 2c20 7766 2069       for i, wf i
+0001f290: 6e20 656e 756d 6572 6174 6528 7761 7665  n enumerate(wave
+0001f2a0: 666f 726d 7329 3a0a 2020 2020 2020 2020  forms):.        
+0001f2b0: 2020 2020 7220 3d20 6920 2f2f 206e 636f      r = i // nco
+0001f2c0: 6c73 0a20 2020 2020 2020 2020 2020 2063  ls.            c
+0001f2d0: 203d 206e 702e 6d6f 6428 692c 206e 636f   = np.mod(i, nco
+0001f2e0: 6c73 290a 2020 2020 2020 2020 2020 2020  ls).            
+0001f2f0: 6773 5f73 656c 203d 2067 735b 722c 2063  gs_sel = gs[r, c
+0001f300: 5d0a 2020 2020 2020 2020 2020 2020 6178  ].            ax
+0001f310: 5f73 656c 203d 2066 6967 2e61 6464 5f73  _sel = fig.add_s
+0001f320: 7562 706c 6f74 2867 735f 7365 6c29 0a20  ubplot(gs_sel). 
+0001f330: 2020 2020 2020 2020 2020 2069 6620 656c             if el
+0001f340: 6563 7472 6f64 6520 3d3d 2022 6d61 7822  ectrode == "max"
+0001f350: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0001f360: 2020 656c 6563 7472 6f64 655f 6964 7820    electrode_idx 
+0001f370: 3d20 6e70 2e75 6e72 6176 656c 5f69 6e64  = np.unravel_ind
+0001f380: 6578 286e 702e 6172 676d 696e 2877 662e  ex(np.argmin(wf.
+0001f390: 6d65 616e 2861 7869 733d 3029 292c 2077  mean(axis=0)), w
+0001f3a0: 662e 6d65 616e 2861 7869 733d 3029 2e73  f.mean(axis=0).s
+0001f3b0: 6861 7065 295b 305d 0a20 2020 2020 2020  hape)[0].       
+0001f3c0: 2020 2020 2020 2020 2070 7269 6e74 2822           print("
+0001f3d0: 6d61 7820 656c 6563 7472 6f64 653a 2022  max electrode: "
+0001f3e0: 2c20 656c 6563 7472 6f64 655f 6964 7829  , electrode_idx)
+0001f3f0: 0a20 2020 2020 2020 2020 2020 2065 6c73  .            els
+0001f400: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+0001f410: 2020 2065 6c65 6374 726f 6465 5f69 6478     electrode_idx
+0001f420: 203d 2065 6c65 6374 726f 6465 0a20 2020   = electrode.   
+0001f430: 2020 2020 2020 2020 2069 6620 6920 3d3d           if i ==
+0001f440: 2030 3a0a 2020 2020 2020 2020 2020 2020   0:.            
+0001f450: 2020 2020 6178 5f73 656c 2e73 6574 5f79      ax_sel.set_y
+0001f460: 6c61 6265 6c28 2276 6f6c 7461 6765 2028  label("voltage (
+0001f470: 245c 5c6d 7524 5629 222c 2066 6f6e 7473  $\\mu$V)", fonts
+0001f480: 697a 653d 3135 290a 2020 2020 2020 2020  ize=15).        
+0001f490: 2020 2020 6178 5f73 656c 2e70 6c6f 7428      ax_sel.plot(
+0001f4a0: 7766 5b3a 2c20 656c 6563 7472 6f64 655f  wf[:, electrode_
+0001f4b0: 6964 785d 2e54 2c20 636f 6c6f 723d 636f  idx].T, color=co
+0001f4c0: 6c6f 7273 5b6e 702e 6d6f 6428 692c 206c  lors[np.mod(i, l
+0001f4d0: 656e 2863 6f6c 6f72 7329 295d 2c20 6c77  en(colors))], lw
+0001f4e0: 3d30 2e31 290a 2020 2020 2020 2020 2020  =0.1).          
+0001f4f0: 2020 6178 5f73 656c 2e70 6c6f 7428 7766    ax_sel.plot(wf
+0001f500: 5b3a 2c20 656c 6563 7472 6f64 655f 6964  [:, electrode_id
+0001f510: 785d 2e6d 6561 6e28 6178 6973 3d30 292c  x].mean(axis=0),
+0001f520: 2063 6f6c 6f72 3d22 6b22 2c20 6c77 3d31   color="k", lw=1
+0001f530: 290a 2020 2020 2020 2020 2020 2020 6178  ).            ax
+0001f540: 5f73 656c 2e73 6574 5f74 6974 6c65 2822  _sel.set_title("
+0001f550: 556e 6974 2022 202b 2073 7472 2869 2920  Unit " + str(i) 
+0001f560: 2b20 2220 2d20 4368 2e20 2220 2b20 7374  + " - Ch. " + st
+0001f570: 7228 656c 6563 7472 6f64 655f 6964 7829  r(electrode_idx)
+0001f580: 2c20 666f 6e74 7369 7a65 3d31 3229 0a20  , fontsize=12). 
+0001f590: 2020 2020 2020 2020 2020 2061 785f 7365             ax_se
+0001f5a0: 6c2e 7365 745f 796c 696d 2879 6c69 6d29  l.set_ylim(ylim)
+0001f5b0: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+0001f5c0: 6320 213d 2030 3a0a 2020 2020 2020 2020  c != 0:.        
+0001f5d0: 2020 2020 2020 2020 6178 5f73 656c 2e73          ax_sel.s
+0001f5e0: 7069 6e65 735b 226c 6566 7422 5d2e 7365  pines["left"].se
+0001f5f0: 745f 7669 7369 626c 6528 4661 6c73 6529  t_visible(False)
+0001f600: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001f610: 2061 785f 7365 6c2e 7365 745f 7974 6963   ax_sel.set_ytic
+0001f620: 6b73 285b 5d29 0a20 2020 2020 2020 2020  ks([]).         
+0001f630: 2020 2061 785f 7365 6c2e 7370 696e 6573     ax_sel.spines
+0001f640: 5b22 7269 6768 7422 5d2e 7365 745f 7669  ["right"].set_vi
+0001f650: 7369 626c 6528 4661 6c73 6529 0a20 2020  sible(False).   
+0001f660: 2020 2020 2020 2020 2061 785f 7365 6c2e           ax_sel.
+0001f670: 7370 696e 6573 5b22 746f 7022 5d2e 7365  spines["top"].se
+0001f680: 745f 7669 7369 626c 6528 4661 6c73 6529  t_visible(False)
+0001f690: 0a20 2020 2061 782e 6178 6973 2822 6f66  .    ax.axis("of
+0001f6a0: 6622 290a 0a20 2020 2072 6574 7572 6e20  f")..    return 
+0001f6b0: 6178 0a0a 0a64 6566 2070 6c6f 745f 616d  ax...def plot_am
+0001f6c0: 706c 6974 7564 6573 280a 2020 2020 7265  plitudes(.    re
+0001f6d0: 6367 656e 2c0a 2020 2020 7370 696b 6574  cgen,.    spiket
+0001f6e0: 7261 696e 5f69 643d 4e6f 6e65 2c0a 2020  rain_id=None,.  
+0001f6f0: 2020 656c 6563 7472 6f64 653d 4e6f 6e65    electrode=None
+0001f700: 2c0a 2020 2020 6178 3d4e 6f6e 652c 0a20  ,.    ax=None,. 
+0001f710: 2020 2063 6f6c 6f72 3d4e 6f6e 652c 0a20     color=None,. 
+0001f720: 2020 2063 6d61 703d 4e6f 6e65 2c0a 2020     cmap=None,.  
+0001f730: 2020 7369 6e67 6c65 5f61 7865 733d 5472    single_axes=Tr
+0001f740: 7565 2c0a 2020 2020 6d61 726b 6572 3d22  ue,.    marker="
+0001f750: 2a22 2c0a 2020 2020 6d73 3d35 2c0a 2020  *",.    ms=5,.  
+0001f760: 2020 6e63 6f6c 733d 362c 0a29 3a0a 2020    ncols=6,.):.  
+0001f770: 2020 2222 220a 2020 2020 506c 6f74 2077    """.    Plot w
+0001f780: 6176 6566 6f72 6d20 616d 706c 6974 7564  aveform amplitud
+0001f790: 6573 206f 7665 7220 7469 6d65 2e0a 0a20  es over time... 
+0001f7a0: 2020 2050 6172 616d 6574 6572 730a 2020     Parameters.  
+0001f7b0: 2020 2d2d 2d2d 2d2d 2d2d 2d2d 0a20 2020    ----------.   
+0001f7c0: 2072 6563 6765 6e20 3a20 5265 636f 7264   recgen : Record
+0001f7d0: 696e 6747 656e 6572 6174 6f72 0a20 2020  ingGenerator.   
+0001f7e0: 2020 2020 2052 6563 6f72 6469 6e67 2067       Recording g
+0001f7f0: 656e 6572 6174 6f72 206f 626a 6563 7420  enerator object 
+0001f800: 746f 2070 6c6f 7420 7370 696b 6520 7472  to plot spike tr
+0001f810: 6169 6e20 7761 7665 666f 726d 2066 726f  ain waveform fro
+0001f820: 6d0a 2020 2020 7370 696b 6574 7261 696e  m.    spiketrain
+0001f830: 5f69 6420 3a20 696e 7420 6f72 206c 6973  _id : int or lis
+0001f840: 740a 2020 2020 2020 2020 496e 6465 7865  t.        Indexe
+0001f850: 7320 6f66 2073 7069 6b65 2074 7261 696e  s of spike train
+0001f860: 730a 2020 2020 656c 6563 7472 6f64 6520  s.    electrode 
+0001f870: 3a20 696e 7420 6f72 2027 6d61 7827 0a20  : int or 'max'. 
+0001f880: 2020 2020 2020 2045 6c65 6374 726f 6465         Electrode
+0001f890: 2069 6420 6f72 2027 6d61 7827 0a20 2020   id or 'max'.   
+0001f8a0: 2061 7820 3a20 6178 6973 0a20 2020 2020   ax : axis.     
+0001f8b0: 2020 204d 6174 706c 6f74 6c69 6220 2061     Matplotlib  a
+0001f8c0: 7869 730a 2020 2020 636f 6c6f 7220 3a20  xis.    color : 
+0001f8d0: 6d61 7470 6c6f 746c 6962 2063 6f6c 6f72  matplotlib color
+0001f8e0: 0a20 2020 2020 2020 2043 6f6c 6f72 206f  .        Color o
+0001f8f0: 6620 7468 6520 7761 7665 666f 726d 2061  f the waveform a
+0001f900: 6d70 6c69 7475 6465 730a 2020 2020 636d  mplitudes.    cm
+0001f910: 6170 203a 206d 6174 706c 6f74 6c69 6220  ap : matplotlib 
+0001f920: 636f 6c6f 726d 6170 0a20 2020 2020 2020  colormap.       
+0001f930: 2043 6f6c 6f72 6d61 7020 746f 2062 6520   Colormap to be 
+0001f940: 7573 6564 0a20 2020 2073 696e 676c 655f  used.    single_
+0001f950: 6178 6573 203a 2062 6f6f 6c0a 2020 2020  axes : bool.    
+0001f960: 2020 2020 4966 2054 7275 6520 616c 6c20      If True all 
+0001f970: 7465 6d70 6c61 7465 7320 6172 6520 706c  templates are pl
+0001f980: 6f74 7465 6420 6f6e 2074 6865 2073 616d  otted on the sam
+0001f990: 6520 6178 6973 0a20 2020 206d 6172 6b65  e axis.    marke
+0001f9a0: 7220 3a20 7374 720a 2020 2020 2020 2020  r : str.        
+0001f9b0: 4d61 7470 6c6f 746c 6962 206d 6172 6b65  Matplotlib marke
+0001f9c0: 7220 2864 6566 6175 6c74 2027 2a27 290a  r (default '*').
+0001f9d0: 2020 2020 6d73 203a 2069 6e74 0a20 2020      ms : int.   
+0001f9e0: 2020 2020 204d 6172 6b65 7273 697a 6520       Markersize 
+0001f9f0: 2864 6566 6175 6c74 2035 290a 2020 2020  (default 5).    
+0001fa00: 6e63 6f6c 7320 3a20 2069 6e74 0a20 2020  ncols :  int.   
+0001fa10: 2020 2020 204e 756d 6265 7220 6f66 2063       Number of c
+0001fa20: 6f6c 756d 6e73 2066 6f72 2073 7562 706c  olumns for subpl
+0001fa30: 6f74 730a 0a20 2020 2052 6574 7572 6e73  ots..    Returns
+0001fa40: 0a20 2020 202d 2d2d 2d2d 2d2d 0a20 2020  .    -------.   
+0001fa50: 2061 7820 3a20 6178 6973 0a20 2020 2020   ax : axis.     
+0001fa60: 2020 204d 6174 706c 6f74 6c69 6220 6178     Matplotlib ax
+0001fa70: 6973 0a0a 2020 2020 2222 220a 2020 2020  is..    """.    
+0001fa80: 696d 706f 7274 206d 6174 706c 6f74 6c69  import matplotli
+0001fa90: 622e 6772 6964 7370 6563 2061 7320 6772  b.gridspec as gr
+0001faa0: 6964 7370 6563 0a20 2020 2069 6d70 6f72  idspec.    impor
+0001fab0: 7420 6d61 7470 6c6f 746c 6962 2e70 796c  t matplotlib.pyl
+0001fac0: 6162 2061 7320 706c 740a 0a20 2020 2069  ab as plt..    i
+0001fad0: 6620 7370 696b 6574 7261 696e 5f69 6420  f spiketrain_id 
+0001fae0: 6973 204e 6f6e 653a 0a20 2020 2020 2020  is None:.       
+0001faf0: 2073 7069 6b65 7472 6169 6e5f 6964 203d   spiketrain_id =
+0001fb00: 206e 702e 6172 616e 6765 286c 656e 2872   np.arange(len(r
+0001fb10: 6563 6765 6e2e 7370 696b 6574 7261 696e  ecgen.spiketrain
+0001fb20: 7329 290a 2020 2020 656c 6966 2069 7369  s)).    elif isi
+0001fb30: 6e73 7461 6e63 6528 7370 696b 6574 7261  nstance(spiketra
+0001fb40: 696e 5f69 642c 2028 696e 742c 206e 702e  in_id, (int, np.
+0001fb50: 696e 7465 6765 7229 293a 0a20 2020 2020  integer)):.     
+0001fb60: 2020 2073 7069 6b65 7472 6169 6e5f 6964     spiketrain_id
+0001fb70: 203d 205b 7370 696b 6574 7261 696e 5f69   = [spiketrain_i
+0001fb80: 645d 0a0a 2020 2020 6e5f 756e 6974 7320  d]..    n_units 
+0001fb90: 3d20 6c65 6e28 7370 696b 6574 7261 696e  = len(spiketrain
+0001fba0: 5f69 6429 0a0a 2020 2020 6966 2065 6c65  _id)..    if ele
+0001fbb0: 6374 726f 6465 2069 7320 4e6f 6e65 3a0a  ctrode is None:.
+0001fbc0: 2020 2020 2020 2020 656c 6563 7472 6f64          electrod
+0001fbd0: 6520 3d20 226d 6178 220a 2020 2020 7761  e = "max".    wa
+0001fbe0: 7665 666f 726d 7320 3d20 5b5d 0a20 2020  veforms = [].   
+0001fbf0: 2066 6f72 2073 7020 696e 2073 7069 6b65   for sp in spike
+0001fc00: 7472 6169 6e5f 6964 3a0a 2020 2020 2020  train_id:.      
+0001fc10: 2020 7766 203d 2072 6563 6765 6e2e 7370    wf = recgen.sp
+0001fc20: 696b 6574 7261 696e 735b 7370 5d2e 7761  iketrains[sp].wa
+0001fc30: 7665 666f 726d 730a 2020 2020 2020 2020  veforms.        
+0001fc40: 6966 2077 6620 6973 204e 6f6e 653a 0a20  if wf is None:. 
+0001fc50: 2020 2020 2020 2020 2020 2066 7320 3d20             fs = 
+0001fc60: 7265 6367 656e 2e69 6e66 6f5b 2272 6563  recgen.info["rec
+0001fc70: 6f72 6469 6e67 7322 5d5b 2266 7322 5d20  ordings"]["fs"] 
+0001fc80: 2a20 7071 2e48 7a0a 2020 2020 2020 2020  * pq.Hz.        
+0001fc90: 2020 2020 6578 7472 6163 745f 7766 285b      extract_wf([
+0001fca0: 7265 6367 656e 2e73 7069 6b65 7472 6169  recgen.spiketrai
+0001fcb0: 6e73 5b73 705d 5d2c 2072 6563 6765 6e2e  ns[sp]], recgen.
+0001fcc0: 7265 636f 7264 696e 6773 2c20 6673 290a  recordings, fs).
+0001fcd0: 2020 2020 2020 2020 2020 2020 7766 203d              wf =
+0001fce0: 2072 6563 6765 6e2e 7370 696b 6574 7261   recgen.spiketra
+0001fcf0: 696e 735b 7370 5d2e 7761 7665 666f 726d  ins[sp].waveform
+0001fd00: 730a 2020 2020 2020 2020 7761 7665 666f  s.        wavefo
+0001fd10: 726d 732e 6170 7065 6e64 2877 6629 0a0a  rms.append(wf)..
+0001fd20: 2020 2020 6966 206e 5f75 6e69 7473 203e      if n_units >
+0001fd30: 2031 3a0a 2020 2020 2020 2020 6966 2063   1:.        if c
+0001fd40: 6f6c 6f72 2069 7320 4e6f 6e65 3a0a 2020  olor is None:.  
+0001fd50: 2020 2020 2020 2020 2020 6966 2063 6d61            if cma
+0001fd60: 7020 6973 206e 6f74 204e 6f6e 653a 0a20  p is not None:. 
+0001fd70: 2020 2020 2020 2020 2020 2020 2020 2063                 c
+0001fd80: 6d20 3d20 706c 742e 6765 745f 636d 6170  m = plt.get_cmap
+0001fd90: 2863 6d61 7029 0a20 2020 2020 2020 2020  (cmap).         
+0001fda0: 2020 2020 2020 2063 6f6c 6f72 7320 3d20         colors = 
+0001fdb0: 5b63 6d28 6920 2f20 6e5f 756e 6974 7329  [cm(i / n_units)
+0001fdc0: 2066 6f72 2069 2069 6e20 6e70 2e61 7261   for i in np.ara
+0001fdd0: 6e67 6528 6e5f 756e 6974 7329 5d0a 2020  nge(n_units)].  
+0001fde0: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
+0001fdf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001fe00: 636f 6c6f 7273 203d 2070 6c74 2e72 6350  colors = plt.rcP
+0001fe10: 6172 616d 735b 2261 7865 732e 7072 6f70  arams["axes.prop
+0001fe20: 5f63 7963 6c65 225d 2e62 795f 6b65 7928  _cycle"].by_key(
+0001fe30: 295b 2263 6f6c 6f72 225d 0a20 2020 2020  )["color"].     
+0001fe40: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+0001fe50: 2020 2020 2063 6f6c 6f72 7320 3d20 706c       colors = pl
+0001fe60: 742e 7263 5061 7261 6d73 5b22 6178 6573  t.rcParams["axes
+0001fe70: 2e70 726f 705f 6379 636c 6522 5d2e 6279  .prop_cycle"].by
+0001fe80: 5f6b 6579 2829 5b22 636f 6c6f 7222 5d0a  _key()["color"].
+0001fe90: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+0001fea0: 2020 6966 2063 6f6c 6f72 2069 7320 4e6f    if color is No
+0001feb0: 6e65 3a0a 2020 2020 2020 2020 2020 2020  ne:.            
+0001fec0: 636f 6c6f 7273 203d 2022 6b22 0a20 2020  colors = "k".   
+0001fed0: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+0001fee0: 2020 2020 2020 2063 6f6c 6f72 7320 3d20         colors = 
+0001fef0: 636f 6c6f 720a 0a20 2020 2069 6620 6178  color..    if ax
+0001ff00: 2069 7320 4e6f 6e65 3a0a 2020 2020 2020   is None:.      
+0001ff10: 2020 6669 6720 3d20 706c 742e 6669 6775    fig = plt.figu
+0001ff20: 7265 2829 0a20 2020 2020 2020 2061 7820  re().        ax 
+0001ff30: 3d20 6669 672e 6164 645f 7375 6270 6c6f  = fig.add_subplo
+0001ff40: 7428 3131 3129 0a20 2020 2065 6c73 653a  t(111).    else:
+0001ff50: 0a20 2020 2020 2020 2066 6967 203d 2061  .        fig = a
+0001ff60: 782e 6765 745f 6669 6775 7265 2829 0a0a  x.get_figure()..
+0001ff70: 2020 2020 616d 7073 203d 205b 5d0a 2020      amps = [].  
+0001ff80: 2020 666f 7220 692c 2069 6420 696e 2065    for i, id in e
+0001ff90: 6e75 6d65 7261 7465 2873 7069 6b65 7472  numerate(spiketr
+0001ffa0: 6169 6e5f 6964 293a 0a20 2020 2020 2020  ain_id):.       
+0001ffb0: 2073 7420 3d20 7265 6367 656e 2e73 7069   st = recgen.spi
+0001ffc0: 6b65 7472 6169 6e73 5b69 645d 0a20 2020  ketrains[id].   
+0001ffd0: 2020 2020 2077 6620 3d20 7374 2e77 6176       wf = st.wav
+0001ffe0: 6566 6f72 6d73 0a20 2020 2020 2020 206d  eforms.        m
+0001fff0: 7766 203d 206e 702e 6d65 616e 2877 662c  wf = np.mean(wf,
+00020000: 2061 7869 733d 3029 0a20 2020 2020 2020   axis=0).       
+00020010: 2069 6620 656c 6563 7472 6f64 6520 3d3d   if electrode ==
+00020020: 2022 6d61 7822 3a0a 2020 2020 2020 2020   "max":.        
+00020030: 2020 2020 6d61 785f 656c 6563 203d 206e      max_elec = n
+00020040: 702e 756e 7261 7665 6c5f 696e 6465 7828  p.unravel_index(
+00020050: 6e70 2e61 7267 6d69 6e28 6d77 6629 2c20  np.argmin(mwf), 
+00020060: 6d77 662e 7368 6170 6529 5b30 5d0a 2020  mwf.shape)[0].  
+00020070: 2020 2020 2020 2020 2020 7072 696e 7428            print(
+00020080: 224d 6178 2065 6c65 6374 726f 6465 222c  "Max electrode",
+00020090: 206d 6178 5f65 6c65 6329 0a20 2020 2020   max_elec).     
+000200a0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+000200b0: 2020 2020 2061 7373 6572 7420 6973 696e       assert isin
+000200c0: 7374 616e 6365 2865 6c65 6374 726f 6465  stance(electrode
+000200d0: 2c20 2869 6e74 2c20 6e70 2e69 6e74 6567  , (int, np.integ
+000200e0: 6572 2929 2c20 2227 656c 6563 7472 6f64  er)), "'electrod
+000200f0: 6527 2063 616e 2062 6520 276d 6178 2720  e' can be 'max' 
+00020100: 6f72 2074 7970 6520 696e 7422 0a20 2020  or type int".   
+00020110: 2020 2020 2020 2020 206d 6178 5f65 6c65           max_ele
+00020120: 6320 3d20 656c 6563 7472 6f64 650a 2020  c = electrode.  
+00020130: 2020 2020 2020 616d 7073 2e61 7070 656e        amps.appen
+00020140: 6428 6e70 2e61 7272 6179 285b 6e70 2e6d  d(np.array([np.m
+00020150: 696e 2877 5b6d 6178 5f65 6c65 635d 2920  in(w[max_elec]) 
+00020160: 666f 7220 7720 696e 2077 665d 2929 0a0a  for w in wf]))..
+00020170: 2020 2020 6966 2073 696e 676c 655f 6178      if single_ax
+00020180: 6573 3a0a 2020 2020 2020 2020 666f 7220  es:.        for 
+00020190: 695f 6e2c 206e 2069 6e20 656e 756d 6572  i_n, n in enumer
+000201a0: 6174 6528 7370 696b 6574 7261 696e 5f69  ate(spiketrain_i
+000201b0: 6429 3a0a 2020 2020 2020 2020 2020 2020  d):.            
+000201c0: 616d 7020 3d20 616d 7073 5b69 5f6e 5d0a  amp = amps[i_n].
+000201d0: 2020 2020 2020 2020 2020 2020 7374 203d              st =
+000201e0: 2072 6563 6765 6e2e 7370 696b 6574 7261   recgen.spiketra
+000201f0: 696e 735b 6e5d 0a20 2020 2020 2020 2020  ins[n].         
+00020200: 2020 2061 782e 706c 6f74 2873 742c 2061     ax.plot(st, a
+00020210: 6d70 2c20 6d61 726b 6572 3d6d 6172 6b65  mp, marker=marke
+00020220: 722c 206d 733d 6d73 2c20 636f 6c6f 723d  r, ms=ms, color=
+00020230: 636f 6c6f 7273 5b69 5f6e 5d2c 206c 733d  colors[i_n], ls=
+00020240: 2222 290a 2020 2020 656c 7365 3a0a 2020  "").    else:.  
+00020250: 2020 2020 2020 6966 206e 5f75 6e69 7473        if n_units
+00020260: 203e 206e 636f 6c73 3a0a 2020 2020 2020   > ncols:.      
+00020270: 2020 2020 2020 6e72 6f77 7320 3d20 696e        nrows = in
+00020280: 7428 6e70 2e63 6569 6c28 6c65 6e28 7370  t(np.ceil(len(sp
+00020290: 696b 6574 7261 696e 5f69 6429 202f 206e  iketrain_id) / n
+000202a0: 636f 6c73 2929 0a20 2020 2020 2020 2065  cols)).        e
+000202b0: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+000202c0: 206e 726f 7773 203d 2031 0a20 2020 2020   nrows = 1.     
+000202d0: 2020 2020 2020 206e 636f 6c73 203d 206e         ncols = n
+000202e0: 5f75 6e69 7473 0a0a 2020 2020 2020 2020  _units..        
+000202f0: 6773 203d 2067 7269 6473 7065 632e 4772  gs = gridspec.Gr
+00020300: 6964 5370 6563 4672 6f6d 5375 6270 6c6f  idSpecFromSubplo
+00020310: 7453 7065 6328 6e72 6f77 732c 206e 636f  tSpec(nrows, nco
+00020320: 6c73 2c20 7375 6270 6c6f 745f 7370 6563  ls, subplot_spec
+00020330: 3d61 7829 0a0a 2020 2020 2020 2020 666f  =ax)..        fo
+00020340: 7220 695f 6e2c 206e 2069 6e20 656e 756d  r i_n, n in enum
+00020350: 6572 6174 6528 7370 696b 6574 7261 696e  erate(spiketrain
+00020360: 5f69 6429 3a0a 2020 2020 2020 2020 2020  _id):.          
+00020370: 2020 7220 3d20 695f 6e20 2f2f 206e 636f    r = i_n // nco
+00020380: 6c73 0a20 2020 2020 2020 2020 2020 2063  ls.            c
+00020390: 203d 206e 702e 6d6f 6428 695f 6e2c 206e   = np.mod(i_n, n
+000203a0: 636f 6c73 290a 2020 2020 2020 2020 2020  cols).          
+000203b0: 2020 6773 5f73 656c 203d 2067 735b 722c    gs_sel = gs[r,
+000203c0: 2063 5d0a 2020 2020 2020 2020 2020 2020   c].            
+000203d0: 6178 5f61 6d70 203d 2066 6967 2e61 6464  ax_amp = fig.add
+000203e0: 5f73 7562 706c 6f74 2867 735f 7365 6c29  _subplot(gs_sel)
+000203f0: 0a20 2020 2020 2020 2020 2020 2061 6d70  .            amp
+00020400: 203d 2061 6d70 735b 695f 6e5d 0a20 2020   = amps[i_n].   
+00020410: 2020 2020 2020 2020 2073 7420 3d20 7265           st = re
+00020420: 6367 656e 2e73 7069 6b65 7472 6169 6e73  cgen.spiketrains
+00020430: 5b6e 5d0a 2020 2020 2020 2020 2020 2020  [n].            
+00020440: 6178 5f61 6d70 2e70 6c6f 7428 7374 2c20  ax_amp.plot(st, 
+00020450: 616d 702c 206d 6172 6b65 723d 6d61 726b  amp, marker=mark
+00020460: 6572 2c20 6d73 3d6d 732c 2063 6f6c 6f72  er, ms=ms, color
+00020470: 3d63 6f6c 6f72 735b 695f 6e5d 2c20 6c73  =colors[i_n], ls
+00020480: 3d22 2229 0a20 2020 2020 2020 2061 782e  ="").        ax.
+00020490: 6178 6973 2822 6f66 6622 290a 0a20 2020  axis("off")..   
+000204a0: 2072 6574 7572 6e20 6178 0a0a 0a64 6566   return ax...def
+000204b0: 2070 6c6f 745f 7063 615f 6d61 7028 0a20   plot_pca_map(. 
+000204c0: 2020 2072 6563 6765 6e2c 206e 5f70 633d     recgen, n_pc=
+000204d0: 322c 206d 6178 5f65 6c65 633d 4e6f 6e65  2, max_elec=None
+000204e0: 2c20 636d 6170 3d22 7261 696e 626f 7722  , cmap="rainbow"
+000204f0: 2c20 6375 745f 6f75 743d 322c 206e 5f75  , cut_out=2, n_u
+00020500: 6e69 7473 3d4e 6f6e 652c 2061 783d 4e6f  nits=None, ax=No
+00020510: 6e65 2c20 7768 6974 656e 3d46 616c 7365  ne, whiten=False
+00020520: 2c20 7063 5f63 6f6d 703d 4e6f 6e65 0a29  , pc_comp=None.)
+00020530: 3a0a 2020 2020 2222 220a 2020 2020 506c  :.    """.    Pl
+00020540: 6f74 7320 6120 5043 4120 6d61 7020 6f66  ots a PCA map of
+00020550: 2074 6865 2077 6176 6566 6f72 6d73 2e0a   the waveforms..
+00020560: 0a20 2020 2050 6172 616d 6574 6572 730a  .    Parameters.
+00020570: 2020 2020 2d2d 2d2d 2d2d 2d2d 2d2d 0a20      ----------. 
+00020580: 2020 2072 6563 6765 6e20 3a20 5265 636f     recgen : Reco
+00020590: 7264 696e 6747 656e 6572 6174 6f72 0a20  rdingGenerator. 
+000205a0: 2020 2020 2020 2052 6563 6f72 6469 6e67         Recording
+000205b0: 2067 656e 6572 6174 6f72 206f 626a 6563   generator objec
+000205c0: 7420 746f 2070 6c6f 7420 5043 4120 7363  t to plot PCA sc
+000205d0: 6f72 6573 206f 660a 2020 2020 6178 203a  ores of.    ax :
+000205e0: 2061 7869 730a 2020 2020 2020 2020 4d61   axis.        Ma
+000205f0: 7470 6c6f 746c 6962 2020 6178 6973 0a20  tplotlib  axis. 
+00020600: 2020 206e 5f70 6320 3a20 696e 740a 2020     n_pc : int.  
+00020610: 2020 2020 2020 4e75 6d62 6572 206f 6620        Number of 
+00020620: 7072 696e 6369 7061 6c20 636f 6d70 6f6e  principal compon
+00020630: 656e 7473 2028 6465 6661 756c 7420 3229  ents (default 2)
+00020640: 0a20 2020 206d 6178 5f65 6c65 6320 3a20  .    max_elec : 
+00020650: 2069 6e74 0a20 2020 2020 2020 204d 6178   int.        Max
+00020660: 206e 756d 6265 7220 6f66 2065 6c65 6374   number of elect
+00020670: 726f 6465 7320 746f 2070 6c6f 740a 2020  rodes to plot.  
+00020680: 2020 636d 6170 203a 206d 6174 706c 6f74    cmap : matplot
+00020690: 6c69 6220 636f 6c6f 726d 6170 0a20 2020  lib colormap.   
+000206a0: 2020 2020 2043 6f6c 6f72 6d61 7020 746f       Colormap to
+000206b0: 2062 6520 7573 6564 0a20 2020 2063 7574   be used.    cut
+000206c0: 5f6f 7574 203a 2066 6c6f 6174 206f 7220  _out : float or 
+000206d0: 6c69 7374 0a20 2020 2020 2020 2043 7574  list.        Cut
+000206e0: 206f 7574 7320 696e 206d 7320 666f 7220   outs in ms for 
+000206f0: 7761 7665 666f 726d 7320 2869 6620 6e6f  waveforms (if no
+00020700: 7420 636f 6d70 7574 6564 292e 2049 6620  t computed). If 
+00020710: 666c 6f61 7420 7468 6520 6375 7420 6f75  float the cut ou
+00020720: 7420 6973 2073 796d 6d65 7472 6963 616c  t is symmetrical
+00020730: 2e20 2020 206e 5f75 6e69 7473 0a20 2020  .    n_units.   
+00020740: 2077 6869 7465 6e20 3a20 2062 6f6f 6c0a   whiten :  bool.
+00020750: 2020 2020 2020 2020 4966 2054 7275 652c          If True,
+00020760: 2050 4341 2073 636f 7265 7320 6172 6520   PCA scores are 
+00020770: 7768 6974 656e 6564 0a20 2020 2070 635f  whitened.    pc_
+00020780: 636f 6d70 203a 206e 702e 6172 7261 790a  comp : np.array.
+00020790: 2020 2020 2020 2020 5043 2063 6f6d 706f          PC compo
+000207a0: 6e65 6e74 206d 6174 7269 7820 746f 2062  nent matrix to b
+000207b0: 6520 7573 6564 2e0a 0a20 2020 2052 6574  e used...    Ret
+000207c0: 7572 6e73 0a20 2020 202d 2d2d 2d2d 2d2d  urns.    -------
+000207d0: 0a20 2020 2061 7820 3a20 6178 6973 0a20  .    ax : axis. 
+000207e0: 2020 2020 2020 204d 6174 706c 6f74 6c69         Matplotli
+000207f0: 6220 6178 6973 0a20 2020 2070 6361 5f73  b axis.    pca_s
+00020800: 636f 7265 7320 3a20 6c69 7374 0a20 2020  cores : list.   
+00020810: 2020 2020 204c 6973 7420 6f66 206e 702e       List of np.
+00020820: 6172 7261 7973 2077 6974 6820 7063 6120  arrays with pca 
+00020830: 7363 6f72 6573 2066 6f72 2074 6865 2064  scores for the d
+00020840: 6966 6665 7265 6e74 2075 6e69 7473 0a20  ifferent units. 
+00020850: 2020 2070 6361 5f63 6f6d 706f 6e65 6e74     pca_component
+00020860: 203a 206e 702e 6172 7261 790a 2020 2020   : np.array.    
+00020870: 2020 2020 5043 4120 636f 6d70 6f6e 656e      PCA componen
+00020880: 7473 206d 6174 7269 7820 286e 5f70 632c  ts matrix (n_pc,
+00020890: 206e 5f77 6176 6566 6f72 6d5f 7469 6d65   n_waveform_time
+000208a0: 706f 696e 7473 290a 0a20 2020 2022 2222  points)..    """
+000208b0: 0a20 2020 2074 7279 3a0a 2020 2020 2020  .    try:.      
+000208c0: 2020 6672 6f6d 2073 6b6c 6561 726e 2e64    from sklearn.d
+000208d0: 6563 6f6d 706f 7369 7469 6f6e 2069 6d70  ecomposition imp
+000208e0: 6f72 7420 5043 410a 2020 2020 6578 6365  ort PCA.    exce
+000208f0: 7074 3a0a 2020 2020 2020 2020 7261 6973  pt:.        rais
+00020900: 6520 4578 6365 7074 696f 6e28 2227 706c  e Exception("'pl
+00020910: 6f74 5f70 6361 5f6d 6170 2720 7265 7175  ot_pca_map' requ
+00020920: 6972 6573 2073 6369 6b69 742d 6c65 6172  ires scikit-lear
+00020930: 6e20 7061 636b 6167 6522 290a 0a20 2020  n package")..   
+00020940: 2069 6d70 6f72 7420 6d61 7470 6c6f 746c   import matplotl
+00020950: 6962 2e67 7269 6473 7065 6320 6173 2067  ib.gridspec as g
+00020960: 7269 6473 7065 630a 2020 2020 696d 706f  ridspec.    impo
+00020970: 7274 206d 6174 706c 6f74 6c69 622e 7079  rt matplotlib.py
+00020980: 6c61 6220 6173 2070 6c74 0a0a 2020 2020  lab as plt..    
+00020990: 7761 7665 666f 726d 7320 3d20 5b5d 0a20  waveforms = []. 
+000209a0: 2020 206e 5f73 7069 6b65 7320 3d20 5b5d     n_spikes = []
+000209b0: 0a0a 2020 2020 6966 206e 5f75 6e69 7473  ..    if n_units
+000209c0: 2069 7320 4e6f 6e65 3a0a 2020 2020 2020   is None:.      
+000209d0: 2020 6e5f 756e 6974 7320 3d20 6c65 6e28    n_units = len(
+000209e0: 7265 6367 656e 2e73 7069 6b65 7472 6169  recgen.spiketrai
+000209f0: 6e73 290a 0a20 2020 2069 6620 7265 6367  ns)..    if recg
+00020a00: 656e 2e73 7069 6b65 7472 6169 6e73 5b30  en.spiketrains[0
+00020a10: 5d2e 7761 7665 666f 726d 7320 6973 204e  ].waveforms is N
+00020a20: 6f6e 653a 0a20 2020 2020 2020 2070 7269  one:.        pri
+00020a30: 6e74 2822 436f 6d70 7574 696e 6720 7761  nt("Computing wa
+00020a40: 7665 666f 726d 7322 290a 2020 2020 2020  veforms").      
+00020a50: 2020 7265 6367 656e 2e65 7874 7261 6374    recgen.extract
+00020a60: 5f77 6176 6566 6f72 6d73 2863 7574 5f6f  _waveforms(cut_o
+00020a70: 7574 3d63 7574 5f6f 7574 290a 0a20 2020  ut=cut_out)..   
+00020a80: 2066 6f72 2073 7420 696e 2072 6563 6765   for st in recge
+00020a90: 6e2e 7370 696b 6574 7261 696e 733a 0a20  n.spiketrains:. 
+00020aa0: 2020 2020 2020 2077 6620 3d20 7374 2e77         wf = st.w
+00020ab0: 6176 6566 6f72 6d73 0a20 2020 2020 2020  aveforms.       
+00020ac0: 2077 6176 6566 6f72 6d73 2e61 7070 656e   waveforms.appen
+00020ad0: 6428 7766 290a 2020 2020 6e5f 656c 6563  d(wf).    n_elec
+00020ae0: 203d 2077 6176 6566 6f72 6d73 5b30 5d2e   = waveforms[0].
+00020af0: 7368 6170 655b 315d 0a0a 2020 2020 6966  shape[1]..    if
+00020b00: 206e 5f70 6320 3d3d 2031 3a0a 2020 2020   n_pc == 1:.    
+00020b10: 2020 2020 7063 5f64 696d 7320 3d20 5b30      pc_dims = [0
+00020b20: 5d0a 2020 2020 656c 6966 206e 5f70 6320  ].    elif n_pc 
+00020b30: 3e20 313a 0a20 2020 2020 2020 2070 635f  > 1:.        pc_
+00020b40: 6469 6d73 203d 206e 702e 6172 616e 6765  dims = np.arange
+00020b50: 286e 5f70 6329 0a20 2020 2065 6c73 653a  (n_pc).    else:
+00020b60: 0a20 2020 2020 2020 2070 635f 6469 6d73  .        pc_dims
+00020b70: 203d 205b 305d 0a0a 2020 2020 6966 206d   = [0]..    if m
+00020b80: 6178 5f65 6c65 6320 6973 206e 6f74 204e  ax_elec is not N
+00020b90: 6f6e 6520 616e 6420 6d61 785f 656c 6563  one and max_elec
+00020ba0: 203c 206e 5f65 6c65 633a 0a20 2020 2020   < n_elec:.     
+00020bb0: 2020 2069 6620 6d61 785f 656c 6563 203d     if max_elec =
+00020bc0: 3d20 313a 0a20 2020 2020 2020 2020 2020  = 1:.           
+00020bd0: 2065 6c65 635f 6469 6d73 203d 205b 6e70   elec_dims = [np
+00020be0: 2e72 616e 646f 6d2e 7261 6e64 696e 7428  .random.randint(
+00020bf0: 6e5f 656c 6563 295d 0a20 2020 2020 2020  n_elec)].       
+00020c00: 2065 6c69 6620 6d61 785f 656c 6563 203e   elif max_elec >
+00020c10: 2031 3a0a 2020 2020 2020 2020 2020 2020   1:.            
+00020c20: 656c 6563 5f64 696d 7320 3d20 6e70 2e72  elec_dims = np.r
+00020c30: 616e 646f 6d2e 7065 726d 7574 6174 696f  andom.permutatio
+00020c40: 6e28 6e70 2e61 7261 6e67 6528 6e5f 656c  n(np.arange(n_el
+00020c50: 6563 2929 5b3a 6d61 785f 656c 6563 5d0a  ec))[:max_elec].
+00020c60: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+00020c70: 2020 2020 2020 2020 2020 656c 6563 5f64            elec_d
+00020c80: 696d 7320 3d20 5b6e 702e 7261 6e64 6f6d  ims = [np.random
+00020c90: 2e72 616e 6469 6e74 286e 5f65 6c65 6329  .randint(n_elec)
+00020ca0: 5d0a 2020 2020 656c 7365 3a0a 2020 2020  ].    else:.    
+00020cb0: 2020 2020 656c 6563 5f64 696d 7320 3d20      elec_dims = 
+00020cc0: 6e70 2e61 7261 6e67 6528 6e5f 656c 6563  np.arange(n_elec
+00020cd0: 290a 0a20 2020 2066 6f72 2069 5f77 2c20  )..    for i_w, 
+00020ce0: 7766 2069 6e20 656e 756d 6572 6174 6528  wf in enumerate(
+00020cf0: 7761 7665 666f 726d 7329 3a0a 2020 2020  waveforms):.    
+00020d00: 2020 2020 2320 7766 5f72 6573 6861 7065      # wf_reshape
+00020d10: 6420 3d20 7766 2e72 6573 6861 7065 2828  d = wf.reshape((
+00020d20: 7766 2e73 6861 7065 5b30 5d20 2a20 7766  wf.shape[0] * wf
+00020d30: 2e73 6861 7065 5b31 5d2c 2077 662e 7368  .shape[1], wf.sh
+00020d40: 6170 655b 325d 2929 0a20 2020 2020 2020  ape[2])).       
+00020d50: 2077 665f 7265 7368 6170 6564 203d 2077   wf_reshaped = w
+00020d60: 662e 7265 7368 6170 6528 2877 662e 7368  f.reshape((wf.sh
+00020d70: 6170 655b 305d 202a 2077 662e 7368 6170  ape[0] * wf.shap
+00020d80: 655b 315d 2c20 7766 2e73 6861 7065 5b32  e[1], wf.shape[2
+00020d90: 5d29 290a 2020 2020 2020 2020 6e5f 7370  ])).        n_sp
+00020da0: 696b 6573 2e61 7070 656e 6428 6c65 6e28  ikes.append(len(
+00020db0: 7766 2920 2a20 6e5f 656c 6563 290a 0a20  wf) * n_elec).. 
+00020dc0: 2020 2020 2020 2069 6620 695f 7720 3d3d         if i_w ==
+00020dd0: 2030 3a0a 2020 2020 2020 2020 2020 2020   0:.            
+00020de0: 616c 6c5f 7761 7665 666f 726d 7320 3d20  all_waveforms = 
+00020df0: 7766 5f72 6573 6861 7065 640a 2020 2020  wf_reshaped.    
+00020e00: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+00020e10: 2020 2020 2020 616c 6c5f 7761 7665 666f        all_wavefo
+00020e20: 726d 7320 3d20 6e70 2e76 7374 6163 6b28  rms = np.vstack(
+00020e30: 2861 6c6c 5f77 6176 6566 6f72 6d73 2c20  (all_waveforms, 
+00020e40: 7766 5f72 6573 6861 7065 6429 290a 0a20  wf_reshaped)).. 
+00020e50: 2020 2069 6620 7063 5f63 6f6d 7020 6973     if pc_comp is
+00020e60: 204e 6f6e 653a 0a20 2020 2020 2020 2063   None:.        c
+00020e70: 6f6d 7075 7465 5f70 6361 203d 2054 7275  ompute_pca = Tru
+00020e80: 650a 2020 2020 656c 6966 2070 635f 636f  e.    elif pc_co
+00020e90: 6d70 2e73 6861 7065 203d 3d20 286e 5f70  mp.shape == (n_p
+00020ea0: 632c 2061 6c6c 5f77 6176 6566 6f72 6d73  c, all_waveforms
+00020eb0: 2e73 6861 7065 5b31 5d29 3a0a 2020 2020  .shape[1]):.    
+00020ec0: 2020 2020 636f 6d70 7574 655f 7063 6120      compute_pca 
+00020ed0: 3d20 4661 6c73 650a 2020 2020 656c 7365  = False.    else
+00020ee0: 3a0a 2020 2020 2020 2020 7072 696e 7428  :.        print(
+00020ef0: 2227 7063 5f63 6f6d 7027 2068 6173 2077  "'pc_comp' has w
+00020f00: 726f 6e67 2064 696d 656e 7369 6f6e 732e  rong dimensions.
+00020f10: 2052 6563 6f6d 7075 7469 6e67 2050 4341   Recomputing PCA
+00020f20: 2229 0a20 2020 2020 2020 2063 6f6d 7075  ").        compu
+00020f30: 7465 5f70 6361 203d 2054 7275 650a 0a20  te_pca = True.. 
+00020f40: 2020 2069 6620 636f 6d70 7574 655f 7063     if compute_pc
+00020f50: 613a 0a20 2020 2020 2020 2070 7269 6e74  a:.        print
+00020f60: 2822 4669 7474 696e 6720 5043 4120 6f66  ("Fitting PCA of
+00020f70: 2025 6420 6469 6d65 6e73 696f 6e73 206f   %d dimensions o
+00020f80: 6e20 2564 2077 6176 6566 6f72 6d73 2220  n %d waveforms" 
+00020f90: 2520 286e 5f70 632c 206c 656e 2861 6c6c  % (n_pc, len(all
+00020fa0: 5f77 6176 6566 6f72 6d73 2929 290a 0a20  _waveforms))).. 
+00020fb0: 2020 2020 2020 2070 6361 203d 2050 4341         pca = PCA
+00020fc0: 286e 5f63 6f6d 706f 6e65 6e74 733d 6e5f  (n_components=n_
+00020fd0: 7063 2c20 7768 6974 656e 3d77 6869 7465  pc, whiten=white
+00020fe0: 6e29 0a20 2020 2020 2020 2023 2070 6361  n).        # pca
+00020ff0: 2e66 6974 5f74 7261 6e73 666f 726d 2861  .fit_transform(a
+00021000: 6c6c 5f77 6176 6566 6f72 6d73 290a 2020  ll_waveforms).  
+00021010: 2020 2020 2020 7063 612e 6669 7428 616c        pca.fit(al
+00021020: 6c5f 7761 7665 666f 726d 7329 0a20 2020  l_waveforms).   
+00021030: 2020 2020 2070 635f 636f 6d70 203d 2070       pc_comp = p
+00021040: 6361 2e63 6f6d 706f 6e65 6e74 735f 0a0a  ca.components_..
+00021050: 2020 2020 7063 615f 7363 6f72 6573 203d      pca_scores =
+00021060: 205b 5d0a 2020 2020 666f 7220 7374 2069   [].    for st i
+00021070: 6e20 7265 6367 656e 2e73 7069 6b65 7472  n recgen.spiketr
+00021080: 6169 6e73 3a0a 2020 2020 2020 2020 7063  ains:.        pc
+00021090: 7420 3d20 6e70 2e64 6f74 2873 742e 7761  t = np.dot(st.wa
+000210a0: 7665 666f 726d 732c 2070 635f 636f 6d70  veforms, pc_comp
+000210b0: 2e54 290a 2020 2020 2020 2020 6966 2077  .T).        if w
+000210c0: 6869 7465 6e3a 0a20 2020 2020 2020 2020  hiten:.         
+000210d0: 2020 2070 6374 202f 3d20 6e70 2e73 7172     pct /= np.sqr
+000210e0: 7428 7063 612e 6578 706c 6169 6e65 645f  t(pca.explained_
+000210f0: 7661 7269 616e 6365 5f29 0a20 2020 2020  variance_).     
+00021100: 2020 2070 6361 5f73 636f 7265 732e 6170     pca_scores.ap
+00021110: 7065 6e64 2870 6374 290a 0a20 2020 2069  pend(pct)..    i
+00021120: 6620 6178 2069 7320 4e6f 6e65 3a0a 2020  f ax is None:.  
+00021130: 2020 2020 2020 6669 6720 3d20 706c 742e        fig = plt.
+00021140: 6669 6775 7265 2829 0a20 2020 2020 2020  figure().       
+00021150: 2061 7820 3d20 6669 672e 6164 645f 7375   ax = fig.add_su
+00021160: 6270 6c6f 7428 3131 3129 0a20 2020 2065  bplot(111).    e
+00021170: 6c73 653a 0a20 2020 2020 2020 2066 6967  lse:.        fig
+00021180: 203d 2061 782e 6765 745f 6669 6775 7265   = ax.get_figure
+00021190: 2829 0a20 2020 2061 782e 6178 6973 2822  ().    ax.axis("
+000211a0: 6f66 6622 290a 0a20 2020 2069 6620 636d  off")..    if cm
+000211b0: 6170 2069 7320 6e6f 7420 4e6f 6e65 3a0a  ap is not None:.
+000211c0: 2020 2020 2020 2020 636d 203d 2070 6c74          cm = plt
+000211d0: 2e67 6574 5f63 6d61 7028 636d 6170 290a  .get_cmap(cmap).
+000211e0: 2020 2020 2020 2020 636f 6c6f 7273 203d          colors =
+000211f0: 205b 636d 2869 202f 206e 5f75 6e69 7473   [cm(i / n_units
+00021200: 2920 666f 7220 6920 696e 206e 702e 6172  ) for i in np.ar
+00021210: 616e 6765 286e 5f75 6e69 7473 295d 0a20  ange(n_units)]. 
+00021220: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+00021230: 2063 6f6c 6f72 7320 3d20 706c 742e 7263   colors = plt.rc
+00021240: 5061 7261 6d73 5b22 6178 6573 2e70 726f  Params["axes.pro
+00021250: 705f 6379 636c 6522 5d2e 6279 5f6b 6579  p_cycle"].by_key
+00021260: 2829 5b22 636f 6c6f 7222 5d0a 0a20 2020  ()["color"]..   
+00021270: 206e 726f 7773 203d 206c 656e 2870 635f   nrows = len(pc_
+00021280: 6469 6d73 2920 2a20 6c65 6e28 656c 6563  dims) * len(elec
+00021290: 5f64 696d 7329 0a20 2020 206e 636f 6c73  _dims).    ncols
+000212a0: 203d 206e 726f 7773 0a20 2020 2067 7320   = nrows.    gs 
+000212b0: 3d20 6772 6964 7370 6563 2e47 7269 6453  = gridspec.GridS
+000212c0: 7065 6346 726f 6d53 7562 706c 6f74 5370  pecFromSubplotSp
+000212d0: 6563 286e 726f 7773 2c20 6e63 6f6c 732c  ec(nrows, ncols,
+000212e0: 2073 7562 706c 6f74 5f73 7065 633d 6178   subplot_spec=ax
+000212f0: 290a 0a20 2020 2066 6f72 2070 3120 696e  )..    for p1 in
+00021300: 2070 635f 6469 6d73 3a0a 2020 2020 2020   pc_dims:.      
+00021310: 2020 666f 7220 6931 2c20 6368 3120 696e    for i1, ch1 in
+00021320: 2065 6e75 6d65 7261 7465 2865 6c65 635f   enumerate(elec_
+00021330: 6469 6d73 293a 0a20 2020 2020 2020 2020  dims):.         
+00021340: 2020 2066 6f72 2070 3220 696e 2070 635f     for p2 in pc_
+00021350: 6469 6d73 3a0a 2020 2020 2020 2020 2020  dims:.          
+00021360: 2020 2020 2020 666f 7220 6932 2c20 6368        for i2, ch
+00021370: 3220 696e 2065 6e75 6d65 7261 7465 2865  2 in enumerate(e
+00021380: 6c65 635f 6469 6d73 293a 0a20 2020 2020  lec_dims):.     
+00021390: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+000213a0: 203d 206e 5f70 6320 2a20 6931 202b 2070   = n_pc * i1 + p
+000213b0: 310a 2020 2020 2020 2020 2020 2020 2020  1.              
+000213c0: 2020 2020 2020 6320 3d20 6e5f 7063 202a        c = n_pc *
+000213d0: 2069 3220 2b20 7032 0a20 2020 2020 2020   i2 + p2.       
+000213e0: 2020 2020 2020 2020 2020 2020 2067 735f               gs_
+000213f0: 7365 6c20 3d20 6773 5b72 2c20 635d 0a20  sel = gs[r, c]. 
+00021400: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00021410: 2020 2061 785f 7365 6c20 3d20 6669 672e     ax_sel = fig.
+00021420: 6164 645f 7375 6270 6c6f 7428 6773 5f73  add_subplot(gs_s
+00021430: 656c 290a 2020 2020 2020 2020 2020 2020  el).            
+00021440: 2020 2020 2020 2020 6966 2063 203c 2072          if c < r
+00021450: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00021460: 2020 2020 2020 2020 2020 6178 5f73 656c            ax_sel
+00021470: 2e61 7869 7328 226f 6666 2229 0a20 2020  .axis("off").   
+00021480: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00021490: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+000214a0: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+000214b0: 6620 7220 3d3d 2030 3a0a 2020 2020 2020  f r == 0:.      
+000214c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000214d0: 2020 2020 2020 6178 5f73 656c 2e73 6574        ax_sel.set
+000214e0: 5f78 6c61 6265 6c28 2243 682e 2220 2b20  _xlabel("Ch." + 
+000214f0: 7374 7228 6368 3220 2b20 3129 202b 2022  str(ch2 + 1) + "
+00021500: 3a50 4322 202b 2073 7472 2870 3220 2b20  :PC" + str(p2 + 
+00021510: 3129 290a 2020 2020 2020 2020 2020 2020  1)).            
+00021520: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00021530: 6178 5f73 656c 2e78 6178 6973 2e73 6574  ax_sel.xaxis.set
+00021540: 5f6c 6162 656c 5f70 6f73 6974 696f 6e28  _label_position(
+00021550: 2274 6f70 2229 0a0a 2020 2020 2020 2020  "top")..        
+00021560: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00021570: 6178 5f73 656c 2e73 6574 5f78 7469 636b  ax_sel.set_xtick
+00021580: 7328 5b5d 290a 2020 2020 2020 2020 2020  s([]).          
+00021590: 2020 2020 2020 2020 2020 2020 2020 6178                ax
+000215a0: 5f73 656c 2e73 6574 5f79 7469 636b 7328  _sel.set_yticks(
+000215b0: 5b5d 290a 2020 2020 2020 2020 2020 2020  []).            
+000215c0: 2020 2020 2020 2020 2020 2020 6178 5f73              ax_s
+000215d0: 656c 2e73 7069 6e65 735b 2272 6967 6874  el.spines["right
+000215e0: 225d 2e73 6574 5f76 6973 6962 6c65 2846  "].set_visible(F
+000215f0: 616c 7365 290a 2020 2020 2020 2020 2020  alse).          
+00021600: 2020 2020 2020 2020 2020 2020 2020 6178                ax
+00021610: 5f73 656c 2e73 7069 6e65 735b 2274 6f70  _sel.spines["top
+00021620: 225d 2e73 6574 5f76 6973 6962 6c65 2846  "].set_visible(F
+00021630: 616c 7365 290a 2020 2020 2020 2020 2020  alse).          
+00021640: 2020 2020 2020 2020 2020 2020 2020 666f                fo
+00021650: 7220 692c 2070 6320 696e 2065 6e75 6d65  r i, pc in enume
+00021660: 7261 7465 2870 6361 5f73 636f 7265 7329  rate(pca_scores)
+00021670: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00021680: 2020 2020 2020 2020 2020 2020 2020 6966                if
+00021690: 2069 3120 3d3d 2069 3220 616e 6420 7031   i1 == i2 and p1
+000216a0: 203d 3d20 7032 3a0a 2020 2020 2020 2020   == p2:.        
+000216b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000216c0: 2020 2020 2020 2020 682c 2062 2c20 5f20          h, b, _ 
+000216d0: 3d20 6178 5f73 656c 2e68 6973 7428 7063  = ax_sel.hist(pc
+000216e0: 5b3a 2c20 6931 2c20 7031 5d2c 2062 696e  [:, i1, p1], bin
+000216f0: 733d 3530 2c20 616c 7068 613d 302e 362c  s=50, alpha=0.6,
+00021700: 2063 6f6c 6f72 3d63 6f6c 6f72 735b 695d   color=colors[i]
+00021710: 2c20 6465 6e73 6974 793d 5472 7565 290a  , density=True).
+00021720: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00021730: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00021740: 6178 5f73 656c 2e73 6574 5f79 6c61 6265  ax_sel.set_ylabe
+00021750: 6c28 2243 682e 2220 2b20 7374 7228 6368  l("Ch." + str(ch
+00021760: 3120 2b20 3129 202b 2022 3a50 4322 202b  1 + 1) + ":PC" +
+00021770: 2073 7472 2870 3120 2b20 3129 290a 2020   str(p1 + 1)).  
+00021780: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00021790: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
+000217a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000217b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000217c0: 6178 5f73 656c 2e70 6c6f 7428 0a20 2020  ax_sel.plot(.   
+000217d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000217e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000217f0: 2070 635b 3a2c 2069 322c 2070 325d 2c20   pc[:, i2, p2], 
+00021800: 7063 5b3a 2c20 6931 2c20 7031 5d2c 206d  pc[:, i1, p1], m
+00021810: 6172 6b65 723d 226f 222c 206d 733d 312c  arker="o", ms=1,
+00021820: 206c 733d 2222 2c20 616c 7068 613d 302e   ls="", alpha=0.
+00021830: 352c 2063 6f6c 6f72 3d63 6f6c 6f72 735b  5, color=colors[
+00021840: 695d 0a20 2020 2020 2020 2020 2020 2020  i].             
+00021850: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00021860: 2020 2029 0a0a 2020 2020 6669 672e 7375     )..    fig.su
+00021870: 6270 6c6f 7473 5f61 646a 7573 7428 7773  bplots_adjust(ws
+00021880: 7061 6365 3d30 2e30 322c 2068 7370 6163  pace=0.02, hspac
+00021890: 653d 302e 3032 290a 2020 2020 7265 7475  e=0.02).    retu
+000218a0: 726e 2061 782c 2070 6361 5f73 636f 7265  rn ax, pca_score
+000218b0: 732c 2070 635f 636f 6d70 0a0a 0a64 6566  s, pc_comp...def
+000218c0: 2070 6c6f 745f 6365 6c6c 5f64 7269 6674   plot_cell_drift
+000218d0: 7328 7265 6367 656e 2c20 6178 3d4e 6f6e  s(recgen, ax=Non
+000218e0: 6529 3a0a 2020 2020 2222 220a 2020 2020  e):.    """.    
+000218f0: 506c 6f74 2064 7269 6674 696e 6720 706f  Plot drifting po
+00021900: 7369 7469 6f6e 7320 666f 7220 616c 6c20  sitions for all 
+00021910: 6365 6c6c 730a 0a20 2020 2050 6172 616d  cells..    Param
+00021920: 6574 6572 730a 2020 2020 2d2d 2d2d 2d2d  eters.    ------
+00021930: 2d2d 2d2d 0a20 2020 2072 6563 6765 6e20  ----.    recgen 
+00021940: 3a20 5265 636f 7264 696e 6747 656e 6572  : RecordingGener
+00021950: 6174 6f72 0a20 2020 2020 2020 2052 6563  ator.        Rec
+00021960: 6f72 6469 6e67 2067 656e 6572 6174 6f72  ording generator
+00021970: 206f 626a 6563 740a 2020 2020 6178 203a   object.    ax :
+00021980: 2061 7869 730a 2020 2020 2020 2020 4d61   axis.        Ma
+00021990: 7470 6c6f 746c 6962 2020 6178 6973 0a0a  tplotlib  axis..
+000219a0: 2020 2020 5265 7475 726e 730a 2020 2020      Returns.    
+000219b0: 2d2d 2d2d 2d2d 2d0a 2020 2020 6178 203a  -------.    ax :
+000219c0: 2061 7869 730a 2020 2020 2020 2020 4d61   axis.        Ma
+000219d0: 7470 6c6f 746c 6962 2061 7869 730a 2020  tplotlib axis.  
+000219e0: 2020 2222 220a 2020 2020 696d 706f 7274    """.    import
+000219f0: 206d 6174 706c 6f74 6c69 622e 7079 6c61   matplotlib.pyla
+00021a00: 6220 6173 2070 6c74 0a0a 2020 2020 6966  b as plt..    if
+00021a10: 2061 7820 6973 204e 6f6e 653a 0a20 2020   ax is None:.   
+00021a20: 2020 2020 2066 6967 203d 2070 6c74 2e66       fig = plt.f
+00021a30: 6967 7572 6528 290a 2020 2020 2020 2020  igure().        
+00021a40: 6178 203d 2066 6967 2e61 6464 5f73 7562  ax = fig.add_sub
+00021a50: 706c 6f74 2831 3131 290a 2020 2020 656c  plot(111).    el
+00021a60: 7365 3a0a 2020 2020 2020 2020 6669 6720  se:.        fig 
+00021a70: 3d20 6178 2e67 6574 5f66 6967 7572 6528  = ax.get_figure(
+00021a80: 290a 2020 2020 6173 7365 7274 2072 6563  ).    assert rec
+00021a90: 6765 6e2e 6472 6966 745f 6c69 7374 2069  gen.drift_list i
+00021aa0: 7320 6e6f 7420 4e6f 6e65 2c20 224e 6f20  s not None, "No 
+00021ab0: 6472 6966 7420 696e 666f 2069 7320 6176  drift info is av
+00021ac0: 6169 6c61 626c 6522 0a0a 2020 2020 6472  ailable"..    dr
+00021ad0: 6966 745f 6c69 7374 203d 2072 6563 6765  ift_list = recge
+00021ae0: 6e2e 6472 6966 745f 6c69 7374 0a0a 2020  n.drift_list..  
+00021af0: 2020 6673 203d 2072 6563 6765 6e2e 696e    fs = recgen.in
+00021b00: 666f 5b22 7265 636f 7264 696e 6773 225d  fo["recordings"]
+00021b10: 5b22 6673 225d 0a0a 2020 2020 6c6f 6361  ["fs"]..    loca
+00021b20: 7469 6f6e 7320 3d20 7265 6367 656e 2e74  tions = recgen.t
+00021b30: 656d 706c 6174 655f 6c6f 6361 7469 6f6e  emplate_location
+00021b40: 730a 2020 2020 6472 6966 745f 7374 6570  s.    drift_step
+00021b50: 7320 3d20 6c6f 6361 7469 6f6e 732e 7368  s = locations.sh
+00021b60: 6170 655b 315d 0a20 2020 2066 6f72 2069  ape[1].    for i
+00021b70: 2c20 7374 2069 6e20 656e 756d 6572 6174  , st in enumerat
+00021b80: 6528 7265 6367 656e 2e73 7069 6b65 7472  e(recgen.spiketr
+00021b90: 6169 6e73 293a 0a20 2020 2020 2020 2073  ains):.        s
+00021ba0: 7069 6b65 5f69 6e64 6963 6573 203d 2028  pike_indices = (
+00021bb0: 7374 2e6d 6167 6e69 7475 6465 202a 2066  st.magnitude * f
+00021bc0: 7329 2e61 7374 7970 6528 2269 6e74 2229  s).astype("int")
+00021bd0: 0a20 2020 2020 2020 2064 7269 6674 5f69  .        drift_i
+00021be0: 6478 7320 3d20 636f 6d70 7574 655f 6472  dxs = compute_dr
+00021bf0: 6966 745f 6964 7873 5f66 726f 6d5f 6472  ift_idxs_from_dr
+00021c00: 6966 745f 6c69 7374 2869 2c20 7370 696b  ift_list(i, spik
+00021c10: 655f 696e 6469 6365 732c 2064 7269 6674  e_indices, drift
+00021c20: 5f6c 6973 742c 2066 7329 0a20 2020 2020  _list, fs).     
+00021c30: 2020 2064 7269 6674 5f69 6478 7320 3d20     drift_idxs = 
+00021c40: 6472 6966 745f 6964 7873 2e63 6c69 7028  drift_idxs.clip(
+00021c50: 302c 2064 7269 6674 5f73 7465 7073 202d  0, drift_steps -
+00021c60: 2031 290a 2020 2020 2020 2020 6c6f 6320   1).        loc 
+00021c70: 3d20 6c6f 6361 7469 6f6e 735b 695d 0a20  = locations[i]. 
+00021c80: 2020 2020 2020 2064 7269 6674 696e 6720         drifting 
+00021c90: 3d20 4661 6c73 650a 2020 2020 2020 2020  = False.        
+00021ca0: 6966 2022 6472 6966 7469 6e67 2220 696e  if "drifting" in
+00021cb0: 2073 742e 616e 6e6f 7461 7469 6f6e 733a   st.annotations:
+00021cc0: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+00021cd0: 7374 2e61 6e6e 6f74 6174 696f 6e73 5b22  st.annotations["
+00021ce0: 6472 6966 7469 6e67 225d 3a0a 2020 2020  drifting"]:.    
+00021cf0: 2020 2020 2020 2020 2020 2020 6472 6966              drif
+00021d00: 7469 6e67 203d 2054 7275 650a 2020 2020  ting = True.    
+00021d10: 2020 2020 6966 2064 7269 6674 696e 673a      if drifting:
+00021d20: 0a20 2020 2020 2020 2020 2020 206c 6f63  .            loc
+00021d30: 5f64 7269 6674 203d 206c 6f63 5b64 7269  _drift = loc[dri
+00021d40: 6674 5f69 6478 732c 2032 5d0a 2020 2020  ft_idxs, 2].    
+00021d50: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+00021d60: 2020 2020 2020 6e5f 7374 6570 7320 3d20        n_steps = 
+00021d70: 6c6f 632e 7368 6170 655b 305d 0a20 2020  loc.shape[0].   
+00021d80: 2020 2020 2020 2020 206c 6f63 5f64 7269           loc_dri
+00021d90: 6674 203d 205b 6c6f 635b 6e5f 7374 6570  ft = [loc[n_step
+00021da0: 7320 2f2f 2032 2c20 325d 5d20 2a20 6c65  s // 2, 2]] * le
+00021db0: 6e28 7374 2e6d 6167 6e69 7475 6465 290a  n(st.magnitude).
+00021dc0: 2020 2020 2020 2020 6178 2e70 6c6f 7428          ax.plot(
+00021dd0: 7374 2e6d 6167 6e69 7475 6465 2c20 6c6f  st.magnitude, lo
+00021de0: 635f 6472 6966 742c 206c 6162 656c 3d66  c_drift, label=f
+00021df0: 2255 6e69 7420 7b69 7d22 290a 2020 2020  "Unit {i}").    
+00021e00: 6178 2e6c 6567 656e 6428 290a 2020 2020  ax.legend().    
+00021e10: 7265 7475 726e 2061 780a 0a0a 2323 2323  return ax...####
+00021e20: 2323 2323 2320 4845 4c50 4552 2046 554e  ##### HELPER FUN
+00021e30: 4354 494f 4e53 2023 2323 2323 2323 2323  CTIONS #########
+00021e40: 0a64 6566 205f 7265 7361 6d70 6c65 5f70  .def _resample_p
+00021e50: 6172 616c 6c65 6c28 692c 2074 656d 706c  arallel(i, templ
+00021e60: 6174 652c 2075 702c 2064 6f77 6e2c 2064  ate, up, down, d
+00021e70: 7269 6674 696e 6729 3a0a 2020 2020 2222  rifting):.    ""
+00021e80: 220a 2020 2020 5265 7361 6d70 6c65 7320  ".    Resamples 
+00021e90: 6120 7465 6d70 6c61 7465 2074 6f20 6120  a template to a 
+00021ea0: 7370 6563 6966 6965 6420 7361 6d70 6c69  specified sampli
+00021eb0: 6e67 2066 7265 7175 656e 6379 2e0a 2020  ng frequency..  
+00021ec0: 2020 5061 7261 6d65 7465 7273 0a20 2020    Parameters.   
+00021ed0: 202d 2d2d 2d2d 2d2d 2d2d 2d0a 2020 2020   ----------.    
+00021ee0: 7465 6d70 6c61 7465 203a 206e 702e 6172  template : np.ar
+00021ef0: 7261 790a 2020 2020 2020 2020 4172 7261  ray.        Arra
+00021f00: 7920 7769 7468 206f 6e65 2074 656d 706c  y with one templ
+00021f10: 6174 6520 286e 5f63 6861 6e6e 656c 732c  ate (n_channels,
+00021f20: 206e 5f73 616d 706c 6573 2920 6f72 2028   n_samples) or (
+00021f30: 6e5f 6472 6966 742c 206e 5f63 6861 6e6e  n_drift, n_chann
+00021f40: 656c 732c 206e 5f73 616d 706c 6573 2920  els, n_samples) 
+00021f50: 6966 2064 7269 6674 696e 670a 2020 2020  if drifting.    
+00021f60: 7570 203a 2066 6c6f 6174 0a20 2020 2020  up : float.     
+00021f70: 2020 2054 6865 206f 7269 6769 6e61 6c20     The original 
+00021f80: 7361 6d70 6c69 6e67 2066 7265 7175 656e  sampling frequen
+00021f90: 6379 2069 6e20 487a 0a20 2020 2064 6f77  cy in Hz.    dow
+00021fa0: 6e20 3a20 666c 6f61 740a 2020 2020 2020  n : float.      
+00021fb0: 2020 5468 6520 6e65 7720 7361 6d70 6c69    The new sampli
+00021fc0: 6e67 2066 7265 7175 656e 6379 2069 6e20  ng frequency in 
+00021fd0: 487a 0a20 2020 2064 7269 6674 696e 6720  Hz.    drifting 
+00021fe0: 3a20 626f 6f6c 0a20 2020 2020 2020 2049  : bool.        I
+00021ff0: 6620 5472 7565 2074 656d 706c 6174 6573  f True templates
+00022000: 2061 7265 2061 7373 756d 6564 2074 6f20   are assumed to 
+00022010: 6265 2064 7269 6674 696e 670a 2020 2020  be drifting.    
+00022020: 5265 7475 726e 730a 2020 2020 2d2d 2d2d  Returns.    ----
+00022030: 2d2d 2d0a 2020 2020 7465 6d70 6c61 7465  ---.    template
+00022040: 5f72 7320 3a20 6e70 2e61 7272 6179 0a20  _rs : np.array. 
+00022050: 2020 2020 2020 2041 7272 6179 2077 6974         Array wit
+00022060: 6820 7265 7361 6d70 6c65 6420 7465 6d70  h resampled temp
+00022070: 6c61 7465 2028 6e5f 6368 616e 6e65 6c73  late (n_channels
+00022080: 2c20 6e5f 7265 7361 6d70 6c65 290a 2020  , n_resample).  
+00022090: 2020 2020 2020 6f72 2028 6e5f 6472 6966        or (n_drif
+000220a0: 742c 206e 5f63 6861 6e6e 656c 732c 206e  t, n_channels, n
+000220b0: 5f72 6573 616d 706c 6529 0a20 2020 2022  _resample).    "
+000220c0: 2222 0a20 2020 2069 6620 6e6f 7420 6472  "".    if not dr
+000220d0: 6966 7469 6e67 3a0a 2020 2020 2020 2020  ifting:.        
+000220e0: 7465 6d5f 706f 6c79 203d 2073 732e 7265  tem_poly = ss.re
+000220f0: 7361 6d70 6c65 5f70 6f6c 7928 7465 6d70  sample_poly(temp
+00022100: 6c61 7465 2c20 7570 2c20 646f 776e 2c20  late, up, down, 
+00022110: 6178 6973 3d31 290a 2020 2020 656c 7365  axis=1).    else
+00022120: 3a0a 2020 2020 2020 2020 7465 6d5f 706f  :.        tem_po
+00022130: 6c79 203d 2073 732e 7265 7361 6d70 6c65  ly = ss.resample
+00022140: 5f70 6f6c 7928 7465 6d70 6c61 7465 2c20  _poly(template, 
+00022150: 7570 2c20 646f 776e 2c20 6178 6973 3d32  up, down, axis=2
+00022160: 290a 2020 2020 7265 7475 726e 2074 656d  ).    return tem
+00022170: 5f70 6f6c 790a 0a0a 6465 6620 5f6a 6974  _poly...def _jit
+00022180: 7465 725f 7061 7261 6c6c 656c 2869 2c20  ter_parallel(i, 
+00022190: 7465 6d70 6c61 7465 2c20 7570 7361 6d70  template, upsamp
+000221a0: 6c65 2c20 6673 2c20 6e5f 6a69 7474 6572  le, fs, n_jitter
+000221b0: 732c 206a 6974 7465 722c 2064 7269 6674  s, jitter, drift
+000221c0: 696e 672c 2076 6572 626f 7365 2c20 7465  ing, verbose, te
+000221d0: 6d70 6c61 7465 735f 6a69 7474 6572 293a  mplates_jitter):
+000221e0: 0a20 2020 2022 2222 0a20 2020 2041 6464  .    """.    Add
+000221f0: 7320 6a69 7474 6572 6564 2072 6570 6c69  s jittered repli
+00022200: 6361 7320 746f 206f 6e65 2074 656d 706c  cas to one templ
+00022210: 6174 652e 0a20 2020 2050 6172 616d 6574  ate..    Paramet
+00022220: 6572 730a 2020 2020 2d2d 2d2d 2d2d 2d2d  ers.    --------
+00022230: 2d2d 0a20 2020 2074 656d 706c 6174 6520  --.    template 
+00022240: 3a20 6e70 2e61 7272 6179 0a20 2020 2020  : np.array.     
+00022250: 2020 2041 7272 6179 2077 6974 6820 7465     Array with te
+00022260: 6d70 6c61 7465 7320 286e 5f63 6861 6e6e  mplates (n_chann
+00022270: 656c 732c 206e 5f73 616d 706c 6573 2920  els, n_samples) 
+00022280: 6f72 2028 6e5f 6472 6966 742c 206e 5f63  or (n_drift, n_c
+00022290: 6861 6e6e 656c 732c 206e 5f73 616d 706c  hannels, n_sampl
+000222a0: 6573 2920 6966 2064 7269 6674 696e 670a  es) if drifting.
+000222b0: 2020 2020 7570 7361 6d70 6c65 203a 2069      upsample : i
+000222c0: 6e74 0a20 2020 2020 2020 2046 6163 746f  nt.        Facto
+000222d0: 7220 666f 7220 7570 7361 6d70 6c69 6e67  r for upsampling
+000222e0: 2074 6865 2074 656d 706c 6174 6573 0a20   the templates. 
+000222f0: 2020 206e 5f6a 6974 7465 7273 203a 2069     n_jitters : i
+00022300: 6e74 0a20 2020 2020 2020 204e 756d 6265  nt.        Numbe
+00022310: 7220 6f66 206a 6974 7465 7265 6420 636f  r of jittered co
+00022320: 7069 6573 2066 6f72 2065 6163 6820 7465  pies for each te
+00022330: 6d70 6c61 7465 0a20 2020 206a 6974 7465  mplate.    jitte
+00022340: 7220 3a20 7175 616e 7469 7479 0a20 2020  r : quantity.   
+00022350: 2020 2020 204a 6974 7465 7220 696e 2074       Jitter in t
+00022360: 696d 6520 666f 7220 7368 6966 7469 6e67  ime for shifting
+00022370: 2074 6865 2074 656d 706c 6174 650a 2020   the template.  
+00022380: 2020 6472 6966 7469 6e67 203a 2062 6f6f    drifting : boo
+00022390: 6c0a 2020 2020 2020 2020 4966 2054 7275  l.        If Tru
+000223a0: 6520 7465 6d70 6c61 7465 7320 6172 6520  e templates are 
+000223b0: 6173 7375 6d65 6420 746f 2062 6520 6472  assumed to be dr
+000223c0: 6966 7469 6e67 0a20 2020 2076 6572 626f  ifting.    verbo
+000223d0: 7365 203a 2062 6f6f 6c0a 2020 2020 2020  se : bool.      
+000223e0: 2020 4966 2054 7275 6520 6f75 7470 7574    If True output
+000223f0: 2069 7320 7665 7262 6f73 650a 2020 2020   is verbose.    
+00022400: 5265 7475 726e 730a 2020 2020 2d2d 2d2d  Returns.    ----
+00022410: 2d2d 2d0a 2020 2020 7465 6d70 6c61 7465  ---.    template
+00022420: 5f6a 6974 7420 3a20 6e70 2e61 7272 6179  _jitt : np.array
+00022430: 0a20 2020 2020 2020 2041 7272 6179 2077  .        Array w
+00022440: 6974 6820 6f6e 6520 6a69 7474 6572 6564  ith one jittered
+00022450: 2074 656d 706c 6174 6520 286e 5f6a 6974   template (n_jit
+00022460: 7465 7273 2c20 6e5f 6368 616e 6e65 6c73  ters, n_channels
+00022470: 2c20 6e5f 7361 6d70 6c65 7329 0a20 2020  , n_samples).   
+00022480: 2020 2020 206f 7220 286e 5f64 7269 6674       or (n_drift
+00022490: 2c20 6e5f 6a69 7474 6572 732c 206e 5f63  , n_jitters, n_c
+000224a0: 6861 6e6e 656c 732c 206e 5f73 616d 706c  hannels, n_sampl
+000224b0: 6573 2920 6966 2064 7269 6674 696e 670a  es) if drifting.
+000224c0: 2020 2020 2222 220a 2020 2020 726e 6720      """.    rng 
+000224d0: 3d20 6e70 2e72 616e 646f 6d2e 5261 6e64  = np.random.Rand
+000224e0: 6f6d 5374 6174 6528 6929 0a0a 2020 2020  omState(i)..    
+000224f0: 6966 206e 6f74 2064 7269 6674 696e 673a  if not drifting:
+00022500: 0a20 2020 2020 2020 2074 656d 706c 6174  .        templat
+00022510: 655f 6a69 7474 6572 203d 206e 702e 7a65  e_jitter = np.ze
+00022520: 726f 7328 286e 5f6a 6974 7465 7273 2c20  ros((n_jitters, 
+00022530: 7465 6d70 6c61 7465 2e73 6861 7065 5b30  template.shape[0
+00022540: 5d2c 2074 656d 706c 6174 652e 7368 6170  ], template.shap
+00022550: 655b 315d 2929 0a20 2020 2020 2020 2074  e[1])).        t
+00022560: 656d 705f 7570 203d 2073 732e 7265 7361  emp_up = ss.resa
+00022570: 6d70 6c65 5f70 6f6c 7928 7465 6d70 6c61  mple_poly(templa
+00022580: 7465 2c20 7570 7361 6d70 6c65 2c20 312c  te, upsample, 1,
+00022590: 2061 7869 733d 3129 0a20 2020 2020 2020   axis=1).       
+000225a0: 206e 7361 6d70 6c65 735f 7570 203d 2074   nsamples_up = t
+000225b0: 656d 705f 7570 2e73 6861 7065 5b31 5d0a  emp_up.shape[1].
+000225c0: 2020 2020 2020 2020 666f 7220 6e20 696e          for n in
+000225d0: 206e 702e 6172 616e 6765 286e 5f6a 6974   np.arange(n_jit
+000225e0: 7465 7273 293a 0a20 2020 2020 2020 2020  ters):.         
+000225f0: 2020 2023 2061 6c69 676e 2077 6176 6566     # align wavef
+00022600: 6f72 6d0a 2020 2020 2020 2020 2020 2020  orm.            
+00022610: 7368 6966 7420 3d20 696e 7428 286a 6974  shift = int((jit
+00022620: 7465 7220 2a20 2872 6e67 2e72 616e 646f  ter * (rng.rando
+00022630: 6d28 2920 2d20 302e 3529 202a 2075 7073  m() - 0.5) * ups
+00022640: 616d 706c 6520 2a20 6673 292e 6d61 676e  ample * fs).magn
+00022650: 6974 7564 6529 0a20 2020 2020 2020 2020  itude).         
+00022660: 2020 2069 6620 7368 6966 7420 3e20 303a     if shift > 0:
+00022670: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00022680: 2074 5f6a 6974 7420 3d20 6e70 2e70 6164   t_jitt = np.pad
+00022690: 2874 656d 705f 7570 2c20 5b28 302c 2030  (temp_up, [(0, 0
+000226a0: 292c 2028 6e70 2e61 6273 2873 6869 6674  ), (np.abs(shift
+000226b0: 292c 2030 295d 2c20 2263 6f6e 7374 616e  ), 0)], "constan
+000226c0: 7422 295b 3a2c 203a 6e73 616d 706c 6573  t")[:, :nsamples
+000226d0: 5f75 705d 0a20 2020 2020 2020 2020 2020  _up].           
+000226e0: 2065 6c69 6620 7368 6966 7420 3c20 303a   elif shift < 0:
+000226f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00022700: 2074 5f6a 6974 7420 3d20 6e70 2e70 6164   t_jitt = np.pad
+00022710: 2874 656d 705f 7570 2c20 5b28 302c 2030  (temp_up, [(0, 0
+00022720: 292c 2028 302c 206e 702e 6162 7328 7368  ), (0, np.abs(sh
+00022730: 6966 7429 295d 2c20 2263 6f6e 7374 616e  ift))], "constan
+00022740: 7422 295b 3a2c 202d 6e73 616d 706c 6573  t")[:, -nsamples
+00022750: 5f75 703a 5d0a 2020 2020 2020 2020 2020  _up:].          
+00022760: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+00022770: 2020 2020 2020 2020 745f 6a69 7474 203d          t_jitt =
+00022780: 2074 656d 705f 7570 0a20 2020 2020 2020   temp_up.       
+00022790: 2020 2020 2074 656d 705f 646f 776e 203d       temp_down =
+000227a0: 2074 5f6a 6974 745b 3a2c 203a 3a75 7073   t_jitt[:, ::ups
+000227b0: 616d 706c 655d 0a20 2020 2020 2020 2020  ample].         
+000227c0: 2020 2074 656d 706c 6174 655f 6a69 7474     template_jitt
+000227d0: 6572 5b6e 5d20 3d20 7465 6d70 5f64 6f77  er[n] = temp_dow
+000227e0: 6e0a 2020 2020 656c 7365 3a0a 2020 2020  n.    else:.    
+000227f0: 2020 2020 6966 2076 6572 626f 7365 3a0a      if verbose:.
+00022800: 2020 2020 2020 2020 2020 2020 7072 696e              prin
+00022810: 7428 224a 6974 7465 7269 6e67 3a20 6e65  t("Jittering: ne
+00022820: 7572 6f6e 2022 2c20 6929 0a20 2020 2020  uron ", i).     
+00022830: 2020 2074 656d 706c 6174 655f 6a69 7474     template_jitt
+00022840: 6572 203d 206e 702e 7a65 726f 7328 2874  er = np.zeros((t
+00022850: 656d 706c 6174 652e 7368 6170 655b 305d  emplate.shape[0]
+00022860: 2c20 6e5f 6a69 7474 6572 732c 2074 656d  , n_jitters, tem
+00022870: 706c 6174 652e 7368 6170 655b 315d 2c20  plate.shape[1], 
+00022880: 7465 6d70 6c61 7465 2e73 6861 7065 5b32  template.shape[2
+00022890: 5d29 290a 2020 2020 2020 2020 666f 7220  ])).        for 
+000228a0: 7470 2c20 7465 6d5f 7020 696e 2065 6e75  tp, tem_p in enu
+000228b0: 6d65 7261 7465 2874 656d 706c 6174 6529  merate(template)
+000228c0: 3a0a 2020 2020 2020 2020 2020 2020 7465  :.            te
+000228d0: 6d70 5f75 7020 3d20 7373 2e72 6573 616d  mp_up = ss.resam
+000228e0: 706c 655f 706f 6c79 2874 656d 5f70 2c20  ple_poly(tem_p, 
+000228f0: 7570 7361 6d70 6c65 2c20 312c 2061 7869  upsample, 1, axi
+00022900: 733d 3129 0a20 2020 2020 2020 2020 2020  s=1).           
+00022910: 206e 7361 6d70 6c65 735f 7570 203d 2074   nsamples_up = t
+00022920: 656d 705f 7570 2e73 6861 7065 5b31 5d0a  emp_up.shape[1].
+00022930: 2020 2020 2020 2020 2020 2020 666f 7220              for 
+00022940: 6e20 696e 206e 702e 6172 616e 6765 286e  n in np.arange(n
+00022950: 5f6a 6974 7465 7273 293a 0a20 2020 2020  _jitters):.     
+00022960: 2020 2020 2020 2020 2020 2023 2061 6c69             # ali
+00022970: 676e 2077 6176 6566 6f72 6d0a 2020 2020  gn waveform.    
+00022980: 2020 2020 2020 2020 2020 2020 7368 6966              shif
+00022990: 7420 3d20 696e 7428 286a 6974 7465 7220  t = int((jitter 
+000229a0: 2a20 726e 672e 7261 6e64 6e28 2920 2a20  * rng.randn() * 
+000229b0: 7570 7361 6d70 6c65 202a 2066 7329 2e6d  upsample * fs).m
+000229c0: 6167 6e69 7475 6465 290a 2020 2020 2020  agnitude).      
+000229d0: 2020 2020 2020 2020 2020 6966 2073 6869            if shi
+000229e0: 6674 203e 2030 3a0a 2020 2020 2020 2020  ft > 0:.        
+000229f0: 2020 2020 2020 2020 2020 2020 745f 6a69              t_ji
+00022a00: 7474 203d 206e 702e 7061 6428 7465 6d70  tt = np.pad(temp
+00022a10: 5f75 702c 205b 2830 2c20 3029 2c20 286e  _up, [(0, 0), (n
+00022a20: 702e 6162 7328 7368 6966 7429 2c20 3029  p.abs(shift), 0)
+00022a30: 5d2c 2022 636f 6e73 7461 6e74 2229 5b3a  ], "constant")[:
+00022a40: 2c20 3a6e 7361 6d70 6c65 735f 7570 5d0a  , :nsamples_up].
+00022a50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022a60: 656c 6966 2073 6869 6674 203c 2030 3a0a  elif shift < 0:.
+00022a70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022a80: 2020 2020 745f 6a69 7474 203d 206e 702e      t_jitt = np.
+00022a90: 7061 6428 7465 6d70 5f75 702c 205b 2830  pad(temp_up, [(0
+00022aa0: 2c20 3029 2c20 2830 2c20 6e70 2e61 6273  , 0), (0, np.abs
+00022ab0: 2873 6869 6674 2929 5d2c 2022 636f 6e73  (shift))], "cons
+00022ac0: 7461 6e74 2229 5b3a 2c20 2d6e 7361 6d70  tant")[:, -nsamp
+00022ad0: 6c65 735f 7570 3a5d 0a20 2020 2020 2020  les_up:].       
+00022ae0: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
+00022af0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022b00: 2020 2074 5f6a 6974 7420 3d20 7465 6d70     t_jitt = temp
+00022b10: 5f75 700a 2020 2020 2020 2020 2020 2020  _up.            
+00022b20: 2020 2020 7465 6d70 5f64 6f77 6e20 3d20      temp_down = 
+00022b30: 745f 6a69 7474 5b3a 2c20 3a3a 7570 7361  t_jitt[:, ::upsa
+00022b40: 6d70 6c65 5d0a 2020 2020 2020 2020 2020  mple].          
+00022b50: 2020 2020 2020 7465 6d70 6c61 7465 5f6a        template_j
+00022b60: 6974 7465 725b 7470 2c20 6e5d 203d 2074  itter[tp, n] = t
+00022b70: 656d 705f 646f 776e 0a0a 2020 2020 6966  emp_down..    if
+00022b80: 2074 656d 706c 6174 6573 5f6a 6974 7465   templates_jitte
+00022b90: 7220 6973 204e 6f6e 653a 0a20 2020 2020  r is None:.     
+00022ba0: 2020 2072 6574 7572 6e20 7465 6d70 6c61     return templa
+00022bb0: 7465 5f6a 6974 7465 720a 2020 2020 656c  te_jitter.    el
+00022bc0: 7365 3a0a 2020 2020 2020 2020 7465 6d70  se:.        temp
+00022bd0: 6c61 7465 735f 6a69 7474 6572 5b69 5d20  lates_jitter[i] 
+00022be0: 3d20 7465 6d70 6c61 7465 5f6a 6974 7465  = template_jitte
+00022bf0: 720a 0a0a 6465 6620 5f70 6164 5f70 6172  r...def _pad_par
+00022c00: 616c 6c65 6c28 692c 2074 656d 706c 6174  allel(i, templat
+00022c10: 652c 2070 6164 5f73 616d 706c 6573 2c20  e, pad_samples, 
+00022c20: 6472 6966 7469 6e67 2c20 7665 7262 6f73  drifting, verbos
+00022c30: 652c 2074 656d 706c 6174 6573 5f70 6164  e, templates_pad
+00022c40: 293a 0a20 2020 2022 2222 0a20 2020 2050  ):.    """.    P
+00022c50: 6164 7320 6f6e 6520 7465 6d70 6c61 7465  ads one template
+00022c60: 206f 6e20 626f 7468 2065 6e64 732e 0a20   on both ends.. 
+00022c70: 2020 2050 6172 616d 6574 6572 730a 2020     Parameters.  
+00022c80: 2020 2d2d 2d2d 2d2d 2d2d 2d2d 0a20 2020    ----------.   
+00022c90: 2074 656d 706c 6174 6520 3a20 6e70 2e61   template : np.a
+00022ca0: 7272 6179 0a20 2020 2020 2020 2041 7272  rray.        Arr
+00022cb0: 6179 2077 6974 6820 7465 6d70 6c61 7465  ay with template
+00022cc0: 7320 286e 5f63 6861 6e6e 656c 732c 206e  s (n_channels, n
+00022cd0: 5f73 616d 706c 6573 2920 6f72 2028 6e5f  _samples) or (n_
+00022ce0: 6472 6966 7420 6e5f 6368 616e 6e65 6c73  drift n_channels
+00022cf0: 2c20 6e5f 7361 6d70 6c65 7329 2069 6620  , n_samples) if 
+00022d00: 6472 6966 7469 6e67 0a20 2020 2070 6164  drifting.    pad
+00022d10: 5f73 616d 706c 6573 203a 206c 6973 740a  _samples : list.
+00022d20: 2020 2020 2020 2020 4c69 7374 206f 6620          List of 
+00022d30: 3220 696e 7473 2077 6974 6820 6e75 6d62  2 ints with numb
+00022d40: 6572 206f 6620 7361 6d70 6c65 7320 666f  er of samples fo
+00022d50: 7220 7061 6464 696e 6720 6265 666f 7265  r padding before
+00022d60: 2061 6e64 2061 6674 6572 0a20 2020 2064   and after.    d
+00022d70: 7269 6674 696e 6720 3a20 626f 6f6c 0a20  rifting : bool. 
+00022d80: 2020 2020 2020 2049 6620 5472 7565 2074         If True t
+00022d90: 656d 706c 6174 6573 2061 7265 2061 7373  emplates are ass
+00022da0: 756d 6564 2074 6f20 6265 2064 7269 6674  umed to be drift
+00022db0: 696e 670a 2020 2020 7665 7262 6f73 6520  ing.    verbose 
+00022dc0: 3a20 626f 6f6c 0a20 2020 2020 2020 2049  : bool.        I
+00022dd0: 6620 5472 7565 206f 7574 7075 7420 6973  f True output is
+00022de0: 2076 6572 626f 7365 0a20 2020 2052 6574   verbose.    Ret
+00022df0: 7572 6e73 0a20 2020 202d 2d2d 2d2d 2d2d  urns.    -------
+00022e00: 0a20 2020 2074 656d 706c 6174 655f 7061  .    template_pa
+00022e10: 6420 3a20 6e70 2e61 7272 6179 0a20 2020  d : np.array.   
+00022e20: 2020 2020 2041 7272 6179 2077 6974 6820       Array with 
+00022e30: 7061 6464 6564 2074 656d 706c 6174 6520  padded template 
+00022e40: 286e 5f63 6861 6e6e 656c 732c 206e 5f70  (n_channels, n_p
+00022e50: 6164 6465 645f 7361 6d70 6c65 290a 2020  added_sample).  
+00022e60: 2020 2020 2020 6f72 2028 6e5f 6472 6966        or (n_drif
+00022e70: 742c 206e 5f63 6861 6e6e 656c 732c 206e  t, n_channels, n
+00022e80: 5f70 6164 6465 645f 7361 6d70 6c65 2920  _padded_sample) 
+00022e90: 6966 2064 7269 6674 696e 670a 2020 2020  if drifting.    
+00022ea0: 2222 220a 2020 2020 6966 206e 6f74 2064  """.    if not d
+00022eb0: 7269 6674 696e 673a 0a20 2020 2020 2020  rifting:.       
+00022ec0: 2074 656d 5f70 6164 203d 2063 7562 6963   tem_pad = cubic
+00022ed0: 5f70 6164 6469 6e67 2874 656d 706c 6174  _padding(templat
+00022ee0: 652c 2070 6164 5f73 616d 706c 6573 290a  e, pad_samples).
+00022ef0: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+00022f00: 2020 6966 2076 6572 626f 7365 3a0a 2020    if verbose:.  
+00022f10: 2020 2020 2020 2020 2020 7072 696e 7428            print(
+00022f20: 2250 6164 6469 6e67 2065 6467 6573 3a20  "Padding edges: 
+00022f30: 6e65 7572 6f6e 2022 2c20 6929 0a20 2020  neuron ", i).   
+00022f40: 2020 2020 2070 6164 6465 645f 7465 6d70       padded_temp
+00022f50: 6c61 7465 5f73 616d 706c 6573 203d 2074  late_samples = t
+00022f60: 656d 706c 6174 652e 7368 6170 655b 2d31  emplate.shape[-1
+00022f70: 5d20 2b20 6e70 2e73 756d 2870 6164 5f73  ] + np.sum(pad_s
+00022f80: 616d 706c 6573 290a 2020 2020 2020 2020  amples).        
+00022f90: 7465 6d5f 7061 6420 3d20 6e70 2e7a 6572  tem_pad = np.zer
+00022fa0: 6f73 2828 7465 6d70 6c61 7465 2e73 6861  os((template.sha
+00022fb0: 7065 5b30 5d2c 2074 656d 706c 6174 652e  pe[0], template.
+00022fc0: 7368 6170 655b 315d 2c20 7061 6464 6564  shape[1], padded
+00022fd0: 5f74 656d 706c 6174 655f 7361 6d70 6c65  _template_sample
+00022fe0: 7329 290a 2020 2020 2020 2020 666f 7220  s)).        for 
+00022ff0: 7470 2c20 7465 6d5f 7020 696e 2065 6e75  tp, tem_p in enu
+00023000: 6d65 7261 7465 2874 656d 706c 6174 6529  merate(template)
+00023010: 3a0a 2020 2020 2020 2020 2020 2020 7465  :.            te
+00023020: 6d5f 7061 645b 7470 5d20 3d20 6375 6269  m_pad[tp] = cubi
+00023030: 635f 7061 6464 696e 6728 7465 6d5f 702c  c_padding(tem_p,
+00023040: 2070 6164 5f73 616d 706c 6573 290a 2020   pad_samples).  
+00023050: 2020 6966 2074 656d 706c 6174 6573 5f70    if templates_p
+00023060: 6164 2069 7320 4e6f 6e65 3a0a 2020 2020  ad is None:.    
+00023070: 2020 2020 7265 7475 726e 2074 656d 5f70      return tem_p
+00023080: 6164 0a20 2020 2065 6c73 653a 0a20 2020  ad.    else:.   
+00023090: 2020 2020 2074 656d 706c 6174 6573 5f70       templates_p
+000230a0: 6164 5b69 5d20 3d20 7465 6d5f 7061 640a  ad[i] = tem_pad.
+000230b0: 0a0a 6465 6620 5f61 6e6e 6f74 6174 655f  ..def _annotate_
+000230c0: 7061 7261 6c6c 656c 2869 2c20 7374 5f69  parallel(i, st_i
+000230d0: 2c20 7370 696b 6574 7261 696e 732c 2074  , spiketrains, t
+000230e0: 5f6a 6974 742c 206f 7665 726c 6170 7069  _jitt, overlappi
+000230f0: 6e67 5f70 6169 7273 2c20 7665 7262 6f73  ng_pairs, verbos
+00023100: 6529 3a0a 2020 2020 2222 220a 2020 2020  e):.    """.    
+00023110: 4865 6c70 6572 2066 756e 6374 696f 6e20  Helper function 
+00023120: 746f 2061 6e6e 6f74 6174 6520 7370 696b  to annotate spik
+00023130: 6520 7472 6169 6e73 2069 6e20 7061 7261  e trains in para
+00023140: 6c6c 656c 2e0a 2020 2020 5061 7261 6d65  llel..    Parame
+00023150: 7465 7273 0a20 2020 202d 2d2d 2d2d 2d2d  ters.    -------
+00023160: 2d2d 2d0a 2020 2020 6920 3a20 696e 740a  ---.    i : int.
+00023170: 2020 2020 2020 2020 496e 6465 7820 6f66          Index of
+00023180: 2073 7069 6b65 2074 7261 696e 0a20 2020   spike train.   
+00023190: 2073 745f 6920 3a20 6e65 6f2e 5370 696b   st_i : neo.Spik
+000231a0: 6554 7261 696e 0a20 2020 2020 2020 2053  eTrain.        S
+000231b0: 7069 6b65 2074 7261 696e 2074 6f20 6265  pike train to be
+000231c0: 2070 726f 6365 7373 6564 0a20 2020 2073   processed.    s
+000231d0: 7069 6b65 7472 6169 6e73 203a 206c 6973  piketrains : lis
+000231e0: 740a 2020 2020 2020 2020 4c69 7374 206f  t.        List o
+000231f0: 6620 6e65 6f20 7370 696b 6574 7261 696e  f neo spiketrain
+00023200: 730a 2020 2020 745f 6a69 7474 203a 2051  s.    t_jitt : Q
+00023210: 7561 6e74 6974 790a 2020 2020 2020 2020  uantity.        
+00023220: 5469 6d65 206a 6974 7465 7220 746f 2063  Time jitter to c
+00023230: 6f6e 7369 6465 7220 6f76 6572 6c61 7070  onsider overlapp
+00023240: 696e 6720 7370 696b 6573 2069 6e20 7469  ing spikes in ti
+00023250: 6d65 2028 6465 6661 756c 7420 3120 6d73  me (default 1 ms
+00023260: 290a 2020 2020 6f76 6572 6c61 7070 696e  ).    overlappin
+00023270: 675f 7061 6972 7320 3a20 6e70 2e61 7272  g_pairs : np.arr
+00023280: 6179 0a20 2020 2020 2020 2041 7272 6179  ay.        Array
+00023290: 2077 6974 6820 6f76 6572 6c61 7070 696e   with overlappin
+000232a0: 6720 696e 666f 726d 6174 696f 6e20 6265  g information be
+000232b0: 7477 6565 6e20 7370 696b 6520 7472 6169  tween spike trai
+000232c0: 6e73 2028 6e5f 7370 696b 6574 7261 696e  ns (n_spiketrain
+000232d0: 732c 2032 290a 2020 2020 7665 7262 6f73  s, 2).    verbos
+000232e0: 6520 3a20 626f 6f6c 0a20 2020 2020 2020  e : bool.       
+000232f0: 2049 6620 5472 7565 206f 7574 7075 7420   If True output 
+00023300: 6973 2076 6572 626f 7365 0a20 2020 2022  is verbose.    "
+00023310: 2222 0a20 2020 2069 6620 7665 7262 6f73  "".    if verbos
+00023320: 653a 0a20 2020 2020 2020 2070 7269 6e74  e:.        print
+00023330: 2822 416e 6e6f 7461 7469 6e67 206f 7665  ("Annotating ove
+00023340: 726c 6170 7069 6e67 2073 7069 6b65 2074  rlapping spike t
+00023350: 7261 696e 2022 2c20 6929 0a20 2020 206f  rain ", i).    o
+00023360: 7665 7220 3d20 6e70 2e61 7272 6179 285b  ver = np.array([
+00023370: 224e 4f4e 4522 5d20 2a20 6c65 6e28 7374  "NONE"] * len(st
+00023380: 5f69 2929 0a20 2020 2066 6f72 2069 5f73  _i)).    for i_s
+00023390: 702c 2074 5f69 2069 6e20 656e 756d 6572  p, t_i in enumer
+000233a0: 6174 6528 7374 5f69 293a 0a20 2020 2020  ate(st_i):.     
+000233b0: 2020 2066 6f72 206a 2c20 7374 5f6a 2069     for j, st_j i
+000233c0: 6e20 656e 756d 6572 6174 6528 7370 696b  n enumerate(spik
+000233d0: 6574 7261 696e 7329 3a0a 2020 2020 2020  etrains):.      
+000233e0: 2020 2020 2020 6966 2069 2021 3d20 6a3a        if i != j:
+000233f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00023400: 2023 2066 696e 6420 6f76 6572 6c61 7070   # find overlapp
+00023410: 696e 670a 2020 2020 2020 2020 2020 2020  ing.            
+00023420: 2020 2020 6964 5f6f 7665 7220 3d20 6e70      id_over = np
+00023430: 2e77 6865 7265 2828 7374 5f6a 203e 2074  .where((st_j > t
+00023440: 5f69 202d 2074 5f6a 6974 7429 2026 2028  _i - t_jitt) & (
+00023450: 7374 5f6a 203c 2074 5f69 202b 2074 5f6a  st_j < t_i + t_j
+00023460: 6974 7429 295b 305d 0a20 2020 2020 2020  itt))[0].       
+00023470: 2020 2020 2020 2020 2069 6620 6e6f 7420           if not 
+00023480: 6e70 2e61 6e79 286f 7665 726c 6170 7069  np.any(overlappi
+00023490: 6e67 5f70 6169 7273 293a 0a20 2020 2020  ng_pairs):.     
+000234a0: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+000234b0: 6620 6c65 6e28 6964 5f6f 7665 7229 2021  f len(id_over) !
+000234c0: 3d20 303a 0a20 2020 2020 2020 2020 2020  = 0:.           
+000234d0: 2020 2020 2020 2020 2020 2020 206f 7665               ove
+000234e0: 725b 695f 7370 5d20 3d20 2254 4f22 0a20  r[i_sp] = "TO". 
+000234f0: 2020 2020 2020 2020 2020 2020 2020 2065                 e
+00023500: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+00023510: 2020 2020 2020 2020 2070 6169 7220 3d20           pair = 
+00023520: 5b69 2c20 6a5d 0a20 2020 2020 2020 2020  [i, j].         
+00023530: 2020 2020 2020 2020 2020 2070 6169 725f             pair_
+00023540: 6920 3d20 5b6a 2c20 695d 0a20 2020 2020  i = [j, i].     
+00023550: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+00023560: 6620 6e70 2e61 6e79 285b 6e70 2e61 6c6c  f np.any([np.all
+00023570: 2870 6169 7220 3d3d 2070 2920 666f 7220  (pair == p) for 
+00023580: 7020 696e 206f 7665 726c 6170 7069 6e67  p in overlapping
+00023590: 5f70 6169 7273 5d29 206f 7220 6e70 2e61  _pairs]) or np.a
+000235a0: 6e79 280a 2020 2020 2020 2020 2020 2020  ny(.            
+000235b0: 2020 2020 2020 2020 2020 2020 5b6e 702e              [np.
+000235c0: 616c 6c28 7061 6972 5f69 203d 3d20 7029  all(pair_i == p)
+000235d0: 2066 6f72 2070 2069 6e20 6f76 6572 6c61   for p in overla
+000235e0: 7070 696e 675f 7061 6972 735d 0a20 2020  pping_pairs].   
+000235f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00023600: 2029 3a0a 2020 2020 2020 2020 2020 2020   ):.            
+00023610: 2020 2020 2020 2020 2020 2020 6966 206c              if l
+00023620: 656e 2869 645f 6f76 6572 2920 213d 2030  en(id_over) != 0
+00023630: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00023640: 2020 2020 2020 2020 2020 2020 2020 6f76                ov
+00023650: 6572 5b69 5f73 705d 203d 2022 5354 4f22  er[i_sp] = "STO"
+00023660: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00023670: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+00023680: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00023690: 2020 2069 6620 6c65 6e28 6964 5f6f 7665     if len(id_ove
+000236a0: 7229 2021 3d20 303a 0a20 2020 2020 2020  r) != 0:.       
+000236b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000236c0: 2020 2020 206f 7665 725b 695f 7370 5d20       over[i_sp] 
+000236d0: 3d20 2254 4f22 0a20 2020 206f 7665 725b  = "TO".    over[
+000236e0: 6f76 6572 203d 3d20 224e 4f4e 4522 5d20  over == "NONE"] 
+000236f0: 3d20 224e 4f22 0a20 2020 2073 745f 692e  = "NO".    st_i.
+00023700: 616e 6e6f 7461 7465 286f 7665 726c 6170  annotate(overlap
+00023710: 3d6f 7665 7229 0a20 2020 2072 6574 7572  =over).    retur
+00023720: 6e20 7374 5f69 0a                        n st_i.
```

### Comparing `MEArec-1.8.0/MEArec.egg-info/PKG-INFO` & `MEArec-1.9.0/PKG-INFO`

 * *Files 18% similar despite different names*

```diff
@@ -1,20 +1,26 @@
 Metadata-Version: 2.1
 Name: MEArec
-Version: 1.8.0
-Summary: Fast and customizable simulation of extracellular recordings on Multi-Electrode-Arrays.
-Home-page: https://github.com/alejoe91/MEArec
-Author: Alessio Buccino
-Author-email: alessiob@ifi.uio.no
-License: UNKNOWN
-Platform: UNKNOWN
-Classifier: Programming Language :: Python :: 3
-Classifier: License :: OSI Approved :: GNU General Public License v3 (GPLv3)  
+Version: 1.9.0
+Summary: Python toolkit for biophysical simulation of extracellular electrophysiology recordings
+Author-email: Alessio Buccino <alessiop.buccino@gmail.com>
+Project-URL: homepage, https://github.com/alejoe91/MEArec
+Project-URL: repository, https://github.com/alejoe91/MEArec
+Project-URL: documentation, https://mearec.readthedocs.io/
+Classifier: Programming Language :: Python :: 3 :: Only
+Classifier: License :: OSI Approved :: MIT License
+Classifier: Intended Audience :: Science/Research
+Classifier: Operating System :: POSIX :: Linux
+Classifier: Operating System :: Microsoft :: Windows
+Classifier: Operating System :: MacOS
 Classifier: Operating System :: OS Independent
+Requires-Python: <4.0,>=3.7
 Description-Content-Type: text/markdown
+Provides-Extra: templates
+Provides-Extra: test
 License-File: LICENSE
 
 [![Build Status](https://github.com/alejoe91/MEArec/actions/workflows/python-package.yml/badge.svg)](https://github.com/alejoe91/MEArec/actions/workflows/python-package.yml/badge.svg) [![PyPI version](https://badge.fury.io/py/MEArec.svg)](https://badge.fury.io/py/MEArec)
 
 # MEArec: Fast and customizable simulation of extracellular recordings on Multi-Electrode-Arrays
 
 MEArec is a package for generating biophysical extracellular neural recording on Multi-Electrode Arrays (MEA). The recording generations combines a Extracellular Action Potentials (EAP) templates generation and spike trains generation. The recordings are built by convoluting and modulating EAP templates with spike trains and adding noise.
@@ -26,18 +32,19 @@
 ## Installation
 
 The MEArec package can be installed with:
 
 ```
 pip install MEArec
 ```
-or, from the cloned folder:
+
+To install from sources, run this from the cloned folder:
 
 ```
-python setup.py develop
+pip install -e .
 ```
 
 ## Documentation
 
 The MEArec detailed documentation is here: https://mearec.readthedocs.io/en/latest/
 
 ### Reference
@@ -51,9 +58,7 @@
   author={Buccino, Alessio Paolo and Einevoll, Gaute Tomas},
   journal={Neuroinformatics},
   pages={1--20},
   year={2020},
   publisher={Springer}
 }
 ```
-
-
```

### Comparing `MEArec-1.8.0/PKG-INFO` & `MEArec-1.9.0/src/MEArec.egg-info/PKG-INFO`

 * *Files 18% similar despite different names*

```diff
@@ -1,20 +1,26 @@
 Metadata-Version: 2.1
 Name: MEArec
-Version: 1.8.0
-Summary: Fast and customizable simulation of extracellular recordings on Multi-Electrode-Arrays.
-Home-page: https://github.com/alejoe91/MEArec
-Author: Alessio Buccino
-Author-email: alessiob@ifi.uio.no
-License: UNKNOWN
-Platform: UNKNOWN
-Classifier: Programming Language :: Python :: 3
-Classifier: License :: OSI Approved :: GNU General Public License v3 (GPLv3)  
+Version: 1.9.0
+Summary: Python toolkit for biophysical simulation of extracellular electrophysiology recordings
+Author-email: Alessio Buccino <alessiop.buccino@gmail.com>
+Project-URL: homepage, https://github.com/alejoe91/MEArec
+Project-URL: repository, https://github.com/alejoe91/MEArec
+Project-URL: documentation, https://mearec.readthedocs.io/
+Classifier: Programming Language :: Python :: 3 :: Only
+Classifier: License :: OSI Approved :: MIT License
+Classifier: Intended Audience :: Science/Research
+Classifier: Operating System :: POSIX :: Linux
+Classifier: Operating System :: Microsoft :: Windows
+Classifier: Operating System :: MacOS
 Classifier: Operating System :: OS Independent
+Requires-Python: <4.0,>=3.7
 Description-Content-Type: text/markdown
+Provides-Extra: templates
+Provides-Extra: test
 License-File: LICENSE
 
 [![Build Status](https://github.com/alejoe91/MEArec/actions/workflows/python-package.yml/badge.svg)](https://github.com/alejoe91/MEArec/actions/workflows/python-package.yml/badge.svg) [![PyPI version](https://badge.fury.io/py/MEArec.svg)](https://badge.fury.io/py/MEArec)
 
 # MEArec: Fast and customizable simulation of extracellular recordings on Multi-Electrode-Arrays
 
 MEArec is a package for generating biophysical extracellular neural recording on Multi-Electrode Arrays (MEA). The recording generations combines a Extracellular Action Potentials (EAP) templates generation and spike trains generation. The recordings are built by convoluting and modulating EAP templates with spike trains and adding noise.
@@ -26,18 +32,19 @@
 ## Installation
 
 The MEArec package can be installed with:
 
 ```
 pip install MEArec
 ```
-or, from the cloned folder:
+
+To install from sources, run this from the cloned folder:
 
 ```
-python setup.py develop
+pip install -e .
 ```
 
 ## Documentation
 
 The MEArec detailed documentation is here: https://mearec.readthedocs.io/en/latest/
 
 ### Reference
@@ -51,9 +58,7 @@
   author={Buccino, Alessio Paolo and Einevoll, Gaute Tomas},
   journal={Neuroinformatics},
   pages={1--20},
   year={2020},
   publisher={Springer}
 }
 ```
-
-
```

### Comparing `MEArec-1.8.0/README.md` & `MEArec-1.9.0/README.md`

 * *Files 4% similar despite different names*

```diff
@@ -11,18 +11,19 @@
 ## Installation
 
 The MEArec package can be installed with:
 
 ```
 pip install MEArec
 ```
-or, from the cloned folder:
+
+To install from sources, run this from the cloned folder:
 
 ```
-python setup.py develop
+pip install -e .
 ```
 
 ## Documentation
 
 The MEArec detailed documentation is here: https://mearec.readthedocs.io/en/latest/
 
 ### Reference
```

