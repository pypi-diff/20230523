# Comparing `tmp/actoolkit-2.6.3-py3-none-any.whl.zip` & `tmp/actoolkit-2.6.4-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,32 +1,35 @@
-Zip file size: 77254 bytes, number of entries: 30
--rw-r--r--  2.0 unx    18774 b- defN 23-Apr-28 18:59 tkHelpers.py
--rw-r--r--  2.0 unx    53562 b- defN 23-Apr-28 18:59 tkParser.py
--rw-r--r--  2.0 unx    91450 b- defN 23-Apr-28 18:59 toolkit.py
--rw-r--r--  2.0 unx      456 b- defN 23-Apr-28 18:59 astraSDK/__init__.py
--rw-r--r--  2.0 unx     3659 b- defN 23-Apr-28 18:59 astraSDK/apiresources.py
--rw-r--r--  2.0 unx    16835 b- defN 23-Apr-28 18:59 astraSDK/apps.py
--rw-r--r--  2.0 unx     8248 b- defN 23-Apr-28 18:59 astraSDK/backups.py
--rw-r--r--  2.0 unx     7321 b- defN 23-Apr-28 18:59 astraSDK/buckets.py
--rw-r--r--  2.0 unx     6972 b- defN 23-Apr-28 18:59 astraSDK/clouds.py
--rw-r--r--  2.0 unx     9155 b- defN 23-Apr-28 18:59 astraSDK/clusters.py
--rw-r--r--  2.0 unx     8157 b- defN 23-Apr-28 18:59 astraSDK/common.py
--rw-r--r--  2.0 unx     9115 b- defN 23-Apr-28 18:59 astraSDK/credentials.py
--rw-r--r--  2.0 unx     2663 b- defN 23-Apr-28 18:59 astraSDK/entitlements.py
--rw-r--r--  2.0 unx     7162 b- defN 23-Apr-28 18:59 astraSDK/hooks.py
--rw-r--r--  2.0 unx     5398 b- defN 23-Apr-28 18:59 astraSDK/namespaces.py
--rw-r--r--  2.0 unx     3511 b- defN 23-Apr-28 18:59 astraSDK/notifications.py
--rw-r--r--  2.0 unx     8803 b- defN 23-Apr-28 18:59 astraSDK/protections.py
--rw-r--r--  2.0 unx     9735 b- defN 23-Apr-28 18:59 astraSDK/replications.py
--rw-r--r--  2.0 unx     5758 b- defN 23-Apr-28 18:59 astraSDK/rolebindings.py
--rw-r--r--  2.0 unx     7091 b- defN 23-Apr-28 18:59 astraSDK/scripts.py
--rw-r--r--  2.0 unx     7035 b- defN 23-Apr-28 18:59 astraSDK/snapshots.py
--rw-r--r--  2.0 unx     2342 b- defN 23-Apr-28 18:59 astraSDK/storagebackends.py
--rw-r--r--  2.0 unx     4726 b- defN 23-Apr-28 18:59 astraSDK/storageclasses.py
--rw-r--r--  2.0 unx     4877 b- defN 23-Apr-28 18:59 astraSDK/users.py
--rw-r--r--  2.0 unx    11357 b- defN 23-Apr-28 19:00 actoolkit-2.6.3.dist-info/LICENSE
--rw-r--r--  2.0 unx     9308 b- defN 23-Apr-28 19:00 actoolkit-2.6.3.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Apr-28 19:00 actoolkit-2.6.3.dist-info/WHEEL
--rw-r--r--  2.0 unx       43 b- defN 23-Apr-28 19:00 actoolkit-2.6.3.dist-info/entry_points.txt
--rw-r--r--  2.0 unx       36 b- defN 23-Apr-28 19:00 actoolkit-2.6.3.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     2344 b- defN 23-Apr-28 19:00 actoolkit-2.6.3.dist-info/RECORD
-30 files, 325985 bytes uncompressed, 73572 bytes compressed:  77.4%
+Zip file size: 78957 bytes, number of entries: 33
+-rw-r--r--  2.0 unx    19527 b- defN 23-May-23 13:34 toolkit.py
+-rw-r--r--  2.0 unx      456 b- defN 23-May-23 13:34 astraSDK/__init__.py
+-rw-r--r--  2.0 unx     3659 b- defN 23-May-23 13:34 astraSDK/apiresources.py
+-rw-r--r--  2.0 unx    16835 b- defN 23-May-23 13:34 astraSDK/apps.py
+-rw-r--r--  2.0 unx     8248 b- defN 23-May-23 13:34 astraSDK/backups.py
+-rw-r--r--  2.0 unx     7321 b- defN 23-May-23 13:34 astraSDK/buckets.py
+-rw-r--r--  2.0 unx     6972 b- defN 23-May-23 13:34 astraSDK/clouds.py
+-rw-r--r--  2.0 unx     9155 b- defN 23-May-23 13:34 astraSDK/clusters.py
+-rw-r--r--  2.0 unx     8083 b- defN 23-May-23 13:34 astraSDK/common.py
+-rw-r--r--  2.0 unx     9115 b- defN 23-May-23 13:34 astraSDK/credentials.py
+-rw-r--r--  2.0 unx     2663 b- defN 23-May-23 13:34 astraSDK/entitlements.py
+-rw-r--r--  2.0 unx     7162 b- defN 23-May-23 13:34 astraSDK/hooks.py
+-rw-r--r--  2.0 unx     5458 b- defN 23-May-23 13:34 astraSDK/namespaces.py
+-rw-r--r--  2.0 unx     3511 b- defN 23-May-23 13:34 astraSDK/notifications.py
+-rw-r--r--  2.0 unx     8803 b- defN 23-May-23 13:34 astraSDK/protections.py
+-rw-r--r--  2.0 unx     9735 b- defN 23-May-23 13:34 astraSDK/replications.py
+-rw-r--r--  2.0 unx     5758 b- defN 23-May-23 13:34 astraSDK/rolebindings.py
+-rw-r--r--  2.0 unx     7091 b- defN 23-May-23 13:34 astraSDK/scripts.py
+-rw-r--r--  2.0 unx     7035 b- defN 23-May-23 13:34 astraSDK/snapshots.py
+-rw-r--r--  2.0 unx     2342 b- defN 23-May-23 13:34 astraSDK/storagebackends.py
+-rw-r--r--  2.0 unx     4726 b- defN 23-May-23 13:34 astraSDK/storageclasses.py
+-rw-r--r--  2.0 unx     4877 b- defN 23-May-23 13:34 astraSDK/users.py
+-rw-r--r--  2.0 unx       87 b- defN 23-May-23 13:34 tkSrc/__init__.py
+-rw-r--r--  2.0 unx    67308 b- defN 23-May-23 13:34 tkSrc/callers.py
+-rw-r--r--  2.0 unx     2634 b- defN 23-May-23 13:34 tkSrc/classes.py
+-rw-r--r--  2.0 unx    18774 b- defN 23-May-23 13:34 tkSrc/helpers.py
+-rw-r--r--  2.0 unx    52332 b- defN 23-May-23 13:34 tkSrc/parser.py
+-rw-r--r--  2.0 unx    11357 b- defN 23-May-23 13:34 actoolkit-2.6.4.dist-info/LICENSE
+-rw-r--r--  2.0 unx     9391 b- defN 23-May-23 13:34 actoolkit-2.6.4.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-May-23 13:34 actoolkit-2.6.4.dist-info/WHEEL
+-rw-r--r--  2.0 unx       43 b- defN 23-May-23 13:34 actoolkit-2.6.4.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx       42 b- defN 23-May-23 13:34 actoolkit-2.6.4.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     2571 b- defN 23-May-23 13:34 actoolkit-2.6.4.dist-info/RECORD
+33 files, 323163 bytes uncompressed, 74933 bytes compressed:  76.8%
```

## zipnote {}

```diff
@@ -1,13 +1,7 @@
-Filename: tkHelpers.py
-Comment: 
-
-Filename: tkParser.py
-Comment: 
-
 Filename: toolkit.py
 Comment: 
 
 Filename: astraSDK/__init__.py
 Comment: 
 
 Filename: astraSDK/apiresources.py
@@ -66,26 +60,41 @@
 
 Filename: astraSDK/storageclasses.py
 Comment: 
 
 Filename: astraSDK/users.py
 Comment: 
 
-Filename: actoolkit-2.6.3.dist-info/LICENSE
+Filename: tkSrc/__init__.py
+Comment: 
+
+Filename: tkSrc/callers.py
+Comment: 
+
+Filename: tkSrc/classes.py
+Comment: 
+
+Filename: tkSrc/helpers.py
+Comment: 
+
+Filename: tkSrc/parser.py
+Comment: 
+
+Filename: actoolkit-2.6.4.dist-info/LICENSE
 Comment: 
 
-Filename: actoolkit-2.6.3.dist-info/METADATA
+Filename: actoolkit-2.6.4.dist-info/METADATA
 Comment: 
 
-Filename: actoolkit-2.6.3.dist-info/WHEEL
+Filename: actoolkit-2.6.4.dist-info/WHEEL
 Comment: 
 
-Filename: actoolkit-2.6.3.dist-info/entry_points.txt
+Filename: actoolkit-2.6.4.dist-info/entry_points.txt
 Comment: 
 
-Filename: actoolkit-2.6.3.dist-info/top_level.txt
+Filename: actoolkit-2.6.4.dist-info/top_level.txt
 Comment: 
 
-Filename: actoolkit-2.6.3.dist-info/RECORD
+Filename: actoolkit-2.6.4.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## toolkit.py

```diff
@@ -11,430 +11,32 @@
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 """
 
-import base64
-import json
-import kubernetes
 import sys
-import time
-import yaml
-from datetime import datetime, timedelta
 
 import astraSDK
-import tkHelpers
-import tkParser
+import tkSrc
 
 
-class ToolKit:
-    def __init__(self):
-        self.conf = astraSDK.common.getConfig().main()
-
-    def doDeploy(self, chart, appName, namespace, setValues, fileValues, verbose, quiet):
-        """Deploy a helm chart <chart>, naming the app <appName> into <namespace>"""
-
-        setStr = tkHelpers.createHelmStr("set", setValues)
-        valueStr = tkHelpers.createHelmStr("values", fileValues)
-
-        nsObj = astraSDK.namespaces.getNamespaces(verbose=verbose)
-        retval = tkHelpers.run("kubectl get ns -o json", captureOutput=True)
-        retvalJSON = json.loads(retval)
-        for item in retvalJSON["items"]:
-            if item["metadata"]["name"] == namespace:
-                print(f"Namespace {namespace} already exists!")
-                sys.exit(24)
-        tkHelpers.run(f"kubectl create namespace {namespace}")
-        tkHelpers.run(f"kubectl config set-context --current --namespace={namespace}")
-
-        # If we're deploying gitlab, we need to ensure at least a premium storageclass
-        # for postgresql and gitaly
-        if chart.split("/")[1] == "gitlab":
-            pgStorageClass = None
-            scMapping = [
-                ["standard-rwo", "premium-rwo"],
-                ["netapp-cvs-perf-standard", "netapp-cvs-perf-premium"],
-                ["azurefile", "azurefile-premium"],
-                ["azurefile-csi", "azurefile-csi-premium"],
-                ["managed", "managed-premium"],
-                ["managed-csi", "managed-csi-premium"],
-            ]
-            configuration = kubernetes.config.load_kube_config()
-            with kubernetes.client.ApiClient(configuration) as api_client:
-                api_instance = kubernetes.client.StorageV1Api(api_client)
-                api_response = api_instance.list_storage_class()
-                for i in api_response.items:
-                    if (
-                        i.metadata.annotations.get("storageclass.kubernetes.io/is-default-class")
-                        == "true"
-                    ):
-                        for sc in scMapping:
-                            if i.metadata.name == sc[0]:
-                                pgStorageClass = sc[1]
-            if pgStorageClass:
-                setStr += f" --set postgresql.global.storageClass={pgStorageClass}"
-                setStr += f" --set gitlab.gitaly.persistence.storageClass={pgStorageClass}"
-
-        tkHelpers.run(f"helm install {appName} {chart}{setStr}{valueStr}")
-        print("Waiting for Astra to discover the namespace", end="")
-        sys.stdout.flush()
-
-        appID = ""
-        while not appID:
-            # It takes Astra some time to realize new apps have been installed
-            time.sleep(3)
-            print(".", end="")
-            sys.stdout.flush()
-            namespaces = nsObj.main()
-            # Cycle through the apps and see if one matches our new namespace
-            for ns in namespaces["items"]:
-                # Check to make sure our namespace name matches, it's in a discovered state,
-                # and that it's a recently created namespace (less than 10 minutes old)
-                if (
-                    ns["name"] == namespace
-                    and ns["namespaceState"] == "discovered"
-                    and (
-                        datetime.utcnow()
-                        - datetime.strptime(
-                            ns["metadata"]["creationTimestamp"], "%Y-%m-%dT%H:%M:%SZ"
-                        )
-                    )
-                    < timedelta(minutes=10)
-                ):
-                    print(" Namespace discovered!")
-                    sys.stdout.flush()
-                    time.sleep(3)
-                    print(f"Managing app: {ns['name']}.", end="")
-                    sys.stdout.flush()
-                    rc = astraSDK.apps.manageApp(verbose=verbose).main(
-                        ns["name"], ns["name"], ns["clusterID"]
-                    )
-                    if rc:
-                        appID = rc["id"]
-                        print(" Success!")
-                        sys.stdout.flush()
-                        break
-                    else:
-                        sys.stdout.flush()
-                        print("\nERROR managing app, trying one more time:")
-                        rc = astraSDK.apps.manageApp(quiet=quiet, verbose=verbose).main(
-                            ns["name"], ns["name"], ns["clusterID"]
-                        )
-                        if rc:
-                            appID = rc["id"]
-                            print("Success!")
-                            break
-                        else:
-                            sys.exit(1)
-
-        # Create a protection policy on that namespace (using its appID)
-        time.sleep(5)
-        backupRetention = "1"
-        snapshotRetention = "1"
-        minute = "0"
-        cpp = astraSDK.protections.createProtectionpolicy(quiet=True)
-        cppData = {
-            "hourly": {"dayOfWeek": "*", "dayOfMonth": "*", "hour": "*"},
-            "daily": {"dayOfWeek": "*", "dayOfMonth": "*", "hour": "2"},
-            "weekly": {"dayOfWeek": "0", "dayOfMonth": "*", "hour": "2"},
-            "monthly": {"dayOfWeek": "*", "dayOfMonth": "1", "hour": "2"},
-        }
-        for period in cppData:
-            print(f"Setting {period} protection policy on {appID}")
-            dayOfWeek = cppData[period]["dayOfWeek"]
-            dayOfMonth = cppData[period]["dayOfMonth"]
-            hour = cppData[period]["hour"]
-            cppRet = cpp.main(
-                period,
-                backupRetention,
-                snapshotRetention,
-                dayOfWeek,
-                dayOfMonth,
-                hour,
-                minute,
-                appID,
-            )
-            if cppRet is False:
-                raise SystemExit(f"cpp.main({period}...) returned False")
-
-    def doClone(
-        self,
-        cloneAppName,
-        clusterID,
-        oApp,
-        namespaceMapping,
-        backupID,
-        snapshotID,
-        sourceAppID,
-        background,
-        pollTimer,
-        resourceFilter,
-        verbose,
-        quiet,
-    ):
-        """Create a clone."""
-        # Check to see if cluster-level resources are needed to be manually created
-        needsIngressclass = False
-        appAssets = astraSDK.apps.getAppAssets(verbose=verbose).main(oApp["id"])
-        for asset in appAssets["items"]:
-            if (
-                "nginx-ingress-controller" in asset["assetName"]
-                or "ingress-nginx-controller" in asset["assetName"]
-            ) and asset["assetType"] == "Pod":
-                needsIngressclass = True
-                assetName = asset["assetName"]
-                if namespaceMapping is None:
-                    cloneNamespace = asset["namespace"]
-                else:
-                    for nsm in namespaceMapping:
-                        if nsm["source"] == asset["namespace"]:
-                            cloneNamespace = nsm["destination"]
-        # Clone 'ingressclass' cluster object
-        if needsIngressclass and oApp["clusterID"] != clusterID:
-            clusters = astraSDK.clusters.getClusters().main(hideUnmanaged=True)
-            contexts, _ = kubernetes.config.list_kube_config_contexts()
-            # Loop through clusters and contexts, find matches and open api_client
-            for cluster in clusters["items"]:
-                for context in contexts:
-                    if cluster["id"] == clusterID:
-                        if cluster["name"] in context["name"]:
-                            destClient = kubernetes.client.NetworkingV1Api(
-                                api_client=kubernetes.config.new_client_from_config(
-                                    context=context["name"]
-                                )
-                            )
-                    elif cluster["id"] == oApp["clusterID"]:
-                        if cluster["name"] in context["name"]:
-                            sourceClient = kubernetes.client.NetworkingV1Api(
-                                api_client=kubernetes.config.new_client_from_config(
-                                    context=context["name"]
-                                )
-                            )
-            try:
-                # Get the source cluster ingressclass and apply it to the dest cluster
-                listResp = sourceClient.list_ingress_class(
-                    _preload_content=False, _request_timeout=5
-                )
-                for i in json.loads(listResp.data)["items"]:
-                    for asset in appAssets["items"]:
-                        if "nginx" in i["metadata"]["name"] and asset["assetName"] == assetName:
-                            for ilKey, ilValue in i["metadata"]["labels"].items():
-                                for al in asset["labels"]:
-                                    if ilKey == al["name"] and ilValue == al["value"]:
-                                        ingName = i["metadata"]["name"]
-                sourceResp = sourceClient.read_ingress_class(
-                    ingName, _preload_content=False, _request_timeout=5
-                )
-                sourceIngress = json.loads(sourceResp.data)
-                if sourceIngress["metadata"].get("resourceVersion"):
-                    del sourceIngress["metadata"]["resourceVersion"]
-                if sourceIngress["metadata"].get("creationTimestamp"):
-                    del sourceIngress["metadata"]["creationTimestamp"]
-                if sourceIngress["metadata"].get("uid"):
-                    del sourceIngress["metadata"]["uid"]
-                if sourceIngress["metadata"]["managedFields"][0].get("time"):
-                    del sourceIngress["metadata"]["managedFields"][0]["time"]
-                sourceIngress["metadata"]["labels"]["app.kubernetes.io/instance"] = cloneNamespace
-                sourceIngress["metadata"]["annotations"][
-                    "meta.helm.sh/release-name"
-                ] = cloneNamespace
-                sourceIngress["metadata"]["annotations"][
-                    "meta.helm.sh/release-namespace"
-                ] = cloneNamespace
-            except:
-                # In the event the sourceCluster no longer exists or isn't in kubeconfig
-                sourceIngress = {
-                    "kind": "IngressClass",
-                    "apiVersion": "networking.k8s.io/v1",
-                    "metadata": {
-                        "name": "nginx",
-                        "generation": 1,
-                        "labels": {
-                            "app.kubernetes.io/component": "controller",
-                            "app.kubernetes.io/instance": cloneNamespace,
-                            "app.kubernetes.io/managed-by": "Helm",
-                            "app.kubernetes.io/name": "ingress-nginx",
-                            "app.kubernetes.io/version": "1.1.0",
-                            "helm.sh/chart": "ingress-nginx-4.0.13",
-                        },
-                        "annotations": {
-                            "meta.helm.sh/release-name": cloneNamespace,
-                            "meta.helm.sh/release-namespace": cloneNamespace,
-                        },
-                        "managedFields": [
-                            {
-                                "manager": "helm",
-                                "operation": "Update",
-                                "apiVersion": "networking.k8s.io/v1",
-                                "fieldsType": "FieldsV1",
-                                "fieldsV1": {
-                                    "f:metadata": {
-                                        "f:annotations": {
-                                            ".": {},
-                                            "f:meta.helm.sh/release-name": {},
-                                            "f:meta.helm.sh/release-namespace": {},
-                                        },
-                                        "f:labels": {
-                                            ".": {},
-                                            "f:app.kubernetes.io/component": {},
-                                            "f:app.kubernetes.io/instance": {},
-                                            "f:app.kubernetes.io/managed-by": {},
-                                            "f:app.kubernetes.io/name": {},
-                                            "f:app.kubernetes.io/version": {},
-                                            "f:helm.sh/chart": {},
-                                        },
-                                    },
-                                    "f:spec": {"f:controller": {}},
-                                },
-                            }
-                        ],
-                    },
-                    "spec": {"controller": "k8s.io/ingress-nginx"},
-                }
-                if "gitlab" in assetName:
-                    sourceIngress["metadata"]["name"] = "gitlab-nginx"
-                    sourceIngress["metadata"]["labels"]["release"] = cloneNamespace
-                    sourceIngress["metadata"]["labels"]["app"] = "nginx-ingress"
-                    sourceIngress["metadata"]["managedFields"][0]["fieldsV1"]["f:metadata"][
-                        "f:labels"
-                    ]["f:release"] = {}
-                    sourceIngress["metadata"]["managedFields"][0]["fieldsV1"]["f:metadata"][
-                        "f:labels"
-                    ]["f:app"] = {}
-            try:
-                # Add the ingressclass to the new cluster
-                destClient.create_ingress_class(sourceIngress, _request_timeout=10)
-            except NameError:
-                raise SystemExit(f"Error: {clusterID} not found in kubeconfig")
-            except kubernetes.client.rest.ApiException as e:
-                # If the failure is due to the resource already existing, then we're all set,
-                # otherwise it's more serious and we must raise an exception
-                body = json.loads(e.body)
-                if not (body.get("reason") == "AlreadyExists"):
-                    raise SystemExit(f"Error: Kubernetes resource creation failed\n{e}")
-
-        cloneRet = astraSDK.apps.cloneApp(verbose=verbose, quiet=quiet).main(
-            cloneAppName,
-            clusterID,
-            oApp["clusterID"],
-            namespaceMapping=namespaceMapping,
-            backupID=backupID,
-            snapshotID=snapshotID,
-            sourceAppID=sourceAppID,
-            resourceFilter=resourceFilter,
-        )
-        if cloneRet:
-            print("Submitting clone succeeded.")
-            if background:
-                print(f"Background clone flag selected, run 'list apps' to get status.")
-                return True
-            print("Waiting for clone to become available.", end="")
-            sys.stdout.flush()
-            appID = cloneRet.get("id")
-            state = cloneRet.get("state")
-            while state != "ready":
-                apps = astraSDK.apps.getApps().main()
-                for app in apps["items"]:
-                    if app["id"] == appID:
-                        if app["state"] == "ready":
-                            state = app["state"]
-                            print("Cloning operation complete.")
-                            sys.stdout.flush()
-                        elif app["state"] == "failed":
-                            print(f"Error: \"{app['name']}\" in a failed state")
-                            sys.stdout.flush()
-                            sys.exit(1)
-                        else:
-                            print(".", end="")
-                            sys.stdout.flush()
-                            time.sleep(pollTimer)
-        else:
-            print("Submitting clone failed.")
-
-    def doProtectionTask(self, protectionType, appID, name, background, pollTimer, quiet, verbose):
-        """Take a snapshot/backup of appID giving it name <name>
-        Return the snapshotID/backupID of the backup taken or False if the protection task fails"""
-        if protectionType == "backup":
-            protectionID = astraSDK.backups.takeBackup(quiet=quiet, verbose=verbose).main(
-                appID, name
-            )
-        elif protectionType == "snapshot":
-            protectionID = astraSDK.snapshots.takeSnap(quiet=quiet, verbose=verbose).main(
-                appID, name
-            )
-        if protectionID == False:
-            return False
-
-        print(f"Starting {protectionType} of {appID}")
-        if background:
-            print(
-                f"Background {protectionType} flag selected, run 'list {protectionType}s' to get status"
-            )
-            return True
-
-        print(f"Waiting for {protectionType} to complete.", end="")
-        sys.stdout.flush()
-        while True:
-            if protectionType == "backup":
-                objects = astraSDK.backups.getBackups().main()
-            elif protectionType == "snapshot":
-                objects = astraSDK.snapshots.getSnaps().main()
-            if not objects:
-                # This isn't technically true.  Trying to list the backups/snapshots after taking the
-                # protection job failed.  The protection job itself may eventually succeed.
-                print(f"Taking {protectionType} failed")
-                return False
-            for obj in objects["items"]:
-                # There's no API for monitoring long running tasks.  Just because
-                # the API call to create a backup/snapshot succeeded, that doesn't mean the
-                # actual backup will succeed as well.  So we spin on checking the backups/snapshots
-                # waiting for our backupsnapshot to either show completed or failed.
-                if obj["id"] == protectionID:
-                    if obj["state"] == "completed":
-                        print("complete!")
-                        sys.stdout.flush()
-                        return protectionID
-                    elif obj["state"] == "failed":
-                        print(f"{protectionType} job failed")
-                        return False
-            time.sleep(pollTimer)
-            print(".", end="")
-            sys.stdout.flush()
-
-
-def main():
+def main(argv=sys.argv):
     # The various functions to populate the lists used for choices() in the options are
     # expensive. argparse provides no way to know what subcommand was selected prior to
     # parsing the options. By then it's too late to decide which functions to run to
     # populate the various choices the differing options for each subcommand needs. So
     # we just go around argparse's back and inspect sys.argv directly.
-    apiResourcesList = []
-    appList = []
-    backupList = []
-    bucketList = []
-    chartsList = []
-    cloudList = []
-    clusterList = []
-    credentialList = []
-    destclusterList = []
-    hookList = []
-    labelList = []
-    namespaceList = []
-    protectionList = []
-    replicationList = []
-    scriptList = []
-    snapshotList = []
-    storageClassList = []
-    userList = []
+    acl = tkSrc.classes.ArgparseChoicesLists()
+    ard = tkSrc.classes.AstraResourceDicts()
     plaidMode = False
 
-    if len(sys.argv) > 1:
-        # verbs must manually be kept in sync with top_level_commands() in tkParser.py
+    if len(argv) > 1:
+        # verbs must manually be kept in sync with top_level_commands() in tkSrc/parser.py
         verbs = {
             "deploy": False,
             "clone": False,
             "restore": False,
             "list": False,
             "get": False,
             "create": False,
@@ -445,21 +47,21 @@
             "update": False,
         }
 
         firstverbfoundPosition = None
         verbPosition = None
         cookedlistofVerbs = [x for x in verbs]
         for verb in verbs:
-            if verb not in sys.argv:
+            if verb not in argv:
                 # no need to iterate over the arg list for a verb that isn't in there
                 continue
             if verbPosition:
                 # once we've found the first verb we can stop looking
                 break
-            for counter, item in enumerate(sys.argv):
+            for counter, item in enumerate(argv):
                 if item == verb:
                     if firstverbfoundPosition is None:
                         # firstverbfoundPosition exists to prevent
                         # "toolkit.py create deploy create deploy" from deciding the second create
                         # is the first verb found
                         firstverbfoundPosition = counter
                     else:
@@ -477,1423 +79,287 @@
                     # verb["deploy"] gets set to False
                     try:
                         cookedlistofVerbs.remove(item)
                     except ValueError:
                         pass
                     verbs[verb] = True
                     verbPosition = counter
-                    for item2 in sys.argv[:(counter)]:
-                        # sys.argv[:(counter)] is a slice of sys.argv of all the items
+                    for item2 in argv[:(counter)]:
+                        # argv[:(counter)] is a slice of sys.argv of all the items
                         # before the one we found
                         if item2 in cookedlistofVerbs:
                             # deploy wasn't the verb, it was a symbolic name of an object
                             verbs[verb] = False
                             verbPosition = None
 
         # Enabling comma separated listing of objects, like:
         # 'toolkit.py list apps,backups,snapshots'
         if (
             (verbs["list"] or verbs["get"])
-            and len(sys.argv) > (verbPosition + 1)
-            and "," in sys.argv[verbPosition + 1]
+            and len(argv) > (verbPosition + 1)
+            and "," in argv[verbPosition + 1]
         ):
-            listTypeArray = sys.argv[verbPosition + 1].split(",")
+            listTypeArray = argv[verbPosition + 1].split(",")
             for lt in listTypeArray:
-                sys.argv[verbPosition + 1] = lt
-                main()
+                argv[verbPosition + 1] = lt
+                main(argv=argv)
             sys.exit(0)
 
         # Turn off verification to speed things up if true
-        for counter, item in enumerate(sys.argv):
+        for counter, item in enumerate(argv):
             if verbPosition and counter < verbPosition and (item == "-f" or item == "--fast"):
                 plaidMode = True
 
         if not plaidMode:
             # It isn't intuitive, however only one key in verbs can be True
             if verbs["deploy"]:
-                chartsDict = tkHelpers.updateHelm()
-                for chart in chartsDict["items"]:
-                    chartsList.append(chart["name"])
+                ard.charts = tkSrc.helpers.updateHelm()
+                acl.charts = ard.buildList("charts", "name")
 
             elif verbs["clone"]:
-                apps = astraSDK.apps.getApps().main()
-                for app in apps["items"]:
-                    appList.append(app["id"])
-                destCluster = astraSDK.clusters.getClusters().main(hideUnmanaged=True)
-                for cluster in destCluster["items"]:
-                    destclusterList.append(cluster["id"])
-                backups = astraSDK.backups.getBackups().main()
-                for backup in backups["items"]:
-                    backupList.append(backup["id"])
-                snapshots = astraSDK.snapshots.getSnaps().main()
-                for snap in snapshots["items"]:
-                    snapshotList.append(snap["id"])
+                ard.apps = astraSDK.apps.getApps().main()
+                acl.apps = ard.buildList("apps", "id")
+                ard.destClusters = astraSDK.clusters.getClusters().main(hideUnmanaged=True)
+                acl.destClusters = ard.buildList("destClusters", "id")
+                ard.backups = astraSDK.backups.getBackups().main()
+                acl.backups = ard.buildList("backups", "id")
+                ard.snapshots = astraSDK.snapshots.getSnaps().main()
+                acl.snapshots = ard.buildList("snapshots", "id")
 
             elif verbs["restore"]:
-                for app in astraSDK.apps.getApps().main()["items"]:
-                    appList.append(app["id"])
+                ard.apps = astraSDK.apps.getApps().main()
+                acl.apps = ard.buildList("apps", "id")
 
                 # This expression translates to "Is there an arg after the verb we found?"
-                if len(sys.argv) - verbPosition >= 2:
+                if len(argv) - verbPosition >= 2:
                     # If that arg after the verb "restore" matches an appID then
                     # populate the lists of backups and snapshots for that appID
-                    backups = astraSDK.backups.getBackups().main()
-                    for backup in backups["items"]:
-                        if backup["appID"] == sys.argv[verbPosition + 1] or (
-                            len(sys.argv) > verbPosition + 2
-                            and backup["appID"] == sys.argv[verbPosition + 2]
-                        ):
-                            backupList.append(backup["id"])
-                    snapshots = astraSDK.snapshots.getSnaps().main()
-                    for snapshot in snapshots["items"]:
-                        if snapshot["appID"] == sys.argv[verbPosition + 1] or (
-                            len(sys.argv) > verbPosition + 2
-                            and snapshot["appID"] == sys.argv[verbPosition + 2]
-                        ):
-                            snapshotList.append(snapshot["id"])
+                    ard.backups = astraSDK.backups.getBackups().main()
+                    ard.snapshots = astraSDK.snapshots.getSnaps().main()
+                    for a in argv[verbPosition + 1 :]:
+                        acl.backups += ard.buildList("backups", "id", "appID", a)
+                        acl.snapshots += ard.buildList("snapshots", "id", "appID", a)
             elif (
                 verbs["create"]
-                and len(sys.argv) - verbPosition >= 2
+                and len(argv) - verbPosition >= 2
                 and (
-                    sys.argv[verbPosition + 1] == "backup"
-                    or sys.argv[verbPosition + 1] == "hook"
-                    or sys.argv[verbPosition + 1] == "protectionpolicy"
-                    or sys.argv[verbPosition + 1] == "protection"
-                    or sys.argv[verbPosition + 1] == "replication"
-                    or sys.argv[verbPosition + 1] == "snapshot"
+                    argv[verbPosition + 1] == "backup"
+                    or argv[verbPosition + 1] == "hook"
+                    or argv[verbPosition + 1] == "protectionpolicy"
+                    or argv[verbPosition + 1] == "protection"
+                    or argv[verbPosition + 1] == "replication"
+                    or argv[verbPosition + 1] == "snapshot"
                 )
             ):
-                if apps := astraSDK.apps.getApps().main():
-                    for app in apps["items"]:
-                        appList.append(app["id"])
-                if sys.argv[verbPosition + 1] == "backup":
-                    if bucketDict := astraSDK.buckets.getBuckets(quiet=True).main():
-                        for bucket in bucketDict["items"]:
-                            bucketList.append(bucket["id"])
-                    # Generate snapshotList if an appID was provided
-                    if len(sys.argv) - verbPosition > 2 and sys.argv[verbPosition + 2] in appList:
-                        snapshotDict = astraSDK.snapshots.getSnaps(quiet=True).main(
-                            appFilter=sys.argv[verbPosition + 2]
-                        )
-                        for snapshot in snapshotDict["items"]:
-                            snapshotList.append(snapshot["id"])
-                if sys.argv[verbPosition + 1] == "hook":
-                    for script in astraSDK.scripts.getScripts().main()["items"]:
-                        scriptList.append(script["id"])
-                if sys.argv[verbPosition + 1] == "replication":
-                    destCluster = astraSDK.clusters.getClusters().main(hideUnmanaged=True)
-                    for cluster in destCluster["items"]:
-                        destclusterList.append(cluster["id"])
-                    storageClassDict = astraSDK.storageclasses.getStorageClasses(quiet=True).main()
-                    if isinstance(storageClassDict, bool):
-                        # getStorageClasses(quiet=True).main() returns either True
-                        # or False if it doesn't work, or if there are no clouds or clusters
-                        sys.exit(1)
-                    for storageClass in storageClassDict["items"]:
-                        storageClassList.append(storageClass["name"])
-                    storageClassList = list(set(storageClassList))
+                ard.apps = astraSDK.apps.getApps().main()
+                acl.apps = ard.buildList("apps", "id")
+                if argv[verbPosition + 1] == "backup":
+                    ard.buckets = astraSDK.buckets.getBuckets(quiet=True).main()
+                    acl.buckets = ard.buildList("buckets", "id")
+                    # Generate acl.snapshots if an appID was provided
+                    for a in argv[verbPosition + 1 :]:
+                        if a in acl.apps:
+                            ard.snapshots = astraSDK.snapshots.getSnaps().main(appFilter=a)
+                            acl.snapshots = ard.buildList("snapshots", "id")
+                if argv[verbPosition + 1] == "hook":
+                    ard.scripts = astraSDK.scripts.getScripts().main()
+                    acl.scripts = ard.buildList("scripts", "id")
+                if argv[verbPosition + 1] == "replication":
+                    ard.destClusters = astraSDK.clusters.getClusters().main(hideUnmanaged=True)
+                    acl.destClusters = ard.buildList("destClusters", "id")
+                    ard.storageClasses = astraSDK.storageclasses.getStorageClasses(
+                        quiet=True
+                    ).main()
+                    acl.storageClasses = ard.buildList("storageClasses", "name")
+                    acl.storageClasses = list(set(acl.storageClasses))
             elif (
                 verbs["create"]
-                and len(sys.argv) - verbPosition >= 2
-                and sys.argv[verbPosition + 1] == "cluster"
+                and len(argv) - verbPosition >= 2
+                and argv[verbPosition + 1] == "cluster"
             ):
-                for cloud in astraSDK.clouds.getClouds().main()["items"]:
+                ard.clouds = astraSDK.clouds.getClouds().main()
+                for cloud in ard.clouds["items"]:
                     if cloud["cloudType"] not in ["GCP", "Azure", "AWS"]:
-                        cloudList.append(cloud["id"])
+                        acl.clouds.append(cloud["id"])
                 # Add a private cloud if it doesn't already exist
-                if len(cloudList) == 0:
+                if len(acl.clouds) == 0:
                     rc = astraSDK.clouds.manageCloud(quiet=True).main("private", "private")
                     if rc:
-                        cloudList.append(rc["id"])
+                        acl.clouds.append(rc["id"])
             elif (
                 verbs["create"]
-                and len(sys.argv) - verbPosition >= 2
-                and sys.argv[verbPosition + 1] == "user"
+                and len(argv) - verbPosition >= 2
+                and argv[verbPosition + 1] == "user"
             ):
-                namespaceDict = astraSDK.namespaces.getNamespaces().main()
-                for namespace in namespaceDict["items"]:
-                    namespaceList.append(namespace["id"])
+                ard.namespaces = astraSDK.namespaces.getNamespaces().main()
+                for namespace in ard.namespaces["items"]:
+                    acl.namespaces.append(namespace["id"])
                     if namespace.get("kubernetesLabels"):
                         for label in namespace["kubernetesLabels"]:
                             labelString = label["name"]
                             if label.get("value"):
                                 labelString += "=" + label["value"]
-                            labelList.append(labelString)
-                labelList = list(set(labelList))
+                            acl.labels.append(labelString)
+                acl.labels = list(set(acl.labels))
 
             elif (
                 verbs["list"]
-                and len(sys.argv) - verbPosition >= 2
-                and sys.argv[verbPosition + 1] == "assets"
+                and len(argv) - verbPosition >= 2
+                and argv[verbPosition + 1] == "assets"
             ):
-                if apps := astraSDK.apps.getApps().main():
-                    for app in apps["items"]:
-                        appList.append(app["id"])
-
-            elif (verbs["manage"] or verbs["define"]) and len(sys.argv) - verbPosition >= 2:
-                if sys.argv[verbPosition + 1] == "app":
-                    if namespaceDict := astraSDK.namespaces.getNamespaces().main():
-                        for namespace in namespaceDict["items"]:
-                            namespaceList.append(namespace["name"])
-                            clusterList.append(namespace["clusterID"])
-                        clusterList = list(set(clusterList))
-                elif sys.argv[verbPosition + 1] == "bucket":
-                    credentialDict = astraSDK.credentials.getCredentials().main()
-                    for credential in credentialDict["items"]:
+                ard.apps = astraSDK.apps.getApps().main()
+                acl.apps = ard.buildList("apps", "id")
+
+            elif (verbs["manage"] or verbs["define"]) and len(argv) - verbPosition >= 2:
+                if argv[verbPosition + 1] == "app":
+                    ard.namespaces = astraSDK.namespaces.getNamespaces().main()
+                    acl.namespaces = ard.buildList("namespaces", "name")
+                    acl.clusters = ard.buildList("namespaces", "clusterID")
+                    acl.clusters = list(set(acl.clusters))
+                elif argv[verbPosition + 1] == "bucket":
+                    ard.credentials = astraSDK.credentials.getCredentials().main()
+                    for credential in ard.credentials["items"]:
                         if credential["metadata"].get("labels"):
                             credID = None
                             if credential.get("keyType") == "s3":
                                 credID = credential["id"]
                             else:
                                 for label in credential["metadata"]["labels"]:
                                     if label["name"] == "astra.netapp.io/labels/read-only/credType":
                                         if label["value"] in ["AzureContainer", "service-account"]:
                                             credID = credential["id"]
                             if credID:
-                                credentialList.append(credential["id"])
-                elif sys.argv[verbPosition + 1] == "cluster":
-                    if clusterDict := astraSDK.clusters.getClusters(quiet=True).main():
-                        for cluster in clusterDict["items"]:
-                            if cluster["managedState"] == "unmanaged":
-                                clusterList.append(cluster["id"])
-                    else:
-                        sys.exit(1)
-                    if storageClassDict := astraSDK.storageclasses.getStorageClasses(
-                        quiet=True
-                    ).main():
-                        for storageClass in storageClassDict["items"]:
-                            if (
-                                len(sys.argv) - verbPosition >= 3
-                                and sys.argv[verbPosition + 2] in clusterList
-                                and storageClass["clusterID"] != sys.argv[verbPosition + 2]
-                            ):
-                                continue
-                            storageClassList.append(storageClass["id"])
-                    else:
-                        sys.exit(1)
-                elif sys.argv[verbPosition + 1] == "cloud":
-                    if bucketDict := astraSDK.buckets.getBuckets(quiet=True).main():
-                        for bucket in bucketDict["items"]:
-                            bucketList.append(bucket["id"])
-
-            elif verbs["destroy"] and len(sys.argv) - verbPosition >= 2:
-                if sys.argv[verbPosition + 1] == "backup" and len(sys.argv) - verbPosition >= 3:
-                    for app in astraSDK.apps.getApps().main()["items"]:
-                        appList.append(app["id"])
-                    backups = astraSDK.backups.getBackups().main()
-                    for backup in backups["items"]:
-                        if backup["appID"] == sys.argv[verbPosition + 2]:
-                            backupList.append(backup["id"])
-                elif (
-                    sys.argv[verbPosition + 1] == "credential" and len(sys.argv) - verbPosition >= 3
-                ):
-                    credentialDict = astraSDK.credentials.getCredentials().main()
-                    for credential in credentialDict["items"]:
-                        credentialList.append(credential["id"])
-                elif sys.argv[verbPosition + 1] == "hook" and len(sys.argv) - verbPosition >= 3:
-                    for app in astraSDK.apps.getApps().main()["items"]:
-                        appList.append(app["id"])
-                    hooks = astraSDK.hooks.getHooks().main()
-                    for hook in hooks["items"]:
-                        if hook["appID"] == sys.argv[verbPosition + 2]:
-                            hookList.append(hook["id"])
-                elif (
-                    sys.argv[verbPosition + 1] == "protection" and len(sys.argv) - verbPosition >= 3
-                ):
-                    for app in astraSDK.apps.getApps().main()["items"]:
-                        appList.append(app["id"])
-                    protections = astraSDK.protections.getProtectionpolicies().main()
-                    for protection in protections["items"]:
-                        if protection["appID"] == sys.argv[verbPosition + 2]:
-                            protectionList.append(protection["id"])
-                elif (
-                    sys.argv[verbPosition + 1] == "replication"
-                    and len(sys.argv) - verbPosition >= 3
-                ):
-                    replicationDict = astraSDK.replications.getReplicationpolicies().main()
-                    if not replicationDict:  # Gracefully handle ACS env
+                                acl.credentials.append(credential["id"])
+                elif argv[verbPosition + 1] == "cluster":
+                    ard.clusters = astraSDK.clusters.getClusters().main()
+                    acl.clusters = ard.buildList(
+                        "clusters", "id", fKey="managedState", fVal="unmanaged"
+                    )
+                    ard.storageClasses = astraSDK.storageclasses.getStorageClasses().main()
+                    for a in argv[verbPosition + 2 :]:
+                        acl.storageClasses += ard.buildList("storageClasses", "id", "clusterID", a)
+                elif argv[verbPosition + 1] == "cloud":
+                    ard.buckets = astraSDK.buckets.getBuckets().main()
+                    acl.buckets = ard.buildList("buckets", "id")
+
+            elif verbs["destroy"] and len(argv) - verbPosition >= 2:
+                if argv[verbPosition + 1] == "backup" and len(argv) - verbPosition >= 3:
+                    ard.apps = astraSDK.apps.getApps().main()
+                    acl.apps = ard.buildList("apps", "id")
+                    ard.backups = astraSDK.backups.getBackups().main()
+                    acl.backups = ard.buildList(
+                        "backups", "id", fKey="appID", fVal=argv[verbPosition + 2]
+                    )
+                elif argv[verbPosition + 1] == "credential" and len(argv) - verbPosition >= 3:
+                    ard.credentials = astraSDK.credentials.getCredentials().main()
+                    acl.credentials = ard.buildList("credentials", "id")
+                elif argv[verbPosition + 1] == "hook" and len(argv) - verbPosition >= 3:
+                    ard.apps = astraSDK.apps.getApps().main()
+                    acl.apps = ard.buildList("apps", "id")
+                    ard.hooks = astraSDK.hooks.getHooks().main()
+                    acl.hooks = ard.buildList(
+                        "hooks", "id", fKey="appID", fVal=argv[verbPosition + 2]
+                    )
+                elif argv[verbPosition + 1] == "protection" and len(argv) - verbPosition >= 3:
+                    ard.apps = astraSDK.apps.getApps().main()
+                    acl.apps = ard.buildList("apps", "id")
+                    ard.protections = astraSDK.protections.getProtectionpolicies().main()
+                    acl.protections = ard.buildList(
+                        "protections", "id", fKey="appID", fVal=argv[verbPosition + 2]
+                    )
+                elif argv[verbPosition + 1] == "replication" and len(argv) - verbPosition >= 3:
+                    ard.replications = astraSDK.replications.getReplicationpolicies().main()
+                    if not ard.replications:  # Gracefully handle ACS env
                         print("Error: 'replication' commands are currently only supported in ACC.")
                         sys.exit(1)
-                    for replication in replicationDict["items"]:
-                        replicationList.append(replication["id"])
-                elif sys.argv[verbPosition + 1] == "snapshot" and len(sys.argv) - verbPosition >= 3:
-                    for app in astraSDK.apps.getApps().main()["items"]:
-                        appList.append(app["id"])
-                    snapshots = astraSDK.snapshots.getSnaps().main()
-                    for snapshot in snapshots["items"]:
-                        if snapshot["appID"] == sys.argv[verbPosition + 2]:
-                            snapshotList.append(snapshot["id"])
-                elif sys.argv[verbPosition + 1] == "script" and len(sys.argv) - verbPosition >= 3:
-                    for script in astraSDK.scripts.getScripts().main()["items"]:
-                        scriptList.append(script["id"])
-                elif sys.argv[verbPosition + 1] == "user" and len(sys.argv) - verbPosition >= 3:
-                    userDict = astraSDK.users.getUsers().main()
-                    for user in userDict["items"]:
-                        userList.append(user["id"])
-
-            elif verbs["unmanage"] and len(sys.argv) - verbPosition >= 2:
-                if sys.argv[verbPosition + 1] == "app":
-                    if apps := astraSDK.apps.getApps().main():
-                        for app in apps["items"]:
-                            appList.append(app["id"])
-                elif sys.argv[verbPosition + 1] == "bucket":
-                    if bucketDict := astraSDK.buckets.getBuckets(quiet=True).main():
-                        for bucket in bucketDict["items"]:
-                            bucketList.append(bucket["id"])
-                elif sys.argv[verbPosition + 1] == "cluster":
-                    if clusterDict := astraSDK.clusters.getClusters(quiet=True).main():
-                        for cluster in clusterDict["items"]:
-                            if cluster["managedState"] == "managed":
-                                clusterList.append(cluster["id"])
-                elif sys.argv[verbPosition + 1] == "cloud":
-                    if cloudDict := astraSDK.clouds.getClouds().main():
-                        for cloud in cloudDict["items"]:
-                            cloudList.append(cloud["id"])
-
-            elif (verbs["update"]) and len(sys.argv) - verbPosition >= 2:
-                if sys.argv[verbPosition + 1] == "bucket":
-                    for bucket in (bucketDict := astraSDK.buckets.getBuckets().main())["items"]:
-                        bucketList.append(bucket["id"])
-                    credentialDict = astraSDK.credentials.getCredentials().main()
-                    for credential in credentialDict["items"]:
+                    acl.replications = ard.buildList("replications", "id")
+                elif argv[verbPosition + 1] == "snapshot" and len(argv) - verbPosition >= 3:
+                    ard.apps = astraSDK.apps.getApps().main()
+                    acl.apps = ard.buildList("apps", "id")
+                    ard.snapshots = astraSDK.snapshots.getSnaps().main()
+                    acl.snapshots = ard.buildList(
+                        "snapshots", "id", fKey="appID", fVal=argv[verbPosition + 2]
+                    )
+                elif argv[verbPosition + 1] == "script" and len(argv) - verbPosition >= 3:
+                    ard.scripts = astraSDK.scripts.getScripts().main()
+                    acl.scripts = ard.buildList("scripts", "id")
+                elif argv[verbPosition + 1] == "user" and len(argv) - verbPosition >= 3:
+                    ard.users = astraSDK.users.getUsers().main()
+                    acl.users = ard.buildList("users", "id")
+
+            elif verbs["unmanage"] and len(argv) - verbPosition >= 2:
+                if argv[verbPosition + 1] == "app":
+                    ard.apps = astraSDK.apps.getApps().main()
+                    acl.apps = ard.buildList("apps", "id")
+                elif argv[verbPosition + 1] == "bucket":
+                    ard.buckets = astraSDK.buckets.getBuckets().main()
+                    acl.buckets = ard.buildList("buckets", "id")
+                elif argv[verbPosition + 1] == "cluster":
+                    ard.clusters = astraSDK.clusters.getClusters().main()
+                    acl.clusters = ard.buildList(
+                        "clusters", "id", fKey="managedState", fVal="managed"
+                    )
+                elif argv[verbPosition + 1] == "cloud":
+                    ard.clouds = astraSDK.clouds.getClouds().main()
+                    acl.clouds = ard.buildList("clouds", "id")
+
+            elif (verbs["update"]) and len(argv) - verbPosition >= 2:
+                if argv[verbPosition + 1] == "bucket":
+                    ard.buckets = astraSDK.buckets.getBuckets().main()
+                    acl.buckets = ard.buildList("buckets", "id")
+                    ard.credentials = astraSDK.credentials.getCredentials().main()
+                    for credential in ard.credentials["items"]:
                         if credential["metadata"].get("labels"):
                             credID = None
                             if credential.get("keyType") == "s3":
                                 credID = credential["id"]
                             else:
                                 for label in credential["metadata"]["labels"]:
                                     if label["name"] == "astra.netapp.io/labels/read-only/credType":
                                         if label["value"] in ["AzureContainer", "service-account"]:
                                             credID = credential["id"]
                             if credID:
-                                credentialList.append(credential["id"])
-                elif sys.argv[verbPosition + 1] == "cloud":
-                    for cloud in (cloudDict := astraSDK.clouds.getClouds().main())["items"]:
-                        cloudList.append(cloud["id"])
-                    for bucket in (bucketDict := astraSDK.buckets.getBuckets().main())["items"]:
-                        bucketList.append(bucket["id"])
-                    credentialDict = astraSDK.credentials.getCredentials().main()
-                    for credential in credentialDict["items"]:
+                                acl.credentials.append(credential["id"])
+                elif argv[verbPosition + 1] == "cloud":
+                    ard.buckets = astraSDK.buckets.getBuckets().main()
+                    acl.buckets = ard.buildList("buckets", "id")
+                    ard.clouds = astraSDK.clouds.getClouds().main()
+                    acl.clouds = ard.buildList("clouds", "id")
+                    ard.credentials = astraSDK.credentials.getCredentials().main()
+                    for credential in ard.credentials["items"]:
                         if credential["metadata"].get("labels"):
                             credID = None
                             if credential.get("keyType") == "s3":
                                 credID = credential["id"]
                             else:
                                 for label in credential["metadata"]["labels"]:
                                     if label["name"] == "astra.netapp.io/labels/read-only/credType":
                                         if label["value"] in ["AzureContainer", "service-account"]:
                                             credID = credential["id"]
                             if credID:
-                                credentialList.append(credential["id"])
-                elif sys.argv[verbPosition + 1] == "cluster":
-                    if clusterDict := astraSDK.clusters.getClusters(quiet=True).main():
-                        for cluster in clusterDict["items"]:
-                            clusterList.append(cluster["id"])
-                    else:
-                        sys.exit(1)
-                elif sys.argv[verbPosition + 1] == "replication":
-                    replicationDict = astraSDK.replications.getReplicationpolicies().main()
-                    if not replicationDict:  # Gracefully handle ACS env
+                                acl.credentials.append(credential["id"])
+                elif argv[verbPosition + 1] == "cluster":
+                    ard.clusters = astraSDK.clusters.getClusters().main()
+                    acl.clusters = ard.buildList("clusters", "id")
+                elif argv[verbPosition + 1] == "replication":
+                    ard.replications = astraSDK.replications.getReplicationpolicies().main()
+                    if not ard.replications:  # Gracefully handle ACS env
                         print("Error: 'replication' commands are currently only supported in ACC.")
                         sys.exit(1)
-                    for replication in replicationDict["items"]:
-                        replicationList.append(replication["id"])
-                elif sys.argv[verbPosition + 1] == "script":
-                    for script in astraSDK.scripts.getScripts().main()["items"]:
-                        scriptList.append(script["id"])
-
-    parser = tkParser.toolkit_parser(plaidMode=plaidMode).main(
-        appList,
-        backupList,
-        bucketList,
-        chartsList,
-        cloudList,
-        clusterList,
-        credentialList,
-        destclusterList,
-        hookList,
-        labelList,
-        namespaceList,
-        protectionList,
-        replicationList,
-        scriptList,
-        snapshotList,
-        storageClassList,
-        userList,
-    )
-    args = parser.parse_args()
-    tk = ToolKit()
-
-    if args.subcommand == "deploy":
-        tk.doDeploy(
-            args.chart,
-            tkHelpers.isRFC1123(args.app),
-            args.namespace,
-            args.set,
-            args.values,
-            args.verbose,
-            args.quiet,
+                    acl.replications = ard.buildList("replications", "id")
+                elif argv[verbPosition + 1] == "script":
+                    ard.scripts = astraSDK.scripts.getScripts().main()
+                    acl.scripts = ard.buildList("scripts", "id")
+
+    else:
+        print(
+            f"{argv[0]}: error: please specify a subcommand. Run '{argv[0]} -h' for "
+            "parser information."
         )
+        sys.exit(1)
 
-    elif args.subcommand == "list" or args.subcommand == "get":
-        if args.objectType == "apiresources":
-            rc = astraSDK.apiresources.getApiResources(
-                quiet=args.quiet, verbose=args.verbose, output=args.output
-            ).main(cluster=args.cluster)
-            if rc is False:
-                print("astraSDK.apiresources.getApiResources() failed")
-                sys.exit(1)
-        elif args.objectType == "apps":
-            rc = astraSDK.apps.getApps(
-                quiet=args.quiet, verbose=args.verbose, output=args.output
-            ).main(
-                namespace=args.namespace,
-                nameFilter=args.nameFilter,
-                cluster=args.cluster,
-            )
-            if rc is False:
-                print("astraSDK.apps.getApps() failed")
-                sys.exit(1)
-        elif args.objectType == "assets":
-            rc = astraSDK.apps.getAppAssets(
-                quiet=args.quiet, verbose=args.verbose, output=args.output
-            ).main(args.appID)
-            if rc is False:
-                print("astraSDK.apps.getAppAssets() failed")
-        elif args.objectType == "backups":
-            rc = astraSDK.backups.getBackups(
-                quiet=args.quiet, verbose=args.verbose, output=args.output
-            ).main(appFilter=args.app)
-            if rc is False:
-                print("astraSDK.backups.getBackups() failed")
-                sys.exit(1)
-        elif args.objectType == "buckets":
-            rc = astraSDK.buckets.getBuckets(
-                quiet=args.quiet, verbose=args.verbose, output=args.output
-            ).main(nameFilter=args.nameFilter, provider=args.provider)
-            if rc is False:
-                print("astraSDK.buckets.getBuckets() failed")
-                sys.exit(1)
-        elif args.objectType == "clouds":
-            rc = astraSDK.clouds.getClouds(
-                quiet=args.quiet, verbose=args.verbose, output=args.output
-            ).main(cloudType=args.cloudType)
-            if rc is False:
-                print("astraSDK.clouds.getClouds() failed")
-                sys.exit(1)
-        elif args.objectType == "clusters":
-            rc = astraSDK.clusters.getClusters(
-                quiet=args.quiet, verbose=args.verbose, output=args.output
-            ).main(
-                hideManaged=args.hideManaged,
-                hideUnmanaged=args.hideUnmanaged,
-                nameFilter=args.nameFilter,
-            )
-            if rc is False:
-                print("astraSDK.clusters.getClusters() failed")
-                sys.exit(1)
-        elif args.objectType == "credentials":
-            rc = astraSDK.credentials.getCredentials(
-                quiet=args.quiet, verbose=args.verbose, output=args.output
-            ).main(kubeconfigOnly=args.kubeconfigOnly)
-            if rc is False:
-                print("astraSDK.credentials.getCredentials() failed")
-                sys.exit(1)
-        elif args.objectType == "hooks":
-            rc = astraSDK.hooks.getHooks(
-                quiet=args.quiet, verbose=args.verbose, output=args.output
-            ).main(appFilter=args.app)
-            if rc is False:
-                print("astraSDK.hooks.getHooks() failed")
-                sys.exit(1)
-        elif args.objectType == "protections":
-            rc = astraSDK.protections.getProtectionpolicies(
-                quiet=args.quiet, verbose=args.verbose, output=args.output
-            ).main(appFilter=args.app)
-            if rc is False:
-                print("astraSDK.protections.getProtectionpolicies() failed")
-                sys.exit(1)
-        elif args.objectType == "replications":
-            rc = astraSDK.replications.getReplicationpolicies(
-                quiet=args.quiet, verbose=args.verbose, output=args.output
-            ).main(appFilter=args.app)
-            if rc is False:
-                print("astraSDK.replications.getReplicationpolicies() failed")
-                sys.exit(1)
-        elif args.objectType == "namespaces":
-            rc = astraSDK.namespaces.getNamespaces(
-                quiet=args.quiet, verbose=args.verbose, output=args.output
-            ).main(
-                clusterID=args.clusterID,
-                nameFilter=args.nameFilter,
-                showRemoved=args.showRemoved,
-                unassociated=args.unassociated,
-                minuteFilter=args.minutes,
-            )
-            if rc is False:
-                print("astraSDK.namespaces.getNamespaces() failed")
-                sys.exit(1)
-        elif args.objectType == "notifications":
-            rc = astraSDK.notifications.getNotifications(
-                quiet=args.quiet, verbose=args.verbose, output=args.output
-            ).main(
-                limit=args.limit,
-                skip=args.offset,
-                minuteFilter=args.minutes,
-                severityFilter=args.severity,
-            )
-            if rc is False:
-                print("astraSDK.namespaces.getNotifications() failed")
-                sys.exit(1)
-        elif args.objectType == "rolebindings":
-            rc = astraSDK.rolebindings.getRolebindings(
-                quiet=args.quiet, verbose=args.verbose, output=args.output
-            ).main(idFilter=args.idFilter)
-            if rc is False:
-                print("astraSDK.rolebindings.getRolebindings() failed")
-                sys.exit(1)
-        elif args.objectType == "scripts":
-            if args.getScriptSource:
-                args.quiet = True
-                args.output = "json"
-            rc = astraSDK.scripts.getScripts(
-                quiet=args.quiet, verbose=args.verbose, output=args.output
-            ).main(nameFilter=args.nameFilter)
-            if rc is False:
-                print("astraSDK.scripts.getScripts() failed")
-                sys.exit(1)
-            else:
-                if args.getScriptSource:
-                    if len(rc["items"]) == 0:
-                        print(f"Script of name '{args.nameFilter}' not found.")
-                    for script in rc["items"]:
-                        print("#" * len(f"### {script['name']} ###"))
-                        print(f"### {script['name']} ###")
-                        print("#" * len(f"### {script['name']} ###"))
-                        print(base64.b64decode(script["source"]).decode("utf-8"))
-        elif args.objectType == "snapshots":
-            rc = astraSDK.snapshots.getSnaps(
-                quiet=args.quiet, verbose=args.verbose, output=args.output
-            ).main(appFilter=args.app)
-            if rc is False:
-                print("astraSDK.snapshots.getSnaps() failed")
-                sys.exit(1)
-        elif args.objectType == "storageclasses":
-            rc = astraSDK.storageclasses.getStorageClasses(
-                quiet=args.quiet, verbose=args.verbose, output=args.output
-            ).main(cloudType=args.cloudType)
-            if rc is False:
-                print("astraSDK.storageclasses.getStorageClasses() failed")
-                sys.exit(1)
-        elif args.objectType == "users":
-            rc = astraSDK.users.getUsers(
-                quiet=args.quiet, verbose=args.verbose, output=args.output
-            ).main(nameFilter=args.nameFilter)
-            if rc is False:
-                print("astraSDK.users.getUsers() failed")
-                sys.exit(1)
-
-    elif args.subcommand == "create":
-        if args.objectType == "backup":
-            rc = tk.doProtectionTask(
-                args.objectType,
-                args.appID,
-                tkHelpers.isRFC1123(args.name),
-                args.background,
-                args.pollTimer,
-                args.quiet,
-                args.verbose,
-            )
-            if rc is False:
-                print("doProtectionTask() failed")
-                sys.exit(1)
-            else:
-                sys.exit(0)
-        elif args.objectType == "cluster":
-            with open(args.filePath, encoding="utf8") as f:
-                kubeconfigDict = yaml.load(f.read().rstrip(), Loader=yaml.SafeLoader)
-                encodedStr = base64.b64encode(json.dumps(kubeconfigDict).encode("utf-8")).decode(
-                    "utf-8"
-                )
-            rc = astraSDK.credentials.createCredential(quiet=args.quiet, verbose=args.verbose).main(
-                kubeconfigDict["clusters"][0]["name"],
-                "kubeconfig",
-                {"base64": encodedStr},
-                cloudName="private",
-            )
-            if rc:
-                rc = astraSDK.clusters.addCluster(quiet=args.quiet, verbose=args.verbose).main(
-                    args.cloudID,
-                    rc["id"],
-                )
-                if rc is False:
-                    print("astraSDK.clusters.createCluster() failed")
-                else:
-                    sys.exit(0)
-            else:
-                print("astraSDK.credentials.createCredential() failed")
-                sys.exit(1)
-        elif args.objectType == "hook":
-            rc = astraSDK.hooks.createHook(quiet=args.quiet, verbose=args.verbose).main(
-                args.appID,
-                args.name,
-                args.scriptID,
-                args.operation.split("-")[0],
-                args.operation.split("-")[1],
-                tkHelpers.createHookList(args.hookArguments),
-                matchingCriteria=tkHelpers.createCriteriaList(
-                    args.containerImage,
-                    args.namespace,
-                    args.podName,
-                    args.label,
-                    args.containerName,
-                ),
-            )
-            if rc is False:
-                print("astraSDK.hooks.createHook() failed")
-            else:
-                sys.exit(0)
-        elif args.objectType == "protection" or args.objectType == "protectionpolicy":
-            if args.granularity == "hourly":
-                if args.hour:
-                    print("Error: 'hourly' granularity must not specify -H / --hour")
-                    sys.exit(1)
-                if not hasattr(args, "minute"):
-                    print("Error: 'hourly' granularity requires -m / --minute")
-                    sys.exit(1)
-                args.hour = "*"
-                args.dayOfWeek = "*"
-                args.dayOfMonth = "*"
-            elif args.granularity == "daily":
-                if type(args.hour) != int and not args.hour:
-                    print("Error: 'daily' granularity requires -H / --hour")
-                    sys.exit(1)
-                args.dayOfWeek = "*"
-                args.dayOfMonth = "*"
-            elif args.granularity == "weekly":
-                if type(args.hour) != int and not args.hour:
-                    print("Error: 'weekly' granularity requires -H / --hour")
-                    sys.exit(1)
-                if type(args.dayOfWeek) != int and not args.dayOfWeek:
-                    print("Error: 'weekly' granularity requires -W / --dayOfWeek")
-                    sys.exit(1)
-                args.dayOfMonth = "*"
-            elif args.granularity == "monthly":
-                if type(args.hour) != int and not args.hour:
-                    print("Error: 'monthly' granularity requires -H / --hour")
-                    sys.exit(1)
-                if args.dayOfWeek:
-                    print("Error: 'monthly' granularity must not specify -W / --dayOfWeek")
-                    sys.exit(1)
-                if not args.dayOfMonth:
-                    print("Error: 'monthly' granularity requires -M / --dayOfMonth")
-                    sys.exit(1)
-                args.dayOfWeek = "*"
-            rc = astraSDK.protections.createProtectionpolicy(
-                quiet=args.quiet, verbose=args.verbose
-            ).main(
-                args.granularity,
-                str(args.backupRetention),
-                str(args.snapshotRetention),
-                str(args.dayOfWeek),
-                str(args.dayOfMonth),
-                str(args.hour),
-                str(args.minute),
-                args.appID,
-            )
-            if rc is False:
-                print("astraSDK.protections.createProtectionpolicy() failed")
-                sys.exit(1)
-            else:
-                sys.exit(0)
-        elif args.objectType == "replication":
-            # Validate offset values and create DTSTART string
-            if ":" in args.offset:
-                hours = args.offset.split(":")[0].zfill(2)
-                minutes = args.offset.split(":")[1].zfill(2)
-            else:
-                hours = "00"
-                minutes = args.offset.zfill(2)
-            if int(hours) < 0 or int(hours) > 23:
-                print(f"Error: offset {args.offset} hours must be between 0 and 23, inclusive")
-                sys.exit(1)
-            elif int(minutes) < 0 or int(minutes) > 59:
-                print(f"Error: offset {args.offset} minutes must be between 0 and 59, inclusive")
-                sys.exit(1)
-            dtstart = "DTSTART:20220101T" + hours + minutes + "00Z\n"
-            # Create RRULE string
-            rrule = "RRULE:FREQ=MINUTELY;INTERVAL="
-            if "m" in args.replicationFrequency:
-                rrule += args.replicationFrequency.strip("m")
-            else:
-                rrule += str(int(args.replicationFrequency.strip("h")) * 60)
-            # Get Source ClusterID
-            if plaidMode:
-                apps = astraSDK.apps.getApps().main()
-            for app in apps["items"]:
-                if app["id"] == args.appID:
-                    sourceClusterID = app["clusterID"]
-                    sourceNamespaces = app["namespaces"]
-            nsMapping = [
-                {"clusterID": sourceClusterID, "namespaces": sourceNamespaces},
-                {"clusterID": args.destClusterID, "namespaces": [args.destNamespace]},
-            ]
-            if args.destStorageClass:
-                args.destStorageClass = [
-                    {"storageClassName": args.destStorageClass, "clusterID": args.destClusterID}
-                ]
-            rc = astraSDK.replications.createReplicationpolicy(
-                quiet=args.quiet, verbose=args.verbose
-            ).main(
-                args.appID,
-                args.destClusterID,
-                nsMapping,
-                destinationStorageClass=args.destStorageClass,
-            )
-            if rc:
-                prc = astraSDK.protections.createProtectionpolicy(
-                    quiet=args.quiet, verbose=args.verbose
-                ).main(
-                    "custom",
-                    "0",
-                    "0",
-                    None,
-                    None,
-                    None,
-                    None,
-                    args.appID,
-                    dtstart + rrule,
-                )
-                if prc:
-                    sys.exit(0)
-                else:
-                    print("astraSDK.protections.createProtectionpolicy() failed")
-                    sys.exit(1)
-            else:
-                print("astraSDK.replications.createReplicationpolicy() failed")
-                sys.exit(1)
-        elif args.objectType == "script":
-            with open(args.filePath, encoding="utf8") as f:
-                encodedStr = base64.b64encode(f.read().rstrip().encode("utf-8")).decode("utf-8")
-            rc = astraSDK.scripts.createScript(quiet=args.quiet, verbose=args.verbose).main(
-                name=args.name, source=encodedStr, description=args.description
-            )
-            if rc is False:
-                print("astraSDK.scripts.createScript() failed")
-            else:
-                sys.exit(0)
-        elif args.objectType == "snapshot":
-            rc = tk.doProtectionTask(
-                args.objectType,
-                args.appID,
-                tkHelpers.isRFC1123(args.name),
-                args.background,
-                args.pollTimer,
-                args.quiet,
-                args.verbose,
-            )
-            if rc is False:
-                print("doProtectionTask() failed")
-                sys.exit(1)
-            else:
-                sys.exit(0)
-        elif args.objectType == "user":
-            # First create the user
-            urc = astraSDK.users.createUser(quiet=args.quiet, verbose=args.verbose).main(
-                args.email, firstName=args.firstName, lastName=args.lastName
-            )
-            if urc:
-                # Next create the role binding
-                rrc = astraSDK.rolebindings.createRolebinding(
-                    quiet=args.quiet, verbose=args.verbose
-                ).main(
-                    args.role,
-                    userID=urc["id"],
-                    roleConstraints=tkHelpers.createConstraintList(
-                        args.namespaceConstraint, args.labelConstraint
-                    ),
-                )
-                if rrc:
-                    # Delete+error "local" users where a tempPassword wasn't provided
-                    if urc["authProvider"] == "local" and not args.tempPassword:
-                        print("Error: --tempPassword is required for ACC+localAuth")
-                        drc = astraSDK.rolebindings.destroyRolebinding(quiet=True).main(rrc["id"])
-                        if not drc:
-                            print("astraSDK.rolebindings.destroyRolebinding() failed")
-                        sys.exit(1)
-                    # Finally, create the credential if local user
-                    if urc["authProvider"] == "local":
-                        crc = astraSDK.credentials.createCredential(
-                            quiet=args.quiet, verbose=args.verbose
-                        ).main(
-                            urc["id"],
-                            "passwordHash",
-                            {
-                                "cleartext": base64.b64encode(
-                                    args.tempPassword.encode("utf-8")
-                                ).decode("utf-8"),
-                                "change": base64.b64encode("true".encode("utf-8")).decode("utf-8"),
-                            },
-                        )
-                        if not crc:
-                            print("astraSDK.credentials.createCredential() failed")
-                            sys.exit(1)
-                else:
-                    print("astraSDK.rolebindings.createRolebinding() failed")
-                    sys.exit(1)
-            else:
-                print("astraSDK.users.createUser() failed")
-                sys.exit(1)
-    elif args.subcommand == "manage" or args.subcommand == "define":
-        if args.objectType == "app":
-            if args.additionalNamespace:
-                args.additionalNamespace = tkHelpers.createNamespaceList(args.additionalNamespace)
-            if args.clusterScopedResource:
-                apiResourcesDict = astraSDK.apiresources.getApiResources().main(
-                    cluster=args.clusterID
-                )
-                for resource in apiResourcesDict["items"]:
-                    apiResourcesList.append(resource["kind"])
-                # Validate input as argparse+choices is unable to only validate the first input
-                for csr in args.clusterScopedResource:
-                    if csr[0] not in apiResourcesList:
-                        print(
-                            f"{sys.argv[0]} {sys.argv[1]} {sys.argv[2]}: error: argument "
-                            + f"-c/--clusterScopedResource: invalid choice: '{csr[0]}' (choose "
-                            + f"from {', '.join(apiResourcesList)})"
-                        )
-                        sys.exit(1)
-                args.clusterScopedResource = tkHelpers.createCsrList(
-                    args.clusterScopedResource, apiResourcesDict
-                )
-            rc = astraSDK.apps.manageApp(quiet=args.quiet, verbose=args.verbose).main(
-                tkHelpers.isRFC1123(args.appName),
-                args.namespace,
-                args.clusterID,
-                args.labelSelectors,
-                addNamespaces=args.additionalNamespace,
-                clusterScopedResources=args.clusterScopedResource,
-            )
-            if rc is False:
-                print("astraSDK.apps.manageApp() failed")
-                sys.exit(1)
-            else:
-                sys.exit(0)
-        elif args.objectType == "bucket":
-            # Validate that both credentialID and accessKey/accessSecret were not specified
-            if args.credentialID is not None and (
-                args.accessKey is not None or args.accessSecret is not None
-            ):
-                print(
-                    f"Error: if a credentialID is specified, neither accessKey nor accessSecret"
-                    + " should be specified."
-                )
-                sys.exit(1)
-            # Validate args and create credential if credentialID was not specified
-            if args.credentialID is None:
-                if args.accessKey is None or args.accessSecret is None:
-                    print(
-                        "Error: if a credentialID is not specified, both accessKey and "
-                        + "accessSecret arguments must be provided."
-                    )
-                    sys.exit(1)
-                encodedKey = base64.b64encode(args.accessKey.encode("utf-8")).decode("utf-8")
-                encodedSecret = base64.b64encode(args.accessSecret.encode("utf-8")).decode("utf-8")
-                crc = astraSDK.credentials.createCredential(
-                    quiet=args.quiet, verbose=args.verbose
-                ).main(
-                    args.bucketName,
-                    "s3",
-                    {"accessKey": encodedKey, "accessSecret": encodedSecret},
-                    cloudName="s3",
-                )
-                if crc:
-                    args.credentialID = crc["id"]
-                else:
-                    print("astraSDK.credentials.createCredential() failed")
-                    sys.exit(1)
-            # Validate serverURL and storageAccount args depending upon provider type
-            if args.serverURL is None and args.provider in [
-                "aws",
-                "generic-s3",
-                "ontap-s3",
-                "storagegrid-s3",
-            ]:
-                print(f"Error: --serverURL must be provided for '{args.provider}' provider.")
-                sys.exit(1)
-            if args.storageAccount is None and args.provider == "azure":
-                print("Error: --storageAccount must be provided for 'azure' provider.")
-                sys.exit(1)
-            # Create bucket parameters based on provider and optional arguments
-            if args.provider == "azure":
-                bucketParameters = {
-                    "azure": {"bucketName": args.bucketName, "storageAccount": args.storageAccount}
-                }
-            elif args.provider == "gcp":
-                bucketParameters = {"gcp": {"bucketName": args.bucketName}}
-            else:
-                bucketParameters = {
-                    "s3": {"bucketName": args.bucketName, "serverURL": args.serverURL}
-                }
-            # Call manageBucket class
-            rc = astraSDK.buckets.manageBucket(quiet=args.quiet, verbose=args.verbose).main(
-                args.bucketName, args.credentialID, args.provider, bucketParameters
-            )
-            if rc is False:
-                print("astraSDK.buckets.manageBucket() failed")
-                sys.exit(1)
-            else:
-                sys.exit(0)
-        elif args.objectType == "cluster":
-            rc = astraSDK.clusters.manageCluster(quiet=args.quiet, verbose=args.verbose).main(
-                args.clusterID, args.defaultStorageClassID
-            )
-            if rc is False:
-                print("astraSDK.clusters.manageCluster() failed")
-                sys.exit(1)
-            else:
-                sys.exit(0)
-        elif args.objectType == "cloud":
-            credentialID = None
-            # First create the credential
-            if args.cloudType != "private":
-                if args.credentialPath is None:
-                    print(f"Error: --credentialPath is required for cloudType of {args.cloudType}")
-                    sys.exit(1)
-                with open(args.credentialPath, encoding="utf8") as f:
-                    try:
-                        credDict = json.loads(f.read().rstrip())
-                    except json.decoder.JSONDecodeError:
-                        print(f"Error: {args.credentialPath} does not seem to be valid JSON")
-                        sys.exit(1)
-                encodedStr = base64.b64encode(json.dumps(credDict).encode("utf-8")).decode("utf-8")
-                rc = astraSDK.credentials.createCredential(
-                    quiet=args.quiet, verbose=args.verbose
-                ).main(
-                    "astra-sa@" + args.cloudName,
-                    "service-account",
-                    {"base64": encodedStr},
-                    args.cloudType,
-                )
-                if rc:
-                    credentialID = rc["id"]
-                else:
-                    print("astraSDK.credentials.createCredential() failed")
-                    sys.exit(1)
-            # Next manage the cloud
-            rc = astraSDK.clouds.manageCloud(quiet=args.quiet, verbose=args.verbose).main(
-                args.cloudName,
-                args.cloudType,
-                credentialID=credentialID,
-                defaultBucketID=args.defaultBucketID,
-            )
-            if rc:
-                sys.exit(0)
-            else:
-                print("astraSDK.clouds.manageCloud() failed")
-
-    elif args.subcommand == "destroy":
-        if args.objectType == "backup":
-            rc = astraSDK.backups.destroyBackup(quiet=args.quiet, verbose=args.verbose).main(
-                args.appID, args.backupID
-            )
-            if rc:
-                print(f"Backup {args.backupID} destroyed")
-            else:
-                print(f"Failed destroying backup: {args.backupID}")
-        elif args.objectType == "credential":
-            rc = astraSDK.credentials.destroyCredential(
-                quiet=args.quiet, verbose=args.verbose
-            ).main(args.credentialID)
-            if rc:
-                print(f"Credential {args.credentialID} destroyed")
-            else:
-                print(f"Failed destroying credential: {args.credentialID}")
-        elif args.objectType == "hook":
-            rc = astraSDK.hooks.destroyHook(quiet=args.quiet, verbose=args.verbose).main(
-                args.appID, args.hookID
-            )
-            if rc:
-                print(f"Hook {args.hookID} destroyed")
-            else:
-                print(f"Failed destroying hook: {args.hookID}")
-        elif args.objectType == "protection":
-            rc = astraSDK.protections.destroyProtectiontionpolicy(
-                quiet=args.quiet, verbose=args.verbose
-            ).main(args.appID, args.protectionID)
-            if rc:
-                print(f"Protection policy {args.protectionID} destroyed")
-            else:
-                print(f"Failed destroying protection policy: {args.protectionID}")
-        elif args.objectType == "replication":
-            if plaidMode:
-                replicationDict = astraSDK.replications.getReplicationpolicies().main()
-            rc = astraSDK.replications.destroyReplicationpolicy(
-                quiet=args.quiet, verbose=args.verbose
-            ).main(args.replicationID)
-            if rc:
-                print(f"Replication policy {args.replicationID} destroyed")
-                # The underlying replication schedule(s) (protection policy) must also be deleted
-                protectionDict = astraSDK.protections.getProtectionpolicies().main()
-                for replication in replicationDict["items"]:
-                    if replication["id"] == args.replicationID:
-                        for protection in protectionDict["items"]:
-                            if (
-                                protection["appID"] == replication["sourceAppID"]
-                                or protection["appID"] == replication["destinationAppID"]
-                            ) and protection.get("replicate") == "true":
-                                if astraSDK.protections.destroyProtectiontionpolicy(
-                                    quiet=args.quiet, verbose=args.verbose
-                                ).main(protection["appID"], protection["id"]):
-                                    print(
-                                        "Underlying replication schedule "
-                                        + f"{protection['id']} destroyed"
-                                    )
-                                else:
-                                    print(
-                                        "Failed destroying underlying replication "
-                                        + f"schedule: {protection['id']}"
-                                    )
-                                    sys.exit(1)
-            else:
-                print(f"Failed destroying replication policy: {args.replicationID}")
-                sys.exit(1)
-        elif args.objectType == "script":
-            rc = astraSDK.scripts.destroyScript(quiet=args.quiet, verbose=args.verbose).main(
-                args.scriptID
-            )
-            if rc:
-                print(f"Script {args.scriptID} destroyed")
-            else:
-                print(f"Failed destroying script: {args.scriptID}")
-        elif args.objectType == "snapshot":
-            rc = astraSDK.snapshots.destroySnapshot(quiet=args.quiet, verbose=args.verbose).main(
-                args.appID, args.snapshotID
-            )
-            if rc:
-                print(f"Snapshot {args.snapshotID} destroyed")
-            else:
-                print(f"Failed destroying snapshot: {args.snapshotID}")
-        elif args.objectType == "user":
-            roleBindings = astraSDK.rolebindings.getRolebindings().main()
-            for rb in roleBindings["items"]:
-                if rb["userID"] == args.userID:
-                    rc = astraSDK.rolebindings.destroyRolebinding(
-                        quiet=args.quiet, verbose=args.verbose
-                    ).main(rb["id"])
-                    if rc:
-                        print(f"User {args.userID} / roleBinding {rb['id']} destroyed")
-                        sys.exit(0)
-                    else:
-                        print(f"Failed destroying user {args.userID} with roleBinding {rb['id']}")
-                        sys.exit(1)
-            # If we reached this point, it's due to plaidMode == True and bad userID
-            print(f"Error: userID {args.userID} not found")
-            sys.exit(1)
-
-    elif args.subcommand == "unmanage":
-        if args.objectType == "app":
-            rc = astraSDK.apps.unmanageApp(quiet=args.quiet, verbose=args.verbose).main(args.appID)
-            if rc is False:
-                print("astraSDK.apps.unmanageApp() failed")
-                sys.exit(1)
-            else:
-                sys.exit(0)
-        elif args.objectType == "bucket":
-            rc = astraSDK.buckets.unmanageBucket(quiet=args.quiet, verbose=args.verbose).main(
-                args.bucketID
-            )
-            if rc is False:
-                print("astraSDK.buckets.unmanageBucket() failed")
-                sys.exit(1)
-            else:
-                sys.exit(0)
-        elif args.objectType == "cluster":
-            rc = astraSDK.clusters.unmanageCluster(quiet=args.quiet, verbose=args.verbose).main(
-                args.clusterID
-            )
-            if rc:
-                # "Private" cloud clusters+credentials also should be deleted
-                if plaidMode:
-                    clusterDict = astraSDK.clusters.getClusters(quiet=True).main()
-                for cluster in clusterDict["items"]:
-                    for label in cluster["metadata"]["labels"]:
-                        if (
-                            cluster["id"] == args.clusterID
-                            and label["name"] == "astra.netapp.io/labels/read-only/cloudName"
-                            and label["value"] == "private"
-                        ):
-                            if astraSDK.clusters.deleteCluster(
-                                quiet=args.quiet, verbose=args.verbose
-                            ).main(args.clusterID, cluster["cloudID"]):
-                                if astraSDK.credentials.destroyCredential(
-                                    quiet=args.quiet, verbose=args.verbose
-                                ).main(cluster.get("credentialID")):
-                                    print(f"Credential deleted")
-                                else:
-                                    print("astraSDK.credentials.destroyCredential() failed")
-                                    sys.exit(1)
-                            else:
-                                print("astraSDK.clusters.deleteCluster() failed")
-                                sys.exit(1)
-                sys.exit(0)
-            else:
-                print("astraSDK.clusters.unmanageCluster() failed")
-                sys.exit(1)
-        elif args.objectType == "cloud":
-            if plaidMode:
-                cloudDict = astraSDK.clouds.getClouds(quiet=True).main()
-            rc = astraSDK.clouds.unmanageCloud(quiet=args.quiet, verbose=args.verbose).main(
-                args.cloudID
-            )
-            if rc:
-                # Cloud credentials also should be deleted
-                for cloud in cloudDict["items"]:
-                    if cloud["id"] == args.cloudID:
-                        if cloud.get("credentialID"):
-                            if astraSDK.credentials.destroyCredential(
-                                quiet=args.quiet, verbose=args.verbose
-                            ).main(cloud.get("credentialID")):
-                                print(f"Credential deleted")
-                            else:
-                                print("astraSDK.credentials.destroyCredential() failed")
-                                sys.exit(1)
-                sys.exit(0)
-            else:
-                print("astraSDK.clusters.unmanageCloud() failed")
-                sys.exit(1)
-
-    elif args.subcommand == "restore":
-        if (args.filterSelection and not args.filterSet) or (
-            args.filterSet and not args.filterSelection
-        ):
-            print(
-                f"{' '.join(sys.argv[0:verbPosition+1])}: error: either both or none of "
-                "--filterSelection and --filterSet should be specified"
-            )
-            sys.exit(1)
-        rc = astraSDK.apps.restoreApp(quiet=args.quiet, verbose=args.verbose).main(
-            args.appID,
-            backupID=args.backupID,
-            snapshotID=args.snapshotID,
-            resourceFilter=tkHelpers.createFilterSet(
-                args.filterSelection, args.filterSet, astraSDK.apps.getAppAssets().main(args.appID)
-            ),
-        )
-        if rc:
-            if args.background:
-                print("Restore job submitted successfully")
-                print("Background restore flag selected, run 'list apps' to get status")
-                sys.exit(0)
-            print("Restore job in progress...", end="")
-            sys.stdout.flush()
-            while True:
-                restoreApps = astraSDK.apps.getApps().main()
-                state = None
-                for restoreApp in restoreApps["items"]:
-                    if restoreApp["id"] == args.appID:
-                        state = restoreApp["state"]
-                if state == "restoring":
-                    print(".", end="")
-                    sys.stdout.flush()
-                elif state == "ready":
-                    print("Success!")
-                    break
-                elif state == "failed":
-                    print("Failed!")
-                    sys.exit(2)
-                time.sleep(args.pollTimer)
-        else:
-            print("Submitting restore job failed.")
-            sys.exit(3)
-
-    elif args.subcommand == "clone":
-        if (args.filterSelection and not args.filterSet) or (
-            args.filterSet and not args.filterSelection
-        ):
-            print(
-                f"{' '.join(sys.argv[0:verbPosition+1])}: error: either both or none of "
-                "--filterSelection and --filterSet should be specified"
-            )
-            sys.exit(1)
-        if args.filterSet and args.sourceAppID:
-            print(
-                "Error: resource filters (--filterSet) may only be specified with --backupID "
-                "or --snapshotID arguments, not --sourceAppID"
-            )
-            sys.exit(1)
-        if not args.cloneAppName:
-            args.cloneAppName = input("App name for the clone: ")
-        if not args.clusterID:
-            print("Select destination cluster for the clone")
-            print("Index\tClusterID\t\t\t\tclusterName\tclusterPlatform")
-            args.clusterID = tkHelpers.userSelect(destCluster, ["id", "name", "clusterType"])
-        # Get the original app dictionary based on args.sourceAppID/args.backupID/args.snapshotID,
-        # as the app dict contains sourceClusterID and namespaceScopedResources which we need
-        oApp = {}
-        # Handle -f/--fast/plaidMode cases
-        if plaidMode:
-            apps = astraSDK.apps.getApps().main()
-        if args.sourceAppID:
-            for app in apps["items"]:
-                if app["id"] == args.sourceAppID:
-                    oApp = app
-        elif args.backupID:
-            if plaidMode:
-                backups = astraSDK.backups.getBackups().main()
-            for app in apps["items"]:
-                for backup in backups["items"]:
-                    if app["id"] == backup["appID"] and backup["id"] == args.backupID:
-                        oApp = app
-        elif args.snapshotID:
-            if plaidMode:
-                snapshots = astraSDK.snapshots.getSnaps().main()
-            for app in apps["items"]:
-                for snapshot in snapshots["items"]:
-                    if app["id"] == snapshot["appID"] and snapshot["id"] == args.snapshotID:
-                        oApp = app
-        # Ensure appIDstr is not equal to "", if so bad values were passed in with plaidMode
-        if not oApp:
-            print(
-                "Error: the corresponding appID was not found in the system, please check "
-                + "your inputs and try again."
-            )
-            sys.exit(1)
-
-        tk.doClone(
-            tkHelpers.isRFC1123(args.cloneAppName),
-            args.clusterID,
-            oApp,
-            tkHelpers.createNamespaceMapping(oApp, args.cloneNamespace, args.multiNsMapping),
-            args.backupID,
-            args.snapshotID,
-            args.sourceAppID,
-            args.background,
-            args.pollTimer,
-            tkHelpers.createFilterSet(
-                args.filterSelection, args.filterSet, astraSDK.apps.getAppAssets().main(oApp["id"])
-            ),
-            args.verbose,
-            args.quiet,
-        )
-
-    elif args.subcommand == "update":
-        if args.objectType == "bucket":
-            # Validate that both credentialID and accessKey/accessSecret were not specified
-            if args.credentialID is not None and (
-                args.accessKey is not None or args.accessSecret is not None
-            ):
-                print(
-                    f"Error: if a credentialID is specified, neither accessKey nor accessSecret"
-                    + " should be specified."
-                )
-                sys.exit(1)
-            # Validate args and create credential if credentialID was not specified
-            if args.credentialID is None:
-                if args.accessKey is None or args.accessSecret is None:
-                    print(
-                        "Error: if a credentialID is not specified, both accessKey and "
-                        + "accessSecret arguments must be provided."
-                    )
-                    sys.exit(1)
-                if plaidMode:
-                    bucketDict = astraSDK.buckets.getBuckets().main()
-                encodedKey = base64.b64encode(args.accessKey.encode("utf-8")).decode("utf-8")
-                encodedSecret = base64.b64encode(args.accessSecret.encode("utf-8")).decode("utf-8")
-                try:
-                    crc = astraSDK.credentials.createCredential(
-                        quiet=args.quiet, verbose=args.verbose
-                    ).main(
-                        next(b for b in bucketDict["items"] if b["id"] == args.bucketID)["name"],
-                        "s3",
-                        {"accessKey": encodedKey, "accessSecret": encodedSecret},
-                        cloudName="s3",
-                    )
-                except StopIteration:
-                    print(f"Error: {args.bucketID} does not seem to be a valid bucketID")
-                    sys.exit(1)
-                if crc:
-                    args.credentialID = crc["id"]
-                else:
-                    print("astraSDK.credentials.createCredential() failed")
-                    sys.exit(1)
-            # Call updateBucket class
-            rc = astraSDK.buckets.updateBucket(quiet=args.quiet, verbose=args.verbose).main(
-                args.bucketID, credentialID=args.credentialID
-            )
-            if rc is False:
-                print("astraSDK.buckets.updateBucket() failed")
-                sys.exit(1)
-            else:
-                sys.exit(0)
-        elif args.objectType == "cloud":
-            if args.credentialPath:
-                with open(args.credentialPath, encoding="utf8") as f:
-                    try:
-                        credDict = json.loads(f.read().rstrip())
-                    except json.decoder.JSONDecodeError:
-                        print(f"Error: {args.credentialPath} does not seem to be valid JSON")
-                        sys.exit(1)
-                encodedStr = base64.b64encode(json.dumps(credDict).encode("utf-8")).decode("utf-8")
-                if plaidMode:
-                    cloudDict = astraSDK.clouds.getClouds().main()
-                try:
-                    cloud = next(c for c in cloudDict["items"] if c["id"] == args.cloudID)
-                except StopIteration:
-                    print(f"Error: {args.cloudID} does not seem to be a valid cloudID")
-                    sys.exit(1)
-                rc = astraSDK.credentials.createCredential(
-                    quiet=args.quiet, verbose=args.verbose
-                ).main(
-                    "astra-sa@" + cloud["name"],
-                    "service-account",
-                    {"base64": encodedStr},
-                    cloud["cloudType"],
-                )
-                if rc:
-                    args.credentialID = rc["id"]
-                else:
-                    print("astraSDK.credentials.createCredential() failed")
-                    sys.exit(1)
-            # Next update the cloud
-            rc = astraSDK.clouds.updateCloud(quiet=args.quiet, verbose=args.verbose).main(
-                args.cloudID,
-                credentialID=args.credentialID,
-                defaultBucketID=args.defaultBucketID,
-            )
-            if rc:
-                sys.exit(0)
-            else:
-                print(rc.error)
-                print("astraSDK.clouds.updateCloud() failed")
-        elif args.objectType == "cluster":
-            # Get the cluster information based on the clusterID input
-            if plaidMode:
-                clusterDict = astraSDK.clusters.getClusters().main()
-            try:
-                cluster = next(c for c in clusterDict["items"] if c["id"] == args.clusterID)
-            except StopIteration:
-                print(f"Error: {args.clusterID} does not seem to be a valid clusterID")
-                sys.exit(1)
-            # Currently this is required to be True, but this will not always be the case
-            if args.credentialPath:
-                with open(args.credentialPath, encoding="utf8") as f:
-                    kubeconfigDict = yaml.load(f.read().rstrip(), Loader=yaml.SafeLoader)
-                    encodedStr = base64.b64encode(
-                        json.dumps(kubeconfigDict).encode("utf-8")
-                    ).decode("utf-8")
-                rc = astraSDK.credentials.updateCredential(
-                    quiet=args.quiet, verbose=args.verbose
-                ).main(
-                    cluster.get("credentialID"),
-                    kubeconfigDict["clusters"][0]["name"],
-                    keyStore={"base64": encodedStr},
-                )
-                if rc:
-                    sys.exit(0)
-                else:
-                    print("astraSDK.credentials.updateCredential() failed")
-                    sys.exit(1)
-        elif args.objectType == "replication":
-            # Gather replication data
-            if plaidMode:
-                replicationDict = astraSDK.replications.getReplicationpolicies().main()
-                if not replicationDict:  # Gracefully handle ACS env
-                    print("Error: 'replication' commands are currently only supported in ACC.")
-                    sys.exit(1)
-            repl = None
-            for replication in replicationDict["items"]:
-                if args.replicationID == replication["id"]:
-                    repl = replication
-            if not repl:
-                print(f"Error: replicationID {args.replicationID} not found")
-                sys.exit(1)
-            # Make call based on operation type
-            if args.operation == "resync":
-                if not args.dataSource:
-                    print("Error: --dataSource must be provided for 'resync' operations")
-                    sys.exit(1)
-                if repl["state"] != "failedOver":
-                    print(
-                        "Error: to resync a replication, it must be in a `failedOver` state"
-                        + f", not a(n) `{repl['state']}` state"
-                    )
-                    sys.exit(1)
-                if args.dataSource in [repl["sourceAppID"], repl["sourceClusterID"]]:
-                    rc = astraSDK.replications.updateReplicationpolicy(
-                        quiet=args.quiet, verbose=args.verbose
-                    ).main(
-                        args.replicationID,
-                        "established",
-                        sourceAppID=repl["sourceAppID"],
-                        sourceClusterID=repl["sourceClusterID"],
-                        destinationAppID=repl["destinationAppID"],
-                        destinationClusterID=repl["destinationClusterID"],
-                    )
-                elif args.dataSource in [repl["destinationAppID"], repl["destinationClusterID"]]:
-                    rc = astraSDK.replications.updateReplicationpolicy(
-                        quiet=args.quiet, verbose=args.verbose
-                    ).main(
-                        args.replicationID,
-                        "established",
-                        sourceAppID=repl["destinationAppID"],
-                        sourceClusterID=repl["destinationClusterID"],
-                        destinationAppID=repl["sourceAppID"],
-                        destinationClusterID=repl["sourceClusterID"],
-                    )
-                else:
-                    print(
-                        f"Error: dataSource '{args.dataSource}' not one of:\n"
-                        + f"\t{repl['sourceAppID']}\t(original sourceAppID)\n"
-                        + f"\t{repl['sourceClusterID']}\t(original sourceClusterID)\n"
-                        + f"\t{repl['destinationAppID']}\t(original destinationAppID)\n"
-                        + f"\t{repl['destinationClusterID']}\t(original destinationClusterID)"
-                    )
-                    sys.exit(1)
-            elif args.operation == "reverse":
-                if repl["state"] != "established" and repl["state"] != "failedOver":
-                    print(
-                        "Error: to reverse a replication, it must be in an `established` or "
-                        + f"`failedOver` state, not a(n) `{repl['state']}` state"
-                    )
-                    sys.exit(1)
-                rc = astraSDK.replications.updateReplicationpolicy(
-                    quiet=args.quiet, verbose=args.verbose
-                ).main(
-                    args.replicationID,
-                    "established",
-                    sourceAppID=repl["destinationAppID"],
-                    sourceClusterID=repl["destinationClusterID"],
-                    destinationAppID=repl["sourceAppID"],
-                    destinationClusterID=repl["sourceClusterID"],
-                )
-            else:  # failover
-                if repl["state"] != "established":
-                    print(
-                        "Error: to failover a replication, it must be in an `established` state"
-                        + f", not a(n) `{repl['state']}` state"
-                    )
-                    sys.exit(1)
-                rc = astraSDK.replications.updateReplicationpolicy(
-                    quiet=args.quiet, verbose=args.verbose
-                ).main(args.replicationID, "failedOver")
-            # Exit based on response
-            if rc:
-                print(f"Replication {args.operation} initiated")
-                sys.exit(0)
-            else:
-                print("astraSDK.replications.updateReplicationpolicy() failed")
-                sys.exit(1)
-        elif args.objectType == "script":
-            with open(args.filePath, encoding="utf8") as f:
-                encodedStr = base64.b64encode(f.read().rstrip().encode("utf-8")).decode("utf-8")
-            rc = astraSDK.scripts.updateScript(quiet=args.quiet, verbose=args.verbose).main(
-                args.scriptID, source=encodedStr
-            )
-            if rc is False:
-                print("astraSDK.scripts.updateScript() failed")
-            else:
-                sys.exit(0)
+    tkParser = tkSrc.parser.ToolkitParser(acl, plaidMode=plaidMode)
+    tkSrc.callers.main(argv, tkParser, ard)
 
 
 if __name__ == "__main__":
     main()
```

## astraSDK/common.py

```diff
@@ -11,40 +11,38 @@
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 """
 
-import inspect
 import json
 import os
 import sys
 import yaml
 from tabulate import tabulate
 from termcolor import colored
 import requests
 from urllib3 import disable_warnings
 
 
 class getConfig:
     """In order to make API calls to Astra Control we need to know which Astra Control instance
     to connect to, and the credentials to make calls.  This info is found in config.yaml,
     which we search for in the following four places:
-    1) The directory that astraSDK.py is located in
+    1) The current working directory that the executed function is located in
     2) ~/.config/astra-toolkits/
     3) /etc/astra-toolkits/
     4) The directory pointed to by the shell env var ASTRATOOLKITS_CONF
     """
 
     def __init__(self):
-        path = sys.argv[0] or inspect.getfile(getConfig)
         self.conf = None
         for loc in (
-            os.path.realpath(os.path.dirname(path)),
+            os.getcwd(),
             os.path.join(os.path.expanduser("~"), ".config", "astra-toolkits"),
             "/etc/astra-toolkits",
             os.environ.get("ASTRATOOLKITS_CONF"),
         ):
             # loc could be None, which would blow up os.path.join()
             if loc:
                 configFile = os.path.join(loc, "config.yaml")
```

## astraSDK/namespaces.py

```diff
@@ -46,14 +46,16 @@
         showRemoved=False,
         unassociated=False,
         minuteFilter=False,
     ):
         if self.clusters is False:
             print("Call to getClusters().main() failed")
             return False
+        elif self.clusters is True:
+            return True
         elif self.apps is False:
             print("Call to getApps().main() failed")
             return False
 
         if clusterID:
             endpoint = f"topology/v1/clusters/{clusterID}/namespaces"
         else:
```

## Comparing `tkHelpers.py` & `tkSrc/helpers.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3
 """
-   Copyright 2022 NetApp, Inc
+   Copyright 2023 NetApp, Inc
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
```

## Comparing `tkParser.py` & `tkSrc/parser.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python3
 """
-   Copyright 2022 NetApp, Inc
+   Copyright 2023 NetApp, Inc
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
@@ -14,20 +14,20 @@
    See the License for the specific language governing permissions and
    limitations under the License.
 """
 
 import argparse
 
 
-class toolkit_parser:
+class ToolkitParser:
     """Creates and returns an argparse parser for use in toolkit.py"""
 
-    def __init__(self, plaidMode=False):
+    def __init__(self, acl, plaidMode=False):
         """Creates the parser object and global arguments"""
-        self.parser = argparse.ArgumentParser(allow_abbrev=True)
+        self.parser = argparse.ArgumentParser(allow_abbrev=True, prog="actoolkit")
         self.parser.add_argument(
             "-v",
             "--verbose",
             default=False,
             action="store_true",
             help="print verbose/verbose output",
         )
@@ -45,14 +45,15 @@
             "-f",
             "--fast",
             default=False,
             action="store_true",
             help="prioritize speed over validation (using this will not validate arguments, which "
             + "may have unintended consequences)",
         )
+        self.acl = acl
         self.plaidMode = plaidMode
 
     def top_level_commands(self):
         """Creates the top level arguments, such as list, create, destroy, etc.
         Be sure to keep these in sync with verbs{} in the calling function."""
         self.subparsers = self.parser.add_subparsers(
             dest="subcommand", required=True, help="subcommand help"
@@ -319,23 +320,23 @@
             help="update replication",
         )
         self.subparserUpdateScript = self.subparserUpdate.add_parser(
             "script",
             help="update script",
         )
 
-    def deploy_args(self, chartsList):
+    def deploy_args(self):
         """deploy args and flags"""
         self.parserDeploy.add_argument(
             "app",
             help="name of app",
         )
         self.parserDeploy.add_argument(
             "chart",
-            choices=(None if self.plaidMode else chartsList),
+            choices=(None if self.plaidMode else self.acl.charts),
             help="chart to deploy",
         )
         self.parserDeploy.add_argument(
             "-n",
             "--namespace",
             required=True,
             help="Namespace to deploy into (must not already exist)",
@@ -352,15 +353,15 @@
             "--set",
             required=False,
             action="append",
             nargs="*",
             help="Individual helm chart parameters",
         )
 
-    def clone_args(self, appList, backupList, destclusterList, snapshotList):
+    def clone_args(self):
         """clone args and flags"""
         self.parserClone.add_argument(
             "-b",
             "--background",
             default=False,
             action="store_true",
             help="Run clone operation in the background",
@@ -369,15 +370,15 @@
             "--cloneAppName",
             required=False,
             default=None,
             help="Clone app name",
         )
         self.parserClone.add_argument(
             "--clusterID",
-            choices=(None if self.plaidMode else destclusterList),
+            choices=(None if self.plaidMode else self.acl.destClusters),
             required=False,
             default=None,
             help="Cluster to clone into (can be same as source)",
         )
         nsGroup = self.parserClone.add_mutually_exclusive_group()
         nsGroup.add_argument(
             "--cloneNamespace",
@@ -393,29 +394,29 @@
             action="append",
             nargs="*",
             help="For multi-namespace apps, specify matching number of sourcens1=destns1 mappings",
         )
         sourceGroup = self.parserClone.add_mutually_exclusive_group(required=True)
         sourceGroup.add_argument(
             "--backupID",
-            choices=(None if self.plaidMode else backupList),
+            choices=(None if self.plaidMode else self.acl.backups),
             required=False,
             default=None,
             help="Source backup to clone from",
         )
         sourceGroup.add_argument(
             "--snapshotID",
-            choices=(None if self.plaidMode else snapshotList),
+            choices=(None if self.plaidMode else self.acl.snapshots),
             required=False,
             default=None,
             help="Source snapshot to clone from",
         )
         sourceGroup.add_argument(
             "--sourceAppID",
-            choices=(None if self.plaidMode else appList),
+            choices=(None if self.plaidMode else self.acl.apps),
             required=False,
             default=None,
             help="Source app to live clone",
         )
         self.parserClone.add_argument(
             "-t",
             "--pollTimer",
@@ -439,39 +440,39 @@
             nargs="*",
             help=r"A comma separated set of key=value filter pairs, where 'key' is one of "
             "['namespace', 'name', 'label', 'group', 'version', 'kind']. This argument can be "
             "specified multiple times for multiple filter sets:\n--filterSet version=v1,kind="
             "PersistentVolumeClaim --filterSet label=app.kubernetes.io/tier=backend,name=mysql",
         )
 
-    def restore_args(self, appList, backupList, snapshotList):
+    def restore_args(self):
         """restore args and flags"""
         self.parserRestore.add_argument(
             "-b",
             "--background",
             default=False,
             action="store_true",
             help="Run restore operation in the background",
         )
         self.parserRestore.add_argument(
             "appID",
-            choices=(None if self.plaidMode else appList),
+            choices=(None if self.plaidMode else self.acl.apps),
             help="appID to restore",
         )
         group = self.parserRestore.add_mutually_exclusive_group(required=True)
         group.add_argument(
             "--backupID",
-            choices=(None if self.plaidMode else backupList),
+            choices=(None if self.plaidMode else self.acl.backups),
             required=False,
             default=None,
             help="Source backup to restore from",
         )
         group.add_argument(
             "--snapshotID",
-            choices=(None if self.plaidMode else snapshotList),
+            choices=(None if self.plaidMode else self.acl.snapshots),
             required=False,
             default=None,
             help="Source snapshot to restore from",
         )
         self.parserRestore.add_argument(
             "-t",
             "--pollTimer",
@@ -516,19 +517,19 @@
             default=None,
             help="Filter app names by this value to minimize output (partial match)",
         )
         self.subparserListApps.add_argument(
             "-c", "--cluster", default=None, help="Only show apps from this cluster"
         )
 
-    def list_assets_args(self, appList):
+    def list_assets_args(self):
         """list assets args and flags"""
         self.subparserListAssets.add_argument(
             "appID",
-            choices=(None if self.plaidMode else appList),
+            choices=(None if self.plaidMode else self.acl.apps),
             help="The appID from which to display the assets",
         )
 
     def list_backups_args(self):
         """list backups args and flags"""
         self.subparserListBackups.add_argument(
             "-a", "--app", default=None, help="Only show backups from this app"
@@ -721,37 +722,37 @@
         self.subparserListUsers.add_argument(
             "-f",
             "--nameFilter",
             default=None,
             help="Filter users by this value to minimize output (partial match)",
         )
 
-    def create_backup_args(self, appList, bucketList, snapshotList):
+    def create_backup_args(self):
         """create backups args and flags"""
         self.subparserCreateBackup.add_argument(
             "appID",
-            choices=(None if self.plaidMode else appList),
+            choices=(None if self.plaidMode else self.acl.apps),
             help="appID to backup",
         )
         self.subparserCreateBackup.add_argument(
             "name",
             help="Name of backup to be taken",
         )
         self.subparserCreateBackup.add_argument(
             "-u",
             "--bucketID",
             default=None,
-            choices=(None if self.plaidMode else bucketList),
+            choices=(None if self.plaidMode else self.acl.buckets),
             help="Optionally specify which bucket to store the backup",
         )
         self.subparserCreateBackup.add_argument(
             "-s",
             "--snapshotID",
             default=None,
-            choices=(None if self.plaidMode else snapshotList),
+            choices=(None if self.plaidMode else self.acl.snapshots),
             help="Optionally specify an existing snapshot as the source of the backup",
         )
         self.subparserCreateBackup.add_argument(
             "-b",
             "--background",
             default=False,
             action="store_true",
@@ -761,43 +762,43 @@
             "-t",
             "--pollTimer",
             type=int,
             default=5,
             help="The frequency (seconds) to poll the operation status (default: %(default)s)",
         )
 
-    def create_cluster_args(self, cloudList):
+    def create_cluster_args(self):
         """create cluster args and flags"""
         self.subparserCreateCluster.add_argument(
             "filePath",
             help="the local filesystem path to the cluster kubeconfig",
         )
         self.subparserCreateCluster.add_argument(
             "-c",
             "--cloudID",
-            choices=(None if self.plaidMode else cloudList),
-            default=(cloudList[0] if len(cloudList) == 1 else None),
-            required=(False if len(cloudList) == 1 else True),
+            choices=(None if self.plaidMode else self.acl.clouds),
+            default=(self.acl.clouds[0] if len(self.acl.clouds) == 1 else None),
+            required=(False if len(self.acl.clouds) == 1 else True),
             help="The cloudID to add the cluster to (only required if # of clouds > 1)",
         )
 
-    def create_hook_args(self, appList, scriptList):
+    def create_hook_args(self):
         """create hooks args and flags"""
         self.subparserCreateHook.add_argument(
             "appID",
-            choices=(None if self.plaidMode else appList),
+            choices=(None if self.plaidMode else self.acl.apps),
             help="appID to create an execution hook for",
         )
         self.subparserCreateHook.add_argument(
             "name",
             help="Name of the execution hook to be created",
         )
         self.subparserCreateHook.add_argument(
             "scriptID",
-            choices=(None if self.plaidMode else scriptList),
+            choices=(None if self.plaidMode else self.acl.scripts),
             help="scriptID to use for the execution hook",
         )
         self.subparserCreateHook.add_argument(
             "-o",
             "--operation",
             choices=["pre-snapshot", "post-snapshot", "pre-backup", "post-backup", "post-restore"],
             required=True,
@@ -859,19 +860,19 @@
             required=False,
             default=[],
             action="append",
             nargs="*",
             help="regex filter for container names",
         )
 
-    def create_protection_args(self, appList):
+    def create_protection_args(self):
         """create protectionpolicy args and flags"""
         self.subparserCreateProtection.add_argument(
             "appID",
-            choices=(None if self.plaidMode else appList),
+            choices=(None if self.plaidMode else self.acl.apps),
             help="appID of the application to create protection schedule for",
         )
         self.subparserCreateProtection.add_argument(
             "-g",
             "--granularity",
             required=True,
             choices=["hourly", "daily", "weekly", "monthly"],
@@ -906,38 +907,38 @@
         self.subparserCreateProtection.add_argument(
             "-H", "--hour", type=int, choices=range(24), help="Hour in military time"
         )
         self.subparserCreateProtection.add_argument(
             "-m", "--minute", default=0, type=int, choices=range(60), help="Minute"
         )
 
-    def create_replication_args(self, appList, destclusterList, storageClassList):
+    def create_replication_args(self):
         """create replication policy args and flags"""
         self.subparserCreateReplication.add_argument(
             "appID",
-            choices=(None if self.plaidMode else appList),
+            choices=(None if self.plaidMode else self.acl.apps),
             help="appID of the application to create the replication policy for",
         )
         self.subparserCreateReplication.add_argument(
             "-c",
             "--destClusterID",
-            choices=(None if self.plaidMode else destclusterList),
+            choices=(None if self.plaidMode else self.acl.destClusters),
             help="the destination cluster ID to replicate to",
             required=True,
         )
         self.subparserCreateReplication.add_argument(
             "-n",
             "--destNamespace",
             help="the namespace to create resources on the destination cluster",
             required=True,
         )
         self.subparserCreateReplication.add_argument(
             "-s",
             "--destStorageClass",
-            choices=(None if self.plaidMode else storageClassList),
+            choices=(None if self.plaidMode else self.acl.storageClasses),
             default=None,
             help="the destination storage class to use for volume creation",
         )
         self.subparserCreateReplication.add_argument(
             "-f",
             "--replicationFrequency",
             choices=[
@@ -979,19 +980,19 @@
         self.subparserCreateScript.add_argument(
             "-d",
             "--description",
             default=None,
             help="The optional description of the script",
         )
 
-    def create_snapshot_args(self, appList):
+    def create_snapshot_args(self):
         """create snapshot args and flags"""
         self.subparserCreateSnapshot.add_argument(
             "appID",
-            choices=(None if self.plaidMode else appList),
+            choices=(None if self.plaidMode else self.acl.apps),
             help="appID to snapshot",
         )
         self.subparserCreateSnapshot.add_argument(
             "name",
             help="Name of snapshot to be taken",
         )
         self.subparserCreateSnapshot.add_argument(
@@ -1005,15 +1006,15 @@
             "-t",
             "--pollTimer",
             type=int,
             default=5,
             help="The frequency (seconds) to poll the operation status (default: %(default)s)",
         )
 
-    def create_user_args(self, labelList, namespaceList):
+    def create_user_args(self):
         """create user args and flags"""
         self.subparserCreateUser.add_argument("email", help="The email of the user to add")
         self.subparserCreateUser.add_argument(
             "role", choices=["viewer", "member", "admin", "owner"], help="The user's role"
         )
         self.subparserCreateUser.add_argument(
             "-p",
@@ -1030,42 +1031,42 @@
         self.subparserCreateUser.add_argument(
             "-l", "--lastName", default=None, help="The user's last name"
         )
         self.subparserCreateUser.add_argument(
             "-a",
             "--labelConstraint",
             default=None,
-            choices=(None if self.plaidMode else labelList),
+            choices=(None if self.plaidMode else self.acl.labels),
             nargs="*",
             action="append",
             help="Restrict user role to label constraints",
         )
         self.subparserCreateUser.add_argument(
             "-n",
             "--namespaceConstraint",
             default=None,
-            choices=(None if self.plaidMode else namespaceList),
+            choices=(None if self.plaidMode else self.acl.namespaces),
             nargs="*",
             action="append",
             help="Restrict user role to namespace constraints",
         )
 
-    def manage_app_args(self, clusterList, namespaceList):
+    def manage_app_args(self):
         """manage app args and flags"""
         self.subparserManageApp.add_argument(
             "appName", help="The logical name of the newly defined app"
         )
         self.subparserManageApp.add_argument(
             "namespace",
-            choices=(None if self.plaidMode else namespaceList),
+            choices=(None if self.plaidMode else self.acl.namespaces),
             help="The namespace to move from undefined (aka unmanaged) to defined (aka managed)",
         )
         self.subparserManageApp.add_argument(
             "clusterID",
-            choices=(None if self.plaidMode else clusterList),
+            choices=(None if self.plaidMode else self.acl.clusters),
             help="The clusterID hosting the newly defined app",
         )
         self.subparserManageApp.add_argument(
             "-l",
             "--labelSelectors",
             required=False,
             default=None,
@@ -1089,15 +1090,15 @@
             default=None,
             nargs="*",
             action="append",
             help="Any number of clusterScopedResources (and optional labelSelectors), one set per"
             + " argument (-c csr-kind1 -c csr-kind2 app=appname)",
         )
 
-    def manage_bucket_args(self, credentialList):
+    def manage_bucket_args(self):
         """manage bucket args and flags"""
         self.subparserManageBucket.add_argument(
             "provider",
             choices=["aws", "azure", "gcp", "generic-s3", "ontap-s3", "storagegrid-s3"],
             help="The infrastructure provider of the storage bucket",
         )
         self.subparserManageBucket.add_argument(
@@ -1107,15 +1108,15 @@
         credGroup = self.subparserManageBucket.add_argument_group(
             "credentialGroup",
             "Either an (existing credentialID) OR (accessKey AND accessSecret)",
         )
         credGroup.add_argument(
             "-c",
             "--credentialID",
-            choices=(None if self.plaidMode else credentialList),
+            choices=(None if self.plaidMode else self.acl.credentials),
             help="The ID of the credentials used to access the bucket",
             default=None,
         )
         credGroup.add_argument(
             "--accessKey",
             help="The access key of the bucket",
             default=None,
@@ -1135,30 +1136,30 @@
         self.subparserManageBucket.add_argument(
             "-a",
             "--storageAccount",
             help="The  Azure storage account name (only needed for 'Azure')",
             default=None,
         )
 
-    def manage_cluster_args(self, clusterList, storageClassList):
+    def manage_cluster_args(self):
         """manage cluster args and flags"""
         self.subparserManageCluster.add_argument(
             "clusterID",
-            choices=(None if self.plaidMode else clusterList),
+            choices=(None if self.plaidMode else self.acl.clusters),
             help="clusterID of the cluster to manage",
         )
         self.subparserManageCluster.add_argument(
             "-s",
             "--defaultStorageClassID",
-            choices=(None if self.plaidMode else storageClassList),
+            choices=(None if self.plaidMode else self.acl.storageClasses),
             default=None,
             help="Optionally modify the default storage class",
         )
 
-    def manage_cloud_args(self, bucketList):
+    def manage_cloud_args(self):
         """manage cloud args and flags"""
         self.subparserManageCloud.add_argument(
             "cloudType",
             choices=["AWS", "Azure", "GCP", "private"],
             help="the type of cloud to add",
         )
         self.subparserManageCloud.add_argument(
@@ -1171,259 +1172,240 @@
             default=None,
             help="the local filesystem path to the cloud credential (required for all but "
             + "'private' clouds)",
         )
         self.subparserManageCloud.add_argument(
             "-b",
             "--defaultBucketID",
-            choices=(None if self.plaidMode else bucketList),
+            choices=(None if self.plaidMode else self.acl.buckets),
             default=None,
             help="optionally specify the default bucketID for backups",
         )
 
-    def destroy_backup_args(self, appList, backupList):
+    def destroy_backup_args(self):
         """destroy backup args and flags"""
         self.subparserDestroyBackup.add_argument(
             "appID",
-            choices=(None if self.plaidMode else appList),
+            choices=(None if self.plaidMode else self.acl.apps),
             help="appID of app to destroy backups from",
         )
         self.subparserDestroyBackup.add_argument(
             "backupID",
-            choices=(None if self.plaidMode else backupList),
+            choices=(None if self.plaidMode else self.acl.backups),
             help="backupID to destroy",
         )
 
-    def destroy_credential_args(self, credentialList):
+    def destroy_credential_args(self):
         """destroy credential args and flags"""
         self.subparserDestroyCredential.add_argument(
             "credentialID",
-            choices=(None if self.plaidMode else credentialList),
+            choices=(None if self.plaidMode else self.acl.credentials),
             help="credentialID to destroy",
         )
 
-    def destroy_hook_args(self, appList, hookList):
+    def destroy_hook_args(self):
         """destroy hook args and flags"""
         self.subparserDestroyHook.add_argument(
             "appID",
-            choices=(None if self.plaidMode else appList),
+            choices=(None if self.plaidMode else self.acl.apps),
             help="appID of app to destroy hooks from",
         )
         self.subparserDestroyHook.add_argument(
             "hookID",
-            choices=(None if self.plaidMode else hookList),
+            choices=(None if self.plaidMode else self.acl.hooks),
             help="hookID to destroy",
         )
 
-    def destroy_protection_args(self, appList, protectionList):
+    def destroy_protection_args(self):
         """destroy protection args and flags"""
         self.subparserDestroyProtection.add_argument(
             "appID",
-            choices=(None if self.plaidMode else appList),
+            choices=(None if self.plaidMode else self.acl.apps),
             help="appID of app to destroy protection policy from",
         )
         self.subparserDestroyProtection.add_argument(
             "protectionID",
-            choices=(None if self.plaidMode else protectionList),
+            choices=(None if self.plaidMode else self.acl.protections),
             help="protectionID to destroy",
         )
 
-    def destroy_replication_args(self, replicationList):
+    def destroy_replication_args(self):
         """destroy replication args and flags"""
         self.subparserDestroyReplication.add_argument(
             "replicationID",
-            choices=(None if self.plaidMode else replicationList),
+            choices=(None if self.plaidMode else self.acl.replications),
             help="replicationID to destroy",
         )
 
-    def destroy_script_args(self, scriptList):
+    def destroy_script_args(self):
         """destroy script args and flags"""
         self.subparserDestroyScript.add_argument(
             "scriptID",
-            choices=(None if self.plaidMode else scriptList),
+            choices=(None if self.plaidMode else self.acl.scripts),
             help="scriptID of script to destroy",
         )
 
-    def destroy_snapshot_args(self, appList, snapshotList):
+    def destroy_snapshot_args(self):
         """destroy snapshot args and flags"""
         self.subparserDestroySnapshot.add_argument(
             "appID",
-            choices=(None if self.plaidMode else appList),
+            choices=(None if self.plaidMode else self.acl.apps),
             help="appID of app to destroy snapshot from",
         )
         self.subparserDestroySnapshot.add_argument(
             "snapshotID",
-            choices=(None if self.plaidMode else snapshotList),
+            choices=(None if self.plaidMode else self.acl.snapshots),
             help="snapshotID to destroy",
         )
 
-    def destroy_user_args(self, userList):
+    def destroy_user_args(self):
         """destroy user args and flags"""
         self.subparserDestroyUser.add_argument(
             "userID",
-            choices=(None if self.plaidMode else userList),
+            choices=(None if self.plaidMode else self.acl.users),
             help="userID to destroy",
         )
 
-    def unmanage_app_args(self, appList):
+    def unmanage_app_args(self):
         """unmanage app args and flags"""
         self.subparserUnmanageApp.add_argument(
             "appID",
-            choices=(None if self.plaidMode else appList),
+            choices=(None if self.plaidMode else self.acl.apps),
             help="appID of app to move from managed to unmanaged",
         )
 
-    def unmanage_bucket_args(self, bucketList):
+    def unmanage_bucket_args(self):
         """unmanage bucket args and flags"""
         self.subparserUnmanageBucket.add_argument(
             "bucketID",
-            choices=(None if self.plaidMode else bucketList),
+            choices=(None if self.plaidMode else self.acl.buckets),
             help="bucketID of bucket to unmanage",
         )
 
-    def unmanage_cluster_args(self, clusterList):
+    def unmanage_cluster_args(self):
         """unmanage cluster args and flags"""
         self.subparserUnmanageCluster.add_argument(
             "clusterID",
-            choices=(None if self.plaidMode else clusterList),
+            choices=(None if self.plaidMode else self.acl.clusters),
             help="clusterID of the cluster to unmanage",
         )
 
-    def unmanage_cloud_args(self, cloudList):
+    def unmanage_cloud_args(self):
         """unmanage cloud args and flags"""
         self.subparserUnmanageCloud.add_argument(
             "cloudID",
-            choices=(None if self.plaidMode else cloudList),
+            choices=(None if self.plaidMode else self.acl.clouds),
             help="cloudID of the cloud to unmanage",
         )
 
-    def update_bucket_args(self, bucketList, credentialList):
+    def update_bucket_args(self):
         """update bucket args and flags"""
         self.subparserUpdateBucket.add_argument(
             "bucketID",
-            choices=(None if self.plaidMode else bucketList),
+            choices=(None if self.plaidMode else self.acl.buckets),
             help="bucketID to update",
         )
         credGroup = self.subparserUpdateBucket.add_argument_group(
             "credentialGroup",
             "Either an (existing credentialID) OR (accessKey AND accessSecret)",
         )
         credGroup.add_argument(
             "-c",
             "--credentialID",
-            choices=(None if self.plaidMode else credentialList),
+            choices=(None if self.plaidMode else self.acl.credentials),
             help="The ID of the credentials used to access the bucket",
             default=None,
         )
         credGroup.add_argument(
             "--accessKey",
             help="The access key of the bucket",
             default=None,
         )
         credGroup.add_argument(
             "--accessSecret",
             help="The access secret of the bucket",
             default=None,
         )
 
-    def update_cloud_args(self, cloudList, bucketList, credentialList):
+    def update_cloud_args(self):
         """update cloud args and flags"""
         self.subparserUpdateCloud.add_argument(
             "cloudID",
-            choices=(None if self.plaidMode else cloudList),
+            choices=(None if self.plaidMode else self.acl.clouds),
             help="cloudID to update",
         )
         credGroup = self.subparserUpdateCloud.add_mutually_exclusive_group()
         credGroup.add_argument(
             "-c",
             "--credentialID",
             default=None,
-            choices=(None if self.plaidMode else credentialList),
+            choices=(None if self.plaidMode else self.acl.credentials),
             help="The existing ID of the credentials used to access the cloud",
         )
         credGroup.add_argument(
             "-p",
             "--credentialPath",
             default=None,
             help="the local filesystem path to the new cloud credential",
         )
         self.subparserUpdateCloud.add_argument(
             "-b",
             "--defaultBucketID",
-            choices=(None if self.plaidMode else bucketList),
+            choices=(None if self.plaidMode else self.acl.buckets),
             default=None,
             help="the new default bucketID for backups",
         )
 
-    def update_cluster_args(self, clusterList):
+    def update_cluster_args(self):
         """update cluster args and flags"""
         self.subparserUpdateCluster.add_argument(
             "clusterID",
-            choices=(None if self.plaidMode else clusterList),
+            choices=(None if self.plaidMode else self.acl.clusters),
             help="clusterID to update",
         )
         self.subparserUpdateCluster.add_argument(
             "-p",
             "--credentialPath",
             default=None,
             required=True,  # Delete / set to False once additional updateCluster args are added
             help="the local filesystem path to the new cluster credential",
         )
 
-    def update_replication_args(self, replicationList):
+    def update_replication_args(self):
         """update replication args and flags"""
         self.subparserUpdateReplication.add_argument(
             "replicationID",
-            choices=(None if self.plaidMode else replicationList),
+            choices=(None if self.plaidMode else self.acl.replications),
             help="replicationID to update",
         )
         self.subparserUpdateReplication.add_argument(
             "operation",
             choices=["failover", "reverse", "resync"],
             help="whether to failover, reverse, or resync the replication policy",
         )
         self.subparserUpdateReplication.add_argument(
             "--dataSource",
             "-s",
             default=None,
             help="resync operation: the new source replication data (either appID or clusterID)",
         )
 
-    def update_script_args(self, scriptList):
+    def update_script_args(self):
         """update script args and flags"""
         self.subparserUpdateScript.add_argument(
             "scriptID",
-            choices=(None if self.plaidMode else scriptList),
+            choices=(None if self.plaidMode else self.acl.scripts),
             help="scriptID to update",
         )
         self.subparserUpdateScript.add_argument(
             "filePath",
             help="the local filesystem path to the updated script",
         )
 
-    def main(
-        self,
-        appList,
-        backupList,
-        bucketList,
-        chartsList,
-        cloudList,
-        clusterList,
-        credentialList,
-        destclusterList,
-        hookList,
-        labelList,
-        namespaceList,
-        protectionList,
-        replicationList,
-        scriptList,
-        snapshotList,
-        storageClassList,
-        userList,
-    ):
+    def main(self):
         # Create the top-level commands like: deploy, clone, list, manage, etc.
         self.top_level_commands()
 
         # *Some* top-level commands have sub-commands like: list apps vs list buckets
         self.sub_commands()
 
         # Of those top-level commands with sub-commands, create those sub-command parsers
@@ -1431,21 +1413,21 @@
         self.sub_create_commands()
         self.sub_manage_commands()
         self.sub_destroy_commands()
         self.sub_unmanage_commands()
         self.sub_update_commands()
 
         # Create arguments for all commands
-        self.deploy_args(chartsList)
-        self.clone_args(appList, backupList, destclusterList, snapshotList)
-        self.restore_args(appList, backupList, snapshotList)
+        self.deploy_args()
+        self.clone_args()
+        self.restore_args()
 
         self.list_apiresources_args()
         self.list_apps_args()
-        self.list_assets_args(appList)
+        self.list_assets_args()
         self.list_backups_args()
         self.list_buckets_args()
         self.list_clouds_args()
         self.list_clusters_args()
         self.list_credentials_args()
         self.list_hooks_args()
         self.list_namespaces_args()
@@ -1454,42 +1436,42 @@
         self.list_replications_args()
         self.list_rolebindings_args()
         self.list_scripts_args()
         self.list_snapshots_args()
         self.list_storageclasses_args()
         self.list_users_args()
 
-        self.create_backup_args(appList, bucketList, snapshotList)
-        self.create_cluster_args(cloudList)
-        self.create_hook_args(appList, scriptList)
-        self.create_protection_args(appList)
-        self.create_replication_args(appList, destclusterList, storageClassList)
+        self.create_backup_args()
+        self.create_cluster_args()
+        self.create_hook_args()
+        self.create_protection_args()
+        self.create_replication_args()
         self.create_script_args()
-        self.create_snapshot_args(appList)
-        self.create_user_args(labelList, namespaceList)
+        self.create_snapshot_args()
+        self.create_user_args()
 
-        self.manage_app_args(clusterList, namespaceList)
-        self.manage_bucket_args(credentialList)
-        self.manage_cluster_args(clusterList, storageClassList)
-        self.manage_cloud_args(bucketList)
-
-        self.destroy_backup_args(appList, backupList)
-        self.destroy_credential_args(credentialList)
-        self.destroy_hook_args(appList, hookList)
-        self.destroy_protection_args(appList, protectionList)
-        self.destroy_replication_args(replicationList)
-        self.destroy_script_args(scriptList)
-        self.destroy_snapshot_args(appList, snapshotList)
-        self.destroy_user_args(userList)
-
-        self.unmanage_app_args(appList)
-        self.unmanage_bucket_args(bucketList)
-        self.unmanage_cluster_args(clusterList)
-        self.unmanage_cloud_args(cloudList)
-
-        self.update_bucket_args(bucketList, credentialList)
-        self.update_cloud_args(cloudList, bucketList, credentialList)
-        self.update_replication_args(replicationList)
-        self.update_script_args(scriptList)
-        self.update_cluster_args(clusterList)
+        self.manage_app_args()
+        self.manage_bucket_args()
+        self.manage_cluster_args()
+        self.manage_cloud_args()
+
+        self.destroy_backup_args()
+        self.destroy_credential_args()
+        self.destroy_hook_args()
+        self.destroy_protection_args()
+        self.destroy_replication_args()
+        self.destroy_script_args()
+        self.destroy_snapshot_args()
+        self.destroy_user_args()
+
+        self.unmanage_app_args()
+        self.unmanage_bucket_args()
+        self.unmanage_cluster_args()
+        self.unmanage_cloud_args()
+
+        self.update_bucket_args()
+        self.update_cloud_args()
+        self.update_replication_args()
+        self.update_script_args()
+        self.update_cluster_args()
 
         return self.parser
```

## Comparing `actoolkit-2.6.3.dist-info/LICENSE` & `actoolkit-2.6.4.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `actoolkit-2.6.3.dist-info/METADATA` & `actoolkit-2.6.4.dist-info/METADATA`

 * *Files 6% similar despite different names*

```diff
@@ -1,30 +1,30 @@
 Metadata-Version: 2.1
 Name: actoolkit
-Version: 2.6.3
+Version: 2.6.4
 Summary: Toolkit and SDK for interacting with Astra Control
 Home-page: https://github.com/NetApp/netapp-astra-toolkits
 Author: Michael Haigh
 Author-email: Michael.Haigh@netapp.com
 Classifier: Programming Language :: Python :: 3
 Classifier: License :: OSI Approved :: Apache Software License
 Classifier: Operating System :: OS Independent
 Requires-Python: >=3.8
 Description-Content-Type: text/markdown
 License-File: LICENSE
-Requires-Dist: certifi (==2022.12.7)
-Requires-Dist: chardet (>=5.0.0)
-Requires-Dist: idna (==3.4)
-Requires-Dist: PyYAML (==6.0)
-Requires-Dist: requests (==2.28.2)
-Requires-Dist: tabulate (==0.9.0)
+Requires-Dist: certifi (<=2023.5.7,>=2022.12.7)
+Requires-Dist: chardet (<=5.1.0,>=4.0.0)
+Requires-Dist: idna (<=3.4,>=2.10)
+Requires-Dist: PyYAML (<=6.0,>=5.4.1)
+Requires-Dist: requests (<=2.30.0,>=2.25.1)
+Requires-Dist: tabulate (<=0.9.0,>=0.8.9)
 Requires-Dist: termcolor (==2.3.0)
-Requires-Dist: urllib3 (==1.26.15)
+Requires-Dist: urllib3 (<=2.0.2,>=1.26.8)
 Requires-Dist: func-timeout (==4.3.5)
-Requires-Dist: kubernetes (==25.3.0)
+Requires-Dist: kubernetes (<=25.3.0,>=24.2.0)
 
 # NetApp Astra Control Python SDK
 
 The NetApp Astra Control Python SDK is designed to provide guidance for working with the NetApp Astra Control API.
 
 You can use the `astraSDK/` library out of the box, and as a set of example recommended code and processes, "cookbook" style. The `toolkit.py` script provides a command line interface to interact with Astra Control with built-in guardrails, and since it utilizes `astraSDK/` it can provide additional context around the requirements of the astraSDK classes.
 
@@ -65,15 +65,15 @@
 * Azure CLI (`az`) 2.25.0+ or Google Cloud SDK (`gcloud`) 345.0.0+ or AWS CLI (`aws`) 1.22.0+
 * Helm 3.2.1+
 
 ### Authentication
 
 No matter the method of installation, the SDK authenticates by reading in the `config.yaml` file from the following locations (in order):
 
-1. The directory that the executed function is located in
+1. The current working directory that the executed function is located in
 1. `~/.config/astra-toolkits/`
 1. `/etc/astra-toolkits/`
 1. The directory pointed to by the shell env var `ASTRATOOLKITS_CONF`
 
 Again, no matter the method of installation, the `config.yaml` file should have the following syntax:
 
 ```text
```

## Comparing `actoolkit-2.6.3.dist-info/RECORD` & `actoolkit-2.6.4.dist-info/RECORD`

 * *Files 13% similar despite different names*

```diff
@@ -1,30 +1,33 @@
-tkHelpers.py,sha256=i5f5bp3i4C4WPfRa8btfhP5x_In_YI3TNDae1I4_0rc,18774
-tkParser.py,sha256=3i-stjIF5wFSsZ4uuia5kWV-Q_8uDvHYPWLHlnzrprw,53562
-toolkit.py,sha256=kE8G3Qyw_gR41gANi9fTmdEs66zd0h5jzExN0xhppC8,91450
+toolkit.py,sha256=sDcLbXGdmpR_koWIo-zE1nCixmKkkgP3b-UCG499Qoo,19527
 astraSDK/__init__.py,sha256=yqW_2eujDPNcBYVkxfLo8Iyuz1tirB3-YvXJjXe7l8w,456
 astraSDK/apiresources.py,sha256=39Ri1uIQ8ZjQ55MNj8X1cyi6hwjv6Z1X1zbZMbvjFaw,3659
 astraSDK/apps.py,sha256=SsFvX2A1G9dhTRHj0sfY9qYfzKQbIcGVN5VxlmznqOI,16835
 astraSDK/backups.py,sha256=D7_8qWuVNgyvY0ujtjg84auwdhAaLwFn0H5D-LFscAc,8248
 astraSDK/buckets.py,sha256=-jb3PJxe1qNqVtyHquoYZODp0NfLCPdAgiKUHAM9fF8,7321
 astraSDK/clouds.py,sha256=d6J7Mae1GahU-Va6Kp9ltpC1RrAzVbAF93m6oOhx8Es,6972
 astraSDK/clusters.py,sha256=kYifg_AC8a3wPAQIFbspoVVH34q2rEYqHNqN0s_D9aY,9155
-astraSDK/common.py,sha256=b_QTt4aZ2WzdEF9U4AW17jQCgtOZmSRV1VIdkYOiXB8,8157
+astraSDK/common.py,sha256=aoQ0bljzzEjpQ1QI4FyQSRFMaCXHQb8gwOvbPE503w8,8083
 astraSDK/credentials.py,sha256=nC887tj5teE6aHSziAhoVDIhtRMYRB798rzSfOEPiUk,9115
 astraSDK/entitlements.py,sha256=ls-TXHRIMftLt9JqhI161lOzmhIlFjL3Ipdgc2uyJVk,2663
 astraSDK/hooks.py,sha256=WF2q1aUe39lpXsThA8d71TGUQqTI8Sbj7RHVkie-t8w,7162
-astraSDK/namespaces.py,sha256=nke3QvPp7B8agSb5P-4256Tz1pTSJaA8h_bUBacGo-A,5398
+astraSDK/namespaces.py,sha256=SJxnwBJm_v-2YQEG0D1cyLd_jIuxRjLzmSVbEMyI7I0,5458
 astraSDK/notifications.py,sha256=k_UXBe_xvhc3VQAxEDRWEnC8iW4HzMHuIoD3hcp_duE,3511
 astraSDK/protections.py,sha256=powIWheo7J_ZDfxmzvYDCyrwso-RGtMDkchdUHiJsf4,8803
 astraSDK/replications.py,sha256=ozM2ORF1TPatyt4OyrULlqHj36tcGRlNXbypM8KqrpE,9735
 astraSDK/rolebindings.py,sha256=f6-mBO20EZKERSeKeL__ihBGan9sGIEHgTeVTmU80CQ,5758
 astraSDK/scripts.py,sha256=A-Rlx9dpVPnNnP4B4b_rGehRqHgKiNGAUb3ru25HrE0,7091
 astraSDK/snapshots.py,sha256=QQFOq7aMJ_ksxRUKwIvG4DKldmLiH7-7o05gqmaslGo,7035
 astraSDK/storagebackends.py,sha256=IUB1oRiyxojsmzCK0yR4xIwn3PKe_TBY4Jpszc34yyk,2342
 astraSDK/storageclasses.py,sha256=_1ikG_7QuPlKFFaV-aBBBxCXGQSogfnPhu1uLWUQ5zg,4726
 astraSDK/users.py,sha256=L-ODrGo6vpoOl3yxqzFjU9-gWqvDQhlFCvvGtoYN2YQ,4877
-actoolkit-2.6.3.dist-info/LICENSE,sha256=xx0jnfkXJvxRnG63LTGOxlggYnIysveWIZ6H3PNdCrQ,11357
-actoolkit-2.6.3.dist-info/METADATA,sha256=X3fV23V1_i9lTz_OJCMKx3M_FzBj-XgkYsVChrM-gtk,9308
-actoolkit-2.6.3.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-actoolkit-2.6.3.dist-info/entry_points.txt,sha256=MdrJm8ktNHa01CEY7q5irB9JDPT_qg6hVpZWUhbKXWU,43
-actoolkit-2.6.3.dist-info/top_level.txt,sha256=PpVEybbyCtNFIaMaOAnKgSrnxUboZ1YyDH3uslFFLUw,36
-actoolkit-2.6.3.dist-info/RECORD,,
+tkSrc/__init__.py,sha256=bezRT2qV1Hn3KtsuOW_eaEgPqdjE5ejneg1QA0dXPpk,87
+tkSrc/callers.py,sha256=EZB6T0FcX4AyJSMk0eb0oXuPzM_omlHm8AKXThO_yu4,67308
+tkSrc/classes.py,sha256=IoNa_B3rXEdCsGgDNztB97f3bXto629_0UC8RNEqkLk,2634
+tkSrc/helpers.py,sha256=DWWOttPAAZvf12zRGEzaYTTqbsV0AN5YNwSW6mVvX7s,18774
+tkSrc/parser.py,sha256=4SAl3D9zFSOUuOYGLh5X0D94omlBGmY9ObpaOjJjGCc,52332
+actoolkit-2.6.4.dist-info/LICENSE,sha256=xx0jnfkXJvxRnG63LTGOxlggYnIysveWIZ6H3PNdCrQ,11357
+actoolkit-2.6.4.dist-info/METADATA,sha256=4lQJSFGSRrpfEl_H8nLFP2-0-IgbwrhW7Df8M2RK79Q,9391
+actoolkit-2.6.4.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+actoolkit-2.6.4.dist-info/entry_points.txt,sha256=MdrJm8ktNHa01CEY7q5irB9JDPT_qg6hVpZWUhbKXWU,43
+actoolkit-2.6.4.dist-info/top_level.txt,sha256=kPzq0QmkpIhsU3ebVM66KWObD9yaaTEifDR30CUh3nU,42
+actoolkit-2.6.4.dist-info/RECORD,,
```

