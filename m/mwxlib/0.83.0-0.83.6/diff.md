# Comparing `tmp/mwxlib-0.83.0-py3-none-any.whl.zip` & `tmp/mwxlib-0.83.6-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,24 +1,24 @@
-Zip file size: 161699 bytes, number of entries: 22
+Zip file size: 161726 bytes, number of entries: 22
 -rw-rw-rw-  2.0 fat     2520 b- defN 23-May-02 16:40 mwx/__init__.py
 -rw-rw-rw-  2.0 fat    43445 b- defN 23-May-02 17:15 mwx/controls.py
--rw-rw-rw-  2.0 fat    73547 b- defN 23-May-13 15:56 mwx/framework.py
--rw-rw-rw-  2.0 fat    69631 b- defN 23-May-12 06:31 mwx/graphman.py
+-rw-rw-rw-  2.0 fat    73366 b- defN 23-May-22 02:21 mwx/framework.py
+-rw-rw-rw-  2.0 fat    69534 b- defN 23-May-17 15:10 mwx/graphman.py
 -rw-rw-rw-  2.0 fat    46248 b- defN 23-Feb-21 08:49 mwx/images.py
--rw-rw-rw-  2.0 fat    36004 b- defN 23-Apr-27 09:45 mwx/matplot2.py
--rw-rw-rw-  2.0 fat    67652 b- defN 23-May-13 15:57 mwx/matplot2g.py
+-rw-rw-rw-  2.0 fat    36017 b- defN 23-May-17 04:56 mwx/matplot2.py
+-rw-rw-rw-  2.0 fat    68253 b- defN 23-May-17 11:19 mwx/matplot2g.py
 -rw-rw-rw-  2.0 fat    27606 b- defN 23-Apr-27 09:45 mwx/matplot2lg.py
 -rw-rw-rw-  2.0 fat     6878 b- defN 23-Feb-21 08:50 mwx/mgplt.py
--rw-rw-rw-  2.0 fat   138196 b- defN 23-May-12 06:24 mwx/nutshell.py
--rw-rw-rw-  2.0 fat    36924 b- defN 23-May-07 16:44 mwx/utilus.py
--rw-rw-rw-  2.0 fat    11335 b- defN 23-May-02 13:35 mwx/wxmon.py
--rw-rw-rw-  2.0 fat    19359 b- defN 23-May-13 15:56 mwx/wxpdb.py
--rw-rw-rw-  2.0 fat     5246 b- defN 23-Mar-25 12:54 mwx/wxwil.py
--rw-rw-rw-  2.0 fat     7416 b- defN 23-May-12 15:08 mwx/wxwit.py
+-rw-rw-rw-  2.0 fat   137383 b- defN 23-May-23 08:19 mwx/nutshell.py
+-rw-rw-rw-  2.0 fat    37504 b- defN 23-May-23 07:00 mwx/utilus.py
+-rw-rw-rw-  2.0 fat    11343 b- defN 23-May-16 07:42 mwx/wxmon.py
+-rw-rw-rw-  2.0 fat    19367 b- defN 23-May-16 07:42 mwx/wxpdb.py
+-rw-rw-rw-  2.0 fat     5254 b- defN 23-May-16 07:42 mwx/wxwil.py
+-rw-rw-rw-  2.0 fat     7424 b- defN 23-May-16 07:42 mwx/wxwit.py
 -rw-rw-rw-  2.0 fat        0 b- defN 23-Jan-23 14:06 mwx/py/__init__.py
 -rw-rw-rw-  2.0 fat    16794 b- defN 23-Apr-27 09:45 mwx/py/filling.py
--rw-rw-rw-  2.0 fat     1091 b- defN 23-May-13 15:57 mwxlib-0.83.0.dist-info/LICENSE
--rw-rw-rw-  2.0 fat     1893 b- defN 23-May-13 15:57 mwxlib-0.83.0.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 23-May-13 15:57 mwxlib-0.83.0.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        4 b- defN 23-May-13 15:57 mwxlib-0.83.0.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     1609 b- defN 23-May-13 15:57 mwxlib-0.83.0.dist-info/RECORD
-22 files, 613490 bytes uncompressed, 159197 bytes compressed:  74.1%
+-rw-rw-rw-  2.0 fat     1091 b- defN 23-May-23 08:20 mwxlib-0.83.6.dist-info/LICENSE
+-rw-rw-rw-  2.0 fat     1893 b- defN 23-May-23 08:20 mwxlib-0.83.6.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 23-May-23 08:20 mwxlib-0.83.6.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat        4 b- defN 23-May-23 08:20 mwxlib-0.83.6.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     1609 b- defN 23-May-23 08:20 mwxlib-0.83.6.dist-info/RECORD
+22 files, 613625 bytes uncompressed, 159224 bytes compressed:  74.1%
```

## zipnote {}

```diff
@@ -45,23 +45,23 @@
 
 Filename: mwx/py/__init__.py
 Comment: 
 
 Filename: mwx/py/filling.py
 Comment: 
 
-Filename: mwxlib-0.83.0.dist-info/LICENSE
+Filename: mwxlib-0.83.6.dist-info/LICENSE
 Comment: 
 
-Filename: mwxlib-0.83.0.dist-info/METADATA
+Filename: mwxlib-0.83.6.dist-info/METADATA
 Comment: 
 
-Filename: mwxlib-0.83.0.dist-info/WHEEL
+Filename: mwxlib-0.83.6.dist-info/WHEEL
 Comment: 
 
-Filename: mwxlib-0.83.0.dist-info/top_level.txt
+Filename: mwxlib-0.83.6.dist-info/top_level.txt
 Comment: 
 
-Filename: mwxlib-0.83.0.dist-info/RECORD
+Filename: mwxlib-0.83.6.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## mwx/framework.py

```diff
@@ -1,14 +1,14 @@
 #! python3
 # -*- coding: utf-8 -*-
 """mwxlib framework
 
 Author: Kazuya O'moto <komoto@jeol.co.jp>
 """
-__version__ = "0.83.0"
+__version__ = "0.83.6"
 __author__ = "Kazuya O'moto <komoto@jeol.co.jp>"
 
 from functools import wraps, partial
 from importlib import reload
 import traceback
 import builtins
 import datetime
@@ -303,19 +303,14 @@
         self.Bind(wx.EVT_MOUSE_AUX1_UP, lambda v: _M('Xbutton1 released', v))
         self.Bind(wx.EVT_MOUSE_AUX2_UP, lambda v: _M('Xbutton2 released', v))
         self.Bind(wx.EVT_MOUSE_AUX1_DOWN, lambda v: _M('Xbutton1 pressed', v))
         self.Bind(wx.EVT_MOUSE_AUX2_DOWN, lambda v: _M('Xbutton2 pressed', v))
         self.Bind(wx.EVT_MOUSE_AUX1_DCLICK, lambda v: _M('Xbutton1 dblclick', v))
         self.Bind(wx.EVT_MOUSE_AUX2_DCLICK, lambda v: _M('Xbutton2 dblclick', v))
     
-    ## Note: Return value of handler.call and skip processing.
-    ##     None => Call v.Skip() if there is no handler.
-    ##     [..] => Don't call v.Skip() if there is a context w or w/o action.
-    ##             Call v.Skip() yourself if needed.
-    
     def on_hotkey_press(self, evt): #<wx._core.KeyEvent>
         """Called when key down."""
         if evt.EventObject is not self:
             evt.Skip()
             return
         key = hotkey(evt)
         self.__key = regulate_key(key + '+')
@@ -1106,17 +1101,17 @@
                                  "- Press [C-g] to quit.")
                 elif not self.debugger.busy:
                     self.message("- The current status is inconsistent. "
                                  "- Press [C-g] to quit.")
                     self.indicator.Value = 7
             v.Skip()
         
-        def fork(v):
+        def dispatch(v):
             """Fork key events to the debugger."""
-            self.debugger.handler(self.handler.event, v)
+            self.debugger.handler(self.handler.current_event, v)
         
         self.handler.update({ # DNA<ShellFrame>
             None : {
                   'debug_begin' : [ None, self.on_debug_begin ],
                    'debug_next' : [ None, self.on_debug_next ],
                     'debug_end' : [ None, self.on_debug_end ],
                   'trace_begin' : [ None, self.on_trace_begin ],
@@ -1127,17 +1122,17 @@
                     'shell_new' : [ None, ],
                       'add_log' : [ None, self.add_log ],
                      'add_help' : [ None, self.add_help ],
                   'add_history' : [ None, self.add_history ],
                  'title_window' : [ None, self.on_title_window ],
             },
             0 : {
-                    '* pressed' : (0, skip, fork), # => debugger
-                   '* released' : (0, skip, fork), # => debugger
-                  'C-g pressed' : (0, self.Quit, skip, fork), # => debugger
+                    '* pressed' : (0, skip, dispatch), # => debugger
+                   '* released' : (0, skip, dispatch), # => debugger
+                  'C-g pressed' : (0, self.Quit, skip, dispatch), # => debugger
                    'f1 pressed' : (0, self.About),
                   'C-f pressed' : (0, self.OnFindText),
                    'f3 pressed' : (0, self.OnFindNext),
                  'S-f3 pressed' : (0, self.OnFindPrev),
                   'f11 pressed' : (0, _F(self.toggle_window, self.ghost, doc="Toggle ghost")),
                 'S-f11 pressed' : (0, _F(self.toggle_window, self.watcher, doc="Toggle watcher")),
                   'f12 pressed' : (0, _F(self.Close, alias="close", doc="Close the window")),
@@ -1240,15 +1235,18 @@
                 ## "self._mgr.GetPane('watcher').FloatingPosition(self.Position)",
                 "self._mgr.Update()\n",
             )))
     
     def _load_file(self, bookname, filename, lineno):
         try:
             book = getattr(self, bookname)
-            book.load_file(filename, lineno)
+            if re.match(r"https?://[\w/:%#\$&\?()~.=+-]+", filename):
+                book.load_url(filename, lineno)
+            else:
+                book.load_file(filename, lineno)
         except Exception:
             pass
     
     def Init(self):
         msg = "#! Opened: <{}>\r\n".format(datetime.datetime.now())
         self.add_history(msg)
         self.add_log(msg)
@@ -1411,26 +1409,23 @@
                     nb.Selection = j # the focus is moved
                 break
         else:
             return
         if show is None:
             show = not pane.IsShown() # toggle show
         
-        ## Modify aui pane floating position when it is shown,
-        ## Note: This is a known bug in wxWidgets 3.17--3.20,
-        ##       and will be fixed in wxPython 4.2.1.
-        if show:
-            w, h = wx.DisplaySize()
-            x, y = pane.floating_pos
-            if x > 2*w or y > h:
-                pane.floating_pos = wx.GetMousePosition()
-        
         if wnd and win.IsShown(): # restore focus
             wnd.SetFocus()
         
+        ## Modify the floating position of the pane when displayed.
+        ## Note: This is a known bug in wxWidgets 3.17 -- 3.20,
+        ##       and will be fixed in wxPython 4.2.1.
+        if wx.Display.GetFromWindow(pane.window) == -1:
+            pane.floating_pos = wx.GetMousePosition()
+        
         nb.Show(show)
         pane.Show(show)
         self._mgr.Update()
     
     ## --------------------------------
     ## Actions for handler
     ## --------------------------------
@@ -1489,15 +1484,15 @@
         self.inspector.highlight(obj, *args, **kwargs)
     
     ## Note: history 変数に余計な文字列が入らないようにする
     @postcall
     def debug(self, obj, *args, **kwargs):
         if isinstance(obj, wx.Object) or obj is None:
             if args or kwargs:
-                self.message("- args:{} and kwargs:{} were given,"
+                self.message("- Args:{} and kwargs:{} were given,"
                              " but ignored for object monitoring.")
             self.monitor.watch(obj)
             if obj:
                 self.popup_window(self.monitor, focus=0)
                 self.linfo.watch(obj.__dict__)
                 self.ginfo.watch({})
         elif isinstance(obj, type(print)):
@@ -1513,16 +1508,15 @@
                 self.debugger.interactive_shell = shell
         elif isinstance(obj, str):
             try:
                 shell = self.debugger.interactive_shell
                 self.debugger.interactive_shell = self.current_shell
                 self.debugger.editor = self.Log # set default logger
                 filename = "<string>"
-                buf = self.Log.find_buffer(filename)\
-                  or self.Log.create_buffer(filename)
+                buf = self.Log.find_buffer(filename) or self.Log.create_buffer(filename)
                 with buf.off_readonly():
                     buf.Text = obj
                 self.debugger.run(obj)
             finally:
                 self.debugger.interactive_shell = shell
         elif hasattr(obj, '__dict__'):
             self.message("Building locals info list...")
```

## mwx/graphman.py

```diff
@@ -899,30 +899,28 @@
     
     def _show_pane(self, name, show=True):
         """Show named pane window (internal use only)."""
         pane = self.get_pane(name)
         plug = self.get_plug(name)
         if plug:
             nb = plug.__notebook # given when load_plug
-            if nb:
-                if show:
-                    nb.SetSelection(nb.GetPageIndex(plug))
+            if nb and show:
+                nb.SetSelection(nb.GetPageIndex(plug))
             if show:
-                ## Modify aui pane floating position when it is shown,
-                ## to address a known BUG with wxWidgets 3.17 -- 3.20.
-                if wx.VERSION <= (4,2,0):
-                    w, h = wx.DisplaySize()
-                    x, y = pane.floating_pos
-                    if x > 2*w or y > h:
-                        pane.floating_pos = wx.GetMousePosition()
                 if not pane.IsShown():
                     plug.handler('page_shown', plug)
             else:
                 if pane.IsShown():
                     plug.handler('page_closed', plug)
+        
+        ## Modify the floating position of the pane when displayed.
+        ## Note: This is a known bug in wxWidgets 3.17 -- 3.20,
+        ##       and will be fixed in wxPython 4.2.1.
+        if wx.Display.GetFromWindow(pane.window) == -1:
+            pane.floating_pos = wx.GetMousePosition()
         pane.Show(show)
     
     def update_pane(self, name, show=False, **kwargs):
         """Update the layout of the pane.
         
         Note:
             This is called automatically from load_plug,
```

## mwx/matplot2.py

```diff
@@ -130,15 +130,15 @@
         self.canvas.Bind(wx.EVT_KILL_FOCUS, lambda v: self.handler('focus_kill', v))
         
         ## `Rbutton pressed` on_menu is enabled for Normal mode only.
         ## The context menus is disabled and never skip to the next handler.
         self.canvas.Bind(wx.EVT_CONTEXT_MENU, lambda v: self.handler('context_menu', v))
         
         def fork(v):
-            if self.handler(self.handler.event, v) is None:
+            if self.handler.fork(self.handler.current_event, v) is None:
                 v.Skip()
         
         self.__handler = mwx.FSM({ # DNA<MatplotPanel>
                 None : {
                   'canvas_draw' : [ None, self.OnDraw ], # before canvas.draw
                 #'canvas_drawn' : [ None, ],             # after canvas.draw :deprecated
               #'canvas_resized' : [ None, ],
```

## mwx/matplot2g.py

```diff
@@ -18,14 +18,24 @@
 from PIL import ImageFile
 import cv2
 import numpy as np
 from numpy import pi, nan
 from scipy import ndimage as ndi
 
 
+def imcv(src):
+    """Convert the image to a type that can be applied to the cv2 function.
+    Note:
+        CV2 normally accepts uint8/16 and float32/64.
+    """
+    if src.dtype in (np.uint32, np.int32): src = src.astype(np.float32)
+    if src.dtype in (np.uint64, np.int64): src = src.astype(np.float64)
+    return src
+
+
 def imbuffer(img):
     if isinstance(img, (Image.Image, ImageFile.ImageFile)):
         ## return np.asarray(img) # ref
         return np.array(img) # copy
     
     if isinstance(img, wx.Bitmap):
         img = img.ConvertToImage()
@@ -60,19 +70,16 @@
     if threshold:
         ## Converted to <uint8(=1byte)> finally, binning should be reduced by itemsize.
         n = int(np.sqrt(src.nbytes / threshold / src.itemsize)) + 1
         if bins < n:
             bins = n # binning or threshold; Select the larger one.
     
     if bins > 1:
-        ## cv2.resize accepts uint8, uint16, float32, and float64 only..
-        if src.dtype in (np.uint32, np.int32): src = src.astype(np.float32)
-        if src.dtype in (np.uint64, np.int64): src = src.astype(np.float64)
-        
         ## src = src[::bins,::bins]
+        src = imcv(src)
         src = cv2.resize(src, None, fx=1/bins, fy=1/bins, interpolation=cv2.INTER_AREA)
     
     if src.dtype == np.uint8:
         return bins, (0,255), src
     
     if hasattr(cutoff, '__iter__'):
         a, b = cutoff
@@ -436,14 +443,25 @@
                  'line_removed' : [ None, draw_idle ],
                     'mark_draw' : [ None ],
                    'mark_drawn' : [ None, draw_idle ],
                  'mark_removed' : [ None, draw_idle ],
                   'region_draw' : [ None ],
                  'region_drawn' : [ None, draw_idle ],
                'region_removed' : [ None, draw_idle ],
+                 'M-up pressed' : [ None, self.OnPageUp ],
+               'M-down pressed' : [ None, self.OnPageDown ],
+               'pageup pressed' : [ None, self.OnPageUp ],
+             'pagedown pressed' : [ None, self.OnPageDown ],
+                  'M-a pressed' : [ None, _F(self.fit_to_canvas) ],
+                  'C-a pressed' : [ None, _F(self.update_axis) ],
+                  'C-i pressed' : [ None, _F(self.invert_cmap) ],
+                  'C-k pressed' : [ None, _F(self.kill_buffer) ],
+                'C-S-k pressed' : [ None, _F(self.kill_buffer_all) ],
+                  'C-c pressed' : [ None, _F(self.write_buffer_to_clipboard) ],
+                  'C-v pressed' : [ None, _F(self.read_buffer_from_clipboard) ],
             },
             NORMAL : {
                  'image_picked' : (NORMAL, self.OnImagePicked),
                   'line_picked' : (LINE, self.OnLineSelected),
                   'mark_picked' : (MARK, self.OnMarkSelected),
                 'region_picked' : (REGION, self.OnRegionSelected),
                     'c pressed' : (MARK, self.OnMarkAppend),
@@ -453,27 +471,14 @@
             'M-Lbutton pressed' : (REGION, self.OnRegionAppend, self.OnEscapeSelection),
                'escape pressed' : (NORMAL, self.OnEscapeSelection, draw_idle),
                 'shift pressed' : (NORMAL, self.on_picker_lock),
                'shift released' : (NORMAL, self.on_picker_unlock),
               'Lbutton pressed' : (NORMAL, self.OnDragLock),
             'S-Lbutton pressed' : (NORMAL, self.OnDragLock, self.OnSelectorAppend),
                  '*Ldrag begin' : (NORMAL+DRAGGING, self.OnDragBegin),
-                 'M-up pressed' : (NORMAL, self.OnPageUp),
-               'M-down pressed' : (NORMAL, self.OnPageDown),
-               'pageup pressed' : (NORMAL, self.OnPageUp),
-             'pagedown pressed' : (NORMAL, self.OnPageDown),
-                 'home pressed' : (NORMAL, _F(self.select, j=0)),
-                  'end pressed' : (NORMAL, _F(self.select, j=-1)),
-                  'M-a pressed' : (NORMAL, _F(self.fit_to_canvas)),
-                  'C-a pressed' : (NORMAL, _F(self.update_axis)),
-                  'C-c pressed' : (NORMAL, _F(self.write_buffer_to_clipboard)),
-                  'C-v pressed' : (NORMAL, _F(self.read_buffer_from_clipboard)),
-                  'C-k pressed' : (NORMAL, _F(self.kill_buffer)),
-                'C-S-k pressed' : (NORMAL, _F(self.kill_buffer_all)),
-                  'C-i pressed' : (NORMAL, _F(self.invert_cmap)),
             },
             NORMAL+DRAGGING : {
                          'quit' : (NORMAL, ),
                     'r pressed' : (REGION+DRAGGING, self.OnRegionAppend, self.OnRegionDragBegin, self.OnEscapeSelection),
                   'alt pressed' : (REGION+DRAGGING, self.OnRegionAppend, self.OnRegionDragBegin, self.OnEscapeSelection),
                'escape pressed' : (NORMAL+DRAGGING, self.OnDragEscape),
                  'S-Ldrag move' : (NORMAL+DRAGGING, self.OnDragShiftMove),
@@ -1033,34 +1038,47 @@
             else:
                 self.message("Read image from clipboard")
                 self.load(Clipboard.imread())
         except Exception as e:
             self.message("- No data in clipboard: {}".format(e))
             traceback.print_exc()
     
+    def destroy_colorbar(self):
+        if self.cbar:
+            self.cbar = None
+            cax = self.figure.axes[1]
+            self.figure.delaxes(cax)
+            self.canvas.draw_idle()
+            self.handler.unbind('frame_cmapped', self.update_colorbar)
+            self.handler.unbind('frame_shown', self.update_colorbar)
+    
+    def update_colorbar(self, frame):
+        if self.cbar:
+            self.cbar.update_normal(frame)
+            self.canvas.draw_idle()
+            self.figure.draw_without_rendering()
+    
     def create_colorbar(self):
         """Make a colorbar.
         The colorbar is plotted in self.figure.axes[1] (second axes)
         """
         from mpl_toolkits.axes_grid1 import make_axes_locatable
         if self.frame:
             divider = make_axes_locatable(self.axes)
             cax = divider.append_axes('right', size=0.1, pad=0.1)
-            cbar = self.figure.colorbar(self.frame, cax=cax)
-            @self.handler.bind('frame_cmapped')
-            @self.handler.bind('frame_shown')
-            def update_cmap(frame):
-                cbar.update_normal(frame)
-                cbar.draw_all()
-                self.canvas.draw_idle()
-            update_cmap(self.frame)
+            self.cbar = self.figure.colorbar(self.frame, cax=cax)
+            self.update_colorbar(self.frame)
+            self.handler.bind('frame_cmapped', self.update_colorbar)
+            self.handler.bind('frame_shown', self.update_colorbar)
         else:
-            self['*dummy*'] = np.random.rand(2,2) # dummy
-            self.create_colorbar()
-            del self['*dummy*']
+            self.message("- A frame must exist to create a colorbar.")
+            ## self['*dummy*'] = np.random.rand(2,2) # dummy
+            ## self.create_colorbar()
+            ## del self['*dummy*']
+            pass
     
     ## --------------------------------
     ## matplotlib interfaces
     ## --------------------------------
     
     def on_pick(self, evt): #<matplotlib.backend_bases.PickEvent>
         """Pickup image and other arts.
@@ -1570,15 +1588,15 @@
         xm, ym = self.marked.get_data(orig=0)
         return np.array((xm, ym))
     
     @Markers.setter
     def Markers(self, v):
         x, y = v
         if len(x) > self.maxnum_markers:
-            self.message("- got too many markers ({}) to plot".format(len(x)))
+            self.message("- Got too many markers ({}) to plot".format(len(x)))
             return
         self.marked.set_data(x, y)
         self.__marksel = []
         self.update_art_of_mark()
         self.handler('mark_drawn', self.frame)
     
     @Markers.deleter
@@ -1750,15 +1768,16 @@
     def _imread(path):
         return Image.open(path)
     
     frm.graph.load(_imread(u"C:/usr/home/workspace/images/sample.bmp"), "sample")
     frm.graph.load(_imread(u"C:/usr/home/workspace/images/サンプル.bmp"), "サンプル")
     frm.graph.load(_imread(u"C:/usr/home/workspace/images/sample_circ.bmp"), "sample data")
     
-    frm.graph.newbuffer = np.uint8(255 * np.random.randn(512,512,3))
+    ## frm.graph.newbuffer = np.uint8(255 * np.random.randn(512,512,3))
+    frm.graph.newbuffer = np.float32(np.random.randn(512,512))
     frm.graph.frame.unit = 0.5
     frm.graph.create_colorbar()
     
     def _plot(graph, r=10):
         ux = uy = graph.unit
         t = np.arange(0,4,0.01) * pi
         x = r * ux * np.cos(t)
```

## mwx/nutshell.py

```diff
@@ -63,15 +63,15 @@
         This class should be mixed-in `wx.stc.StyledTextCtrl`
     """
     def __init__(self):
         CtrlInterface.__init__(self)
         
         def dispatch(v):
             """Fork mouse events to the parent."""
-            self.parent.handler(self.handler.event, v)
+            self.parent.handler(self.handler.current_event, v)
         
         self.make_keymap('C-x')
         self.make_keymap('C-c')
         
         self.handler.update({ # DNA<EditorInterface>
             None : {
                      'mark_set' : [ None, dispatch ],
@@ -112,15 +112,14 @@
                 'S-tab pressed' : (0, self.on_outdent_line),
                   ## 'C-/ pressed' : (0, ), # cf. C-a home
                   ## 'C-\ pressed' : (0, ), # cf. C-e end
                   'C-; pressed' : (0, _F(self.comment_out_line)),
                 'C-S-; pressed' : (0, _F(self.comment_out_line)),
                   'C-: pressed' : (0, _F(self.uncomment_line)),
                 'C-S-: pressed' : (0, _F(self.uncomment_line)),
-                 'select_itext' : (10, self.filter_text, self.on_itext_enter),
                   'select_line' : (100, self.on_linesel_begin),
             },
             10 : {
                          'quit' : (0, self.on_itext_exit),
                     '* pressed' : (0, self.on_itext_exit),
                    'up pressed' : (10, skip),
                  'down pressed' : (10, skip),
@@ -257,31 +256,28 @@
         self.MarkerDefine(stc.STC_MARKNUM_FOLDERTAIL,    stc.STC_MARK_LCORNER,  *v)
         ## self.MarkerDefine(stc.STC_MARKNUM_FOLDEREND,     stc.STC_MARK_TCORNER, *v)
         ## self.MarkerDefine(stc.STC_MARKNUM_FOLDEROPENMID, stc.STC_MARK_TCORNER, *v)
         self.MarkerDefine(stc.STC_MARKNUM_FOLDEREND,     stc.STC_MARK_VLINE, *v)
         self.MarkerDefine(stc.STC_MARKNUM_FOLDEROPENMID, stc.STC_MARK_VLINE, *v)
         self.MarkerDefine(stc.STC_MARKNUM_FOLDERMIDTAIL, stc.STC_MARK_VLINE, *v)
         
-        ## Custom indicator [0,1] for search-word
+        ## Custom indicator [0,1] for filter_text
+        ## if wx.VERSION >= (4,1,0):
         try:
             self.IndicatorSetStyle(0, stc.STC_INDIC_TEXTFORE)
             self.IndicatorSetStyle(1, stc.STC_INDIC_ROUNDBOX)
         except AttributeError:
             self.IndicatorSetStyle(0, stc.STC_INDIC_PLAIN)
             self.IndicatorSetStyle(1, stc.STC_INDIC_ROUNDBOX)
         
+        self.IndicatorSetUnder(1, True)
+        self.IndicatorSetAlpha(1, 60)
+        self.IndicatorSetOutlineAlpha(1, 120)
         self.IndicatorSetForeground(0, "red")
         self.IndicatorSetForeground(1, "yellow")
-        try:
-            self.IndicatorSetHoverStyle(1, stc.STC_INDIC_ROUNDBOX)
-            self.IndicatorSetHoverForeground(1, "blue")
-        except AttributeError:
-            pass
-        
-        self.Bind(stc.EVT_STC_INDICATOR_CLICK, self.OnIndicatorClick)
         
         ## Custom indicator [2] for match_paren
         self.IndicatorSetStyle(2, stc.STC_INDIC_DOTS)
         self.IndicatorSetForeground(2, "light gray")
         
         ## Custom annotation
         self.AnnotationSetVisible(stc.STC_ANNOTATION_BOXED)
@@ -863,30 +859,30 @@
                 pass
         
         ## Apply the rest of the style
         for key, value in spec.items():
             self.StyleSetSpec(key, value)
     
     def match_paren(self):
-        self.SetIndicatorCurrent(2)
-        self.IndicatorClearRange(0, self.TextLength)
+        ## self.SetIndicatorCurrent(2)
+        ## self.IndicatorClearRange(0, self.TextLength)
         p = self.cpos
         if self.get_char(p-1) in ")}]>":
             q = self.BraceMatch(p-1)
             if q != -1:
                 self.BraceHighlight(q, p-1) # matched the preceding char
-                self.IndicatorFillRange(q, p-q)
+                ## self.IndicatorFillRange(q, p-q)
                 return q
             else:
                 self.BraceBadLight(p-1)
         elif self.get_char(p) in "({[<":
             q = self.BraceMatch(p)
             if q != -1:
                 self.BraceHighlight(p, q) # matched the following char
-                self.IndicatorFillRange(p, q-p+1)
+                ## self.IndicatorFillRange(p, q-p+1)
                 return q
             else:
                 self.BraceBadLight(p)
         else:
             self.BraceHighlight(-1,-1) # no highlight
     
     def over(self, mode=1):
@@ -1107,23 +1103,14 @@
             return
         line = self.__itextlines[i]
         self.EnsureVisible(line) # expand if folded
         self.goto_line(line)
         self.recenter()
         self.on_itext_exit(evt)
     
-    def OnIndicatorClick(self, evt):
-        ## i = self.IndicatorValue #? -> 1 常に１が返される▲ BUG of wx.stc ?
-        pos = evt.Position
-        if self.IndicatorValueAt(0, pos): # check indicator [0]
-            p = self.IndicatorStart(0, pos)
-            q = self.IndicatorEnd(0, pos)
-            self.goto_char(pos)
-            self.handler('select_itext', self.GetTextRange(p, q))
-    
     ## --------------------------------
     ## goto / skip / selection / etc.
     ## --------------------------------
     
     def goto_char(self, pos, selection=False, interactive=False):
         """Goto char position with selection."""
         if pos is None or pos < 0:
@@ -1381,15 +1368,14 @@
 
 class Buffer(EditWindow, EditorInterface):
     """Python code buffer.
     
     Attributes:
         name     : buffer-name (basename)
         filename : buffer-file-name
-        codename : code-file-name (e.g. '<scratch>')
         code     : code object
     """
     STYLE = {
         stc.STC_STYLE_DEFAULT     : "fore:#7f7f7f,back:#ffffb8,size:9,face:MS Gothic",
         stc.STC_STYLE_LINENUMBER  : "fore:#000000,back:#ffffb8,size:9",
         stc.STC_STYLE_BRACELIGHT  : "fore:#000000,back:#ffffb8,bold",
         stc.STC_STYLE_BRACEBAD    : "fore:#000000,back:#ff0000,bold",
@@ -1436,15 +1422,15 @@
             self.__mtime = None
         try:
             renamed = (self.filename != f)
         except AttributeError:
             renamed = False
         self.__filename = f
         if renamed:
-            self.parent.handler('buffer_filename_set', self)
+            self.parent.handler('buffer_filename_reset', self)
     
     @property
     def mtdelta(self):
         """Timestamp delta (for checking external mod).
         
         Returns:
             None : No file
@@ -1455,24 +1441,27 @@
         f = self.filename
         if f and os.path.isfile(f):
             return os.path.getmtime(f) - self.__mtime
         elif f and re.match(r"https?://[\w/:%#\$&\?()~.=+-]+", f):
             return -1
     
     @property
-    def caption_prefix(self):
-        if self.mtdelta is not None:
-            prefix = ''
+    def caption(self):
+        prefix = ''
+        dt = self.mtdelta
+        if dt is not None:
             if self.IsModified():
                 prefix += '*'
-            if self.mtdelta > 0:
+            if dt > 0:
                 prefix += '!'
-            elif self.mtdelta < 0:
+            elif dt < 0:
                 prefix += '%'
-            return prefix + ' ' if prefix else ''
+        if prefix:
+            prefix += ' '
+        return prefix + self.name
     
     @property
     def need_buffer_save(self):
         """Returns whether the buffer should be saved.
         The file has been modified internally.
         """
         return self.mtdelta is not None and self.IsModified()
@@ -1481,30 +1470,29 @@
     def need_buffer_load(self):
         """Returns whether the buffer should be loaded.
         The file has been modified externally.
         """
         return self.mtdelta is not None and self.mtdelta > 0
     
     def pre_command_hook(self, evt):
-        self.parent.handler(self.handler.event, evt)
+        self.parent.handler(self.handler.current_event, evt)
         return EditorInterface.pre_command_hook(self, evt)
     pre_command_hook.__name__ = str('pre_command_dispatch') # alias
     
     def post_command_hook(self, evt):
-        self.parent.handler(self.handler.event, evt)
+        self.parent.handler(self.handler.current_event, evt)
         return EditorInterface.post_command_hook(self, evt)
     post_command_hook.__name__ = str('post_command_dispatch') # alias
     
     def __init__(self, parent, filename=None, **kwargs):
         EditWindow.__init__(self, parent, **kwargs)
         EditorInterface.__init__(self)
         
         self.parent = parent
         self.filename = filename
-        self.codename = ''
         self.code = None
         
         self.Bind(stc.EVT_STC_UPDATEUI, self.OnUpdate) # skip to brace matching
         
         self.Bind(stc.EVT_STC_SAVEPOINTLEFT, self.OnSavePointLeft)
         self.Bind(stc.EVT_STC_SAVEPOINTREACHED, self.OnSavePointReached)
         
@@ -1514,17 +1502,17 @@
         self.Bind(wx.EVT_SET_FOCUS, activate)
         
         def inactivate(v):
             self.handler('buffer_inactivated', self)
             v.Skip()
         self.Bind(wx.EVT_KILL_FOCUS, inactivate)
         
-        def dispatch(*v):
+        def dispatch(v):
             """Fork mouse events to the parent."""
-            self.parent.handler(self.handler.event, *v)
+            self.parent.handler(self.handler.current_event, v)
         
         self.handler.update({ # DNA<Buffer>
             None : {
                   'stc_updated' : [ None, ],
                  'buffer_saved' : [ None, self.on_activated, dispatch ],
                 'buffer_loaded' : [ None, self.on_activated, dispatch ],
              'buffer_activated' : [ None, self.on_activated, dispatch ],
@@ -1560,30 +1548,27 @@
     def OnUpdate(self, evt): #<wx._stc.StyledTextEvent>
         if evt.Updated & (stc.STC_UPDATE_SELECTION | stc.STC_UPDATE_CONTENT):
             self.trace_position()
             self.handler('stc_updated', evt)
         evt.Skip()
     
     def OnSavePointLeft(self, evt):
-        prefix = self.caption_prefix
-        if prefix is not None:
-            self.parent.handler('buffer_caption_prefix', self, prefix + self.name)
+        if self.mtdelta is not None:
+            self.parent.handler('buffer_caption_reset', self)
         evt.Skip()
     
     def OnSavePointReached(self, evt):
-        prefix = self.caption_prefix
-        if prefix is not None:
-            self.parent.handler('buffer_caption_prefix', self, prefix + self.name)
+        if self.mtdelta is not None:
+            self.parent.handler('buffer_caption_reset', self)
         evt.Skip()
     
     def on_activated(self, buf):
         """Called when the buffer is activated."""
-        prefix = self.caption_prefix
-        if prefix is not None:
-            self.parent.handler('buffer_caption_prefix', self, prefix + self.name)
+        if self.mtdelta is not None:
+            self.parent.handler('buffer_caption_reset', self)
         self.trace_position()
     
     def on_inactivated(self, buf):
         """Called when the buffer is inactivated."""
         pass
     
     def on_enter_escmap(self, evt):
@@ -1694,15 +1679,14 @@
                 self.EnsureVisible(lx) # expand if folded
                 self.EnsureCaretVisible()
                 self.AnnotationSetStyle(lx, stc.STC_STYLE_ANNOTATION)
                 self.AnnotationSetText(lx, msg)
             self.message("- {!r}".format(e))
             ## print(msg, file=sys.__stderr__)
         else:
-            self.codename = filename
             self.code = code
             del self.pointer # Reset pointer (debugger hook point).
             del self.red_arrow
             self.handler('py_region_executed', self)
             self.message("Evaluated {!r} successfully".format(filename))
             self.AnnotationClearAll()
     
@@ -1759,31 +1743,31 @@
         def destroy(v):
             obj = v.EventObject
             if isinstance(obj, Buffer):
                 self.handler('buffer_removed', obj)
             v.Skip()
         self.Bind(wx.EVT_WINDOW_DESTROY, destroy)
         
-        def dispatch(*v):
+        def dispatch(v):
             """Fork mouse events to the parent."""
-            self.parent.handler(self.handler.event, *v)
+            self.parent.handler(self.handler.current_event, v)
         
         self.make_keymap('C-x')
         self.make_keymap('C-c')
         
         self.handler.update({ # DNA<EditorBook>
             None : {
                    'buffer_new' : [ None, dispatch, ],
                  'buffer_saved' : [ None, dispatch, self.set_caption ],
                 'buffer_loaded' : [ None, dispatch, self.set_caption ],
                'buffer_removed' : [ None, dispatch, ],
              'buffer_activated' : [ None, dispatch, self.on_activated ],
            'buffer_inactivated' : [ None, dispatch, self.on_inactivated ],
-          'buffer_filename_set' : [ None, dispatch, ],
-        'buffer_caption_prefix' : [ None, dispatch, self.set_caption ],
+         'buffer_caption_reset' : [ None, dispatch, self.set_caption ],
+        'buffer_filename_reset' : [ None, dispatch, ],
              '*button* pressed' : [ None, dispatch, skip ],
             '*button* released' : [ None, dispatch, skip ],
             },
             0 : { # Normal mode
                     '* pressed' : (0, skip),
                    '* released' : (0, skip),
                  'M-up pressed' : (0, _F(self.previous_buffer)),
@@ -1813,15 +1797,15 @@
             self.new_buffer()
         evt.Skip()
     
     def set_caption(self, buf, caption=None):
         ## if wx.VERSION >= (4,1,0):
         try:
             _p, tab, idx = self.FindTab(buf)
-            tab.GetPage(idx).caption = caption or buf.name
+            tab.GetPage(idx).caption = caption or buf.caption
             tab.Refresh()
         except AttributeError:
             pass
     
     def set_attributes(self, buf=None, **kwargs):
         """Sets attributes and defaultBufferStyle
         that apply to all buffers contained in the EditorBook.
@@ -1884,21 +1868,16 @@
     def buffer(self):
         """Returns the currently selected page or None."""
         return self.CurrentPage
     
     def find_buffer(self, f):
         """Find buffer with specified f:filename or code."""
         for buf in self.all_buffers:
-            if f is buf or f in buf: # check code
+            if f is buf or f in buf or f == buf.filename: # check code
                 return buf
-            elif isinstance(f, str):
-                if buf.code and f == buf.codename:
-                    return buf
-                if f == buf.filename:
-                    return buf
     
     def create_buffer(self, filename, index=None):
         """Create a new buffer (internal use only)."""
         try:
             self.Freeze()
             buf = Buffer(self, filename)
             self.set_attributes(buf, **self.defaultBufferStyle)
@@ -1947,15 +1926,15 @@
     ## File I/O
     ## --------------------------------
     wildcards = [
         "PY files (*.py)|*.py",
         "ALL files (*.*)|*.*",
     ]
     
-    def load_url(self, url, *args, **kwargs):
+    def load_url(self, url, lineno=0):
         import requests
         if wx.MessageBox( # Confirm URL load.
                 "You are loading URL contents.\n\n"
                f"{url!r}\n"
                 "Continue loading?",
                 "Load URL",
                 style=wx.YES_NO|wx.ICON_INFORMATION) != wx.YES:
@@ -1964,15 +1943,15 @@
         try:
             res = requests.get(url)
         except Exception as e:
             self.post_message("Failed to load URL: {}".format(e))
             return None
         if res.status_code == 200: # success
             buf = self.find_buffer(url) or self.create_buffer(url)
-            buf._load_textfile(res.text, url)
+            buf._load_textfile(res.text, url, lineno)
             self.swap_page(buf)
             return True
         return False
     
     def load_cache(self, filename, lineno=0, globals=None):
         """Load a file from cache using linecache.
         Note:
@@ -2040,32 +2019,38 @@
         except Exception as e:
             self.post_message("Failed to save {!r}: {}".format(buf.name, e))
             return False
     
     def load_buffer(self, buf=None):
         """Confirm the load with the dialog."""
         buf = buf or self.buffer
-        if buf.mtdelta is None:
+        dt = buf.mtdelta
+        if dt is None:
             self.post_message("No filename.")
             return None
-        if buf.mtdelta == 0 and not buf.IsModified():
+        elif dt == 0 and not buf.IsModified():
             self.post_message("No need to load.")
             return None
-        return self.load_file(buf, buf.markline+1)
+        elif dt < 0:
+            return self.load_url(buf.filename, buf.markline+1)
+        else:
+            return self.load_file(buf, buf.markline+1)
     
     def save_buffer(self, buf=None):
         """Confirm the save with the dialog."""
         buf = buf or self.buffer
-        if buf.mtdelta is None:
+        dt = buf.mtdelta
+        if dt is None:
             self.post_message("No filename.")
             return None
-        if buf.mtdelta == 0 and not buf.IsModified():
+        elif dt == 0 and not buf.IsModified():
             self.post_message("No need to save.")
             return None
-        return self.save_file(buf.filename, buf)
+        else:
+            return self.save_file(buf.filename, buf)
     
     def save_buffer_as(self, buf=None):
         """Confirm the saveas with the dialog."""
         buf = buf or self.buffer
         name = re.sub("[\\/:*?\"<>|]", '', buf.name)
         with wx.FileDialog(self, "Save buffer as",
                 defaultFile=name,
@@ -2399,19 +2384,19 @@
             ## if self.AutoCompActive():
             ##     self.AutoCompCancel() # may delete selection
             if self.CanEdit():
                 self.ReplaceSelection("")
             self.message("")
         
         def fork(v):
-            self.handler(self.handler.event, v)
+            self.handler.fork(self.handler.current_event, v)
         
         def dispatch(v):
             """Fork mouse events to the parent."""
-            self.parent.handler(self.handler.event, v)
+            self.parent.handler(self.handler.current_event, v)
         
         self.handler.update({ # DNA<Nautilus>
             None : {
                   'stc_updated' : [ None, ],
                  'interp_error' : [ None, self.on_interp_error ],
                 'shell_deleted' : [ None, dispatch, self.on_deleted ],
               'shell_activated' : [ None, dispatch, self.on_activated ],
```

## mwx/utilus.py

```diff
@@ -539,18 +539,19 @@
     debug = 0
     debugger = None
     
     default_state = None
     current_state = property(lambda self: self.__state)
     previous_state = property(lambda self: self.__prev_state)
     
-    event = property(lambda self: self.__event)
     current_event = property(lambda self: self.__event)
     previous_event = property(lambda self: self.__prev_event)
     
+    event = current_event # for backward compatibility
+    
     @current_state.setter
     def current_state(self, state):
         self.__state = state
         self.__event = '*forced*'
         self.__debcall__(self.__event)
     
     def clear(self, state):
@@ -580,58 +581,71 @@
         return "<{} object at 0x{:X}>".format(self.__class__.__name__, id(self))
     
     def __str__(self):
         return '\n'.join("[ {!r} ]\n{!s}".format(k, v) for k, v in self.items())
     
     def __call__(self, event, *args, **kwargs):
         """Handle the event.
-        First, call handlers with the state:None.
-        Then, call handlers with the current state.
+        
+        First, call handlers with the state: None.
+        Then call handlers with the current state.
         
         Returns:
             list or None depending on the handler
             
             - process the event (with actions) -> [retvals]
             - process the event (no actions) -> []
             - no event:transaction -> None
         """
         recept = False # Is transaction performed?
         retvals = [] # retvals of actions
+        self.__event = event
         if None in self:
             org = self.__state
             prev = self.__prev_state
             try:
-                self.__event = event
                 self.__state = None
+                self.__prev_state = None
                 ret = self.call(event, *args, **kwargs) # None process
                 if ret is not None:
                     recept = True
                     retvals += ret
             finally:
                 if self.__state is None: # restore original
                     self.__state = org
                     self.__prev_state = prev
         
-        self.__event = event
         if self.__state is not None:
             ret = self.call(event, *args, **kwargs) # normal process
             if ret is not None:
                 recept = True
                 retvals += ret
         
+        ## Save the previous event for next handler debug call.
+        self.__prev_event = self.__event
         self.__prev_state = self.__state
-        self.__prev_event = event
         if recept:
             return retvals
     
+    def fork(self, event, *args, **kwargs):
+        """Invoke the event handlers (internal use only).
+        
+        Intended to fork events in the same handler.
+        Similar to __call__, but ignore state: None.
+        """
+        self.__event = event
+        ret = self.call(event, *args, **kwargs)
+        self.__prev_event = self.__event
+        return ret
+    
     def call(self, event, *args, **kwargs):
-        """Invoke the event handlers.
+        """Invoke the event handlers (internal use only).
         
-        1. transit the state
-        2. try actions after transition
+        1. Transit the state.
+        2. Try actions after transition.
         
         Returns:
             list or None depending on the handler
             
             - process the event (with actions) -> [retvals]
             - process the event (no actions) -> []
             - no event:transaction -> None
@@ -663,52 +677,55 @@
                     traceback.print_exc()
                     if self.debugger:
                         self.debugger(act, *args, **kwargs)
                         self.clear(self.default_state)
                         break
             self.__matched_pattern = None
             return retvals
-        elif isinstance(event, str): # matching test using fnmatch
+        
+        if isinstance(event, str): # matching test using fnmatch
             for pat in context:
                 if fnmatch.fnmatchcase(event, pat):
                     self.__matched_pattern = pat
                     return self.call(pat, *args, **kwargs) # recursive call
         
         self.__debcall__(event, *args, **kwargs) # check when no transition
         return None # no event, no action
     
     def __debcall__(self, pattern, *args, **kwargs):
+        def log(*args):
+            self.log(*args, end='' if v > 7 else '\n')
+        
         v = self.debug
         if v and self.__state is not None:
             transaction = self[self.__prev_state].get(pattern) or []
             actions = ', '.join(typename(a, qualp=0) for a in transaction[1:])
             if (v > 0 and self.__prev_state != self.__state
              or v > 1 and self.__prev_event != self.__event
              or v > 2 and actions
              or v > 3):
-                self.log("{c} {1} --> {2} {0!r} {a}".format(
+                log("{c} {1} --> {2} [{0}] {a}".format(
                     self.__event, self.__prev_state, self.__state,
                     a = '' if not actions else ('=> ' + actions),
                     c = '*' if self.__prev_state != self.__state else ' '))
         
         elif v > 3: # state is None
             transaction = self[None].get(pattern) or []
             actions = ', '.join(typename(a, qualp=0) for a in transaction[1:])
             if actions or v > 4:
-                self.log(" --> None {0!r} {a}".format(
+                log("  None [{0}] {a}".format(
                     self.__event,
                     a = '' if not actions else ('=> ' + actions)))
         
         if v > 7: # max verbose level puts all args
-            self.log("\t:", args)
-            self.log("\t:", kwargs)
+            self.log("\t:", args, kwargs)
     
     @staticmethod
-    def log(*args):
-        print(*args, file=sys.__stdout__)
+    def log(*args, **kwargs):
+        print(*args, file=sys.__stdout__, **kwargs)
     
     @staticmethod
     def dump(*args):
         print(*args, sep='\n', file=sys.__stderr__)
         f = get_rootpath("deb-dump.log")
         with open(f, 'a') as o:
             print(time.strftime('!!! %Y/%m/%d %H:%M:%S'), file=o)
```

## mwx/wxmon.py

```diff
@@ -79,15 +79,15 @@
         for module in (adv, aui, stc, media):
             ew.addModuleEvents(module)
         
         @self.handler.bind('*button* pressed')
         @self.handler.bind('*button* released')
         def dispatch(v):
             """Fork mouse events to the parent."""
-            self.parent.handler(self.handler.event, v)
+            self.parent.handler(self.handler.current_event, v)
             v.Skip()
     
     def OnDestroy(self, evt):
         if evt.EventObject is self:
             self.unwatch()
         evt.Skip()
```

## mwx/wxpdb.py

```diff
@@ -106,15 +106,15 @@
         
         def _help():
             self.parent.handler('add_help', pdb.__doc__)
         pdb.help = _help
         
         def dispatch(v):
             """Fork mouse events to the parent."""
-            self.parent.handler(self.handler.event, v)
+            self.parent.handler(self.handler.current_event, v)
         
         self.__handler = FSM({ # DNA<Debugger>
             0 : {
                   'debug_begin' : (1, self.on_debug_begin, dispatch),
                   'trace_begin' : (2, dispatch),
             },
             1 : {
```

## mwx/wxwil.py

```diff
@@ -43,15 +43,15 @@
         self.Bind(wx.EVT_LIST_COL_CLICK, self.OnSortItems)
         self.Bind(wx.EVT_CONTEXT_MENU, self.OnContextMenu)
         
         @self.handler.bind('*button* pressed')
         @self.handler.bind('*button* released')
         def dispatch(v):
             """Fork mouse events to the parent."""
-            self.parent.handler(self.handler.event, v)
+            self.parent.handler(self.handler.current_event, v)
             v.Skip()
         
         dispatcher.connect(receiver=self._update, signal='Interpreter.push')
     
     def _update(self, *args, **kwargs):
         if not self:
             dispatcher.disconnect(receiver=self._update, signal='Interpreter.push')
```

## mwx/wxwit.py

```diff
@@ -43,15 +43,15 @@
         self.highlighter = it._InspectionHighlighter()
         self.highlighter.highlightTime = 2000
         
         @self.handler.bind('*button* pressed')
         @self.handler.bind('*button* released')
         def dispatch(v):
             """Fork mouse events to the parent."""
-            self.parent.handler(self.handler.event, v)
+            self.parent.handler(self.handler.current_event, v)
             v.Skip()
         
         @self.handler.bind('f4 pressed')
         def highlight(v):
             if self.target:
                 self.highlighter.HighlightCurrentItem(self)
```

## Comparing `mwxlib-0.83.0.dist-info/LICENSE` & `mwxlib-0.83.6.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `mwxlib-0.83.0.dist-info/METADATA` & `mwxlib-0.83.6.dist-info/METADATA`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: mwxlib
-Version: 0.83.0
+Version: 0.83.6
 Summary: A wrapper of matplotlib and wxPython (phoenix)
 Home-page: https://github.com/komoto48g/mwxlib
 Author: Kazuya O'moto <komoto@jeol.co.jp>
 Author-email: komoto@jeol.co.jp
 License: MIT
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Programming Language :: Python :: 3
```

## Comparing `mwxlib-0.83.0.dist-info/RECORD` & `mwxlib-0.83.6.dist-info/RECORD`

 * *Files 27% similar despite different names*

```diff
@@ -1,22 +1,22 @@
 mwx/__init__.py,sha256=bSRdncjfSCKycMFQVnagOi9R2vUCC5snGkjea7jqPgU,2520
 mwx/controls.py,sha256=7hnSimA3bKDgTct29l6Hqpq7BCKqCeOjZJ6JQ1xjh7I,43445
-mwx/framework.py,sha256=gstFOhhfvY-Y_bJ-V1-iV2d9iCM7fNmfItgeyECOMEY,73547
-mwx/graphman.py,sha256=AY5uDOwuguJdCi_7CHBHxuuO8p3AuXtdY-meIY-caIU,69631
+mwx/framework.py,sha256=RMhgj174gLaoLZFYBC74_25gD7Fp081eew5EeA7m0jk,73366
+mwx/graphman.py,sha256=Edw2pZKghWGkbR_AV9PDWQpZz6q8XstTL5Q-xDrAce4,69534
 mwx/images.py,sha256=9e8X7OpJ6Z3fF3ez17P_qk2D1NMO10-lN8TCtulAqT0,46248
-mwx/matplot2.py,sha256=mzctMUk00m-tvs268PTwdLln7G3NCl6J-5zFzJkfsVI,36004
-mwx/matplot2g.py,sha256=0ysXo-mnluvaikIq2d9FiF8MM07Nzxx3ILpUkIXsPnQ,67652
+mwx/matplot2.py,sha256=W_FpY0S33crCAh7N9YTXo-jgYzj8uL9gqXkekfQo7Pk,36017
+mwx/matplot2g.py,sha256=cBuLMnQt3XSKQL9io0XJb_v8Lv0pO9hm0IMjVIERtu4,68253
 mwx/matplot2lg.py,sha256=h_aFij_7ksG2DXuYCaGmjtlcl122vZnwbMTv21Mprcg,27606
 mwx/mgplt.py,sha256=49_wpFZUEKErQmtobqrlNKDjWlAsdLft-izlqSyGPD0,6878
-mwx/nutshell.py,sha256=foEdUYR4Am4P1rP2kHJ6fQoNNG-l73uPaPlp-kHQw3g,138196
-mwx/utilus.py,sha256=yl0pVbi1f-Nj02GchztVS-kA2bx0WGAb-JgyD32pacE,36924
-mwx/wxmon.py,sha256=L2Q9n2zaSAWruUcBWw9lPpe-NIshoD3LR9o_sRqNENo,11335
-mwx/wxpdb.py,sha256=orVy4H1AhVaybw1LWrT_H-g2YVf7mOwxrH_1A_A57aY,19359
-mwx/wxwil.py,sha256=BUfEF0Nc1E-mVC3Vdz6k1E-2s5J0PO6qEzRQ6lfyePI,5246
-mwx/wxwit.py,sha256=-Dy09jCdKHNSbiFCFR3xM92_4PacdSRlPBZcLXIUeVo,7416
+mwx/nutshell.py,sha256=_cNKd_f5heEFcYb4PvlVNZqyLPNCNpDH8wAHFgDwmXw,137383
+mwx/utilus.py,sha256=H4wXPBix3zmq8wGn6YQKMO7aohSnPh_3fxUkAjDX0ZQ,37504
+mwx/wxmon.py,sha256=hEXto7dD5JunPf-iv2hhcwTIILLkNPlcl6wRt20_Wqc,11343
+mwx/wxpdb.py,sha256=M_xxXzIYhAwO1IHXVkjIC4Y2JCCCGLdgPL5R4bRtp04,19367
+mwx/wxwil.py,sha256=DPXXx4OdEzvHr-_jxz9J29Ozufmb6Vr7rXVkG_LKQd0,5254
+mwx/wxwit.py,sha256=UG361QTUheO_hlSIRgkprrGUYh0IzHB8ZqOoJeeMzUs,7424
 mwx/py/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 mwx/py/filling.py,sha256=f6KMBcBv7gwrl6qmJYLTL-O0Z47bWNAdTCZtUZIo8vM,16794
-mwxlib-0.83.0.dist-info/LICENSE,sha256=PGtRKCaTkmUDlBQwpptJAxJtdqxIUtAmdBsaT9nUVkA,1091
-mwxlib-0.83.0.dist-info/METADATA,sha256=5HCmzU_6cAeVXt0hbWu4hMZhLA5bX6_ABOxo23ppe9E,1893
-mwxlib-0.83.0.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-mwxlib-0.83.0.dist-info/top_level.txt,sha256=SI1Mh118AstnUFGPNq5aMNKiAnVNmZk1S9Ij-OwAEpY,4
-mwxlib-0.83.0.dist-info/RECORD,,
+mwxlib-0.83.6.dist-info/LICENSE,sha256=PGtRKCaTkmUDlBQwpptJAxJtdqxIUtAmdBsaT9nUVkA,1091
+mwxlib-0.83.6.dist-info/METADATA,sha256=Ld0rMHR_ESJ7ATfAKtUwDUnJ8XbtRG-E9rMjo5ZTSuY,1893
+mwxlib-0.83.6.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+mwxlib-0.83.6.dist-info/top_level.txt,sha256=SI1Mh118AstnUFGPNq5aMNKiAnVNmZk1S9Ij-OwAEpY,4
+mwxlib-0.83.6.dist-info/RECORD,,
```

