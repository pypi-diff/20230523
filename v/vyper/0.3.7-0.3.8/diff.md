# Comparing `tmp/vyper-0.3.7.tar.gz` & `tmp/vyper-0.3.8.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "vyper-0.3.7.tar", last modified: Tue Sep 27 01:22:10 2022, max compression
+gzip compressed data, was "vyper-0.3.8.tar", last modified: Tue May 23 15:01:34 2023, max compression
```

## Comparing `vyper-0.3.7.tar` & `vyper-0.3.8.tar`

### file list

```diff
@@ -1,545 +1,543 @@
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.549466 vyper-0.3.7/
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.501465 vyper-0.3.7/.github/
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.501465 vyper-0.3.7/.github/ISSUE_TEMPLATE/
--rw-r--r--   0 runner    (1001) docker     (121)      689 2022-09-27 01:21:57.000000 vyper-0.3.7/.github/ISSUE_TEMPLATE/bug.md
--rw-r--r--   0 runner    (1001) docker     (121)     1308 2022-09-27 01:21:57.000000 vyper-0.3.7/.github/ISSUE_TEMPLATE/vip.md
--rw-r--r--   0 runner    (1001) docker     (121)      453 2022-09-27 01:21:57.000000 vyper-0.3.7/.github/PULL_REQUEST_TEMPLATE.md
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.501465 vyper-0.3.7/.github/workflows/
--rw-r--r--   0 runner    (1001) docker     (121)     1611 2022-09-27 01:21:57.000000 vyper-0.3.7/.github/workflows/build.yml
--rw-r--r--   0 runner    (1001) docker     (121)      850 2022-09-27 01:21:57.000000 vyper-0.3.7/.github/workflows/publish.yml
--rw-r--r--   0 runner    (1001) docker     (121)     4593 2022-09-27 01:21:57.000000 vyper-0.3.7/.github/workflows/test.yml
--rw-r--r--   0 runner    (1001) docker     (121)      509 2022-09-27 01:21:57.000000 vyper-0.3.7/.gitignore
--rw-r--r--   0 runner    (1001) docker     (121)      516 2022-09-27 01:21:57.000000 vyper-0.3.7/.pre-commit-config.yaml
--rw-r--r--   0 runner    (1001) docker     (121)      274 2022-09-27 01:21:57.000000 vyper-0.3.7/.readthedocs.yaml
--rw-r--r--   0 runner    (1001) docker     (121)     1131 2022-09-27 01:21:57.000000 vyper-0.3.7/Dockerfile
--rw-r--r--   0 runner    (1001) docker     (121)       70 2022-09-27 01:21:57.000000 vyper-0.3.7/FUNDING.yml
--rw-r--r--   0 runner    (1001) docker     (121)    11549 2022-09-27 01:21:57.000000 vyper-0.3.7/LICENSE
--rw-r--r--   0 runner    (1001) docker     (121)     1853 2022-09-27 01:21:57.000000 vyper-0.3.7/Makefile
--rw-r--r--   0 runner    (1001) docker     (121)     3570 2022-09-27 01:22:10.549466 vyper-0.3.7/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (121)     2871 2022-09-27 01:21:57.000000 vyper-0.3.7/README.md
--rw-r--r--   0 runner    (1001) docker     (121)     3315 2022-09-27 01:21:57.000000 vyper-0.3.7/SECURITY.md
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.505465 vyper-0.3.7/docs/
--rw-r--r--   0 runner    (1001) docker     (121)      605 2022-09-27 01:21:57.000000 vyper-0.3.7/docs/Makefile
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.493465 vyper-0.3.7/docs/_static/
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.505465 vyper-0.3.7/docs/_static/css/
--rw-r--r--   0 runner    (1001) docker     (121)     2977 2022-09-27 01:21:57.000000 vyper-0.3.7/docs/_static/css/dark.css
--rw-r--r--   0 runner    (1001) docker     (121)     1454 2022-09-27 01:21:57.000000 vyper-0.3.7/docs/_static/css/toggle.css
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.505465 vyper-0.3.7/docs/_static/js/
--rw-r--r--   0 runner    (1001) docker     (121)      791 2022-09-27 01:21:57.000000 vyper-0.3.7/docs/_static/js/toggle.js
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.505465 vyper-0.3.7/docs/_templates/
--rw-r--r--   0 runner    (1001) docker     (121)     1429 2022-09-27 01:21:57.000000 vyper-0.3.7/docs/_templates/versions.html
--rw-r--r--   0 runner    (1001) docker     (121)    35222 2022-09-27 01:21:57.000000 vyper-0.3.7/docs/built-in-functions.rst
--rw-r--r--   0 runner    (1001) docker     (121)     6880 2022-09-27 01:21:57.000000 vyper-0.3.7/docs/compiler-exceptions.rst
--rw-r--r--   0 runner    (1001) docker     (121)    12450 2022-09-27 01:21:57.000000 vyper-0.3.7/docs/compiling-a-contract.rst
--rw-r--r--   0 runner    (1001) docker     (121)     5918 2022-09-27 01:21:57.000000 vyper-0.3.7/docs/conf.py
--rw-r--r--   0 runner    (1001) docker     (121)     3937 2022-09-27 01:21:57.000000 vyper-0.3.7/docs/constants-and-vars.rst
--rw-r--r--   0 runner    (1001) docker     (121)     3283 2022-09-27 01:21:57.000000 vyper-0.3.7/docs/contributing.rst
--rw-r--r--   0 runner    (1001) docker     (121)    11173 2022-09-27 01:21:57.000000 vyper-0.3.7/docs/control-structures.rst
--rw-r--r--   0 runner    (1001) docker     (121)     1038 2022-09-27 01:21:57.000000 vyper-0.3.7/docs/deploying-contracts.rst
--rw-r--r--   0 runner    (1001) docker     (121)     4498 2022-09-27 01:21:57.000000 vyper-0.3.7/docs/event-logging.rst
--rw-r--r--   0 runner    (1001) docker     (121)     4310 2022-09-27 01:21:57.000000 vyper-0.3.7/docs/index.rst
--rw-r--r--   0 runner    (1001) docker     (121)     3100 2022-09-27 01:21:57.000000 vyper-0.3.7/docs/installing-vyper.rst
--rw-r--r--   0 runner    (1001) docker     (121)     6818 2022-09-27 01:21:57.000000 vyper-0.3.7/docs/interfaces.rst
--rw-r--r--   0 runner    (1001) docker     (121)      803 2022-09-27 01:21:57.000000 vyper-0.3.7/docs/make.bat
--rw-r--r--   0 runner    (1001) docker     (121)     4978 2022-09-27 01:21:57.000000 vyper-0.3.7/docs/natspec.rst
--rw-r--r--   0 runner    (1001) docker     (121)    47954 2022-09-27 01:21:57.000000 vyper-0.3.7/docs/release-notes.rst
--rw-r--r--   0 runner    (1001) docker     (121)     7785 2022-09-27 01:21:57.000000 vyper-0.3.7/docs/scoping-and-declarations.rst
--rw-r--r--   0 runner    (1001) docker     (121)     3271 2022-09-27 01:21:57.000000 vyper-0.3.7/docs/statements.rst
--rw-r--r--   0 runner    (1001) docker     (121)     3429 2022-09-27 01:21:57.000000 vyper-0.3.7/docs/structure-of-a-contract.rst
--rw-r--r--   0 runner    (1001) docker     (121)    15593 2022-09-27 01:21:57.000000 vyper-0.3.7/docs/style-guide.rst
--rw-r--r--   0 runner    (1001) docker     (121)     5723 2022-09-27 01:21:57.000000 vyper-0.3.7/docs/testing-contracts-brownie.rst
--rw-r--r--   0 runner    (1001) docker     (121)     3440 2022-09-27 01:21:57.000000 vyper-0.3.7/docs/testing-contracts-ethtester.rst
--rw-r--r--   0 runner    (1001) docker     (121)      670 2022-09-27 01:21:57.000000 vyper-0.3.7/docs/testing-contracts.rst
--rw-r--r--   0 runner    (1001) docker     (121)      815 2022-09-27 01:21:57.000000 vyper-0.3.7/docs/toctree.rst
--rw-r--r--   0 runner    (1001) docker     (121)    20460 2022-09-27 01:21:57.000000 vyper-0.3.7/docs/types.rst
--rw-r--r--   0 runner    (1001) docker     (121)     7753 2022-09-27 01:21:57.000000 vyper-0.3.7/docs/versioning.rst
--rw-r--r--   0 runner    (1001) docker     (121)    29136 2022-09-27 01:21:57.000000 vyper-0.3.7/docs/vyper-by-example.rst
--rw-r--r--   0 runner    (1001) docker     (121)     1042 2022-09-27 01:21:57.000000 vyper-0.3.7/docs/vyper-logo-transparent.svg
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.505465 vyper-0.3.7/examples/
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.505465 vyper-0.3.7/examples/auctions/
--rw-r--r--   0 runner    (1001) docker     (121)     5666 2022-09-27 01:21:57.000000 vyper-0.3.7/examples/auctions/blind_auction.vy
--rw-r--r--   0 runner    (1001) docker     (121)     3058 2022-09-27 01:21:57.000000 vyper-0.3.7/examples/auctions/simple_open_auction.vy
--rw-r--r--   0 runner    (1001) docker     (121)     1186 2022-09-27 01:21:57.000000 vyper-0.3.7/examples/crowdfund.vy
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.505465 vyper-0.3.7/examples/factory/
--rw-r--r--   0 runner    (1001) docker     (121)      927 2022-09-27 01:21:57.000000 vyper-0.3.7/examples/factory/Exchange.vy
--rw-r--r--   0 runner    (1001) docker     (121)     1655 2022-09-27 01:21:57.000000 vyper-0.3.7/examples/factory/Factory.vy
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.505465 vyper-0.3.7/examples/market_maker/
--rw-r--r--   0 runner    (1001) docker     (121)     1951 2022-09-27 01:21:57.000000 vyper-0.3.7/examples/market_maker/on_chain_market_maker.vy
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.505465 vyper-0.3.7/examples/name_registry/
--rw-r--r--   0 runner    (1001) docker     (121)      306 2022-09-27 01:21:57.000000 vyper-0.3.7/examples/name_registry/name_registry.vy
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.509465 vyper-0.3.7/examples/safe_remote_purchase/
--rw-r--r--   0 runner    (1001) docker     (121)     2178 2022-09-27 01:21:57.000000 vyper-0.3.7/examples/safe_remote_purchase/safe_remote_purchase.vy
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.509465 vyper-0.3.7/examples/stock/
--rw-r--r--   0 runner    (1001) docker     (121)     4606 2022-09-27 01:21:57.000000 vyper-0.3.7/examples/stock/company.vy
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.509465 vyper-0.3.7/examples/storage/
--rw-r--r--   0 runner    (1001) docker     (121)      405 2022-09-27 01:21:57.000000 vyper-0.3.7/examples/storage/advanced_storage.vy
--rw-r--r--   0 runner    (1001) docker     (121)      141 2022-09-27 01:21:57.000000 vyper-0.3.7/examples/storage/storage.vy
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.509465 vyper-0.3.7/examples/tokens/
--rw-r--r--   0 runner    (1001) docker     (121)    15252 2022-09-27 01:21:57.000000 vyper-0.3.7/examples/tokens/ERC1155ownable.vy
--rw-r--r--   0 runner    (1001) docker     (121)     5167 2022-09-27 01:21:57.000000 vyper-0.3.7/examples/tokens/ERC20.vy
--rw-r--r--   0 runner    (1001) docker     (121)     6361 2022-09-27 01:21:57.000000 vyper-0.3.7/examples/tokens/ERC4626.vy
--rw-r--r--   0 runner    (1001) docker     (121)    13366 2022-09-27 01:21:57.000000 vyper-0.3.7/examples/tokens/ERC721.vy
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.509465 vyper-0.3.7/examples/voting/
--rw-r--r--   0 runner    (1001) docker     (121)     5809 2022-09-27 01:21:57.000000 vyper-0.3.7/examples/voting/ballot.vy
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.509465 vyper-0.3.7/examples/wallet/
--rw-r--r--   0 runner    (1001) docker     (121)     3106 2022-09-27 01:21:57.000000 vyper-0.3.7/examples/wallet/wallet.vy
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.509465 vyper-0.3.7/hooks/
--rwxr-xr-x   0 runner    (1001) docker     (121)      265 2022-09-27 01:21:57.000000 vyper-0.3.7/hooks/build
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.509465 vyper-0.3.7/logo/
--rw-r--r--   0 runner    (1001) docker     (121)    42373 2022-09-27 01:21:57.000000 vyper-0.3.7/logo/vyper-logo-flat.png
--rw-r--r--   0 runner    (1001) docker     (121)      888 2022-09-27 01:21:57.000000 vyper-0.3.7/logo/vyper-logo-flat.svg
--rw-r--r--   0 runner    (1001) docker     (121)    38259 2022-09-27 01:21:57.000000 vyper-0.3.7/logo/vyper-logo-transparent.png
--rw-r--r--   0 runner    (1001) docker     (121)     1042 2022-09-27 01:21:57.000000 vyper-0.3.7/logo/vyper-logo-transparent.svg
--rw-r--r--   0 runner    (1001) docker     (121)   647034 2022-09-27 01:21:57.000000 vyper-0.3.7/logo/vyper-logo.ai
--rw-r--r--   0 runner    (1001) docker     (121)     1614 2022-09-27 01:21:57.000000 vyper-0.3.7/make.cmd
--rw-r--r--   0 runner    (1001) docker     (121)      497 2022-09-27 01:21:57.000000 vyper-0.3.7/pyproject.toml
--rwxr-xr-x   0 runner    (1001) docker     (121)      239 2022-09-27 01:21:57.000000 vyper-0.3.7/quicktest.sh
--rw-r--r--   0 runner    (1001) docker     (121)       58 2022-09-27 01:21:57.000000 vyper-0.3.7/requirements-docs.txt
--rw-r--r--   0 runner    (1001) docker     (121)      740 2022-09-27 01:22:10.549466 vyper-0.3.7/setup.cfg
--rw-r--r--   0 runner    (1001) docker     (121)     3955 2022-09-27 01:21:57.000000 vyper-0.3.7/setup.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.509465 vyper-0.3.7/tests/
--rw-r--r--   0 runner    (1001) docker     (121)        0 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.509465 vyper-0.3.7/tests/ast/
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.513465 vyper-0.3.7/tests/ast/nodes/
--rw-r--r--   0 runner    (1001) docker     (121)      426 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/ast/nodes/test_binary.py
--rw-r--r--   0 runner    (1001) docker     (121)     1150 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/ast/nodes/test_compare_nodes.py
--rw-r--r--   0 runner    (1001) docker     (121)     2914 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/ast/nodes/test_evaluate_binop_decimal.py
--rw-r--r--   0 runner    (1001) docker     (121)     3732 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/ast/nodes/test_evaluate_binop_int.py
--rw-r--r--   0 runner    (1001) docker     (121)     1859 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/ast/nodes/test_evaluate_boolop.py
--rw-r--r--   0 runner    (1001) docker     (121)     3492 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/ast/nodes/test_evaluate_compare.py
--rw-r--r--   0 runner    (1001) docker     (121)      685 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/ast/nodes/test_evaluate_subscript.py
--rw-r--r--   0 runner    (1001) docker     (121)      972 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/ast/nodes/test_evaluate_unaryop.py
--rw-r--r--   0 runner    (1001) docker     (121)     1038 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/ast/nodes/test_from_node.py
--rw-r--r--   0 runner    (1001) docker     (121)      845 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/ast/nodes/test_get_children.py
--rw-r--r--   0 runner    (1001) docker     (121)     2245 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/ast/nodes/test_get_descendants.py
--rw-r--r--   0 runner    (1001) docker     (121)     1070 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/ast/nodes/test_hex.py
--rw-r--r--   0 runner    (1001) docker     (121)     2179 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/ast/nodes/test_replace_in_tree.py
--rw-r--r--   0 runner    (1001) docker     (121)     8341 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/ast/test_folding.py
--rw-r--r--   0 runner    (1001) docker     (121)     8845 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/ast/test_natspec.py
--rw-r--r--   0 runner    (1001) docker     (121)     2573 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/ast/test_pre_parser.py
--rw-r--r--   0 runner    (1001) docker     (121)     7611 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/base_conftest.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.497465 vyper-0.3.7/tests/cli/
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.513465 vyper-0.3.7/tests/cli/outputs/
--rw-r--r--   0 runner    (1001) docker     (121)     1556 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/cli/outputs/test_storage_layout.py
--rw-r--r--   0 runner    (1001) docker     (121)     2645 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/cli/outputs/test_storage_layout_overrides.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.513465 vyper-0.3.7/tests/cli/vyper_compile/
--rw-r--r--   0 runner    (1001) docker     (121)     1514 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/cli/vyper_compile/test_compile_files.py
--rw-r--r--   0 runner    (1001) docker     (121)     8045 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/cli/vyper_compile/test_import_paths.py
--rw-r--r--   0 runner    (1001) docker     (121)      617 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/cli/vyper_compile/test_parse_args.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.513465 vyper-0.3.7/tests/cli/vyper_json/
--rw-r--r--   0 runner    (1001) docker     (121)     4284 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/cli/vyper_json/test_compile_from_input_dict.py
--rw-r--r--   0 runner    (1001) docker     (121)     1382 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/cli/vyper_json/test_compile_json.py
--rw-r--r--   0 runner    (1001) docker     (121)     1940 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/cli/vyper_json/test_get_contracts.py
--rw-r--r--   0 runner    (1001) docker     (121)      816 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/cli/vyper_json/test_get_settings.py
--rw-r--r--   0 runner    (1001) docker     (121)     3724 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/cli/vyper_json/test_interfaces.py
--rw-r--r--   0 runner    (1001) docker     (121)     1326 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/cli/vyper_json/test_output_dict.py
--rw-r--r--   0 runner    (1001) docker     (121)     1881 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/cli/vyper_json/test_output_selection.py
--rw-r--r--   0 runner    (1001) docker     (121)     2836 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/cli/vyper_json/test_parse_args_vyperjson.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.513465 vyper-0.3.7/tests/compiler/
--rw-r--r--   0 runner    (1001) docker     (121)        0 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/compiler/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.513465 vyper-0.3.7/tests/compiler/ir/
--rw-r--r--   0 runner    (1001) docker     (121)        0 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/compiler/ir/__init__.py
--rw-r--r--   0 runner    (1001) docker     (121)     1912 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/compiler/ir/test_compile_ir.py
--rw-r--r--   0 runner    (1001) docker     (121)     9781 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/compiler/ir/test_optimize_ir.py
--rw-r--r--   0 runner    (1001) docker     (121)      392 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/compiler/ir/test_repeat.py
--rw-r--r--   0 runner    (1001) docker     (121)    13843 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/compiler/ir/test_with.py
--rw-r--r--   0 runner    (1001) docker     (121)      306 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/compiler/test_bytecode_runtime.py
--rw-r--r--   0 runner    (1001) docker     (121)      125 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/compiler/test_calldatacopy.py
--rw-r--r--   0 runner    (1001) docker     (121)    24862 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/compiler/test_compile_code.py
--rw-r--r--   0 runner    (1001) docker     (121)     1728 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/compiler/test_opcodes.py
--rw-r--r--   0 runner    (1001) docker     (121)     2366 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/compiler/test_pre_parser.py
--rw-r--r--   0 runner    (1001) docker     (121)      370 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/compiler/test_sha3_32.py
--rw-r--r--   0 runner    (1001) docker     (121)     3211 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/compiler/test_source_map.py
--rw-r--r--   0 runner    (1001) docker     (121)     6274 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/conftest.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.513465 vyper-0.3.7/tests/examples/
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.513465 vyper-0.3.7/tests/examples/auctions/
--rw-r--r--   0 runner    (1001) docker     (121)    12478 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/examples/auctions/test_blind_auction.py
--rw-r--r--   0 runner    (1001) docker     (121)     4257 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/examples/auctions/test_simple_open_auction.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.513465 vyper-0.3.7/tests/examples/company/
--rw-r--r--   0 runner    (1001) docker     (121)     4434 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/examples/company/test_company.py
--rw-r--r--   0 runner    (1001) docker     (121)       81 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/examples/conftest.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.513465 vyper-0.3.7/tests/examples/crowdfund/
--rw-r--r--   0 runner    (1001) docker     (121)     1826 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/examples/crowdfund/test_crowdfund_example.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.513465 vyper-0.3.7/tests/examples/factory/
--rw-r--r--   0 runner    (1001) docker     (121)     2071 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/examples/factory/test_factory.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.513465 vyper-0.3.7/tests/examples/market_maker/
--rw-r--r--   0 runner    (1001) docker     (121)     4622 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/examples/market_maker/test_on_chain_market_maker.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.513465 vyper-0.3.7/tests/examples/name_registry/
--rw-r--r--   0 runner    (1001) docker     (121)      346 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/examples/name_registry/test_name_registry.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.513465 vyper-0.3.7/tests/examples/safe_remote_purchase/
--rw-r--r--   0 runner    (1001) docker     (121)     5652 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/examples/safe_remote_purchase/test_safe_remote_purchase.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.517465 vyper-0.3.7/tests/examples/storage/
--rw-r--r--   0 runner    (1001) docker     (121)     2402 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/examples/storage/test_advanced_storage.py
--rw-r--r--   0 runner    (1001) docker     (121)      863 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/examples/storage/test_storage.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.517465 vyper-0.3.7/tests/examples/tokens/
--rw-r--r--   0 runner    (1001) docker     (121)    14158 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/examples/tokens/test_erc1155.py
--rw-r--r--   0 runner    (1001) docker     (121)    14628 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/examples/tokens/test_erc20.py
--rw-r--r--   0 runner    (1001) docker     (121)     3424 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/examples/tokens/test_erc4626.py
--rw-r--r--   0 runner    (1001) docker     (121)    11525 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/examples/tokens/test_erc721.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.517465 vyper-0.3.7/tests/examples/voting/
--rw-r--r--   0 runner    (1001) docker     (121)     9158 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/examples/voting/test_ballot.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.517465 vyper-0.3.7/tests/examples/wallet/
--rw-r--r--   0 runner    (1001) docker     (121)     4732 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/examples/wallet/test_wallet.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.517465 vyper-0.3.7/tests/fixtures/
--rw-r--r--   0 runner    (1001) docker     (121)        0 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/fixtures/__init__.py
--rw-r--r--   0 runner    (1001) docker     (121)     1612 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/fixtures/memorymock.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.517465 vyper-0.3.7/tests/functional/
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.517465 vyper-0.3.7/tests/functional/codegen/
--rw-r--r--   0 runner    (1001) docker     (121)     2552 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/functional/codegen/test_struct_return.py
--rw-r--r--   0 runner    (1001) docker     (121)     1089 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/functional/codegen/test_tuple_return.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.517465 vyper-0.3.7/tests/functional/context/
--rw-r--r--   0 runner    (1001) docker     (121)      736 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/functional/context/conftest.py
--rw-r--r--   0 runner    (1001) docker     (121)     2604 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/functional/context/test_namespace.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.517465 vyper-0.3.7/tests/functional/context/types/
--rw-r--r--   0 runner    (1001) docker     (121)     2600 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/functional/context/types/test_event.py
--rw-r--r--   0 runner    (1001) docker     (121)     4093 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/functional/context/types/test_pure_types.py
--rw-r--r--   0 runner    (1001) docker     (121)     2294 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/functional/context/types/test_size_in_bytes.py
--rw-r--r--   0 runner    (1001) docker     (121)     1647 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/functional/context/types/test_type_from_abi.py
--rw-r--r--   0 runner    (1001) docker     (121)     4181 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/functional/context/types/test_type_from_annotation.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.517465 vyper-0.3.7/tests/functional/context/validation/
--rw-r--r--   0 runner    (1001) docker     (121)     1899 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/functional/context/validation/test_array_index.py
--rw-r--r--   0 runner    (1001) docker     (121)     1322 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/functional/context/validation/test_cyclic_function_calls.py
--rw-r--r--   0 runner    (1001) docker     (121)     1745 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/functional/context/validation/test_for_loop.py
--rw-r--r--   0 runner    (1001) docker     (121)     7466 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/functional/context/validation/test_potential_types.py
--rw-r--r--   0 runner    (1001) docker     (121)     2784 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/functional/test_storage_slots.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.497465 vyper-0.3.7/tests/functions/
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.517465 vyper-0.3.7/tests/functions/folding/
--rw-r--r--   0 runner    (1001) docker     (121)     1531 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/functions/folding/test_abs.py
--rw-r--r--   0 runner    (1001) docker     (121)      878 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/functions/folding/test_addmod_mulmod.py
--rw-r--r--   0 runner    (1001) docker     (121)     1731 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/functions/folding/test_bitwise.py
--rw-r--r--   0 runner    (1001) docker     (121)      525 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/functions/folding/test_epsilon.py
--rw-r--r--   0 runner    (1001) docker     (121)     1032 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/functions/folding/test_floor_ceil.py
--rw-r--r--   0 runner    (1001) docker     (121)     1468 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/functions/folding/test_fold_as_wei_value.py
--rw-r--r--   0 runner    (1001) docker     (121)     2085 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/functions/folding/test_keccak_sha.py
--rw-r--r--   0 runner    (1001) docker     (121)     1458 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/functions/folding/test_len.py
--rw-r--r--   0 runner    (1001) docker     (121)     2177 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/functions/folding/test_min_max.py
--rw-r--r--   0 runner    (1001) docker     (121)      716 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/functions/folding/test_powmod.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.517465 vyper-0.3.7/tests/fuzzing/
--rw-r--r--   0 runner    (1001) docker     (121)     3646 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/fuzzing/test_exponents.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.517465 vyper-0.3.7/tests/grammar/
--rw-r--r--   0 runner    (1001) docker     (121)     3655 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/grammar/test_grammar.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.501465 vyper-0.3.7/tests/parser/
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.521465 vyper-0.3.7/tests/parser/ast_utils/
--rw-r--r--   0 runner    (1001) docker     (121)      561 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/ast_utils/test_ast.py
--rw-r--r--   0 runner    (1001) docker     (121)     2472 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/ast_utils/test_ast_dict.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.521465 vyper-0.3.7/tests/parser/exceptions/
--rw-r--r--   0 runner    (1001) docker     (121)        0 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/exceptions/__init__.py
--rw-r--r--   0 runner    (1001) docker     (121)     1685 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/exceptions/test_argument_exception.py
--rw-r--r--   0 runner    (1001) docker     (121)      547 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/exceptions/test_call_violation.py
--rw-r--r--   0 runner    (1001) docker     (121)     1912 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/exceptions/test_constancy_exception.py
--rw-r--r--   0 runner    (1001) docker     (121)      872 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/exceptions/test_function_declaration_exception.py
--rw-r--r--   0 runner    (1001) docker     (121)      967 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/exceptions/test_invalid_literal_exception.py
--rw-r--r--   0 runner    (1001) docker     (121)      340 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/exceptions/test_invalid_operation.py
--rw-r--r--   0 runner    (1001) docker     (121)      709 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/exceptions/test_invalid_payable.py
--rw-r--r--   0 runner    (1001) docker     (121)      632 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/exceptions/test_invalid_reference.py
--rw-r--r--   0 runner    (1001) docker     (121)     1458 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/exceptions/test_invalid_type_exception.py
--rw-r--r--   0 runner    (1001) docker     (121)     1019 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/exceptions/test_namespace_collision.py
--rw-r--r--   0 runner    (1001) docker     (121)      945 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/exceptions/test_overflow_exception.py
--rw-r--r--   0 runner    (1001) docker     (121)     2175 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/exceptions/test_structure_exception.py
--rw-r--r--   0 runner    (1001) docker     (121)     1404 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/exceptions/test_syntax_exception.py
--rw-r--r--   0 runner    (1001) docker     (121)      617 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/exceptions/test_type_mismatch_exception.py
--rw-r--r--   0 runner    (1001) docker     (121)     1121 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/exceptions/test_undeclared_definition.py
--rw-r--r--   0 runner    (1001) docker     (121)      602 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/exceptions/test_variable_declaration_exception.py
--rw-r--r--   0 runner    (1001) docker     (121)      689 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/exceptions/test_vyper_exception_pos.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.521465 vyper-0.3.7/tests/parser/features/
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.525465 vyper-0.3.7/tests/parser/features/arithmetic/
--rw-r--r--   0 runner    (1001) docker     (121)      703 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/features/arithmetic/test_division.py
--rw-r--r--   0 runner    (1001) docker     (121)     1942 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/features/arithmetic/test_modulo.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.525465 vyper-0.3.7/tests/parser/features/decorators/
--rw-r--r--   0 runner    (1001) docker     (121)     6738 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/features/decorators/test_nonreentrant.py
--rw-r--r--   0 runner    (1001) docker     (121)     5598 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/features/decorators/test_payable.py
--rw-r--r--   0 runner    (1001) docker     (121)    14628 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/features/decorators/test_private.py
--rw-r--r--   0 runner    (1001) docker     (121)      636 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/features/decorators/test_public.py
--rw-r--r--   0 runner    (1001) docker     (121)     2435 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/features/decorators/test_pure.py
--rw-r--r--   0 runner    (1001) docker     (121)      678 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/features/decorators/test_view.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.525465 vyper-0.3.7/tests/parser/features/external_contracts/
--rw-r--r--   0 runner    (1001) docker     (121)     4237 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/features/external_contracts/test_erc20_abi.py
--rw-r--r--   0 runner    (1001) docker     (121)    58270 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/features/external_contracts/test_external_contract_calls.py
--rw-r--r--   0 runner    (1001) docker     (121)     6674 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/features/external_contracts/test_modifiable_external_contract_calls.py
--rw-r--r--   0 runner    (1001) docker     (121)     1507 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/features/external_contracts/test_self_call_struct.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.525465 vyper-0.3.7/tests/parser/features/iteration/
--rw-r--r--   0 runner    (1001) docker     (121)     1971 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/features/iteration/test_break.py
--rw-r--r--   0 runner    (1001) docker     (121)     1579 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/features/iteration/test_continue.py
--rw-r--r--   0 runner    (1001) docker     (121)    14238 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/features/iteration/test_for_in_list.py
--rw-r--r--   0 runner    (1001) docker     (121)     3934 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/features/iteration/test_range_in.py
--rw-r--r--   0 runner    (1001) docker     (121)     5814 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/features/iteration/test_repeater.py
--rw-r--r--   0 runner    (1001) docker     (121)     4982 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/features/test_assert.py
--rw-r--r--   0 runner    (1001) docker     (121)     1480 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/features/test_assert_unreachable.py
--rw-r--r--   0 runner    (1001) docker     (121)     4861 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/features/test_assignment.py
--rw-r--r--   0 runner    (1001) docker     (121)     4228 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/features/test_bytes_map_keys.py
--rw-r--r--   0 runner    (1001) docker     (121)    17736 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/features/test_clampers.py
--rw-r--r--   0 runner    (1001) docker     (121)      261 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/features/test_comments.py
--rw-r--r--   0 runner    (1001) docker     (121)     1586 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/features/test_comparison.py
--rw-r--r--   0 runner    (1001) docker     (121)      949 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/features/test_conditionals.py
--rw-r--r--   0 runner    (1001) docker     (121)     5814 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/features/test_constructor.py
--rw-r--r--   0 runner    (1001) docker     (121)      276 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/features/test_gas.py
--rw-r--r--   0 runner    (1001) docker     (121)     5284 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/features/test_immutable.py
--rw-r--r--   0 runner    (1001) docker     (121)     1238 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/features/test_init.py
--rw-r--r--   0 runner    (1001) docker     (121)    13821 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/features/test_internal_call.py
--rw-r--r--   0 runner    (1001) docker     (121)    33795 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/features/test_logging.py
--rw-r--r--   0 runner    (1001) docker     (121)     3114 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/features/test_logging_bytes_extended.py
--rw-r--r--   0 runner    (1001) docker     (121)     4632 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/features/test_logging_from_call.py
--rw-r--r--   0 runner    (1001) docker     (121)      529 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/features/test_memory_dealloc.py
--rw-r--r--   0 runner    (1001) docker     (121)     1282 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/features/test_packing.py
--rw-r--r--   0 runner    (1001) docker     (121)     3601 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/features/test_short_circuiting.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.529465 vyper-0.3.7/tests/parser/functions/
--rw-r--r--   0 runner    (1001) docker     (121)        0 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/functions/__init__.py
--rw-r--r--   0 runner    (1001) docker     (121)     4126 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/functions/test_abi.py
--rw-r--r--   0 runner    (1001) docker     (121)    12861 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/functions/test_abi_decode.py
--rw-r--r--   0 runner    (1001) docker     (121)    12101 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/functions/test_abi_encode.py
--rw-r--r--   0 runner    (1001) docker     (121)     4205 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/functions/test_bitwise.py
--rw-r--r--   0 runner    (1001) docker     (121)     1214 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/functions/test_block.py
--rw-r--r--   0 runner    (1001) docker     (121)      312 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/functions/test_block_number.py
--rw-r--r--   0 runner    (1001) docker     (121)     2099 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/functions/test_ceil.py
--rw-r--r--   0 runner    (1001) docker     (121)     5364 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/functions/test_concat.py
--rw-r--r--   0 runner    (1001) docker     (121)    20555 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/functions/test_convert.py
--rw-r--r--   0 runner    (1001) docker     (121)    11496 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/functions/test_create_functions.py
--rw-r--r--   0 runner    (1001) docker     (121)     3321 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/functions/test_default_function.py
--rw-r--r--   0 runner    (1001) docker     (121)     9313 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/functions/test_default_parameters.py
--rw-r--r--   0 runner    (1001) docker     (121)     2033 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/functions/test_ec.py
--rw-r--r--   0 runner    (1001) docker     (121)     1644 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/functions/test_ecrecover.py
--rw-r--r--   0 runner    (1001) docker     (121)    16408 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/functions/test_empty.py
--rw-r--r--   0 runner    (1001) docker     (121)     2433 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/functions/test_extract32.py
--rw-r--r--   0 runner    (1001) docker     (121)     2154 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/functions/test_floor.py
--rw-r--r--   0 runner    (1001) docker     (121)    16618 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/functions/test_interfaces.py
--rw-r--r--   0 runner    (1001) docker     (121)      695 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/functions/test_is_contract.py
--rw-r--r--   0 runner    (1001) docker     (121)     2345 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/functions/test_keccak256.py
--rw-r--r--   0 runner    (1001) docker     (121)      410 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/functions/test_length.py
--rw-r--r--   0 runner    (1001) docker     (121)     1768 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/functions/test_method_id.py
--rw-r--r--   0 runner    (1001) docker     (121)     6087 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/functions/test_minmax.py
--rw-r--r--   0 runner    (1001) docker     (121)     2310 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/functions/test_minmax_value.py
--rw-r--r--   0 runner    (1001) docker     (121)      938 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/functions/test_mkstr.py
--rw-r--r--   0 runner    (1001) docker     (121)    10069 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/functions/test_raw_call.py
--rw-r--r--   0 runner    (1001) docker     (121)     1171 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/functions/test_return.py
--rw-r--r--   0 runner    (1001) docker     (121)     8794 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/functions/test_return_struct.py
--rw-r--r--   0 runner    (1001) docker     (121)     4562 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/functions/test_return_tuple.py
--rw-r--r--   0 runner    (1001) docker     (121)     1576 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/functions/test_send.py
--rw-r--r--   0 runner    (1001) docker     (121)     1797 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/functions/test_sha256.py
--rw-r--r--   0 runner    (1001) docker     (121)     9975 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/functions/test_slice.py
--rw-r--r--   0 runner    (1001) docker     (121)      237 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/functions/test_tx.py
--rw-r--r--   0 runner    (1001) docker     (121)     1992 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/functions/test_unary.py
--rw-r--r--   0 runner    (1001) docker     (121)     2179 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/functions/test_unsafe_math.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.529465 vyper-0.3.7/tests/parser/globals/
--rw-r--r--   0 runner    (1001) docker     (121)     1845 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/globals/test_getters.py
--rw-r--r--   0 runner    (1001) docker     (121)      752 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/globals/test_globals.py
--rw-r--r--   0 runner    (1001) docker     (121)     6529 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/globals/test_setters.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.529465 vyper-0.3.7/tests/parser/integration/
--rw-r--r--   0 runner    (1001) docker     (121)      399 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/integration/test_basics.py
--rw-r--r--   0 runner    (1001) docker     (121)     5402 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/integration/test_crowdfund.py
--rw-r--r--   0 runner    (1001) docker     (121)     1870 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/integration/test_escrow.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.529465 vyper-0.3.7/tests/parser/parser_utils/
--rw-r--r--   0 runner    (1001) docker     (121)     1703 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/parser_utils/test_annotate_and_optimize_ast.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.533465 vyper-0.3.7/tests/parser/syntax/
--rw-r--r--   0 runner    (1001) docker     (121)        0 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/syntax/__init__.py
--rw-r--r--   0 runner    (1001) docker     (121)     2155 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/syntax/test_abi_encode.py
--rw-r--r--   0 runner    (1001) docker     (121)     6081 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/syntax/test_address_code.py
--rw-r--r--   0 runner    (1001) docker     (121)     2670 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/syntax/test_ann_assign.py
--rw-r--r--   0 runner    (1001) docker     (121)      697 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/syntax/test_as_uint256.py
--rw-r--r--   0 runner    (1001) docker     (121)     1401 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/syntax/test_as_wei_value.py
--rw-r--r--   0 runner    (1001) docker     (121)     2909 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/syntax/test_block.py
--rw-r--r--   0 runner    (1001) docker     (121)     1708 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/syntax/test_blockscope.py
--rw-r--r--   0 runner    (1001) docker     (121)     3921 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/syntax/test_bool.py
--rw-r--r--   0 runner    (1001) docker     (121)      906 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/syntax/test_bool_ops.py
--rw-r--r--   0 runner    (1001) docker     (121)      438 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/syntax/test_byte_string.py
--rw-r--r--   0 runner    (1001) docker     (121)     1971 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/syntax/test_bytes.py
--rw-r--r--   0 runner    (1001) docker     (121)     2287 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/syntax/test_chainid.py
--rw-r--r--   0 runner    (1001) docker     (121)      845 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/syntax/test_code_size.py
--rw-r--r--   0 runner    (1001) docker     (121)     1398 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/syntax/test_codehash.py
--rw-r--r--   0 runner    (1001) docker     (121)     2673 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/syntax/test_concat.py
--rw-r--r--   0 runner    (1001) docker     (121)      440 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/syntax/test_conditionals.py
--rw-r--r--   0 runner    (1001) docker     (121)     4897 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/syntax/test_constants.py
--rw-r--r--   0 runner    (1001) docker     (121)     1817 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/syntax/test_create_with_code_of.py
--rw-r--r--   0 runner    (1001) docker     (121)     1690 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/syntax/test_enum.py
--rw-r--r--   0 runner    (1001) docker     (121)     2073 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/syntax/test_extract32.py
--rw-r--r--   0 runner    (1001) docker     (121)      601 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/syntax/test_for_range.py
--rw-r--r--   0 runner    (1001) docker     (121)     1368 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/syntax/test_functions_call.py
--rw-r--r--   0 runner    (1001) docker     (121)     2933 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/syntax/test_immutables.py
--rw-r--r--   0 runner    (1001) docker     (121)     3615 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/syntax/test_interfaces.py
--rw-r--r--   0 runner    (1001) docker     (121)     4263 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/syntax/test_invalids.py
--rw-r--r--   0 runner    (1001) docker     (121)     1143 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/syntax/test_keccak256.py
--rw-r--r--   0 runner    (1001) docker     (121)      904 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/syntax/test_len.py
--rw-r--r--   0 runner    (1001) docker     (121)     4428 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/syntax/test_list.py
--rw-r--r--   0 runner    (1001) docker     (121)      774 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/syntax/test_logging.py
--rw-r--r--   0 runner    (1001) docker     (121)      407 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/syntax/test_minmax.py
--rw-r--r--   0 runner    (1001) docker     (121)      451 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/syntax/test_minmax_value.py
--rw-r--r--   0 runner    (1001) docker     (121)     3577 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/syntax/test_msg_data.py
--rw-r--r--   0 runner    (1001) docker     (121)     1384 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/syntax/test_nested_list.py
--rw-r--r--   0 runner    (1001) docker     (121)     3389 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/syntax/test_no_none.py
--rw-r--r--   0 runner    (1001) docker     (121)      752 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/syntax/test_print.py
--rw-r--r--   0 runner    (1001) docker     (121)      493 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/syntax/test_public.py
--rw-r--r--   0 runner    (1001) docker     (121)     2009 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/syntax/test_raw_call.py
--rw-r--r--   0 runner    (1001) docker     (121)     4177 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/syntax/test_return_tuple.py
--rw-r--r--   0 runner    (1001) docker     (121)      799 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/syntax/test_self_balance.py
--rw-r--r--   0 runner    (1001) docker     (121)      576 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/syntax/test_selfdestruct.py
--rw-r--r--   0 runner    (1001) docker     (121)     2004 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/syntax/test_send.py
--rw-r--r--   0 runner    (1001) docker     (121)     1103 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/syntax/test_slice.py
--rw-r--r--   0 runner    (1001) docker     (121)      607 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/syntax/test_string.py
--rw-r--r--   0 runner    (1001) docker     (121)     7933 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/syntax/test_structs.py
--rw-r--r--   0 runner    (1001) docker     (121)     2281 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/syntax/test_tuple_assign.py
--rw-r--r--   0 runner    (1001) docker     (121)     2305 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/syntax/test_unbalanced_return.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.533465 vyper-0.3.7/tests/parser/syntax/utils/
--rw-r--r--   0 runner    (1001) docker     (121)     2322 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/syntax/utils/test_event_names.py
--rw-r--r--   0 runner    (1001) docker     (121)     1382 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/syntax/utils/test_function_names.py
--rw-r--r--   0 runner    (1001) docker     (121)     1509 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/syntax/utils/test_variable_names.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.537465 vyper-0.3.7/tests/parser/types/
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.537465 vyper-0.3.7/tests/parser/types/numbers/
--rw-r--r--   0 runner    (1001) docker     (121)     5530 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/types/numbers/test_constants.py
--rw-r--r--   0 runner    (1001) docker     (121)     5826 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/types/numbers/test_decimals.py
--rw-r--r--   0 runner    (1001) docker     (121)     3089 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/types/numbers/test_isqrt.py
--rw-r--r--   0 runner    (1001) docker     (121)     9651 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/types/numbers/test_signed_ints.py
--rw-r--r--   0 runner    (1001) docker     (121)     4111 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/types/numbers/test_sqrt.py
--rw-r--r--   0 runner    (1001) docker     (121)     7408 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/types/numbers/test_unsigned_ints.py
--rw-r--r--   0 runner    (1001) docker     (121)     7436 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/types/test_bytes.py
--rw-r--r--   0 runner    (1001) docker     (121)     2282 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/types/test_bytes_literal.py
--rw-r--r--   0 runner    (1001) docker     (121)      911 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/types/test_bytes_zero_padding.py
--rw-r--r--   0 runner    (1001) docker     (121)    47710 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/types/test_dynamic_array.py
--rw-r--r--   0 runner    (1001) docker     (121)     5790 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/types/test_enum.py
--rwxr-xr-x   0 runner    (1001) docker     (121)     1992 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/types/test_identifier_naming.py
--rw-r--r--   0 runner    (1001) docker     (121)    22690 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/types/test_lists.py
--rw-r--r--   0 runner    (1001) docker     (121)     1946 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/types/test_node_types.py
--rw-r--r--   0 runner    (1001) docker     (121)     9423 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/types/test_string.py
--rw-r--r--   0 runner    (1001) docker     (121)     1014 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/types/test_string_literal.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.537465 vyper-0.3.7/tests/parser/types/value/
--rw-r--r--   0 runner    (1001) docker     (121)     2345 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/parser/types/value/test_as_wei_value.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.537465 vyper-0.3.7/tests/signatures/
--rw-r--r--   0 runner    (1001) docker     (121)      446 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/signatures/test_invalid_function_decorators.py
--rw-r--r--   0 runner    (1001) docker     (121)     1032 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/signatures/test_method_id_conflicts.py
--rw-r--r--   0 runner    (1001) docker     (121)     6342 2022-09-27 01:21:57.000000 vyper-0.3.7/tests/test_utils.py
--rw-r--r--   0 runner    (1001) docker     (121)     1273 2022-09-27 01:21:57.000000 vyper-0.3.7/tox.ini
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.537465 vyper-0.3.7/vyper/
--rw-r--r--   0 runner    (1001) docker     (121)      767 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/__init__.py
--rw-r--r--   0 runner    (1001) docker     (121)      726 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/__main__.py
--rw-r--r--   0 runner    (1001) docker     (121)     8162 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/abi_types.py
--rw-r--r--   0 runner    (1001) docker     (121)     1877 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/address_space.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.541465 vyper-0.3.7/vyper/ast/
--rw-r--r--   0 runner    (1001) docker     (121)     5821 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/ast/README.md
--rw-r--r--   0 runner    (1001) docker     (121)      493 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/ast/__init__.py
--rw-r--r--   0 runner    (1001) docker     (121)      285 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/ast/__init__.pyi
--rw-r--r--   0 runner    (1001) docker     (121)     9793 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/ast/annotation.py
--rw-r--r--   0 runner    (1001) docker     (121)     4593 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/ast/expansion.py
--rw-r--r--   0 runner    (1001) docker     (121)     9235 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/ast/folding.py
--rw-r--r--   0 runner    (1001) docker     (121)     9587 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/ast/grammar.lark
--rw-r--r--   0 runner    (1001) docker     (121)      827 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/ast/grammar.py
--rw-r--r--   0 runner    (1001) docker     (121)     4850 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/ast/natspec.py
--rw-r--r--   0 runner    (1001) docker     (121)    41696 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/ast/nodes.py
--rw-r--r--   0 runner    (1001) docker     (121)     5283 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/ast/nodes.pyi
--rw-r--r--   0 runner    (1001) docker     (121)     4688 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/ast/pre_parser.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.541465 vyper-0.3.7/vyper/ast/signatures/
--rw-r--r--   0 runner    (1001) docker     (121)       77 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/ast/signatures/__init__.py
--rw-r--r--   0 runner    (1001) docker     (121)     7596 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/ast/signatures/function_signature.py
--rw-r--r--   0 runner    (1001) docker     (121)     4923 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/ast/signatures/interface.py
--rw-r--r--   0 runner    (1001) docker     (121)     2794 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/ast/utils.py
--rw-r--r--   0 runner    (1001) docker     (121)     4084 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/ast/validation.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.541465 vyper-0.3.7/vyper/builtin_functions/
--rw-r--r--   0 runner    (1001) docker     (121)       39 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/builtin_functions/__init__.py
--rw-r--r--   0 runner    (1001) docker     (121)    17193 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/builtin_functions/convert.py
--rw-r--r--   0 runner    (1001) docker     (121)    93402 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/builtin_functions/functions.py
--rw-r--r--   0 runner    (1001) docker     (121)     5564 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/builtin_functions/signatures.py
--rw-r--r--   0 runner    (1001) docker     (121)     1950 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/builtin_functions/utils.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.541465 vyper-0.3.7/vyper/builtin_interfaces/
--rw-r--r--   0 runner    (1001) docker     (121)      103 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/builtin_interfaces/ERC165.py
--rw-r--r--   0 runner    (1001) docker     (121)      689 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/builtin_interfaces/ERC20.py
--rw-r--r--   0 runner    (1001) docker     (121)      477 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/builtin_interfaces/ERC20Detailed.py
--rw-r--r--   0 runner    (1001) docker     (121)     1510 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/builtin_interfaces/ERC4626.py
--rw-r--r--   0 runner    (1001) docker     (121)     1072 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/builtin_interfaces/ERC721.py
--rw-r--r--   0 runner    (1001) docker     (121)        0 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/builtin_interfaces/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.541465 vyper-0.3.7/vyper/cli/
--rw-r--r--   0 runner    (1001) docker     (121)        0 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/cli/__init__.py
--rw-r--r--   0 runner    (1001) docker     (121)     2540 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/cli/utils.py
--rwxr-xr-x   0 runner    (1001) docker     (121)    11056 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/cli/vyper_compile.py
--rwxr-xr-x   0 runner    (1001) docker     (121)     1894 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/cli/vyper_ir.py
--rwxr-xr-x   0 runner    (1001) docker     (121)    18509 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/cli/vyper_json.py
--rwxr-xr-x   0 runner    (1001) docker     (121)     3741 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/cli/vyper_serve.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.545465 vyper-0.3.7/vyper/codegen/
--rw-r--r--   0 runner    (1001) docker     (121)        0 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/codegen/__init__.py
--rw-r--r--   0 runner    (1001) docker     (121)     9252 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/codegen/abi_encoder.py
--rw-r--r--   0 runner    (1001) docker     (121)    13552 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/codegen/arithmetic.py
--rw-r--r--   0 runner    (1001) docker     (121)     8718 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/codegen/context.py
--rw-r--r--   0 runner    (1001) docker     (121)    37461 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/codegen/core.py
--rw-r--r--   0 runner    (1001) docker     (121)     2443 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/codegen/events.py
--rw-r--r--   0 runner    (1001) docker     (121)    29408 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/codegen/expr.py
--rw-r--r--   0 runner    (1001) docker     (121)     8583 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/codegen/external_call.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.545465 vyper-0.3.7/vyper/codegen/function_definitions/
--rw-r--r--   0 runner    (1001) docker     (121)       53 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/codegen/function_definitions/__init__.py
--rw-r--r--   0 runner    (1001) docker     (121)     2959 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/codegen/function_definitions/common.py
--rw-r--r--   0 runner    (1001) docker     (121)     8103 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/codegen/function_definitions/external_function.py
--rw-r--r--   0 runner    (1001) docker     (121)     2744 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/codegen/function_definitions/internal_function.py
--rw-r--r--   0 runner    (1001) docker     (121)      911 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/codegen/function_definitions/utils.py
--rw-r--r--   0 runner    (1001) docker     (121)     7776 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/codegen/global_context.py
--rw-r--r--   0 runner    (1001) docker     (121)    21304 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/codegen/ir_node.py
--rw-r--r--   0 runner    (1001) docker     (121)     1807 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/codegen/keccak256_helper.py
--rw-r--r--   0 runner    (1001) docker     (121)     4957 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/codegen/memory_allocator.py
--rw-r--r--   0 runner    (1001) docker     (121)     9572 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/codegen/module.py
--rw-r--r--   0 runner    (1001) docker     (121)     3445 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/codegen/return_.py
--rw-r--r--   0 runner    (1001) docker     (121)     3820 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/codegen/self_call.py
--rw-r--r--   0 runner    (1001) docker     (121)    15811 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/codegen/stmt.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.545465 vyper-0.3.7/vyper/codegen/types/
--rw-r--r--   0 runner    (1001) docker     (121)       34 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/codegen/types/__init__.py
--rw-r--r--   0 runner    (1001) docker     (121)     2054 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/codegen/types/convert.py
--rw-r--r--   0 runner    (1001) docker     (121)    16053 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/codegen/types/types.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.545465 vyper-0.3.7/vyper/compiler/
--rw-r--r--   0 runner    (1001) docker     (121)     4040 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/compiler/README.md
--rw-r--r--   0 runner    (1001) docker     (121)     7552 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/compiler/__init__.py
--rw-r--r--   0 runner    (1001) docker     (121)    10387 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/compiler/output.py
--rw-r--r--   0 runner    (1001) docker     (121)    10546 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/compiler/phases.py
--rw-r--r--   0 runner    (1001) docker     (121)      484 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/compiler/settings.py
--rw-r--r--   0 runner    (1001) docker     (121)     1271 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/compiler/utils.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.545465 vyper-0.3.7/vyper/evm/
--rw-r--r--   0 runner    (1001) docker     (121)        0 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/evm/__init__.py
--rw-r--r--   0 runner    (1001) docker     (121)     9095 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/evm/opcodes.py
--rw-r--r--   0 runner    (1001) docker     (121)     9779 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/exceptions.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.545465 vyper-0.3.7/vyper/ir/
--rw-r--r--   0 runner    (1001) docker     (121)     8791 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/ir/README.md
--rw-r--r--   0 runner    (1001) docker     (121)        0 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/ir/__init__.py
--rw-r--r--   0 runner    (1001) docker     (121)    39171 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/ir/compile_ir.py
--rw-r--r--   0 runner    (1001) docker     (121)    23351 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/ir/optimizer.py
--rwxr-xr-x   0 runner    (1001) docker     (121)     1076 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/ir/s_expressions.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.545465 vyper-0.3.7/vyper/semantics/
--rw-r--r--   0 runner    (1001) docker     (121)    10999 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/semantics/README.md
--rw-r--r--   0 runner    (1001) docker     (121)      101 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/semantics/__init__.py
--rw-r--r--   0 runner    (1001) docker     (121)     1800 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/semantics/environment.py
--rw-r--r--   0 runner    (1001) docker     (121)     5129 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/semantics/namespace.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.545465 vyper-0.3.7/vyper/semantics/types/
--rw-r--r--   0 runner    (1001) docker     (121)     1632 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/semantics/types/__init__.py
--rw-r--r--   0 runner    (1001) docker     (121)     3081 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/semantics/types/abstract.py
--rw-r--r--   0 runner    (1001) docker     (121)    21953 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/semantics/types/bases.py
--rw-r--r--   0 runner    (1001) docker     (121)    23510 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/semantics/types/function.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.549466 vyper-0.3.7/vyper/semantics/types/indexable/
--rw-r--r--   0 runner    (1001) docker     (121)       32 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/semantics/types/indexable/__init__.py
--rw-r--r--   0 runner    (1001) docker     (121)     2303 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/semantics/types/indexable/mapping.py
--rw-r--r--   0 runner    (1001) docker     (121)    10559 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/semantics/types/indexable/sequence.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.549466 vyper-0.3.7/vyper/semantics/types/user/
--rw-r--r--   0 runner    (1001) docker     (121)      132 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/semantics/types/user/__init__.py
--rw-r--r--   0 runner    (1001) docker     (121)     4649 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/semantics/types/user/enum.py
--rw-r--r--   0 runner    (1001) docker     (121)     4719 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/semantics/types/user/event.py
--rw-r--r--   0 runner    (1001) docker     (121)     8352 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/semantics/types/user/interface.py
--rw-r--r--   0 runner    (1001) docker     (121)     5712 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/semantics/types/user/struct.py
--rw-r--r--   0 runner    (1001) docker     (121)     8595 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/semantics/types/utils.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.549466 vyper-0.3.7/vyper/semantics/types/value/
--rw-r--r--   0 runner    (1001) docker     (121)       66 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/semantics/types/value/__init__.py
--rw-r--r--   0 runner    (1001) docker     (121)     1701 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/semantics/types/value/address.py
--rw-r--r--   0 runner    (1001) docker     (121)     5910 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/semantics/types/value/array_value.py
--rw-r--r--   0 runner    (1001) docker     (121)     1069 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/semantics/types/value/boolean.py
--rw-r--r--   0 runner    (1001) docker     (121)     1907 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/semantics/types/value/bytes_fixed.py
--rw-r--r--   0 runner    (1001) docker     (121)     6225 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/semantics/types/value/numeric.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.549466 vyper-0.3.7/vyper/semantics/validation/
--rw-r--r--   0 runner    (1001) docker     (121)      333 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/semantics/validation/__init__.py
--rw-r--r--   0 runner    (1001) docker     (121)    10268 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/semantics/validation/annotation.py
--rw-r--r--   0 runner    (1001) docker     (121)      565 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/semantics/validation/base.py
--rw-r--r--   0 runner    (1001) docker     (121)     8297 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/semantics/validation/data_positions.py
--rw-r--r--   0 runner    (1001) docker     (121)     5273 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/semantics/validation/levenshtein_utils.py
--rw-r--r--   0 runner    (1001) docker     (121)    23485 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/semantics/validation/local.py
--rw-r--r--   0 runner    (1001) docker     (121)    13013 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/semantics/validation/module.py
--rw-r--r--   0 runner    (1001) docker     (121)    18616 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/semantics/validation/utils.py
--rw-r--r--   0 runner    (1001) docker     (121)      766 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/typing.py
--rw-r--r--   0 runner    (1001) docker     (121)    12987 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/utils.py
--rw-r--r--   0 runner    (1001) docker     (121)      176 2022-09-27 01:22:10.000000 vyper-0.3.7/vyper/version.py
--rw-r--r--   0 runner    (1001) docker     (121)        7 2022-09-27 01:22:05.000000 vyper-0.3.7/vyper/vyper_git_commithash.txt
--rw-r--r--   0 runner    (1001) docker     (121)      133 2022-09-27 01:21:57.000000 vyper-0.3.7/vyper/warnings.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2022-09-27 01:22:10.537465 vyper-0.3.7/vyper.egg-info/
--rw-r--r--   0 runner    (1001) docker     (121)     3570 2022-09-27 01:22:10.000000 vyper-0.3.7/vyper.egg-info/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (121)    16247 2022-09-27 01:22:10.000000 vyper-0.3.7/vyper.egg-info/SOURCES.txt
--rw-r--r--   0 runner    (1001) docker     (121)        1 2022-09-27 01:22:10.000000 vyper-0.3.7/vyper.egg-info/dependency_links.txt
--rw-r--r--   0 runner    (1001) docker     (121)      210 2022-09-27 01:22:10.000000 vyper-0.3.7/vyper.egg-info/entry_points.txt
--rw-r--r--   0 runner    (1001) docker     (121)     1089 2022-09-27 01:22:10.000000 vyper-0.3.7/vyper.egg-info/requires.txt
--rw-r--r--   0 runner    (1001) docker     (121)       12 2022-09-27 01:22:10.000000 vyper-0.3.7/vyper.egg-info/top_level.txt
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.587607 vyper-0.3.8/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.527604 vyper-0.3.8/.github/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.527604 vyper-0.3.8/.github/ISSUE_TEMPLATE/
+-rw-r--r--   0 runner    (1001) docker     (123)      689 2023-05-23 15:01:16.000000 vyper-0.3.8/.github/ISSUE_TEMPLATE/bug.md
+-rw-r--r--   0 runner    (1001) docker     (123)     1308 2023-05-23 15:01:16.000000 vyper-0.3.8/.github/ISSUE_TEMPLATE/vip.md
+-rw-r--r--   0 runner    (1001) docker     (123)      453 2023-05-23 15:01:16.000000 vyper-0.3.8/.github/PULL_REQUEST_TEMPLATE.md
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.527604 vyper-0.3.8/.github/workflows/
+-rw-r--r--   0 runner    (1001) docker     (123)     1659 2023-05-23 15:01:16.000000 vyper-0.3.8/.github/workflows/build.yml
+-rw-r--r--   0 runner    (1001) docker     (123)      687 2023-05-23 15:01:16.000000 vyper-0.3.8/.github/workflows/codeql.yml
+-rw-r--r--   0 runner    (1001) docker     (123)     3375 2023-05-23 15:01:16.000000 vyper-0.3.8/.github/workflows/era-tester.yml
+-rw-r--r--   0 runner    (1001) docker     (123)     2207 2023-05-23 15:01:16.000000 vyper-0.3.8/.github/workflows/ghcr.yml
+-rw-r--r--   0 runner    (1001) docker     (123)      851 2023-05-23 15:01:16.000000 vyper-0.3.8/.github/workflows/publish.yml
+-rw-r--r--   0 runner    (1001) docker     (123)     5013 2023-05-23 15:01:16.000000 vyper-0.3.8/.github/workflows/test.yml
+-rw-r--r--   0 runner    (1001) docker     (123)      509 2023-05-23 15:01:16.000000 vyper-0.3.8/.gitignore
+-rw-r--r--   0 runner    (1001) docker     (123)      517 2023-05-23 15:01:16.000000 vyper-0.3.8/.pre-commit-config.yaml
+-rw-r--r--   0 runner    (1001) docker     (123)      493 2023-05-23 15:01:16.000000 vyper-0.3.8/.readthedocs.yaml
+-rw-r--r--   0 runner    (1001) docker     (123)     1147 2023-05-23 15:01:16.000000 vyper-0.3.8/Dockerfile
+-rw-r--r--   0 runner    (1001) docker     (123)       70 2023-05-23 15:01:16.000000 vyper-0.3.8/FUNDING.yml
+-rw-r--r--   0 runner    (1001) docker     (123)    11549 2023-05-23 15:01:17.000000 vyper-0.3.8/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)     1886 2023-05-23 15:01:17.000000 vyper-0.3.8/Makefile
+-rw-r--r--   0 runner    (1001) docker     (123)     3654 2023-05-23 15:01:34.587607 vyper-0.3.8/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)     3006 2023-05-23 15:01:17.000000 vyper-0.3.8/README.md
+-rw-r--r--   0 runner    (1001) docker     (123)     3315 2023-05-23 15:01:17.000000 vyper-0.3.8/SECURITY.md
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.535604 vyper-0.3.8/docs/
+-rw-r--r--   0 runner    (1001) docker     (123)      605 2023-05-23 15:01:17.000000 vyper-0.3.8/docs/Makefile
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.519604 vyper-0.3.8/docs/_static/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.535604 vyper-0.3.8/docs/_static/css/
+-rw-r--r--   0 runner    (1001) docker     (123)     2977 2023-05-23 15:01:17.000000 vyper-0.3.8/docs/_static/css/dark.css
+-rw-r--r--   0 runner    (1001) docker     (123)     1454 2023-05-23 15:01:17.000000 vyper-0.3.8/docs/_static/css/toggle.css
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.535604 vyper-0.3.8/docs/_static/js/
+-rw-r--r--   0 runner    (1001) docker     (123)      791 2023-05-23 15:01:17.000000 vyper-0.3.8/docs/_static/js/toggle.js
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.535604 vyper-0.3.8/docs/_templates/
+-rw-r--r--   0 runner    (1001) docker     (123)     1429 2023-05-23 15:01:17.000000 vyper-0.3.8/docs/_templates/versions.html
+-rw-r--r--   0 runner    (1001) docker     (123)    36099 2023-05-23 15:01:17.000000 vyper-0.3.8/docs/built-in-functions.rst
+-rw-r--r--   0 runner    (1001) docker     (123)     6880 2023-05-23 15:01:17.000000 vyper-0.3.8/docs/compiler-exceptions.rst
+-rw-r--r--   0 runner    (1001) docker     (123)    12605 2023-05-23 15:01:17.000000 vyper-0.3.8/docs/compiling-a-contract.rst
+-rw-r--r--   0 runner    (1001) docker     (123)     5918 2023-05-23 15:01:17.000000 vyper-0.3.8/docs/conf.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3937 2023-05-23 15:01:17.000000 vyper-0.3.8/docs/constants-and-vars.rst
+-rw-r--r--   0 runner    (1001) docker     (123)     3283 2023-05-23 15:01:17.000000 vyper-0.3.8/docs/contributing.rst
+-rw-r--r--   0 runner    (1001) docker     (123)    11980 2023-05-23 15:01:17.000000 vyper-0.3.8/docs/control-structures.rst
+-rw-r--r--   0 runner    (1001) docker     (123)     1038 2023-05-23 15:01:17.000000 vyper-0.3.8/docs/deploying-contracts.rst
+-rw-r--r--   0 runner    (1001) docker     (123)     4498 2023-05-23 15:01:17.000000 vyper-0.3.8/docs/event-logging.rst
+-rw-r--r--   0 runner    (1001) docker     (123)     4310 2023-05-23 15:01:17.000000 vyper-0.3.8/docs/index.rst
+-rw-r--r--   0 runner    (1001) docker     (123)     3100 2023-05-23 15:01:17.000000 vyper-0.3.8/docs/installing-vyper.rst
+-rw-r--r--   0 runner    (1001) docker     (123)     8946 2023-05-23 15:01:17.000000 vyper-0.3.8/docs/interfaces.rst
+-rw-r--r--   0 runner    (1001) docker     (123)      803 2023-05-23 15:01:17.000000 vyper-0.3.8/docs/make.bat
+-rw-r--r--   0 runner    (1001) docker     (123)     5135 2023-05-23 15:01:17.000000 vyper-0.3.8/docs/natspec.rst
+-rw-r--r--   0 runner    (1001) docker     (123)    57259 2023-05-23 15:01:17.000000 vyper-0.3.8/docs/release-notes.rst
+-rw-r--r--   0 runner    (1001) docker     (123)     2406 2023-05-23 15:01:17.000000 vyper-0.3.8/docs/resources.rst
+-rw-r--r--   0 runner    (1001) docker     (123)     7889 2023-05-23 15:01:17.000000 vyper-0.3.8/docs/scoping-and-declarations.rst
+-rw-r--r--   0 runner    (1001) docker     (123)     3201 2023-05-23 15:01:17.000000 vyper-0.3.8/docs/statements.rst
+-rw-r--r--   0 runner    (1001) docker     (123)     3429 2023-05-23 15:01:17.000000 vyper-0.3.8/docs/structure-of-a-contract.rst
+-rw-r--r--   0 runner    (1001) docker     (123)    15593 2023-05-23 15:01:17.000000 vyper-0.3.8/docs/style-guide.rst
+-rw-r--r--   0 runner    (1001) docker     (123)     5723 2023-05-23 15:01:17.000000 vyper-0.3.8/docs/testing-contracts-brownie.rst
+-rw-r--r--   0 runner    (1001) docker     (123)     3440 2023-05-23 15:01:17.000000 vyper-0.3.8/docs/testing-contracts-ethtester.rst
+-rw-r--r--   0 runner    (1001) docker     (123)      670 2023-05-23 15:01:17.000000 vyper-0.3.8/docs/testing-contracts.rst
+-rw-r--r--   0 runner    (1001) docker     (123)      829 2023-05-23 15:01:17.000000 vyper-0.3.8/docs/toctree.rst
+-rw-r--r--   0 runner    (1001) docker     (123)    22576 2023-05-23 15:01:17.000000 vyper-0.3.8/docs/types.rst
+-rw-r--r--   0 runner    (1001) docker     (123)     7753 2023-05-23 15:01:17.000000 vyper-0.3.8/docs/versioning.rst
+-rw-r--r--   0 runner    (1001) docker     (123)    29136 2023-05-23 15:01:17.000000 vyper-0.3.8/docs/vyper-by-example.rst
+-rw-r--r--   0 runner    (1001) docker     (123)     1042 2023-05-23 15:01:17.000000 vyper-0.3.8/docs/vyper-logo-transparent.svg
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.535604 vyper-0.3.8/examples/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.535604 vyper-0.3.8/examples/auctions/
+-rw-r--r--   0 runner    (1001) docker     (123)     5666 2023-05-23 15:01:17.000000 vyper-0.3.8/examples/auctions/blind_auction.vy
+-rw-r--r--   0 runner    (1001) docker     (123)     3058 2023-05-23 15:01:17.000000 vyper-0.3.8/examples/auctions/simple_open_auction.vy
+-rw-r--r--   0 runner    (1001) docker     (123)     1186 2023-05-23 15:01:17.000000 vyper-0.3.8/examples/crowdfund.vy
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.535604 vyper-0.3.8/examples/factory/
+-rw-r--r--   0 runner    (1001) docker     (123)      927 2023-05-23 15:01:17.000000 vyper-0.3.8/examples/factory/Exchange.vy
+-rw-r--r--   0 runner    (1001) docker     (123)     1655 2023-05-23 15:01:17.000000 vyper-0.3.8/examples/factory/Factory.vy
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.535604 vyper-0.3.8/examples/market_maker/
+-rw-r--r--   0 runner    (1001) docker     (123)     1951 2023-05-23 15:01:17.000000 vyper-0.3.8/examples/market_maker/on_chain_market_maker.vy
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.535604 vyper-0.3.8/examples/name_registry/
+-rw-r--r--   0 runner    (1001) docker     (123)      306 2023-05-23 15:01:17.000000 vyper-0.3.8/examples/name_registry/name_registry.vy
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.535604 vyper-0.3.8/examples/safe_remote_purchase/
+-rw-r--r--   0 runner    (1001) docker     (123)     2178 2023-05-23 15:01:17.000000 vyper-0.3.8/examples/safe_remote_purchase/safe_remote_purchase.vy
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.535604 vyper-0.3.8/examples/stock/
+-rw-r--r--   0 runner    (1001) docker     (123)     4606 2023-05-23 15:01:17.000000 vyper-0.3.8/examples/stock/company.vy
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.535604 vyper-0.3.8/examples/storage/
+-rw-r--r--   0 runner    (1001) docker     (123)      405 2023-05-23 15:01:17.000000 vyper-0.3.8/examples/storage/advanced_storage.vy
+-rw-r--r--   0 runner    (1001) docker     (123)      141 2023-05-23 15:01:17.000000 vyper-0.3.8/examples/storage/storage.vy
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.535604 vyper-0.3.8/examples/tokens/
+-rw-r--r--   0 runner    (1001) docker     (123)    15232 2023-05-23 15:01:17.000000 vyper-0.3.8/examples/tokens/ERC1155ownable.vy
+-rw-r--r--   0 runner    (1001) docker     (123)     5167 2023-05-23 15:01:17.000000 vyper-0.3.8/examples/tokens/ERC20.vy
+-rw-r--r--   0 runner    (1001) docker     (123)     6361 2023-05-23 15:01:17.000000 vyper-0.3.8/examples/tokens/ERC4626.vy
+-rw-r--r--   0 runner    (1001) docker     (123)    13366 2023-05-23 15:01:17.000000 vyper-0.3.8/examples/tokens/ERC721.vy
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.535604 vyper-0.3.8/examples/voting/
+-rw-r--r--   0 runner    (1001) docker     (123)     5809 2023-05-23 15:01:17.000000 vyper-0.3.8/examples/voting/ballot.vy
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.535604 vyper-0.3.8/examples/wallet/
+-rw-r--r--   0 runner    (1001) docker     (123)     3106 2023-05-23 15:01:17.000000 vyper-0.3.8/examples/wallet/wallet.vy
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.535604 vyper-0.3.8/hooks/
+-rwxr-xr-x   0 runner    (1001) docker     (123)      265 2023-05-23 15:01:17.000000 vyper-0.3.8/hooks/build
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.539605 vyper-0.3.8/logo/
+-rw-r--r--   0 runner    (1001) docker     (123)    42373 2023-05-23 15:01:17.000000 vyper-0.3.8/logo/vyper-logo-flat.png
+-rw-r--r--   0 runner    (1001) docker     (123)      888 2023-05-23 15:01:17.000000 vyper-0.3.8/logo/vyper-logo-flat.svg
+-rw-r--r--   0 runner    (1001) docker     (123)    38259 2023-05-23 15:01:17.000000 vyper-0.3.8/logo/vyper-logo-transparent.png
+-rw-r--r--   0 runner    (1001) docker     (123)     1042 2023-05-23 15:01:17.000000 vyper-0.3.8/logo/vyper-logo-transparent.svg
+-rw-r--r--   0 runner    (1001) docker     (123)   647034 2023-05-23 15:01:17.000000 vyper-0.3.8/logo/vyper-logo.ai
+-rw-r--r--   0 runner    (1001) docker     (123)     1614 2023-05-23 15:01:17.000000 vyper-0.3.8/make.cmd
+-rw-r--r--   0 runner    (1001) docker     (123)      482 2023-05-23 15:01:17.000000 vyper-0.3.8/pyproject.toml
+-rwxr-xr-x   0 runner    (1001) docker     (123)      239 2023-05-23 15:01:17.000000 vyper-0.3.8/quicktest.sh
+-rw-r--r--   0 runner    (1001) docker     (123)       58 2023-05-23 15:01:17.000000 vyper-0.3.8/requirements-docs.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      740 2023-05-23 15:01:34.587607 vyper-0.3.8/setup.cfg
+-rw-r--r--   0 runner    (1001) docker     (123)     3786 2023-05-23 15:01:17.000000 vyper-0.3.8/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.539605 vyper-0.3.8/tests/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.539605 vyper-0.3.8/tests/ast/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.543605 vyper-0.3.8/tests/ast/nodes/
+-rw-r--r--   0 runner    (1001) docker     (123)      426 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/ast/nodes/test_binary.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1150 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/ast/nodes/test_compare_nodes.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2906 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/ast/nodes/test_evaluate_binop_decimal.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3725 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/ast/nodes/test_evaluate_binop_int.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1857 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/ast/nodes/test_evaluate_boolop.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3492 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/ast/nodes/test_evaluate_compare.py
+-rw-r--r--   0 runner    (1001) docker     (123)      685 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/ast/nodes/test_evaluate_subscript.py
+-rw-r--r--   0 runner    (1001) docker     (123)      972 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/ast/nodes/test_evaluate_unaryop.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1038 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/ast/nodes/test_from_node.py
+-rw-r--r--   0 runner    (1001) docker     (123)      845 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/ast/nodes/test_get_children.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2245 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/ast/nodes/test_get_descendants.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1070 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/ast/nodes/test_hex.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2179 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/ast/nodes/test_replace_in_tree.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8341 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/ast/test_folding.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8938 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/ast/test_natspec.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2573 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/ast/test_pre_parser.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7915 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/base_conftest.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.523604 vyper-0.3.8/tests/builtins/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.543605 vyper-0.3.8/tests/builtins/folding/
+-rw-r--r--   0 runner    (1001) docker     (123)     1522 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/builtins/folding/test_abs.py
+-rw-r--r--   0 runner    (1001) docker     (123)      877 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/builtins/folding/test_addmod_mulmod.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3449 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/builtins/folding/test_bitwise.py
+-rw-r--r--   0 runner    (1001) docker     (123)      526 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/builtins/folding/test_epsilon.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1029 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/builtins/folding/test_floor_ceil.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1538 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/builtins/folding/test_fold_as_wei_value.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2085 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/builtins/folding/test_keccak_sha.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1459 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/builtins/folding/test_len.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2259 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/builtins/folding/test_min_max.py
+-rw-r--r--   0 runner    (1001) docker     (123)      720 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/builtins/folding/test_powmod.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.523604 vyper-0.3.8/tests/cli/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.543605 vyper-0.3.8/tests/cli/outputs/
+-rw-r--r--   0 runner    (1001) docker     (123)     1556 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/cli/outputs/test_storage_layout.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3042 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/cli/outputs/test_storage_layout_overrides.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.543605 vyper-0.3.8/tests/cli/vyper_compile/
+-rw-r--r--   0 runner    (1001) docker     (123)     1514 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/cli/vyper_compile/test_compile_files.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8045 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/cli/vyper_compile/test_import_paths.py
+-rw-r--r--   0 runner    (1001) docker     (123)      617 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/cli/vyper_compile/test_parse_args.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.547605 vyper-0.3.8/tests/cli/vyper_json/
+-rw-r--r--   0 runner    (1001) docker     (123)     4284 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/cli/vyper_json/test_compile_from_input_dict.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1382 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/cli/vyper_json/test_compile_json.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1940 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/cli/vyper_json/test_get_contracts.py
+-rw-r--r--   0 runner    (1001) docker     (123)      816 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/cli/vyper_json/test_get_settings.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3724 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/cli/vyper_json/test_interfaces.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1384 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/cli/vyper_json/test_output_dict.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1881 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/cli/vyper_json/test_output_selection.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2836 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/cli/vyper_json/test_parse_args_vyperjson.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.547605 vyper-0.3.8/tests/compiler/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/compiler/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.547605 vyper-0.3.8/tests/compiler/asm/
+-rw-r--r--   0 runner    (1001) docker     (123)     1171 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/compiler/asm/test_asm_optimizer.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.547605 vyper-0.3.8/tests/compiler/ir/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/compiler/ir/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1908 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/compiler/ir/test_compile_ir.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10166 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/compiler/ir/test_optimize_ir.py
+-rw-r--r--   0 runner    (1001) docker     (123)      392 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/compiler/ir/test_repeat.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13843 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/compiler/ir/test_with.py
+-rw-r--r--   0 runner    (1001) docker     (123)      306 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/compiler/test_bytecode_runtime.py
+-rw-r--r--   0 runner    (1001) docker     (123)      125 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/compiler/test_calldatacopy.py
+-rw-r--r--   0 runner    (1001) docker     (123)    24862 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/compiler/test_compile_code.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1986 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/compiler/test_opcodes.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2366 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/compiler/test_pre_parser.py
+-rw-r--r--   0 runner    (1001) docker     (123)      527 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/compiler/test_sha3_32.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3211 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/compiler/test_source_map.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7070 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/conftest.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.547605 vyper-0.3.8/tests/examples/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.547605 vyper-0.3.8/tests/examples/auctions/
+-rw-r--r--   0 runner    (1001) docker     (123)    12478 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/examples/auctions/test_blind_auction.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4249 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/examples/auctions/test_simple_open_auction.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.547605 vyper-0.3.8/tests/examples/company/
+-rw-r--r--   0 runner    (1001) docker     (123)     4430 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/examples/company/test_company.py
+-rw-r--r--   0 runner    (1001) docker     (123)       81 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/examples/conftest.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.547605 vyper-0.3.8/tests/examples/crowdfund/
+-rw-r--r--   0 runner    (1001) docker     (123)     1826 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/examples/crowdfund/test_crowdfund_example.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.551605 vyper-0.3.8/tests/examples/factory/
+-rw-r--r--   0 runner    (1001) docker     (123)     2071 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/examples/factory/test_factory.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.551605 vyper-0.3.8/tests/examples/market_maker/
+-rw-r--r--   0 runner    (1001) docker     (123)     4647 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/examples/market_maker/test_on_chain_market_maker.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.551605 vyper-0.3.8/tests/examples/name_registry/
+-rw-r--r--   0 runner    (1001) docker     (123)      346 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/examples/name_registry/test_name_registry.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.551605 vyper-0.3.8/tests/examples/safe_remote_purchase/
+-rw-r--r--   0 runner    (1001) docker     (123)     5655 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/examples/safe_remote_purchase/test_safe_remote_purchase.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.551605 vyper-0.3.8/tests/examples/storage/
+-rw-r--r--   0 runner    (1001) docker     (123)     2402 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/examples/storage/test_advanced_storage.py
+-rw-r--r--   0 runner    (1001) docker     (123)      863 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/examples/storage/test_storage.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.551605 vyper-0.3.8/tests/examples/tokens/
+-rw-r--r--   0 runner    (1001) docker     (123)    14584 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/examples/tokens/test_erc1155.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14626 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/examples/tokens/test_erc20.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3376 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/examples/tokens/test_erc4626.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11525 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/examples/tokens/test_erc721.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.551605 vyper-0.3.8/tests/examples/voting/
+-rw-r--r--   0 runner    (1001) docker     (123)     9261 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/examples/voting/test_ballot.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.551605 vyper-0.3.8/tests/examples/wallet/
+-rw-r--r--   0 runner    (1001) docker     (123)     4756 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/examples/wallet/test_wallet.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.551605 vyper-0.3.8/tests/fixtures/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/fixtures/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1679 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/fixtures/memorymock.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.551605 vyper-0.3.8/tests/functional/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.551605 vyper-0.3.8/tests/functional/codegen/
+-rw-r--r--   0 runner    (1001) docker     (123)     2552 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/functional/codegen/test_struct_return.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1089 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/functional/codegen/test_tuple_return.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.551605 vyper-0.3.8/tests/functional/semantics/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.551605 vyper-0.3.8/tests/functional/semantics/analysis/
+-rw-r--r--   0 runner    (1001) docker     (123)     1891 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/functional/semantics/analysis/test_array_index.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1581 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/functional/semantics/analysis/test_cyclic_function_calls.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2567 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/functional/semantics/analysis/test_for_loop.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7055 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/functional/semantics/analysis/test_potential_types.py
+-rw-r--r--   0 runner    (1001) docker     (123)      736 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/functional/semantics/conftest.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2618 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/functional/semantics/test_namespace.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.555605 vyper-0.3.8/tests/functional/semantics/types/
+-rw-r--r--   0 runner    (1001) docker     (123)     2596 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/functional/semantics/types/test_event.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4079 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/functional/semantics/types/test_pure_types.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1797 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/functional/semantics/types/test_size_in_bytes.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1119 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/functional/semantics/types/test_type_from_abi.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3364 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/functional/semantics/types/test_type_from_annotation.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3147 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/functional/test_storage_slots.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.555605 vyper-0.3.8/tests/fuzzing/
+-rw-r--r--   0 runner    (1001) docker     (123)     3540 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/fuzzing/test_exponents.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.555605 vyper-0.3.8/tests/grammar/
+-rw-r--r--   0 runner    (1001) docker     (123)     3655 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/grammar/test_grammar.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.555605 vyper-0.3.8/tests/parser/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.555605 vyper-0.3.8/tests/parser/ast_utils/
+-rw-r--r--   0 runner    (1001) docker     (123)      561 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/ast_utils/test_ast.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3510 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/ast_utils/test_ast_dict.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.559605 vyper-0.3.8/tests/parser/exceptions/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/exceptions/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1685 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/exceptions/test_argument_exception.py
+-rw-r--r--   0 runner    (1001) docker     (123)      547 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/exceptions/test_call_violation.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2220 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/exceptions/test_constancy_exception.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1112 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/exceptions/test_function_declaration_exception.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1177 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/exceptions/test_instantiation_exception.py
+-rw-r--r--   0 runner    (1001) docker     (123)      967 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/exceptions/test_invalid_literal_exception.py
+-rw-r--r--   0 runner    (1001) docker     (123)      709 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/exceptions/test_invalid_payable.py
+-rw-r--r--   0 runner    (1001) docker     (123)      685 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/exceptions/test_invalid_reference.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1468 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/exceptions/test_invalid_type_exception.py
+-rw-r--r--   0 runner    (1001) docker     (123)      957 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/exceptions/test_namespace_collision.py
+-rw-r--r--   0 runner    (1001) docker     (123)      945 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/exceptions/test_overflow_exception.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2098 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/exceptions/test_structure_exception.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1591 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/exceptions/test_syntax_exception.py
+-rw-r--r--   0 runner    (1001) docker     (123)      617 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/exceptions/test_type_mismatch_exception.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1121 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/exceptions/test_undeclared_definition.py
+-rw-r--r--   0 runner    (1001) docker     (123)      602 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/exceptions/test_variable_declaration_exception.py
+-rw-r--r--   0 runner    (1001) docker     (123)      689 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/exceptions/test_vyper_exception_pos.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.563606 vyper-0.3.8/tests/parser/features/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.563606 vyper-0.3.8/tests/parser/features/arithmetic/
+-rw-r--r--   0 runner    (1001) docker     (123)      703 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/features/arithmetic/test_division.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1942 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/features/arithmetic/test_modulo.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.563606 vyper-0.3.8/tests/parser/features/decorators/
+-rw-r--r--   0 runner    (1001) docker     (123)     6830 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/features/decorators/test_nonreentrant.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6212 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/features/decorators/test_payable.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14672 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/features/decorators/test_private.py
+-rw-r--r--   0 runner    (1001) docker     (123)      636 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/features/decorators/test_public.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2435 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/features/decorators/test_pure.py
+-rw-r--r--   0 runner    (1001) docker     (123)      678 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/features/decorators/test_view.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.563606 vyper-0.3.8/tests/parser/features/external_contracts/
+-rw-r--r--   0 runner    (1001) docker     (123)     4232 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/features/external_contracts/test_erc20_abi.py
+-rw-r--r--   0 runner    (1001) docker     (123)    58262 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/features/external_contracts/test_external_contract_calls.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6674 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/features/external_contracts/test_modifiable_external_contract_calls.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1507 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/features/external_contracts/test_self_call_struct.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.563606 vyper-0.3.8/tests/parser/features/iteration/
+-rw-r--r--   0 runner    (1001) docker     (123)     2662 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/features/iteration/test_break.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1777 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/features/iteration/test_continue.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14417 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/features/iteration/test_for_in_list.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6702 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/features/iteration/test_for_range.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3934 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/features/iteration/test_range_in.py
+-rw-r--r--   0 runner    (1001) docker     (123)      456 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/features/test_address_balance.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4980 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/features/test_assert.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1643 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/features/test_assert_unreachable.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6151 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/features/test_assignment.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4226 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/features/test_bytes_map_keys.py
+-rw-r--r--   0 runner    (1001) docker     (123)    17561 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/features/test_clampers.py
+-rw-r--r--   0 runner    (1001) docker     (123)      261 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/features/test_comments.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1588 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/features/test_comparison.py
+-rw-r--r--   0 runner    (1001) docker     (123)      949 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/features/test_conditionals.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5808 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/features/test_constructor.py
+-rw-r--r--   0 runner    (1001) docker     (123)      276 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/features/test_gas.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7656 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/features/test_immutable.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1692 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/features/test_init.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15761 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/features/test_internal_call.py
+-rw-r--r--   0 runner    (1001) docker     (123)    33790 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/features/test_logging.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3114 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/features/test_logging_bytes_extended.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4641 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/features/test_logging_from_call.py
+-rw-r--r--   0 runner    (1001) docker     (123)      529 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/features/test_memory_dealloc.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1282 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/features/test_packing.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1678 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/features/test_reverting.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3601 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/features/test_short_circuiting.py
+-rw-r--r--   0 runner    (1001) docker     (123)      554 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/features/test_string_map_keys.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6665 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/features/test_ternary.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1879 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/features/test_transient.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.571606 vyper-0.3.8/tests/parser/functions/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/functions/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4126 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/functions/test_abi.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12558 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/functions/test_abi_decode.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12026 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/functions/test_abi_encode.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1384 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/functions/test_addmod.py
+-rw-r--r--   0 runner    (1001) docker     (123)      755 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/functions/test_as_wei_value.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4667 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/functions/test_bitwise.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1214 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/functions/test_block.py
+-rw-r--r--   0 runner    (1001) docker     (123)      312 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/functions/test_block_number.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2788 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/functions/test_ceil.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5364 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/functions/test_concat.py
+-rw-r--r--   0 runner    (1001) docker     (123)    19453 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/functions/test_convert.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11678 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/functions/test_create_functions.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5878 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/functions/test_default_function.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9307 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/functions/test_default_parameters.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3531 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/functions/test_ec.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1633 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/functions/test_ecrecover.py
+-rw-r--r--   0 runner    (1001) docker     (123)    16817 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/functions/test_empty.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2431 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/functions/test_extract32.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2850 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/functions/test_floor.py
+-rw-r--r--   0 runner    (1001) docker     (123)    16188 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/functions/test_interfaces.py
+-rw-r--r--   0 runner    (1001) docker     (123)      695 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/functions/test_is_contract.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2306 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/functions/test_keccak256.py
+-rw-r--r--   0 runner    (1001) docker     (123)      751 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/functions/test_length.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1768 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/functions/test_method_id.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6352 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/functions/test_minmax.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1730 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/functions/test_minmax_value.py
+-rw-r--r--   0 runner    (1001) docker     (123)      934 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/functions/test_mkstr.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1906 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/functions/test_mulmod.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10546 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/functions/test_raw_call.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1173 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/functions/test_return.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8794 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/functions/test_return_struct.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4562 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/functions/test_return_tuple.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2455 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/functions/test_send.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1797 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/functions/test_sha256.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10390 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/functions/test_slice.py
+-rw-r--r--   0 runner    (1001) docker     (123)      233 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/functions/test_tx.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1978 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/functions/test_unary.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2035 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/functions/test_unsafe_math.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.571606 vyper-0.3.8/tests/parser/globals/
+-rw-r--r--   0 runner    (1001) docker     (123)     2212 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/globals/test_getters.py
+-rw-r--r--   0 runner    (1001) docker     (123)      752 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/globals/test_globals.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6529 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/globals/test_setters.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.571606 vyper-0.3.8/tests/parser/integration/
+-rw-r--r--   0 runner    (1001) docker     (123)      399 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/integration/test_basics.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5402 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/integration/test_crowdfund.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1870 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/integration/test_escrow.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.571606 vyper-0.3.8/tests/parser/parser_utils/
+-rw-r--r--   0 runner    (1001) docker     (123)     1703 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/parser_utils/test_annotate_and_optimize_ast.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.575606 vyper-0.3.8/tests/parser/syntax/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/syntax/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2154 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/syntax/test_abi_encode.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6164 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/syntax/test_address_code.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2670 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/syntax/test_ann_assign.py
+-rw-r--r--   0 runner    (1001) docker     (123)      696 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/syntax/test_as_uint256.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1401 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/syntax/test_as_wei_value.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2908 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/syntax/test_block.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1706 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/syntax/test_blockscope.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3675 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/syntax/test_bool.py
+-rw-r--r--   0 runner    (1001) docker     (123)      906 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/syntax/test_bool_ops.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2121 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/syntax/test_bytes.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2286 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/syntax/test_chainid.py
+-rw-r--r--   0 runner    (1001) docker     (123)      844 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/syntax/test_code_size.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1398 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/syntax/test_codehash.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2672 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/syntax/test_concat.py
+-rw-r--r--   0 runner    (1001) docker     (123)      440 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/syntax/test_conditionals.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5781 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/syntax/test_constants.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1817 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/syntax/test_create_with_code_of.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1023 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/syntax/test_dynamic_array.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2566 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/syntax/test_enum.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2072 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/syntax/test_extract32.py
+-rw-r--r--   0 runner    (1001) docker     (123)      950 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/syntax/test_for_range.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1367 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/syntax/test_functions_call.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3146 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/syntax/test_immutables.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5392 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/syntax/test_interfaces.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4325 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/syntax/test_invalids.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1143 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/syntax/test_keccak256.py
+-rw-r--r--   0 runner    (1001) docker     (123)      903 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/syntax/test_len.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4501 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/syntax/test_list.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1166 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/syntax/test_logging.py
+-rw-r--r--   0 runner    (1001) docker     (123)      591 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/syntax/test_minmax.py
+-rw-r--r--   0 runner    (1001) docker     (123)      450 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/syntax/test_minmax_value.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3713 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/syntax/test_msg_data.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1384 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/syntax/test_nested_list.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3389 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/syntax/test_no_none.py
+-rw-r--r--   0 runner    (1001) docker     (123)      752 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/syntax/test_print.py
+-rw-r--r--   0 runner    (1001) docker     (123)      871 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/syntax/test_public.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2008 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/syntax/test_raw_call.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4176 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/syntax/test_return_tuple.py
+-rw-r--r--   0 runner    (1001) docker     (123)      799 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/syntax/test_self_balance.py
+-rw-r--r--   0 runner    (1001) docker     (123)      575 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/syntax/test_selfdestruct.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2942 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/syntax/test_send.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1102 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/syntax/test_slice.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1094 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/syntax/test_string.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7967 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/syntax/test_structs.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2828 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/syntax/test_ternary.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2537 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/syntax/test_tuple_assign.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2890 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/syntax/test_unbalanced_return.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.575606 vyper-0.3.8/tests/parser/syntax/utils/
+-rw-r--r--   0 runner    (1001) docker     (123)     2322 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/syntax/utils/test_event_names.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1508 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/syntax/utils/test_function_names.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1509 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/syntax/utils/test_variable_names.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2298 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/test_call_graph_stability.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.575606 vyper-0.3.8/tests/parser/types/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.575606 vyper-0.3.8/tests/parser/types/numbers/
+-rw-r--r--   0 runner    (1001) docker     (123)     5506 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/types/numbers/test_constants.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6400 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/types/numbers/test_decimals.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3086 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/types/numbers/test_isqrt.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9704 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/types/numbers/test_signed_ints.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4135 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/types/numbers/test_sqrt.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6046 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/types/numbers/test_unsigned_ints.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7419 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/types/test_bytes.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2282 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/types/test_bytes_literal.py
+-rw-r--r--   0 runner    (1001) docker     (123)      883 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/types/test_bytes_zero_padding.py
+-rw-r--r--   0 runner    (1001) docker     (123)    49324 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/types/test_dynamic_array.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6459 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/types/test_enum.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)     2377 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/types/test_identifier_naming.py
+-rw-r--r--   0 runner    (1001) docker     (123)    23319 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/types/test_lists.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1719 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/types/test_node_types.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9418 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/types/test_string.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1014 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/types/test_string_literal.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.575606 vyper-0.3.8/tests/parser/types/value/
+-rw-r--r--   0 runner    (1001) docker     (123)     2323 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/parser/types/value/test_as_wei_value.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.575606 vyper-0.3.8/tests/signatures/
+-rw-r--r--   0 runner    (1001) docker     (123)      446 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/signatures/test_invalid_function_decorators.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1032 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/signatures/test_method_id_conflicts.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6342 2023-05-23 15:01:17.000000 vyper-0.3.8/tests/test_utils.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1244 2023-05-23 15:01:17.000000 vyper-0.3.8/tox.ini
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.579606 vyper-0.3.8/vyper/
+-rw-r--r--   0 runner    (1001) docker     (123)      767 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      725 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/__main__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8162 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/abi_types.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.579606 vyper-0.3.8/vyper/ast/
+-rw-r--r--   0 runner    (1001) docker     (123)     5822 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/ast/README.md
+-rw-r--r--   0 runner    (1001) docker     (123)      493 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/ast/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      285 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/ast/__init__.pyi
+-rw-r--r--   0 runner    (1001) docker     (123)     9622 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/ast/annotation.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4754 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/ast/expansion.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9141 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/ast/folding.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9889 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/ast/grammar.lark
+-rw-r--r--   0 runner    (1001) docker     (123)      827 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/ast/grammar.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2466 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/ast/metadata.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4883 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/ast/natspec.py
+-rw-r--r--   0 runner    (1001) docker     (123)    44488 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/ast/nodes.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5754 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/ast/nodes.pyi
+-rw-r--r--   0 runner    (1001) docker     (123)     4688 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/ast/pre_parser.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2794 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/ast/utils.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4135 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/ast/validation.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.579606 vyper-0.3.8/vyper/builtins/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/builtins/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    16343 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/builtins/_convert.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5205 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/builtins/_signatures.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1997 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/builtins/_utils.py
+-rw-r--r--   0 runner    (1001) docker     (123)    92662 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/builtins/functions.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.583607 vyper-0.3.8/vyper/builtins/interfaces/
+-rw-r--r--   0 runner    (1001) docker     (123)      103 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/builtins/interfaces/ERC165.py
+-rw-r--r--   0 runner    (1001) docker     (123)      689 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/builtins/interfaces/ERC20.py
+-rw-r--r--   0 runner    (1001) docker     (123)      477 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/builtins/interfaces/ERC20Detailed.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1550 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/builtins/interfaces/ERC4626.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1151 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/builtins/interfaces/ERC721.py
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/builtins/interfaces/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.583607 vyper-0.3.8/vyper/cli/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/cli/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2540 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/cli/utils.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)    11182 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/cli/vyper_compile.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)     1894 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/cli/vyper_ir.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)    18889 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/cli/vyper_json.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)     3805 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/cli/vyper_serve.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.583607 vyper-0.3.8/vyper/codegen/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/codegen/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9385 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/codegen/abi_encoder.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13329 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/codegen/arithmetic.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7708 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/codegen/context.py
+-rw-r--r--   0 runner    (1001) docker     (123)    39472 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/codegen/core.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2425 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/codegen/events.py
+-rw-r--r--   0 runner    (1001) docker     (123)    30185 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/codegen/expr.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8219 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/codegen/external_call.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.583607 vyper-0.3.8/vyper/codegen/function_definitions/
+-rw-r--r--   0 runner    (1001) docker     (123)       53 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/codegen/function_definitions/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4729 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/codegen/function_definitions/common.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9700 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/codegen/function_definitions/external_function.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2772 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/codegen/function_definitions/internal_function.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1017 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/codegen/function_definitions/utils.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1068 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/codegen/global_context.py
+-rw-r--r--   0 runner    (1001) docker     (123)    21590 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/codegen/ir_node.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1828 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/codegen/keccak256_helper.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4912 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/codegen/memory_allocator.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7768 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/codegen/module.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3449 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/codegen/return_.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4413 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/codegen/self_call.py
+-rw-r--r--   0 runner    (1001) docker     (123)    16378 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/codegen/stmt.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.583607 vyper-0.3.8/vyper/compiler/
+-rw-r--r--   0 runner    (1001) docker     (123)     4040 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/compiler/README.md
+-rw-r--r--   0 runner    (1001) docker     (123)     7607 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/compiler/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10916 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/compiler/output.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10041 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/compiler/phases.py
+-rw-r--r--   0 runner    (1001) docker     (123)      484 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/compiler/settings.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1308 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/compiler/utils.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.583607 vyper-0.3.8/vyper/evm/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/evm/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1934 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/evm/address_space.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9260 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/evm/opcodes.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9888 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/exceptions.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.587607 vyper-0.3.8/vyper/ir/
+-rw-r--r--   0 runner    (1001) docker     (123)     9117 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/ir/README.md
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/ir/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    39171 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/ir/compile_ir.py
+-rw-r--r--   0 runner    (1001) docker     (123)    23828 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/ir/optimizer.py
+-rwxr-xr-x   0 runner    (1001) docker     (123)     1076 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/ir/s_expressions.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.587607 vyper-0.3.8/vyper/semantics/
+-rw-r--r--   0 runner    (1001) docker     (123)     8991 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/semantics/README.md
+-rw-r--r--   0 runner    (1001) docker     (123)       97 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/semantics/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.587607 vyper-0.3.8/vyper/semantics/analysis/
+-rw-r--r--   0 runner    (1001) docker     (123)      490 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/semantics/analysis/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10668 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/semantics/analysis/annotation.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8346 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/semantics/analysis/base.py
+-rw-r--r--   0 runner    (1001) docker     (123)      564 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/semantics/analysis/common.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8867 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/semantics/analysis/data_positions.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5273 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/semantics/analysis/levenshtein_utils.py
+-rw-r--r--   0 runner    (1001) docker     (123)    24757 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/semantics/analysis/local.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14227 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/semantics/analysis/module.py
+-rw-r--r--   0 runner    (1001) docker     (123)    22704 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/semantics/analysis/utils.py
+-rw-r--r--   0 runner    (1001) docker     (123)      199 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/semantics/data_locations.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1710 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/semantics/environment.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5526 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/semantics/namespace.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.587607 vyper-0.3.8/vyper/semantics/types/
+-rw-r--r--   0 runner    (1001) docker     (123)     1590 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/semantics/types/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11910 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/semantics/types/base.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5612 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/semantics/types/bytestrings.py
+-rw-r--r--   0 runner    (1001) docker     (123)    24304 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/semantics/types/function.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10610 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/semantics/types/primitives.py
+-rw-r--r--   0 runner    (1001) docker     (123)      387 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/semantics/types/shortcuts.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11860 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/semantics/types/subscriptable.py
+-rw-r--r--   0 runner    (1001) docker     (123)    20687 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/semantics/types/user.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5709 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/semantics/types/utils.py
+-rw-r--r--   0 runner    (1001) docker     (123)      766 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/typing.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12809 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/utils.py
+-rw-r--r--   0 runner    (1001) docker     (123)      160 2023-05-23 15:01:34.000000 vyper-0.3.8/vyper/version.py
+-rw-r--r--   0 runner    (1001) docker     (123)        7 2023-05-23 15:01:30.000000 vyper-0.3.8/vyper/vyper_git_commithash.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      133 2023-05-23 15:01:17.000000 vyper-0.3.8/vyper/warnings.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-23 15:01:34.579606 vyper-0.3.8/vyper.egg-info/
+-rw-r--r--   0 runner    (1001) docker     (123)     3654 2023-05-23 15:01:34.000000 vyper-0.3.8/vyper.egg-info/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)    16239 2023-05-23 15:01:34.000000 vyper-0.3.8/vyper.egg-info/SOURCES.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-05-23 15:01:34.000000 vyper-0.3.8/vyper.egg-info/dependency_links.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      210 2023-05-23 15:01:34.000000 vyper-0.3.8/vyper.egg-info/entry_points.txt
+-rw-r--r--   0 runner    (1001) docker     (123)     1054 2023-05-23 15:01:34.000000 vyper-0.3.8/vyper.egg-info/requires.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       12 2023-05-23 15:01:34.000000 vyper-0.3.8/vyper.egg-info/top_level.txt
```

### Comparing `vyper-0.3.7/.github/ISSUE_TEMPLATE/bug.md` & `vyper-0.3.8/.github/ISSUE_TEMPLATE/bug.md`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/.github/ISSUE_TEMPLATE/vip.md` & `vyper-0.3.8/.github/ISSUE_TEMPLATE/vip.md`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/.github/workflows/build.yml` & `vyper-0.3.8/.github/workflows/build.yml`

 * *Files 14% similar despite different names*

```diff
@@ -27,26 +27,27 @@
         with:
             # grab the commit passed in via `tag`, if any
             ref: ${{ github.event.inputs.tag }}
             # need to fetch unshallow so that setuptools_scm can infer the version
             fetch-depth: 0
 
       - name: Python
-        uses: actions/setup-python@v2
+        uses: actions/setup-python@v4
         with:
-          python-version: "3.8"
+          python-version: "3.11"
+          cache: "pip"
 
       - name: Generate Binary
         run: >-
           pip install . &&
           pip install pyinstaller &&
           make freeze
 
       - name: Upload Artifact
-        uses: actions/upload-artifact@v2
+        uses: actions/upload-artifact@v3
         with:
           path: dist/vyper.*
 
   windows-build:
     runs-on: windows-latest
 
     steps:
@@ -54,21 +55,22 @@
         with:
             # grab the commit passed in via `tag`, if any
             ref: ${{ github.event.inputs.tag }}
             # need to fetch unshallow so that setuptools_scm can infer the version
             fetch-depth: 0
 
       - name: Python
-        uses: actions/setup-python@v2
+        uses: actions/setup-python@v4
         with:
-          python-version: "3.8"
+          python-version: "3.11"
+          cache: "pip"
 
       - name: Generate Binary
         run: >-
           pip install . &&
           pip install pyinstaller &&
           ./make.cmd freeze
 
       - name: Upload Artifact
-        uses: actions/upload-artifact@v2
+        uses: actions/upload-artifact@v3
         with:
           path: dist/vyper.*
```

### Comparing `vyper-0.3.7/.github/workflows/publish.yml` & `vyper-0.3.8/.github/workflows/publish.yml`

 * *Files 17% similar despite different names*

```diff
@@ -12,17 +12,17 @@
   deploy:
     runs-on: ubuntu-latest
 
     steps:
     - uses: actions/checkout@v2
 
     - name: Python
-      uses: actions/setup-python@v2
+      uses: actions/setup-python@v4
       with:
-        python-version: '3.x'
+        python-version: "3.11"
 
     - name: Install dependencies
       run: |
         python -m pip install --upgrade pip
         pip install setuptools wheel twine
 
     - name: Build
```

### Comparing `vyper-0.3.7/.github/workflows/test.yml` & `vyper-0.3.8/.github/workflows/test.yml`

 * *Files 12% similar despite different names*

```diff
@@ -1,23 +1,31 @@
 name: Test
 
 on: [push, pull_request]
 
+concurrency:
+  # cancel older, in-progress jobs from the same PR, same workflow.
+  # use run_id if the job is triggered by a push to ensure
+  # push-triggered jobs to not get canceled.
+  group: ${{ github.workflow }}-${{ github.head_ref || github.run_id }}
+  cancel-in-progress: true
+
 jobs:
 
   lint:
     runs-on: ubuntu-latest
 
     steps:
     - uses: actions/checkout@v1
 
-    - name: Set up Python 3.8
-      uses: actions/setup-python@v1
+    - name: Set up Python 3.11
+      uses: actions/setup-python@v4
       with:
-        python-version: 3.8
+        python-version: "3.11"
+        cache: "pip"
 
     - name: Install Dependencies
       run: pip install .[lint]
 
     - name: Run Black
       run: black --check -C --force-exclude=vyper/version.py ./vyper ./tests ./setup.py
 
@@ -31,60 +39,63 @@
 
   docs:
     runs-on: ubuntu-latest
 
     steps:
       - uses: actions/checkout@v1
 
-      - name: Set up Python 3.8
-        uses: actions/setup-python@v1
+      - name: Set up Python 3.11
+        uses: actions/setup-python@v4
         with:
-          python-version: 3.8
+          python-version: "3.11"
+          cache: "pip"
 
       - name: Install Tox
         run: pip install tox
 
       - name: Run Tox
         run: TOXENV=docs tox -r
 
   mypy:
     runs-on: ubuntu-latest
 
     steps:
     - uses: actions/checkout@v1
 
-    - name: Set up Python 3.8
-      uses: actions/setup-python@v1
+    - name: Set up Python 3.11
+      uses: actions/setup-python@v4
       with:
-        python-version: 3.8
+        python-version: "3.11"
+        cache: "pip"
 
     - name: Install Tox
       run: pip install tox
 
     - name: Run Tox
       run: TOXENV=mypy tox -r
 
   # "Regular"/core tests.
   tests:
     runs-on: ubuntu-latest
     strategy:
       matrix:
-        python-version: [["3.8", "38"], ["3.9", "39"], ["3.10", "310"]]
+        python-version: [["3.10", "310"], ["3.11", "311"]]
         # run in default (optimized) and --no-optimize mode
         flag: ["core", "no-opt"]
 
     name: py${{ matrix.python-version[1] }}-${{ matrix.flag }}
 
     steps:
     - uses: actions/checkout@v1
 
     - name: Set up Python ${{ matrix.python-version[0] }}
-      uses: actions/setup-python@v1
+      uses: actions/setup-python@v4
       with:
         python-version: ${{ matrix.python-version[0] }}
+        cache: "pip"
 
     - name: Install Tox
       run: pip install tox
 
     - name: Run Tox
       run: TOXENV=py${{ matrix.python-version[1] }}-${{ matrix.flag }} tox -r -- --reruns 10 --reruns-delay 1 -r aR tests/
 
@@ -115,27 +126,28 @@
     strategy:
       matrix:
         group: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60]
 
     steps:
     - uses: actions/checkout@v1
 
-    - name: Set up Python 3.8
-      uses: actions/setup-python@v1
+    - name: Set up Python 3.11
+      uses: actions/setup-python@v4
       with:
-        python-version: 3.8
+        python-version: "3.11"
+        cache: "pip"
 
     - name: Install Tox
       run: pip install tox
 
     # fetch test durations
     # NOTE: if the tests get poorly distributed, run this and commit the resulting `.test_durations` file to the `vyper-test-durations` repo.
     # `TOXENV=fuzzing tox -r -- --store-durations --reruns 10 --reruns-delay 1 -r aR tests/`
     - name: Fetch test-durations
-      run: curl --location "https://raw.githubusercontent.com/vyperlang/vyper-test-durations/ac71e77863d7f4e7e7cd19a93cf50a8c39de4845/test_durations" -o .test_durations
+      run: curl --location "https://raw.githubusercontent.com/vyperlang/vyper-test-durations/5982755ee8459f771f2e8622427c36494646e1dd/test_durations" -o .test_durations
 
     - name: Run Tox
       run: TOXENV=fuzzing tox -r -- --splits 60 --group ${{ matrix.group }} --splitting-algorithm least_duration --reruns 10 --reruns-delay 1 -r aR tests/
 
     - name: Upload Coverage
       uses: codecov/codecov-action@v1
       with:
@@ -156,18 +168,19 @@
 
   memory:
     runs-on: ubuntu-latest
 
     steps:
     - uses: actions/checkout@v1
 
-    - name: Set up Python 3.8
-      uses: actions/setup-python@v1
+    - name: Set up Python 3.11
+      uses: actions/setup-python@v4
       with:
-        python-version: 3.8
+        python-version: "3.11"
+        cache: "pip"
 
     - name: Install Tox
       run: pip install tox
 
     - name: Run Tox
       run: TOXENV=memory tox -r
```

### Comparing `vyper-0.3.7/.pre-commit-config.yaml` & `vyper-0.3.8/.pre-commit-config.yaml`

 * *Files 0% similar despite different names*

```diff
@@ -20,8 +20,8 @@
     rev: v0.910
     hooks:
     -   id: mypy
         additional_dependencies:
           - "types-setuptools"
 
 default_language_version:
-    python: python3.8
+    python: python3.10
```

### Comparing `vyper-0.3.7/Dockerfile` & `vyper-0.3.8/Dockerfile`

 * *Files 9% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-FROM python:3.8-slim
+FROM python:3.11-slim
 
 # Specify label-schema specific arguments and labels.
 ARG BUILD_DATE
 ARG VCS_REF
 LABEL org.label-schema.build-date=$BUILD_DATE \
     org.label-schema.name="Vyper" \
     org.label-schema.description="Vyper is an experimental programming language" \
@@ -28,11 +28,11 @@
 
 WORKDIR /code
 
 # force repository to be clean so the version string is right
 RUN git reset --hard
 
 # Using "test" optional to include test dependencies in built docker-image
-RUN pip install .[test] && \
+RUN pip install --no-cache-dir .[test] && \
     apt-get purge -y --auto-remove apt-utils gcc libc6-dev libc-dev libssl-dev
 
 ENTRYPOINT ["/usr/local/bin/vyper"]
```

### Comparing `vyper-0.3.7/LICENSE` & `vyper-0.3.8/LICENSE`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/Makefile` & `vyper-0.3.8/Makefile`

 * *Files 2% similar despite different names*

```diff
@@ -39,15 +39,15 @@
 	twine check dist/*
 	#twine upload dist/*
 
 freeze: clean init
 	echo Generating binary...
 	export OS="$$(uname -s | tr A-Z a-z)" && \
 	export VERSION="$$(PYTHONPATH=. python vyper/cli/vyper_compile.py --version)" && \
-	pyinstaller --clean --onefile vyper/cli/vyper_compile.py --name "vyper.$${VERSION}.$${OS}" --add-data vyper:vyper
+	pyinstaller --target-architecture=universal2 --clean --onefile vyper/cli/vyper_compile.py --name "vyper.$${VERSION}.$${OS}" --add-data vyper:vyper
 
 clean: clean-build clean-docs clean-pyc clean-test
 
 clean-build:
 	@echo Cleaning python build files...
 	@rm -fr build/
 	@rm -fr _build/ # docs build dir
```

### Comparing `vyper-0.3.7/PKG-INFO` & `vyper-0.3.8/PKG-INFO`

 * *Files 5% similar despite different names*

```diff
@@ -1,41 +1,40 @@
 Metadata-Version: 2.1
 Name: vyper
-Version: 0.3.7
+Version: 0.3.8
 Summary: Vyper: the Pythonic Programming Language for the EVM
 Home-page: https://github.com/vyperlang/vyper
 Author: Vyper Team
 Author-email: 
 License: Apache License 2.0
 Keywords: ethereum evm smart contract language
 Classifier: Intended Audience :: Developers
 Classifier: License :: OSI Approved :: Apache Software License
-Classifier: Programming Language :: Python :: 3.8
-Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
-Requires-Python: >=3.7,<3.11
+Classifier: Programming Language :: Python :: 3.11
+Requires-Python: >=3.10,<4
 Description-Content-Type: text/markdown
 Provides-Extra: test
 Provides-Extra: lint
 Provides-Extra: docs
 Provides-Extra: dev
 License-File: LICENSE
 
 
 <img src="https://raw.githubusercontent.com/vyperlang/vyper/master/logo/vyper-logo-transparent.svg?sanitize=true" alt="" width="110">
 
-[![Build Status](https://github.com/vyperlang/vyper/workflows/Test/badge.svg)](https://github.com/vyperlang/vyper/actions)
+[![Build Status](https://github.com/vyperlang/vyper/workflows/Test/badge.svg)](https://github.com/vyperlang/vyper/actions/workflows/test.yml)
 [![Documentation Status](https://readthedocs.org/projects/vyper/badge/?version=latest)](http://vyper.readthedocs.io/en/latest/?badge=latest "ReadTheDocs")
 [![Discord](https://img.shields.io/discord/969926564286459934.svg?label=%23vyper)](https://discord.gg/6tw7PTM7C2)
 
 [![PyPI](https://badge.fury.io/py/vyper.svg)](https://pypi.org/project/vyper "PyPI")
-[![Docker](https://images.microbadger.com/badges/version/vyperlang/vyper.svg)](https://hub.docker.com/r/vyperlang/vyper "DockerHub")
+[![Docker](https://img.shields.io/docker/cloud/build/vyperlang/vyper)](https://hub.docker.com/r/vyperlang/vyper "DockerHub")
 
 [![Coverage Status](https://codecov.io/gh/vyperlang/vyper/branch/master/graph/badge.svg)](https://codecov.io/gh/vyperlang/vyper "Codecov")
-[![Language grade: Python](https://img.shields.io/lgtm/grade/python/g/vyperlang/vyper.svg?logo=lgtm&logoWidth=18)](https://lgtm.com/projects/g/vyperlang/vyper/context:python)
+[![Language grade: Python](https://github.com/vyperlang/vyper/workflows/CodeQL/badge.svg)](https://github.com/vyperlang/vyper/actions/workflows/codeql.yml)
 
 # Getting Started
 See [Installing Vyper](http://vyper.readthedocs.io/en/latest/installing-vyper.html) to install vyper.
 See [Tools and Resources](https://github.com/vyperlang/vyper/wiki/Vyper-tools-and-resources) for an additional list of framework and tools with vyper support.
 See [Documentation](http://vyper.readthedocs.io/en/latest/index.html) for the documentation and overall design goals of the Vyper language.
 
 See [Learn.Vyperlang.org](https://learn.vyperlang.org/) for **learning Vyper by building a Pokmon game**.
@@ -48,14 +47,21 @@
 for build instructions.
 
 # Compiling a contract
 To compile a contract, use:
 ```bash
 vyper your_file_name.vy
 ```
+***generate bytecode***
+
+    vyper -f bytecode file-name.vy > file-name.bin
+
+***generate abi***
+
+    vyper -f abi file-name.vy > file-name.abi
 
 There is also an [online compiler](https://vyper.online/) available you can use to experiment with
 the language and compile to ``bytecode`` and/or ``IR``.
 
 **Note: While the vyper version of the online compiler is updated on a regular basis it might
 be a bit behind the latest version found in the master branch of this repository.**
```

### Comparing `vyper-0.3.7/README.md` & `vyper-0.3.8/README.md`

 * *Files 16% similar despite different names*

```diff
@@ -1,19 +1,19 @@
 
 <img src="https://raw.githubusercontent.com/vyperlang/vyper/master/logo/vyper-logo-transparent.svg?sanitize=true" alt="" width="110">
 
-[![Build Status](https://github.com/vyperlang/vyper/workflows/Test/badge.svg)](https://github.com/vyperlang/vyper/actions)
+[![Build Status](https://github.com/vyperlang/vyper/workflows/Test/badge.svg)](https://github.com/vyperlang/vyper/actions/workflows/test.yml)
 [![Documentation Status](https://readthedocs.org/projects/vyper/badge/?version=latest)](http://vyper.readthedocs.io/en/latest/?badge=latest "ReadTheDocs")
 [![Discord](https://img.shields.io/discord/969926564286459934.svg?label=%23vyper)](https://discord.gg/6tw7PTM7C2)
 
 [![PyPI](https://badge.fury.io/py/vyper.svg)](https://pypi.org/project/vyper "PyPI")
-[![Docker](https://images.microbadger.com/badges/version/vyperlang/vyper.svg)](https://hub.docker.com/r/vyperlang/vyper "DockerHub")
+[![Docker](https://img.shields.io/docker/cloud/build/vyperlang/vyper)](https://hub.docker.com/r/vyperlang/vyper "DockerHub")
 
 [![Coverage Status](https://codecov.io/gh/vyperlang/vyper/branch/master/graph/badge.svg)](https://codecov.io/gh/vyperlang/vyper "Codecov")
-[![Language grade: Python](https://img.shields.io/lgtm/grade/python/g/vyperlang/vyper.svg?logo=lgtm&logoWidth=18)](https://lgtm.com/projects/g/vyperlang/vyper/context:python)
+[![Language grade: Python](https://github.com/vyperlang/vyper/workflows/CodeQL/badge.svg)](https://github.com/vyperlang/vyper/actions/workflows/codeql.yml)
 
 # Getting Started
 See [Installing Vyper](http://vyper.readthedocs.io/en/latest/installing-vyper.html) to install vyper.
 See [Tools and Resources](https://github.com/vyperlang/vyper/wiki/Vyper-tools-and-resources) for an additional list of framework and tools with vyper support.
 See [Documentation](http://vyper.readthedocs.io/en/latest/index.html) for the documentation and overall design goals of the Vyper language.
 
 See [Learn.Vyperlang.org](https://learn.vyperlang.org/) for **learning Vyper by building a Pokmon game**.
@@ -26,14 +26,21 @@
 for build instructions.
 
 # Compiling a contract
 To compile a contract, use:
 ```bash
 vyper your_file_name.vy
 ```
+***generate bytecode***
+
+    vyper -f bytecode file-name.vy > file-name.bin
+
+***generate abi***
+
+    vyper -f abi file-name.vy > file-name.abi
 
 There is also an [online compiler](https://vyper.online/) available you can use to experiment with
 the language and compile to ``bytecode`` and/or ``IR``.
 
 **Note: While the vyper version of the online compiler is updated on a regular basis it might
 be a bit behind the latest version found in the master branch of this repository.**
```

### Comparing `vyper-0.3.7/SECURITY.md` & `vyper-0.3.8/SECURITY.md`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/docs/Makefile` & `vyper-0.3.8/docs/Makefile`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/docs/_static/css/dark.css` & `vyper-0.3.8/docs/_static/css/dark.css`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/docs/_static/css/toggle.css` & `vyper-0.3.8/docs/_static/css/toggle.css`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/docs/_static/js/toggle.js` & `vyper-0.3.8/docs/_static/js/toggle.js`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/docs/_templates/versions.html` & `vyper-0.3.8/docs/_templates/versions.html`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/docs/built-in-functions.rst` & `vyper-0.3.8/docs/built-in-functions.rst`

 * *Files 8% similar despite different names*

```diff
@@ -86,15 +86,15 @@
         >>> ExampleContract.foo(31337, 8008135)
         8014766
 
 .. note::
 
   This function has been deprecated from version 0.3.4 onwards. Please use the ``^`` operator instead.
 
-.. py:function:: shift(x: uint256, _shift: int128) -> uint256
+.. py:function:: shift(x: int256 | uint256, _shift: integer) -> uint256
 
     Return ``x`` with the bits shifted ``_shift`` places. A positive ``_shift`` value equals a left shift, a negative value is a right shift.
 
     .. code-block:: python
 
         @external
         @view
@@ -102,14 +102,19 @@
             return shift(x, y)
 
     .. code-block:: python
 
         >>> ExampleContract.foo(2, 8)
         512
 
+.. note::
+
+  This function has been deprecated from version 0.3.8 onwards. Please use the ``<<`` and ``>>`` operators instead.
+
+
 Chain Interaction
 =================
 
 
 Vyper has three built-ins for contract creation; all three contract creation built-ins rely on the code to deploy already being stored on-chain, but differ in call vs deploy overhead, and whether or not they invoke the constructor of the contract to be deployed. The following list provides a short summary of the differences between them.
 
 * ``create_minimal_proxy_to(target: address, ...)``
@@ -197,34 +202,34 @@
         def foo(blueprint: address) -> address:
             arg1: uint256 = 18
             arg2: String = "some string"
             return create_from_blueprint(blueprint, arg1, arg2, code_offset=1)
 
 .. note::
 
-    To properly deploy a blueprint contract, special deploy bytecode must be used. Deploying blueprint contracts is generally out of scope of this article, but the following preamble, prepended to regular deploy bytecode (output of ``vyper -f bytecode``), should deploy the blueprint in an ordinary contract creation transaction: ``deploy_preamble = "61" + <bytecode len in 4 hex characters> + "3d81600a3d39f3"``. To see an example of this, please see `the setup code for testing create_from_blueprint <https://github.com/vyperlang/vyper/blob/2adc34ffd3bee8b6dee90f552bbd9bb844509e19/tests/base_conftest.py#L130-L160>`_.
+    To properly deploy a blueprint contract, special deploy bytecode must be used. The output of ``vyper -f blueprint_bytecode`` will produce bytecode which deploys an ERC-5202 compatible blueprint.
 
 .. warning::
 
-    It is recommended to deploy blueprints with the ERC5202 preamble ``0xfe7100`` to guard them from being called as regular contracts. This is particularly important for factories where the constructor has side effects (including ``SELFDESTRUCT``!), as those could get executed by *anybody* calling the blueprint contract directly. The ``code_offset=`` kwarg is provided to enable this pattern:
+    It is recommended to deploy blueprints with the ERC-5202 preamble ``0xFE7100`` to guard them from being called as regular contracts. This is particularly important for factories where the constructor has side effects (including ``SELFDESTRUCT``!), as those could get executed by *anybody* calling the blueprint contract directly. The ``code_offset=`` kwarg is provided to enable this pattern:
 
     .. code-block:: python
 
         @external
         def foo(blueprint: address) -> address:
             # `blueprint` is a blueprint contract with some known preamble b"abcd..."
             return create_from_blueprint(blueprint, code_offset=<preamble length>)
 
-.. py:function:: raw_call(to: address, data: Bytes, max_outsize: int = 0, gas: uint256 = gasLeft, value: uint256 = 0, is_delegate_call: bool = False, is_static_call: bool = False, revert_on_failure: bool = True) -> Bytes[max_outsize]
+.. py:function:: raw_call(to: address, data: Bytes, max_outsize: uint256 = 0, gas: uint256 = gasLeft, value: uint256 = 0, is_delegate_call: bool = False, is_static_call: bool = False, revert_on_failure: bool = True) -> Bytes[max_outsize]
 
     Call to the specified Ethereum address.
 
     * ``to``: Destination address to call to
     * ``data``: Data to send to the destination address
-    * ``max_outsize``: Maximum length of the bytes array returned from the call. If the returned call data exceeds this length, only this number of bytes is returned.
+    * ``max_outsize``: Maximum length of the bytes array returned from the call. If the returned call data exceeds this length, only this number of bytes is returned. (Optional, default ``0``)
     * ``gas``: The amount of gas to attach to the call. If not set, all remaining gas is forwarded.
     * ``value``: The wei value to send to the address (Optional, default ``0``)
     * ``is_delegate_call``: If ``True``, the call will be sent as ``DELEGATECALL`` (Optional, default ``False``)
     * ``is_static_call``: If ``True``, the call will be sent as ``STATICCALL`` (Optional, default ``False``)
     * ``revert_on_failure``: If ``True``, the call will revert on a failure, otherwise ``success`` will be returned (Optional, default ``True``)
 
     .. note::
@@ -246,18 +251,18 @@
         @external
         @payable
         def bar(_target: address) -> Bytes[32]:
             success: bool = False
             response: Bytes[32] = b""
             x: uint256 = 123
             success, response = raw_call(
-                _target, 
-                _abi_encode(x, method_id=method_id("someMethodName(uint256)")), 
+                _target,
+                _abi_encode(x, method_id=method_id("someMethodName(uint256)")),
                 max_outsize=32,
-                value=msg.value, 
+                value=msg.value,
                 revert_on_failure=False
                 )
             assert success
             return response
 
 .. py:function:: raw_log(topics: bytes32[4], data: Union[Bytes, bytes32]) -> None
 
@@ -268,46 +273,63 @@
 
     .. code-block:: python
 
         @external
         def foo(_topic: bytes32, _data: Bytes[100]):
             raw_log([_topic], _data)
 
+.. py:function:: raw_revert(data: Bytes) -> None
+
+    Provides low level access to the ``REVERT`` opcode, reverting execution with the specified data returned.
+
+    * ``data``: Data representing the error message causing the revert.
+
+    .. code-block:: python
+
+        @external
+        def foo(_data: Bytes[100]):
+            raw_revert(_data)
+
 .. py:function:: selfdestruct(to: address) -> None
 
     Trigger the ``SELFDESTRUCT`` opcode (``0xFF``), causing the contract to be destroyed.
 
     * ``to``: Address to forward the contract's ether balance to
 
     .. warning::
 
-        This method delete the contract from the blockchain. All non-ether assets associated with this contract are "burned" and the contract is no longer accessible.
+        This method deletes the contract from the blockchain. All non-ether assets associated with this contract are "burned" and the contract is no longer accessible.
+
+    .. note::
+
+        This function has been deprecated from version 0.3.8 onwards. The underlying opcode will eventually undergo breaking changes, and its use is not recommended.
 
     .. code-block:: python
 
         @external
         def do_the_needful():
             selfdestruct(msg.sender)
 
-.. py:function:: send(to: address, value: uint256) -> None
+.. py:function:: send(to: address, value: uint256, gas: uint256 = 0) -> None
 
     Send ether from the contract to the specified Ethereum address.
 
     * ``to``: The destination address to send ether to
     * ``value``: The wei value to send to the address
+    * ``gas``: The amount of gas (the "stipend") to attach to the call. If not set, the stipend defaults to 0.
 
     .. note::
 
         The amount to send is always specified in ``wei``.
 
     .. code-block:: python
 
         @external
-        def foo(_receiver: address, _amount: uint256):
-            send(_receiver, _amount)
+        def foo(_receiver: address, _amount: uint256, gas: uint256):
+            send(_receiver, _amount, gas=gas)
 
 Cryptography
 ============
 
 .. py:function:: ecadd(a: uint256[2], b: uint256[2]) -> uint256[2]
 
     Take two points on the Alt-BN128 curve and add them together.
@@ -380,15 +402,15 @@
             )
         '0x9eE53ad38Bb67d745223a4257D7d48cE973FeB7A'
 
 .. py:function:: keccak256(_value) -> bytes32
 
     Return a ``keccak256`` hash of the given value.
 
-    * ``_value``: Value to hash. Can be a literal string, ``Bytes``, or ``bytes32``.
+    * ``_value``: Value to hash. Can be a ``String``, ``Bytes``, or ``bytes32``.
 
     .. code-block:: python
 
         @external
         @view
         def foo(_value: Bytes[100]) -> bytes32
             return keccak256(_value)
@@ -398,15 +420,15 @@
         >>> ExampleContract.foo(b"potato")
         0x9e159dfcfe557cc1ca6c716e87af98fdcb94cd8c832386d0429b2b7bec02754f
 
 .. py:function:: sha256(_value) -> bytes32
 
     Return a ``sha256`` (SHA2 256-bit output) hash of the given value.
 
-    * ``_value``: Value to hash. Can be a literal string, ``Bytes``, or ``bytes32``.
+    * ``_value``: Value to hash. Can be a ``String``, ``Bytes``, or ``bytes32``.
 
     .. code-block:: python
 
         @external
         @view
         def foo(_value: Bytes[100]) -> bytes32
             return sha256(_value)
@@ -417,15 +439,15 @@
         0xe91c254ad58860a02c788dfb5c1a65d6a8846ab1dc649631c7db16fef4af2dec
 
 Data Manipulation
 =================
 
 .. py:function:: concat(a, b, *args) -> Union[Bytes, String]
 
-    Take 2 or more bytes arrays of type ``bytes32``, ``Bytes`` or ``String`` and combine them into a single value.
+    Take 2 or more bytes arrays of type ``bytesM``, ``Bytes`` or ``String`` and combine them into a single value.
 
     If the input arguments are ``String`` the return type is ``String``.  Otherwise the return type is ``Bytes``.
 
     .. code-block:: python
 
         @external
         @view
@@ -443,15 +465,15 @@
 
     * ``value``: Value to convert
     * ``type_``: The destination type to convert to (e.g., ``bool``, ``decimal``, ``int128``, ``uint256`` or ``bytes32``)
 
     Returns a value of the type specified by ``type_``.
 
     For more details on available type conversions, see :ref:`type_conversions`.
-    
+
 .. py:function:: uint2str(value: unsigned integer) -> String
 
     Returns an unsigned integer's string representation.
 
     * ``value``: Unsigned integer to convert.
 
     Returns the string representation of ``value``.
@@ -492,15 +514,15 @@
 
 .. py:function:: slice(b: Union[Bytes, bytes32, String], start: uint256, length: uint256) -> Union[Bytes, String]
 
     Copy a list of bytes and return a specified slice.
 
     * ``b``: value being sliced
     * ``start``: start position of the slice
-    * ``length``: length of the slice, must be constant. Immutables and variables are not supported.
+    * ``length``: length of the slice
 
     If the value being sliced is a ``Bytes`` or ``bytes32``, the return type is ``Bytes``.  If it is a ``String``, the return type is ``String``.
 
     .. code-block:: python
 
         @external
         @view
@@ -667,31 +689,31 @@
     .. code-block:: python
 
         >>> ExampleContract.foo(9.0)
         3.0
 
 .. py:function:: isqrt(x: uint256) -> uint256
 
-    Return the (integer) square root of the provided integer number, using the Babylonian square root algorithm. The rounding mode is to round down to the nearest integer. For instance, ``isqrt(101) == 10``.    
+    Return the (integer) square root of the provided integer number, using the Babylonian square root algorithm. The rounding mode is to round down to the nearest integer. For instance, ``isqrt(101) == 10``.
 
     .. code-block:: python
 
         @external
         @view
         def foo(x: uint256) -> uint256:
             return isqrt(x)
 
     .. code-block:: python
 
         >>> ExampleContract.foo(101)
         10
 
 .. py:function:: uint256_addmod(a: uint256, b: uint256, c: uint256) -> uint256
-
-    Return the modulo of ``(a + b) % c``. Reverts if ``c == 0``.
+    
+    Return the modulo of ``(a + b) % c``. Reverts if ``c == 0``. As this built-in function is intended to provides access to the underlying ``ADDMOD`` opcode, all intermediate calculations of this operation are not subject to the ``2 ** 256`` modulo according to the EVM specifications.
 
     .. code-block:: python
 
         @external
         @view
         def foo(a: uint256, b: uint256, c: uint256) -> uint256:
             return uint256_addmod(a, b, c)
@@ -701,15 +723,15 @@
         >>> (6 + 13) % 8
         3
         >>> ExampleContract.foo(6, 13, 8)
         3
 
 .. py:function:: uint256_mulmod(a: uint256, b: uint256, c: uint256) -> uint256
 
-    Return the modulo from ``(a * b) % c``. Reverts if ``c == 0``.
+    Return the modulo from ``(a * b) % c``. Reverts if ``c == 0``. As this built-in function is intended to provides access to the underlying ``MULMOD`` opcode, all intermediate calculations of this operation are not subject to the ``2 ** 256`` modulo according to the EVM specifications.
 
     .. code-block:: python
 
         @external
         @view
         def foo(a: uint256, b: uint256, c: uint256) -> uint256:
             return uint256_mulmod(a, b, c)
@@ -875,15 +897,15 @@
 
 .. py:function:: blockhash(block_num: uint256) -> bytes32
 
     Return the hash of the block at the specified height.
 
     .. note::
 
-        The EVM only provides access to the most recent 256 blocks. This function returns ``EMPTY_BYTES32`` if the block number is greater than or equal to the current block number or more than 256 blocks behind the current block.
+        The EVM only provides access to the most recent 256 blocks. This function reverts if the block number is greater than or equal to the current block number or more than 256 blocks behind the current block.
 
     .. code-block:: python
 
         @external
         @view
         def foo() -> bytes32:
             return blockhash(block.number - 16)
@@ -893,26 +915,26 @@
         >>> ExampleContract.foo()
         0xf3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
 
 .. py:function:: empty(typename) -> Any
 
     Return a value which is the default (zero-ed) value of its type. Useful for initializing new memory variables.
 
-    * ``typename``: Name of the type
+    * ``typename``: Name of the type, except ``HashMap[_KeyType, _ValueType]``
 
     .. code-block:: python
 
         @external
         @view
         def foo():
             x: uint256[2][5] = empty(uint256[2][5])
 
-.. py:function:: len(b: Union[Bytes, String]) -> uint256
+.. py:function:: len(b: Union[Bytes, String, DynArray[_Type, _Integer]]) -> uint256
 
-    Return the length of a given ``Bytes`` or ``String``.
+    Return the length of a given ``Bytes``, ``String`` or ``DynArray[_Type, _Integer]``.
 
     .. code-block:: python
 
         @external
         @view
         def foo(s: String[32]) -> uint256:
             return len(s)
```

### Comparing `vyper-0.3.7/docs/compiler-exceptions.rst` & `vyper-0.3.8/docs/compiler-exceptions.rst`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/docs/compiling-a-contract.rst` & `vyper-0.3.8/docs/compiling-a-contract.rst`

 * *Files 2% similar despite different names*

```diff
@@ -88,15 +88,15 @@
 Importing Interfaces
 ~~~~~~~~~~~~~~~~~~~~
 
 ``vyper-json`` searches for imported interfaces in the following sequence:
 
 1. Interfaces defined in the ``interfaces`` field of the input JSON.
 2. Derived interfaces generated from contracts in the ``sources`` field of the input JSON.
-3. (Optional) The local filesystem, if a root path was explicitely declared via the ``-p`` flag.
+3. (Optional) The local filesystem, if a root path was explicitly declared via the ``-p`` flag.
 
 See :ref:`searching_for_imports` for more information on Vyper's import system.
 
 Online Compilers
 ================
 
 Remix IDE
@@ -204,14 +204,17 @@
         },
         // Optional
         "settings": {
             "evmVersion": "istanbul",  // EVM version to compile for. Can be byzantium, constantinople, petersburg or istanbul.
             // optional, whether or not optimizations are turned on
             // defaults to true
             "optimize": true,
+            // optional, whether or not the bytecode should include Vyper's signature
+            // defaults to true
+            "bytecodeMetadata": true,
             // The following is used to select desired outputs based on file names.
             // File names are given as keys, a star as a file name matches all files.
             // Outputs can also follow the Solidity format where second level keys
             // denoting contract names - all 2nd level outputs are applied to the file.
             //
             // To select all possible compiler outputs: "outputSelection: { '*': ["*"] }"
             // Note that this might slow down the compilation process needlessly.
```

### Comparing `vyper-0.3.7/docs/conf.py` & `vyper-0.3.8/docs/conf.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/docs/constants-and-vars.rst` & `vyper-0.3.8/docs/constants-and-vars.rst`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/docs/contributing.rst` & `vyper-0.3.8/docs/contributing.rst`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/docs/control-structures.rst` & `vyper-0.3.8/docs/control-structures.rst`

 * *Files 2% similar despite different names*

```diff
@@ -32,33 +32,42 @@
 
 .. code-block:: python
 
     @external
     def add_seven(a: int128) -> int128:
         return a + 7
 
+    @external
+    def add_seven_with_overloading(a: uint256, b: uint256 = 3):
+        return a + b
+
 A Vyper contract cannot call directly between two external functions. If you must do this, you can use an :ref:`interface <interfaces>`.
 
+.. note::
+    For external functions with default arguments like ``def my_function(x: uint256, b: uint256 = 1)`` the Vyper compiler will generate ``N+1`` overloaded function selectors based on ``N`` default arguments.
+
 .. _structure-functions-internal:
 
 Internal Functions
 ******************
 
 Internal functions (marked with the ``@internal`` decorator) are only accessible from other functions within the same contract. They are called via the :ref:`self<constants-self>` object:
 
 .. code-block:: python
 
     @internal
-    def _times_two(amount: uint256) -> uint256:
-        return amount * 2
+    def _times_two(amount: uint256, two: uint256 = 2) -> uint256:
+        return amount * two
 
     @external
     def calculate(amount: uint256) -> uint256:
         return self._times_two(amount)
 
+.. note::
+    Since calling an ``internal`` function is realized by jumping to its entry label, the internal function dispatcher ensures the correctness of the jumps. Please note that for ``internal`` functions which use more than one default parameter, Vyper versions ``>=0.3.8`` are strongly recommended due to the security advisory `GHSA-ph9x-4vc9-m39g <https://github.com/vyperlang/vyper/security/advisories/GHSA-ph9x-4vc9-m39g>`_.
 
 Mutability
 ----------
 
 .. _function-mutability:
 
 You can optionally declare a function's mutability by using a :ref:`decorator <function-decorators>`. There are four mutability levels:
@@ -160,14 +169,15 @@
 
 ``__init__`` is a special initialization function that may only be called at the time of deploying a contract. It can be used to set initial values for storage variables. A common use case is to set an ``owner`` variable with the creator the contract:
 
 .. code-block:: python
 
     owner: address
 
+    @external
     def __init__():
         self.owner = msg.sender
 
 You cannot call to other contract functions from the initialization function.
 
 .. _function-decorators:
 
@@ -218,15 +228,15 @@
 The ``for`` statement is a control flow construct used to iterate over a value:
 
 .. code-block:: python
 
     for i in <ITERABLE>:
         ...
 
-The iterated value can be a static array, or generated from the builtin ``range`` function.
+The iterated value can be a static array, a dynamic array, or generated from the built-in ``range`` function.
 
 Array Iteration
 ---------------
 
 You can use ``for`` to iterate through the values of any array variable:
 
 .. code-block:: python
@@ -259,15 +269,15 @@
     for i in range(STOP):
         ...
 
 ``STOP`` is a literal integer greater than zero. ``i`` begins as zero and increments by one until it is equal to ``STOP``.
 
 .. code-block:: python
 
-    for i in range(start, stop):
+    for i in range(START, STOP):
         ...
 
 ``START`` and ``STOP`` are literal integers, with ``STOP`` being a greater value than ``START``. ``i`` begins as ``START`` and increments by one until it is equal to ``STOP``.
 
 .. code-block:: python
 
     for i in range(a, a + N):
```

### Comparing `vyper-0.3.7/docs/deploying-contracts.rst` & `vyper-0.3.8/docs/deploying-contracts.rst`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/docs/event-logging.rst` & `vyper-0.3.8/docs/event-logging.rst`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/docs/index.rst` & `vyper-0.3.8/docs/index.rst`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/docs/installing-vyper.rst` & `vyper-0.3.8/docs/installing-vyper.rst`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/docs/interfaces.rst` & `vyper-0.3.8/docs/interfaces.rst`

 * *Files 18% similar despite different names*

```diff
@@ -53,14 +53,36 @@
     @external
     def test(foobar: FooBar):
         foobar.calculate()  # cannot change storage
         foobar.query()  # cannot change storage, but reads itself
         foobar.update()  # storage can be altered
         foobar.pay(value=1)  # storage can be altered, and value can be sent
 
+Vyper offers the option to set the following additional keyword arguments when making external calls:
+
+=============================== ===========================================================
+Keyword                         Description
+=============================== ===========================================================
+``gas``                         Specify gas value for the call
+``value``                       Specify amount of ether sent with the call
+``skip_contract_check``         Drop ``EXTCODESIZE`` and ``RETURNDATASIZE`` checks
+``default_return_value``        Specify a default return value if no value is returned
+=============================== ===========================================================
+
+The ``default_return_value`` parameter can be used to handle ERC20 tokens affected by the missing return value bug in a way similar to OpenZeppelin's ``safeTransfer`` for Solidity:
+
+.. code-block:: python
+
+    ERC20(USDT).transfer(msg.sender, 1, default_return_value=True) # returns True
+    ERC20(USDT).transfer(msg.sender, 1) # reverts because nothing returned
+
+.. warning::
+
+   When ``skip_contract_check=True`` is used and the called function returns data (ex.: ``x: uint256 = SomeContract.foo(skip_contract_check=True)``, no guarantees are provided by the compiler as to the validity of the returned value. In other words, it is undefined behavior what happens if the called contract did not exist. In particular, the returned value might point to garbage memory. It is therefore recommended to only use ``skip_contract_check=True`` to call contracts which have been manually ensured to exist at the time of the call.
+
 Importing Interfaces
 ====================
 
 Interfaces are imported with ``import`` or ``from ... import`` statements.
 
 Imported interfaces are written using standard Vyper syntax. The body of each function is ignored when the interface is imported. If you are defining a standalone interface, it is normally specified by using a ``pass`` statement:
 
@@ -123,15 +145,15 @@
 .. _searching_for_imports:
 
 Searching For Interface Files
 -----------------------------
 
 When looking for a file to import, Vyper will first search relative to the same folder as the contract being compiled. For absolute imports, it also searches relative to the root path for the project. Vyper checks for the file name with a ``.vy`` suffix first, then ``.json``.
 
-When using the command line compiler, the root path defaults to to the current working directory. You can change it with the ``-p`` flag:
+When using the command line compiler, the root path defaults to the current working directory. You can change it with the ``-p`` flag:
 
 ::
 
     $ vyper my_project/contracts/my_contract.vy -p my_project
 
 In the above example, the ``my_project`` folder is set as the root path. A contract cannot perform a relative import that goes beyond the top-level folder.
 
@@ -142,16 +164,15 @@
 
 .. code-block:: python
 
     from vyper.interfaces import ERC20
 
     implements: ERC20
 
-You can see all the available built-in interfaces in the `Vyper GitHub <https://github.com/vyperlang/vyper/tree/master/vyper/builtin_interfaces>`_ repo.
-
+You can see all the available built-in interfaces in the `Vyper GitHub <https://github.com/vyperlang/vyper/tree/master/vyper/builtins/interfaces>`_ repo.
 
 Implementing an Interface
 =========================
 
 You can define an interface for your contract with the ``implements`` statement:
 
 .. code-block:: python
@@ -159,14 +180,18 @@
     import an_interface as FooBarInterface
 
     implements: FooBarInterface
 
 
 This imports the defined interface from the vyper file at ``an_interface.vy`` (or ``an_interface.json`` if using ABI json interface type) and ensures your current contract implements all the necessary external functions. If any interface functions are not included in the contract, it will fail to compile. This is especially useful when developing contracts around well-defined standards such as ERC20.
 
+.. note::
+
+  Interfaces that implement functions with return values that require an upper bound (e.g. ``Bytes``, ``DynArray``, or ``String``), the upper bound defined in the interface represents the lower bound of the implementation. Assuming a function ``my_func`` returns a value ``String[1]`` in the interface, this would mean for the implementation function of ``my_func`` that the return value must have **at least** length 1. This behavior might change in the future.
+
 Extracting Interfaces
 =====================
 
 Vyper has a built-in format option to allow you to make your own Vyper interfaces easily.
 
 ::
```

### Comparing `vyper-0.3.7/docs/make.bat` & `vyper-0.3.8/docs/make.bat`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/docs/natspec.rst` & `vyper-0.3.8/docs/natspec.rst`

 * *Files 4% similar despite different names*

```diff
@@ -41,25 +41,26 @@
         """
 
 Tags
 ====
 
 All tags are optional. The following table explains the purpose of each NatSpec tag and where it may be used:
 
-============ ======================================== ==================
-Tag          Description                              Context
-============ ======================================== ==================
-``@title``   Title that describes the contract        contract
-``@licence`` License of the contract                  contract
-``@author``  Name of the author                       contract, function
-``@notice``  Explain to an end user what this does    contract, function
-``@dev``     Explain to a developer any extra details contract, function
-``@param``   Documents a single parameter             function
-``@return``  Documents one or all return variable(s)  function
-============ ======================================== ==================
+=============== ============================================ ==================
+Tag             Description                                  Context
+=============== ============================================ ==================
+``@title``      Title that describes the contract            contract
+``@license``    License of the contract                      contract
+``@author``     Name of the author                           contract, function
+``@notice``     Explain to an end user what this does        contract, function
+``@dev``        Explain to a developer any extra details     contract, function
+``@param``      Documents a single parameter                 function
+``@return``     Documents one or all return variable(s)      function
+``@custom:...`` Custom tag, semantics is application-defined contract, function
+=============== ============================================ ==================
 
 Some rules / restrictions:
 
 1. A single tag description may span multiple lines. All whitespace between lines is interpreted as a single space.
 2. If a docstring is included with no NatSpec tags, it is interpreted as a ``@notice``.
 3. Each use of ``@param`` must be followed by the name of an input argument. Including invalid or duplicate argument names raises a :func:`NatSpecSyntaxException<NatSpecSyntaxException>`.
 4. The preferred use of ``@return`` is one entry for each output value, however you may also use it once for all outputs. Including more ``@return`` values than output values raises a :func:`NatSpecSyntaxException<NatSpecSyntaxException>`.
```

### Comparing `vyper-0.3.7/docs/release-notes.rst` & `vyper-0.3.8/docs/release-notes.rst`

 * *Files 8% similar despite different names*

```diff
@@ -1,50 +1,157 @@
 .. _release-notes:
 
 Release Notes
 #############
 
+..
+    vim regexes:
+    first convert all single backticks to double backticks:
+    :'<,'>s/`/``/g
+    to convert links to nice rst links:
+    :'<,'>s/\v(https:\/\/github.com\/vyperlang\/vyper\/pull\/)(\d+)/(`#\2 <\1\2>`_)/g
+    ex. in: https://github.com/vyperlang/vyper/pull/3373
+    ex. out: (`#3373 <https://github.com/vyperlang/vyper/pull/3373>`_)
+    for advisory links:
+    :'<,'>s/\v(https:\/\/github.com\/vyperlang\/vyper\/security\/advisories\/)([-A-Za-z0-9]+)/(`\2 <\1\2>`_)/g
+
+v0.3.8
+******
+
+Date released: 2023-05-23
+
+Non-breaking changes and improvements:
+
+- ``transient`` storage keyword (`#3373 <https://github.com/vyperlang/vyper/pull/3373>`_)
+- ternary operators (`#3398 <https://github.com/vyperlang/vyper/pull/3398>`_)
+- ``raw_revert()`` builtin (`#3136 <https://github.com/vyperlang/vyper/pull/3136>`_)
+- shift operators (`#3019 <https://github.com/vyperlang/vyper/pull/3019>`_)
+- make ``send()`` gas stipend configurable (`#3158 <https://github.com/vyperlang/vyper/pull/3158>`_)
+- use new ``push0`` opcode (`#3361 <https://github.com/vyperlang/vyper/pull/3361>`_)
+- python 3.11 support (`#3129 <https://github.com/vyperlang/vyper/pull/3129>`_)
+- drop support for python 3.8 and 3.9 (`#3325 <https://github.com/vyperlang/vyper/pull/3325>`_)
+- build for ``aarch64`` (`#2687 <https://github.com/vyperlang/vyper/pull/2687>`_)
+
+Major refactoring PRs:
+
+- refactor front-end type system (`#2974 <https://github.com/vyperlang/vyper/pull/2974>`_)
+- merge front-end and codegen type systems (`#3182 <https://github.com/vyperlang/vyper/pull/3182>`_)
+- simplify ``GlobalContext`` (`#3209 <https://github.com/vyperlang/vyper/pull/3209>`_)
+- remove ``FunctionSignature`` (`#3390 <https://github.com/vyperlang/vyper/pull/3390>`_)
+
+Notable fixes:
+
+- assignment when rhs is complex type and references lhs (`#3410 <https://github.com/vyperlang/vyper/pull/3410>`_)
+- uninitialized immutable values (`#3409 <https://github.com/vyperlang/vyper/pull/3409>`_)
+- success value when mixing ``max_outsize=0`` and ``revert_on_failure=False`` (`GHSA-w9g2-3w7p-72g9 <https://github.com/vyperlang/vyper/security/advisories/GHSA-w9g2-3w7p-72g9>`_)
+- block certain kinds of storage allocator overflows (`GHSA-mgv8-gggw-mrg6 <https://github.com/vyperlang/vyper/security/advisories/GHSA-mgv8-gggw-mrg6>`_) 
+- store-before-load when a dynarray appears on both sides of an assignment (`GHSA-3p37-3636-q8wv <https://github.com/vyperlang/vyper/security/advisories/GHSA-3p37-3636-q8wv>`_)
+- bounds check for loops of the form ``for i in range(x, x+N)`` (`GHSA-6r8q-pfpv-7cgj <https://github.com/vyperlang/vyper/security/advisories/GHSA-6r8q-pfpv-7cgj>`_)
+- alignment of call-site posargs and kwargs for internal functions (`GHSA-ph9x-4vc9-m39g <https://github.com/vyperlang/vyper/security/advisories/GHSA-ph9x-4vc9-m39g>`_)
+- batch nonpayable check for default functions calldatasize < 4 (`#3104 <https://github.com/vyperlang/vyper/pull/3104>`_, `#3408 <https://github.com/vyperlang/vyper/pull/3408>`_, cf. `GHSA-vxmm-cwh2-q762 <https://github.com/vyperlang/vyper/security/advisories/GHSA-vxmm-cwh2-q762>`_)
+
+Other docs updates, chores and fixes:
+
+- call graph stability (`#3370 <https://github.com/vyperlang/vyper/pull/3370>`_)
+- fix ``vyper-serve`` output (`#3338 <https://github.com/vyperlang/vyper/pull/3338>`_)
+- add ``custom:`` natspec tags (`#3403 <https://github.com/vyperlang/vyper/pull/3403>`_)
+- add missing pc maps to ``vyper_json`` output (`#3333 <https://github.com/vyperlang/vyper/pull/3333>`_)
+- fix constructor context for internal functions (`#3388 <https://github.com/vyperlang/vyper/pull/3388>`_)
+- add deprecation warning for ``selfdestruct`` usage (`#3372 <https://github.com/vyperlang/vyper/pull/3372>`_)
+- add bytecode metadata option to vyper-json (`#3117 <https://github.com/vyperlang/vyper/pull/3117>`_)
+- fix compiler panic when a ``break`` is outside of a loop (`#3177 <https://github.com/vyperlang/vyper/pull/3177>`_)
+- fix complex arguments to builtin functions (`#3167 <https://github.com/vyperlang/vyper/pull/3167>`_)
+- add support for all types in ABI imports (`#3154 <https://github.com/vyperlang/vyper/pull/3154>`_)
+- disable uadd operator (`#3174 <https://github.com/vyperlang/vyper/pull/3174>`_)
+- block bitwise ops on decimals (`#3219 <https://github.com/vyperlang/vyper/pull/3219>`_)
+- raise ``UNREACHABLE`` (`#3194 <https://github.com/vyperlang/vyper/pull/3194>`_)
+- allow enum as mapping key (`#3256 <https://github.com/vyperlang/vyper/pull/3256>`_)
+- block boolean ``not`` operator on numeric types (`#3231 <https://github.com/vyperlang/vyper/pull/3231>`_)
+- enforce that loop's iterators are valid names (`#3242 <https://github.com/vyperlang/vyper/pull/3242>`_)
+- fix typechecker hotspot (`#3318 <https://github.com/vyperlang/vyper/pull/3318>`_)
+- rewrite typechecker journal to handle nested commits (`#3375 <https://github.com/vyperlang/vyper/pull/3375>`_)
+- fix missing pc map for empty functions (`#3202 <https://github.com/vyperlang/vyper/pull/3202>`_)
+- guard against iterating over empty list in for loop (`#3197 <https://github.com/vyperlang/vyper/pull/3197>`_)
+- skip enum members during constant folding (`#3235 <https://github.com/vyperlang/vyper/pull/3235>`_)
+- bitwise ``not`` constant folding (`#3222 <https://github.com/vyperlang/vyper/pull/3222>`_)
+- allow accessing members of constant address (`#3261 <https://github.com/vyperlang/vyper/pull/3261>`_)
+- guard against decorators in interface (`#3266 <https://github.com/vyperlang/vyper/pull/3266>`_)
+- fix bounds for decimals in some builtins (`#3283 <https://github.com/vyperlang/vyper/pull/3283>`_)
+- length of literal empty bytestrings (`#3276 <https://github.com/vyperlang/vyper/pull/3276>`_)
+- block ``empty()`` for HashMaps (`#3303 <https://github.com/vyperlang/vyper/pull/3303>`_)
+- fix type inference for empty lists (`#3377 <https://github.com/vyperlang/vyper/pull/3377>`_)
+- disallow logging from ``pure``, ``view`` functions (`#3424 <https://github.com/vyperlang/vyper/pull/3424>`_)
+- improve optimizer rules for comparison operators (`#3412 <https://github.com/vyperlang/vyper/pull/3412>`_)
+- deploy to ghcr on push (`#3435 <https://github.com/vyperlang/vyper/pull/3435>`_)
+- add note on return value bounds in interfaces (`#3205 <https://github.com/vyperlang/vyper/pull/3205>`_)
+- index ``id`` param in ``URI`` event of ``ERC1155ownable`` (`#3203 <https://github.com/vyperlang/vyper/pull/3203>`_)
+- add missing ``asset`` function to ``ERC4626`` built-in interface (`#3295 <https://github.com/vyperlang/vyper/pull/3295>`_)
+- clarify ``skip_contract_check=True`` can result in undefined behavior (`#3386 <https://github.com/vyperlang/vyper/pull/3386>`_)
+- add ``custom`` NatSpec tag to docs (`#3404 <https://github.com/vyperlang/vyper/pull/3404>`_)
+- fix ``uint256_addmod`` doc (`#3300 <https://github.com/vyperlang/vyper/pull/3300>`_)
+- document optional kwargs for external calls (`#3122 <https://github.com/vyperlang/vyper/pull/3122>`_)
+- remove ``slice()`` length documentation caveats (`#3152 <https://github.com/vyperlang/vyper/pull/3152>`_)
+- fix docs of ``blockhash`` to reflect revert behaviour (`#3168 <https://github.com/vyperlang/vyper/pull/3168>`_)
+- improvements to compiler error messages (`#3121 <https://github.com/vyperlang/vyper/pull/3121>`_, `#3134 <https://github.com/vyperlang/vyper/pull/3134>`_, `#3312 <https://github.com/vyperlang/vyper/pull/3312>`_, `#3304 <https://github.com/vyperlang/vyper/pull/3304>`_, `#3240 <https://github.com/vyperlang/vyper/pull/3240>`_, `#3264 <https://github.com/vyperlang/vyper/pull/3264>`_, `#3343 <https://github.com/vyperlang/vyper/pull/3343>`_, `#3307 <https://github.com/vyperlang/vyper/pull/3307>`_, `#3313 <https://github.com/vyperlang/vyper/pull/3313>`_ and `#3215 <https://github.com/vyperlang/vyper/pull/3215>`_)
+
+These are really just the highlights, as many other bugfixes, docs updates and refactoring (over 150 pull requests!) made it into this release! For the full list, please see the `changelog <https://github.com/vyperlang/vyper/compare/v0.3.7...v0.3.8>`_. Special thanks to contributions from @tserg, @trocher, @z80dev, @emc415 and @benber86 in this release!
+
+New Contributors:
+
+- @omahs made their first contribution in (`#3128 <https://github.com/vyperlang/vyper/pull/3128>`_)
+- @ObiajuluM made their first contribution in (`#3124 <https://github.com/vyperlang/vyper/pull/3124>`_)
+- @trocher made their first contribution in (`#3134 <https://github.com/vyperlang/vyper/pull/3134>`_)
+- @ozmium22 made their first contribution in (`#3149 <https://github.com/vyperlang/vyper/pull/3149>`_)
+- @ToonVanHove made their first contribution in (`#3168 <https://github.com/vyperlang/vyper/pull/3168>`_)
+- @emc415 made their first contribution in (`#3158 <https://github.com/vyperlang/vyper/pull/3158>`_)
+- @lgtm-com made their first contribution in (`#3147 <https://github.com/vyperlang/vyper/pull/3147>`_)
+- @tdurieux made their first contribution in (`#3224 <https://github.com/vyperlang/vyper/pull/3224>`_)
+- @victor-ego made their first contribution in (`#3263 <https://github.com/vyperlang/vyper/pull/3263>`_)
+- @miohtama made their first contribution in (`#3257 <https://github.com/vyperlang/vyper/pull/3257>`_)
+- @kelvinfan001 made their first contribution in (`#2687 <https://github.com/vyperlang/vyper/pull/2687>`_)
+
+
 v0.3.7
 ******
 
 Date released: 2022-09-26
 
-## Breaking changes:
+Breaking changes:
 
 - chore: drop python 3.7 support (`#3071 <https://github.com/vyperlang/vyper/pull/3071>`_)
 - fix: relax check for statically sized calldata (`#3090 <https://github.com/vyperlang/vyper/pull/3090>`_)
 
-## Non-breaking changes and improvements:
+Non-breaking changes and improvements:
 
-- fix: assert description in Crowdfund.finalize() (`#3058 <https://github.com/vyperlang/vyper/pull/3058>`_)
+- fix: assert description in ``Crowdfund.finalize()`` (`#3058 <https://github.com/vyperlang/vyper/pull/3058>`_)
 - fix: change mutability of example ERC721 interface (`#3076 <https://github.com/vyperlang/vyper/pull/3076>`_)
 - chore: improve error message for non-checksummed address literal (`#3065 <https://github.com/vyperlang/vyper/pull/3065>`_)
-- feat: isqrt built-in (`#3074 <https://github.com/vyperlang/vyper/pull/3074>`_) (`#3069 <https://github.com/vyperlang/vyper/pull/3069>`_)
-- feat: add `block.prevrandao` as alias for `block.difficulty` (`#3085 <https://github.com/vyperlang/vyper/pull/3085>`_)
-- feat: epsilon builtin (`#3057 <https://github.com/vyperlang/vyper/pull/3057>`_)
+- feat: ``isqrt()`` builtin (`#3074 <https://github.com/vyperlang/vyper/pull/3074>`_) (`#3069 <https://github.com/vyperlang/vyper/pull/3069>`_)
+- feat: add ``block.prevrandao`` as alias for ``block.difficulty`` (`#3085 <https://github.com/vyperlang/vyper/pull/3085>`_)
+- feat: ``epsilon()`` builtin (`#3057 <https://github.com/vyperlang/vyper/pull/3057>`_)
 - feat: extend ecrecover signature to accept additional parameter types (`#3084 <https://github.com/vyperlang/vyper/pull/3084>`_)
 - feat: allow constant and immutable variables to be declared public (`#3024 <https://github.com/vyperlang/vyper/pull/3024>`_)
 - feat: optionally disable metadata in bytecode (`#3107 <https://github.com/vyperlang/vyper/pull/3107>`_)
     
-## Bugfixes:
+Bugfixes:
 
 - fix: empty nested dynamic arrays (`#3061 <https://github.com/vyperlang/vyper/pull/3061>`_)
 - fix: foldable builtin default args in imports (`#3079 <https://github.com/vyperlang/vyper/pull/3079>`_) (`#3077 <https://github.com/vyperlang/vyper/pull/3077>`_)
 
-## Additional changes and improvements:
+Additional changes and improvements:
 
 - doc: update broken links in SECURITY.md (`#3095 <https://github.com/vyperlang/vyper/pull/3095>`_)
 - chore: update discord link in docs (`#3031 <https://github.com/vyperlang/vyper/pull/3031>`_)
 - fix: broken links in various READMEs (`#3072 <https://github.com/vyperlang/vyper/pull/3072>`_)
 - chore: fix compile warnings in examples (`#3033 <https://github.com/vyperlang/vyper/pull/3033>`_)
 - feat: append lineno to the filename in error messages (`#3092 <https://github.com/vyperlang/vyper/pull/3092>`_)
 - chore: migrate lark grammar (`#3082 <https://github.com/vyperlang/vyper/pull/3082>`_)
 - chore: loosen and upgrade semantic version (`#3106 <https://github.com/vyperlang/vyper/pull/3106>`_)
 
-# New Contributors
+New Contributors
 
 - @emilianobonassi made their first contribution in `#3107 <https://github.com/vyperlang/vyper/pull/3107>`_
 - @unparalleled-js made their first contribution in `#3106 <https://github.com/vyperlang/vyper/pull/3106>`_
 - @pcaversaccio made their first contribution in `#3085 <https://github.com/vyperlang/vyper/pull/3085>`_
 - @nfwsncked made their first contribution in `#3058 <https://github.com/vyperlang/vyper/pull/3058>`_
 - @z80 made their first contribution in `#3057 <https://github.com/vyperlang/vyper/pull/3057>`_
 - @Benny made their first contribution in `#3024 <https://github.com/vyperlang/vyper/pull/3024>`_
```

### Comparing `vyper-0.3.7/docs/scoping-and-declarations.rst` & `vyper-0.3.8/docs/scoping-and-declarations.rst`

 * *Files 5% similar despite different names*

```diff
@@ -142,33 +142,35 @@
     def foo() -> int128:
         b: int128 = self.foo()
         return self.a  + b
 
 Name Shadowing
 **************
 
-It is not permitted for a memory or calldata variable to shadow the name of a storage variable. The following examples will not compile:
+It is not permitted for a memory or calldata variable to shadow the name of an immutable or constant value. The following examples will not compile:
 
 .. code-block:: python
 
-    a: int128
+    a: constant(bool) = True
 
     @external
-    def foo() -> int128:
-        # memory variable cannot have the same name as a storage variable
-        a: int128 = self.a
+    def foo() -> bool:
+        # memory variable cannot have the same name as a constant or immutable variable
+        a: bool = False
         return a
-
 .. code-block:: python
 
-    a: int128
+    a: immutable(bool)
 
     @external
-    def foo(a: int128) -> int128:
-        # input argument cannot have the same name as a storage variable
+    def __init__():
+        a = True
+    @external
+    def foo(a:bool) -> bool:
+        # input argument cannot have the same name as a constant or immutable variable
         return a
 
 Function Scope
 --------------
 
 Variables that are declared within a function, or given as function input arguments, are visible within the body of that function. For example, the following contract is valid because each declaration of ``a`` only exists within one function's body.
```

### Comparing `vyper-0.3.7/docs/statements.rst` & `vyper-0.3.8/docs/statements.rst`

 * *Files 7% similar despite different names*

```diff
@@ -53,15 +53,15 @@
 
 ``return`` leaves the current function call with the expression list (or None) as a return value.
 
 .. code-block:: python
 
     return RETURN_VALUE
 
-An important distinction between Vyper and Python is that Vyper does not implicitly return ``None`` at the end of a function if no ``return`` statement is given. All functions must end with a ``return`` statement, or another terminating action such as ``raise``.
+If a function has no return type, it is allowed to omit the ``return`` statement, otherwise, the function must end with a ``return`` statement, or another terminating action such as ``raise``.
 
 It is not allowed to have additional, unreachable statements after a ``return`` statement.
 
 Event Logging
 =============
 
 log
```

### Comparing `vyper-0.3.7/docs/structure-of-a-contract.rst` & `vyper-0.3.8/docs/structure-of-a-contract.rst`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/docs/style-guide.rst` & `vyper-0.3.8/docs/style-guide.rst`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/docs/testing-contracts-brownie.rst` & `vyper-0.3.8/docs/testing-contracts-brownie.rst`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/docs/testing-contracts-ethtester.rst` & `vyper-0.3.8/docs/testing-contracts-ethtester.rst`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/docs/testing-contracts.rst` & `vyper-0.3.8/docs/testing-contracts.rst`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/docs/toctree.rst` & `vyper-0.3.8/docs/toctree.rst`

 * *Files 6% similar despite different names*

```diff
@@ -38,11 +38,12 @@
     deploying-contracts.rst
     testing-contracts.rst
 
 .. toctree::
     :caption: Additional Resources
     :maxdepth: 2
 
+    resources
     release-notes.rst
     contributing.rst
     style-guide.rst
     versioning.rst
```

### Comparing `vyper-0.3.7/docs/types.rst` & `vyper-0.3.8/docs/types.rst`

 * *Files 3% similar despite different names*

```diff
@@ -98,16 +98,43 @@
 ``x / y``      Division
 ``x**y``       Exponentiation
 ``x % y``      Modulo
 =============  ======================
 
 ``x`` and ``y`` must both be of the same type.
 
+Bitwise Operators
+^^^^^^^^^^^^^^^^^
+
+=============  ======================
+Operator       Description
+=============  ======================
+``x & y``      Bitwise and
+``x | y``      Bitwise or
+``x ^ y``      Bitwise xor
+=============  ======================
+
+``x`` and ``y`` must be of the same type.
+
+Shifts
+^^^^^^^^^^^^^^^^^
+
+=============  ======================
+Operator       Description
+=============  ======================
+``x << y``     Left shift
+``x >> y``     Right shift
+=============  ======================
+
+Shifting is only available for 256-bit wide types. That is, ``x`` must be ``int256``, and ``y`` can be any unsigned integer. The right shift for ``int256`` compiles to a signed right shift (EVM ``SAR`` instruction).
+
+
 .. note::
-    Arithmetic is currently only available for ``int128`` and ``int256`` types.
+   While at runtime shifts are unchecked (that is, they can be for any number of bits), to prevent common mistakes, the compiler is stricter at compile-time and will prevent out of bounds shifts. For instance, at runtime, ``1 << 257`` will evaluate to ``0``, while that expression at compile-time will raise an ``OverflowException``.
+
 
 .. index:: ! uint, ! uintN, ! unsigned integer
 
 Unsigned Integer (N bit)
 --------------------------
 
 **Keyword:** ``uintN`` (e.g., ``uint8``)
@@ -172,15 +199,33 @@
 ``x ^ y``      Bitwise xor
 ``~x``         Bitwise not
 =============  ======================
 
 ``x`` and ``y`` must be of the same type.
 
 .. note::
-    Bitwise operations are currently only available for ``uint256`` type.
+    The Bitwise ``not`` operator is currently only available for ``uint256`` type.
+
+Shifts
+^^^^^^^^^^^^^^^^^
+
+=============  ======================
+Operator       Description
+=============  ======================
+``x << y``     Left shift
+``x >> y``     Right shift
+=============  ======================
+
+Shifting is only available for 256-bit wide types. That is, ``x`` must be ``uint256``, and ``y`` can be any unsigned integer. The right shift for ``uint256`` compiles to a signed right shift (EVM ``SHR`` instruction).
+
+
+.. note::
+   While at runtime shifts are unchecked (that is, they can be for any number of bits), to prevent common mistakes, the compiler is stricter at compile-time and will prevent out of bounds shifts. For instance, at runtime, ``1 << 257`` will evaluate to ``0``, while that expression at compile-time will raise an ``OverflowException``.
+
+
 
 Decimals
 --------
 
 **Keyword:** ``decimal``
 
 A decimal is a type to store a decimal fixed point value.
@@ -439,15 +484,15 @@
 .. index:: !arrays
 
 Fixed-size Lists
 ----------------
 
 Fixed-size lists hold a finite number of elements which belong to a specified type.
 
-Lists can be declared with ``_name: _ValueType[_Integer]``.
+Lists can be declared with ``_name: _ValueType[_Integer]``, except ``Bytes[N]``, ``String[N]`` and enums.
 
 .. code-block:: python
 
     # Defining a list
     exampleList: int128[3]
 
     # Setting values
@@ -471,20 +516,23 @@
 
     # Setting values
     exampleList2D = [[10, 11, 12, 13, 14], [16, 17, 18, 19, 20]]
 
     # Returning the value in row 0 column 4 (in this case 14)
     return exampleList2D[0][4]
 
+.. note::
+    Defining an array in storage whose size is significantly larger than ``2**64`` can result in security vulnerabilities due to risk of overflow.
+
 .. index:: !dynarrays
 
 Dynamic Arrays
 ----------------
 
-Dynamic arrays represent bounded arrays whose length can be modified at runtime, up to a bound specified in the type. They can be declared with ``_name: DynArray[_Type, _Integer]``, where ``_Type`` can be of value type (except ``Bytes[N]`` and ``String[N]``) or reference type (except mappings).
+Dynamic arrays represent bounded arrays whose length can be modified at runtime, up to a bound specified in the type. They can be declared with ``_name: DynArray[_Type, _Integer]``, where ``_Type`` can be of value type or reference type (except mappings).
 
 .. code-block:: python
 
     # Defining a list
     exampleList: DynArray[int128, 3]
 
     # Setting values
@@ -503,23 +551,27 @@
     return exampleList[0]
 
 
 .. note::
     Attempting to access data past the runtime length of an array, ``pop()`` an empty array or ``append()`` to a full array will result in a runtime ``REVERT``. Attempting to pass an array in calldata which is larger than the array bound will result in a runtime ``REVERT``.
 
 .. note::
-    To keep code easy to reason about, modifying an array while using it as an iterator it is disallowed by the language. For instance, the following usage is not allowed:
+    To keep code easy to reason about, modifying an array while using it as an iterator is disallowed by the language. For instance, the following usage is not allowed:
 
     .. code-block:: python
 
         for item in self.my_array:
             self.my_array[0] = item
 
 In the ABI, they are represented as ``_Type[]``. For instance, ``DynArray[int128, 3]`` gets represented as ``int128[]``, and ``DynArray[DynArray[int128, 3], 3]`` gets represented as ``int128[][]``.
 
+.. note::
+    Defining a dynamic array in storage whose size is significantly larger than ``2**64`` can result in security vulnerabilities due to risk of overflow.
+
+
 .. _types-struct:
 
 Structs
 -------
 
 Structs are custom defined types that can group several variables.
 
@@ -547,15 +599,15 @@
 
 Mappings are `hash tables <https://en.wikipedia.org/wiki/Hash_table>`_ that are virtually initialized such that every possible key exists and is mapped to a value whose byte-representation is all zeros: a type's :ref:`default value <types-initial>`.
 
 The key data is not stored in a mapping. Instead, its ``keccak256`` hash is used to look up a value. For this reason, mappings do not have a length or a concept of a key or value being "set".
 
 Mapping types are declared as ``HashMap[_KeyType, _ValueType]``.
 
-* ``_KeyType`` can be any base or bytes type. Mappings, interfaces or structs are not supported as key types.
+* ``_KeyType`` can be any base or bytes type. Mappings, arrays or structs are not supported as key types.
 * ``_ValueType`` can actually be any type, including mappings.
 
 .. note::
     Mappings are only allowed as state variables.
 
 .. code-block:: python
```

### Comparing `vyper-0.3.7/docs/versioning.rst` & `vyper-0.3.8/docs/versioning.rst`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/docs/vyper-by-example.rst` & `vyper-0.3.8/docs/vyper-by-example.rst`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/docs/vyper-logo-transparent.svg` & `vyper-0.3.8/docs/vyper-logo-transparent.svg`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/examples/auctions/blind_auction.vy` & `vyper-0.3.8/examples/auctions/blind_auction.vy`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/examples/auctions/simple_open_auction.vy` & `vyper-0.3.8/examples/auctions/simple_open_auction.vy`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/examples/crowdfund.vy` & `vyper-0.3.8/examples/crowdfund.vy`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/examples/factory/Exchange.vy` & `vyper-0.3.8/examples/factory/Exchange.vy`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/examples/factory/Factory.vy` & `vyper-0.3.8/examples/factory/Factory.vy`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/examples/market_maker/on_chain_market_maker.vy` & `vyper-0.3.8/examples/market_maker/on_chain_market_maker.vy`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/examples/safe_remote_purchase/safe_remote_purchase.vy` & `vyper-0.3.8/examples/safe_remote_purchase/safe_remote_purchase.vy`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/examples/stock/company.vy` & `vyper-0.3.8/examples/stock/company.vy`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/examples/tokens/ERC1155ownable.vy` & `vyper-0.3.8/examples/tokens/ERC1155ownable.vy`

 * *Files 0% similar despite different names*

```diff
@@ -87,15 +87,15 @@
     account: indexed(address)
     operator: indexed(address)
     approved: bool
 
 event URI:
     # This emits when the URI gets changed
     value: String[MAX_URI_LENGTH]
-    id: uint256
+    id: indexed(uint256)
 
 ############### interfaces ###############
 implements: ERC165
 
 interface IERC1155Receiver:
     def onERC1155Received(
        operator: address,
@@ -203,15 +203,15 @@
     for i in ids:
         batchBalances.append(self.balanceOf[accounts[j]][i])
         j += 1
     return batchBalances
 
 ## mint ##
 @external
-def mint(receiver: address, id: uint256, amount:uint256, data:bytes32):
+def mint(receiver: address, id: uint256, amount:uint256):
     """
     @dev mint one new token with a certain ID
     @dev this can be a new token or "topping up" the balance of a non-fungible token ID
     @param receiver the account that will receive the minted token
     @param id the ID of the token
     @param amount of tokens for this ID
     @param data the data associated with this mint. Usually stays empty
@@ -221,15 +221,15 @@
     assert receiver != empty(address), "Can not mint to ZERO ADDRESS"
     operator: address = msg.sender
     self.balanceOf[receiver][id] += amount
     log TransferSingle(operator, empty(address), receiver, id, amount)
 
 
 @external
-def mintBatch(receiver: address, ids: DynArray[uint256, BATCH_SIZE], amounts: DynArray[uint256, BATCH_SIZE], data: bytes32):
+def mintBatch(receiver: address, ids: DynArray[uint256, BATCH_SIZE], amounts: DynArray[uint256, BATCH_SIZE]):
     """
     @dev mint a batch of new tokens with the passed IDs
     @dev this can be new tokens or "topping up" the balance of existing non-fungible token IDs in the contract
     @param receiver the account that will receive the minted token
     @param ids array of ids for the tokens
     @param amounts amounts of tokens for each ID in the ids array
     @param data the data associated with this mint. Usually stays empty
```

### Comparing `vyper-0.3.7/examples/tokens/ERC20.vy` & `vyper-0.3.8/examples/tokens/ERC20.vy`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/examples/tokens/ERC4626.vy` & `vyper-0.3.8/examples/tokens/ERC4626.vy`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/examples/tokens/ERC721.vy` & `vyper-0.3.8/examples/tokens/ERC721.vy`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/examples/voting/ballot.vy` & `vyper-0.3.8/examples/voting/ballot.vy`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/examples/wallet/wallet.vy` & `vyper-0.3.8/examples/wallet/wallet.vy`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/logo/vyper-logo-flat.png` & `vyper-0.3.8/logo/vyper-logo-flat.png`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/logo/vyper-logo-flat.svg` & `vyper-0.3.8/logo/vyper-logo-flat.svg`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/logo/vyper-logo-transparent.png` & `vyper-0.3.8/logo/vyper-logo-transparent.png`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/logo/vyper-logo-transparent.svg` & `vyper-0.3.8/logo/vyper-logo-transparent.svg`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/logo/vyper-logo.ai` & `vyper-0.3.8/logo/vyper-logo.ai`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/make.cmd` & `vyper-0.3.8/make.cmd`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/setup.cfg` & `vyper-0.3.8/setup.cfg`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/setup.py` & `vyper-0.3.8/setup.py`

 * *Files 12% similar despite different names*

```diff
@@ -10,31 +10,31 @@
     "test": [
         "pytest>=6.2.5,<7.0",
         "pytest-cov>=2.10,<3.0",
         "pytest-instafail>=0.4,<1.0",
         "pytest-xdist>=2.5,<3.0",
         "pytest-split>=0.7.0,<1.0",
         "pytest-rerunfailures>=10.2,<11",
-        "eth-tester[py-evm]>=0.6.0b6,<0.7",
-        "py-evm>=0.5.0a3,<0.6",
-        "web3==5.27.0",
+        "eth-tester[py-evm]>=0.9.0b1,<0.10",
+        "py-evm>=0.7.0a1,<0.8",
+        "web3==6.0.0",
         "tox>=3.15,<4.0",
         "lark==1.1.2",
         "hypothesis[lark]>=5.37.1,<6.0",
+        "eth-stdlib==0.2.6",
     ],
     "lint": [
-        "black==21.9b0",
-        "click<8.1.0",  # temporary pin - black21.9b0 fails with 8.1.0
+        "black==23.3.0",
         "flake8==3.9.2",
         "flake8-bugbear==20.1.4",
         "flake8-use-fstring==1.1",
         "isort==5.9.3",
         "mypy==0.910",
     ],
-    "docs": ["recommonmark", "sphinx>=3.0,<4.0", "sphinx_rtd_theme>=0.5,<0.6"],
+    "docs": ["recommonmark", "sphinx>=6.0,<7.0", "sphinx_rtd_theme>=1.2,<1.3"],
     "dev": ["ipython", "pre-commit", "pyinstaller", "twine"],
 }
 
 extras_require["dev"] = (
     extras_require["test"] + extras_require["lint"] + extras_require["docs"] + extras_require["dev"]
 )
 
@@ -85,22 +85,21 @@
     author="Vyper Team",
     author_email="",
     url="https://github.com/vyperlang/vyper",
     license="Apache License 2.0",
     keywords="ethereum evm smart contract language",
     include_package_data=True,
     packages=find_packages(exclude=("tests", "docs")),
-    python_requires=">=3.7,<3.11",
+    python_requires=">=3.10,<4",
     py_modules=["vyper"],
     install_requires=[
-        "asttokens==2.0.5",
+        "asttokens>=2.0.5,<3",
         "pycryptodome>=3.5.1,<4",
         "semantic-version>=2.10,<3",
-        "cached-property==1.5.2 ; python_version<'3.8'",
-        "importlib-metadata ; python_version<'3.8'",
+        "importlib-metadata",
         "wheel",
     ],
     setup_requires=["pytest-runner", "setuptools_scm"],
     tests_require=extras_require["test"],
     extras_require=extras_require,
     entry_points={
         "console_scripts": [
@@ -109,14 +108,13 @@
             "fang=vyper.cli.vyper_ir:_parse_cli_args",
             "vyper-json=vyper.cli.vyper_json:_parse_cli_args",
         ]
     },
     classifiers=[
         "Intended Audience :: Developers",
         "License :: OSI Approved :: Apache Software License",
-        "Programming Language :: Python :: 3.8",
-        "Programming Language :: Python :: 3.9",
         "Programming Language :: Python :: 3.10",
+        "Programming Language :: Python :: 3.11",
     ],
     package_data={"vyper.ast": ["grammar.lark"]},
     data_files=[("", [hash_file_rel_path])],
 )
```

### Comparing `vyper-0.3.7/tests/ast/nodes/test_compare_nodes.py` & `vyper-0.3.8/tests/ast/nodes/test_compare_nodes.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/ast/nodes/test_evaluate_binop_decimal.py` & `vyper-0.3.8/tests/ast/nodes/test_evaluate_binop_decimal.py`

 * *Files 3% similar despite different names*

```diff
@@ -4,15 +4,15 @@
 from hypothesis import example, given, settings
 from hypothesis import strategies as st
 
 from vyper import ast as vy_ast
 from vyper.exceptions import OverflowException, TypeMismatch, ZeroDivisionException
 
 st_decimals = st.decimals(
-    min_value=-(2 ** 32), max_value=2 ** 32, allow_nan=False, allow_infinity=False, places=10
+    min_value=-(2**32), max_value=2**32, allow_nan=False, allow_infinity=False, places=10
 )
 
 
 @pytest.mark.fuzzing
 @settings(max_examples=50, deadline=1000)
 @given(left=st_decimals, right=st_decimals)
 @example(left=Decimal("0.9999999999"), right=Decimal("0.0000000001"))
@@ -71,15 +71,15 @@
 
     literal_op = " ".join(f"{a} {b}" for a, b in zip(values, ops))
     literal_op = literal_op.rsplit(maxsplit=1)[0]
     vyper_ast = vy_ast.parse_to_ast(literal_op)
     try:
         vy_ast.folding.replace_literal_ops(vyper_ast)
         expected = vyper_ast.body[0].value.value
-        is_valid = -(2 ** 127) <= expected < 2 ** 127
+        is_valid = -(2**127) <= expected < 2**127
     except (OverflowException, ZeroDivisionException):
         # for overflow or division/modulus by 0, expect the contract call to revert
         is_valid = False
 
     if is_valid:
         assert contract.foo(*values) == expected
     else:
```

### Comparing `vyper-0.3.7/tests/ast/nodes/test_evaluate_binop_int.py` & `vyper-0.3.8/tests/ast/nodes/test_evaluate_binop_int.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 import pytest
 from hypothesis import example, given, settings
 from hypothesis import strategies as st
 
 from vyper import ast as vy_ast
 from vyper.exceptions import ZeroDivisionException
 
-st_int32 = st.integers(min_value=-(2 ** 32), max_value=2 ** 32)
+st_int32 = st.integers(min_value=-(2**32), max_value=2**32)
 
 
 @pytest.mark.fuzzing
 @settings(max_examples=50, deadline=1000)
 @given(left=st_int32, right=st_int32)
 @example(left=1, right=1)
 @example(left=1, right=-1)
@@ -34,15 +34,15 @@
 
     if is_valid:
         assert contract.foo(left, right) == new_node.value
     else:
         assert_tx_failed(lambda: contract.foo(left, right))
 
 
-st_uint64 = st.integers(min_value=0, max_value=2 ** 64)
+st_uint64 = st.integers(min_value=0, max_value=2**64)
 
 
 @pytest.mark.fuzzing
 @settings(max_examples=50, deadline=1000)
 @given(left=st_uint64, right=st_uint64)
 @pytest.mark.parametrize("op", "+-*/%")
 def test_binop_uint256(get_contract, assert_tx_failed, op, left, right):
@@ -91,15 +91,14 @@
 @pytest.mark.fuzzing
 @settings(max_examples=50, deadline=1000)
 @given(
     values=st.lists(st.integers(min_value=-256, max_value=256), min_size=2, max_size=10),
     ops=st.lists(st.sampled_from("+-*/%"), min_size=11, max_size=11),
 )
 def test_binop_nested(get_contract, assert_tx_failed, values, ops):
-
     variables = "abcdefghij"
     input_value = ",".join(f"{i}: int128" for i in variables[: len(values)])
     return_value = " ".join(f"{a} {b}" for a, b in zip(variables[: len(values)], ops))
     return_value = return_value.rsplit(maxsplit=1)[0]
 
     source = f"""
 @external
```

### Comparing `vyper-0.3.7/tests/ast/nodes/test_evaluate_boolop.py` & `vyper-0.3.8/tests/ast/nodes/test_evaluate_boolop.py`

 * *Files 1% similar despite different names*

```diff
@@ -8,15 +8,14 @@
 
 
 @pytest.mark.fuzzing
 @settings(max_examples=50, deadline=1000)
 @given(values=st.lists(st.booleans(), min_size=2, max_size=10))
 @pytest.mark.parametrize("comparator", ["and", "or"])
 def test_boolop_simple(get_contract, values, comparator):
-
     input_value = ",".join(f"{i}: bool" for i in variables[: len(values)])
     return_value = f" {comparator} ".join(variables[: len(values)])
 
     source = f"""
 @external
 def foo({input_value}) -> bool:
     return {return_value}
@@ -35,15 +34,14 @@
 @pytest.mark.fuzzing
 @settings(max_examples=50, deadline=1000)
 @given(
     values=st.lists(st.booleans(), min_size=2, max_size=10),
     comparators=st.lists(st.sampled_from(["and", "or"]), min_size=11, max_size=11),
 )
 def test_boolop_nested(get_contract, values, comparators):
-
     input_value = ",".join(f"{i}: bool" for i in variables[: len(values)])
     return_value = " ".join(f"{a} {b}" for a, b in zip(variables[: len(values)], comparators))
     return_value = return_value.rsplit(maxsplit=1)[0]
 
     source = f"""
 @external
 def foo({input_value}) -> bool:
```

### Comparing `vyper-0.3.7/tests/ast/nodes/test_evaluate_compare.py` & `vyper-0.3.8/tests/ast/nodes/test_evaluate_compare.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/ast/nodes/test_evaluate_subscript.py` & `vyper-0.3.8/tests/ast/nodes/test_evaluate_subscript.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/ast/nodes/test_evaluate_unaryop.py` & `vyper-0.3.8/tests/ast/nodes/test_evaluate_unaryop.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/ast/nodes/test_from_node.py` & `vyper-0.3.8/tests/ast/nodes/test_from_node.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/ast/nodes/test_get_children.py` & `vyper-0.3.8/tests/ast/nodes/test_get_children.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/ast/nodes/test_get_descendants.py` & `vyper-0.3.8/tests/ast/nodes/test_get_descendants.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/ast/nodes/test_hex.py` & `vyper-0.3.8/tests/ast/nodes/test_hex.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/ast/nodes/test_replace_in_tree.py` & `vyper-0.3.8/tests/ast/nodes/test_replace_in_tree.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,20 +1,20 @@
 import pytest
 
 from vyper import ast as vy_ast
 from vyper.exceptions import CompilerPanic
 
 
 def test_assumptions():
-    # ASTs generated seperately from the same source should compare equal
+    # ASTs generated separately from the same source should compare equal
     test_tree = vy_ast.parse_to_ast("foo = 42")
     expected_tree = vy_ast.parse_to_ast("foo = 42")
     assert vy_ast.compare_nodes(test_tree, expected_tree)
 
-    # ASTs generated seperately with different source should compare not-equal
+    # ASTs generated separately with different source should compare not-equal
     test_tree = vy_ast.parse_to_ast("foo = 42")
     expected_tree = vy_ast.parse_to_ast("bar = 666")
     assert not vy_ast.compare_nodes(test_tree, expected_tree)
 
 
 def test_simple_replacement():
     test_tree = vy_ast.parse_to_ast("foo = 42")
```

### Comparing `vyper-0.3.7/tests/ast/test_folding.py` & `vyper-0.3.8/tests/ast/test_folding.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/ast/test_natspec.py` & `vyper-0.3.8/tests/ast/test_natspec.py`

 * *Files 1% similar despite different names*

```diff
@@ -20,14 +20,15 @@
 def doesEat(food: String[30], qty: uint256) -> bool:
     '''
     @notice Determine if Bugs will accept `qty` of `food` to eat
     @dev Compares the entire string and does not rely on a hash
     @param food The name of a food to evaluate (in English)
     @param qty The number of food items to evaluate
     @return True if Bugs will eat it, False otherwise
+    @custom:my-custom-tag hello, world!
     '''
     return True
 """
 
 
 expected_userdoc = {
     "methods": {
@@ -47,14 +48,15 @@
         "doesEat(string,uint256)": {
             "details": "Compares the entire string and does not rely on a hash",
             "params": {
                 "food": "The name of a food to evaluate (in English)",
                 "qty": "The number of food items to evaluate",
             },
             "returns": {"_0": "True if Bugs will eat it, False otherwise"},
+            "custom:my-custom-tag": "hello, world!",
         }
     },
     "title": "A simulator for Bug Bunny, the most famous Rabbit",
 }
 
 
 def parse_natspec(code):
```

### Comparing `vyper-0.3.7/tests/ast/test_pre_parser.py` & `vyper-0.3.8/tests/ast/test_pre_parser.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/base_conftest.py` & `vyper-0.3.8/tests/base_conftest.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,14 +1,17 @@
+import json
+
 import pytest
+import web3.exceptions
 from eth_tester import EthereumTester, PyEVMBackend
 from eth_tester.exceptions import TransactionFailed
 from eth_utils.toolz import compose
 from hexbytes import HexBytes
 from web3 import Web3
-from web3.contract import Contract, mk_collision_prop
+from web3.contract import Contract
 from web3.providers.eth_tester import EthereumTesterProvider
 
 from vyper import compiler
 from vyper.ast.grammar import parse_vyper_source
 
 
 class VyperMethod:
@@ -26,15 +29,15 @@
             modifier, modifier_dict = "call", {}
             fn_abi = [
                 x
                 for x in self._function.contract_abi
                 if x.get("name") == self._function.function_identifier
             ].pop()
             # To make tests faster just supply some high gas value.
-            modifier_dict.update({"gas": fn_abi.get("gas", 0) + 50000})
+            modifier_dict.update({"gas": fn_abi.get("gas", 0) + 500000})
         elif len(kwargs) == 1:
             modifier, modifier_dict = kwargs.popitem()
             if modifier not in self.ALLOWED_MODIFIERS:
                 raise TypeError(f"The only allowed keyword arguments are: {self.ALLOWED_MODIFIERS}")
         else:
             raise TypeError(f"Use up to one keyword argument, one of: {self.ALLOWED_MODIFIERS}")
         return getattr(self._function(*args), modifier)(modifier_dict)
@@ -51,18 +54,24 @@
     """
 
     def __init__(self, classic_contract, method_class=VyperMethod):
         classic_contract._return_data_normalizers += CONCISE_NORMALIZERS
         self._classic_contract = classic_contract
         self.address = self._classic_contract.address
         protected_fn_names = [fn for fn in dir(self) if not fn.endswith("__")]
-        for fn_name in self._classic_contract.functions:
+
+        try:
+            fn_names = [fn["name"] for fn in self._classic_contract.functions._functions]
+        except web3.exceptions.NoABIFunctionsFound:
+            fn_names = []
+
+        for fn_name in fn_names:
             # Override namespace collisions
             if fn_name in protected_fn_names:
-                _concise_method = mk_collision_prop(fn_name)
+                raise AttributeError(f"{fn_name} is protected!")
             else:
                 _classic_method = getattr(self._classic_contract.functions, fn_name)
                 _concise_method = method_class(
                     _classic_method, self._classic_contract._return_data_normalizers
                 )
             setattr(self, fn_name, _concise_method)
 
@@ -81,15 +90,15 @@
 CONCISE_NORMALIZERS = (_none_addr,)
 
 
 @pytest.fixture(scope="module")
 def tester():
     # set absurdly high gas limit so that london basefee never adjusts
     # (note: 2**63 - 1 is max that evm allows)
-    custom_genesis = PyEVMBackend._generate_genesis_params(overrides={"gas_limit": 10 ** 10})
+    custom_genesis = PyEVMBackend._generate_genesis_params(overrides={"gas_limit": 10**10})
     custom_genesis["base_fee_per_gas"] = 0
     backend = PyEVMBackend(genesis_parameters=custom_genesis)
     return EthereumTester(backend=backend)
 
 
 def zero_gas_price_strategy(web3, transaction_params=None):
     return 0  # zero gas price makes testing simpler.
@@ -101,24 +110,26 @@
     w3.eth.set_gas_price_strategy(zero_gas_price_strategy)
     return w3
 
 
 def _get_contract(w3, source_code, no_optimize, *args, **kwargs):
     out = compiler.compile_code(
         source_code,
-        ["abi", "bytecode"],
+        # test that metadata gets generated
+        ["abi", "bytecode", "metadata"],
         interface_codes=kwargs.pop("interface_codes", None),
         no_optimize=no_optimize,
         evm_version=kwargs.pop("evm_version", None),
         show_gas_estimates=True,  # Enable gas estimates for testing
     )
     parse_vyper_source(source_code)  # Test grammar.
+    json.dumps(out["metadata"])  # test metadata is json serializable
     abi = out["abi"]
     bytecode = out["bytecode"]
-    value = kwargs.pop("value_in_eth", 0) * 10 ** 18  # Handle deploying with an eth value.
+    value = kwargs.pop("value_in_eth", 0) * 10**18  # Handle deploying with an eth value.
     c = w3.eth.contract(abi=abi, bytecode=bytecode)
     deploy_transaction = c.constructor(*args)
     tx_info = {"from": w3.eth.accounts[0], "value": value, "gasPrice": 0}
     tx_info.update(kwargs)
     tx_hash = deploy_transaction.transact(tx_info)
     address = w3.eth.get_transaction_receipt(tx_hash)["contractAddress"]
     return w3.eth.contract(address, abi=abi, bytecode=bytecode, ContractFactoryClass=VyperContract)
@@ -177,15 +188,15 @@
     return get_contract
 
 
 @pytest.fixture
 def get_logs(w3):
     def get_logs(tx_hash, c, event_name):
         tx_receipt = w3.eth.get_transaction_receipt(tx_hash)
-        return c._classic_contract.events[event_name]().processReceipt(tx_receipt)
+        return c._classic_contract.events[event_name]().process_receipt(tx_receipt)
 
     return get_logs
 
 
 @pytest.fixture(scope="module")
 def assert_tx_failed(tester):
     def assert_tx_failed(function_to_test, exception=TransactionFailed, exc_text=None):
```

### Comparing `vyper-0.3.7/tests/cli/outputs/test_storage_layout.py` & `vyper-0.3.8/tests/cli/outputs/test_storage_layout.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/cli/outputs/test_storage_layout_overrides.py` & `vyper-0.3.8/tests/cli/outputs/test_storage_layout_overrides.py`

 * *Files 2% similar despite different names*

```diff
@@ -91,14 +91,29 @@
         " but it has already been reserved by 'name'",
     ):
         compile_code(
             code, output_formats=["layout"], storage_layout_override=storage_layout_override
         )
 
 
+def test_overflow():
+    code = """
+x: uint256[2]
+    """
+
+    storage_layout_override = {"x": {"slot": 2**256 - 1, "type": "uint256[2]"}}
+
+    with pytest.raises(
+        StorageLayoutException, match=f"Invalid storage slot for var x, out of bounds: {2**256}\n"
+    ):
+        compile_code(
+            code, output_formats=["layout"], storage_layout_override=storage_layout_override
+        )
+
+
 def test_incomplete_overrides():
     code = """
 name: public(String[64])
 symbol: public(String[32])"""
 
     storage_layout_override = {"name": {"slot": 0, "type": "String[64]"}}
```

### Comparing `vyper-0.3.7/tests/cli/vyper_compile/test_compile_files.py` & `vyper-0.3.8/tests/cli/vyper_compile/test_compile_files.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/cli/vyper_compile/test_import_paths.py` & `vyper-0.3.8/tests/cli/vyper_compile/test_import_paths.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/cli/vyper_compile/test_parse_args.py` & `vyper-0.3.8/tests/cli/vyper_compile/test_parse_args.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/cli/vyper_json/test_compile_from_input_dict.py` & `vyper-0.3.8/tests/cli/vyper_json/test_compile_from_input_dict.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/cli/vyper_json/test_compile_json.py` & `vyper-0.3.8/tests/cli/vyper_json/test_compile_json.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/cli/vyper_json/test_get_contracts.py` & `vyper-0.3.8/tests/cli/vyper_json/test_get_contracts.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/cli/vyper_json/test_get_settings.py` & `vyper-0.3.8/tests/cli/vyper_json/test_get_settings.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/cli/vyper_json/test_interfaces.py` & `vyper-0.3.8/tests/cli/vyper_json/test_interfaces.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/cli/vyper_json/test_output_dict.py` & `vyper-0.3.8/tests/cli/vyper_json/test_output_dict.py`

 * *Files 6% similar despite different names*

```diff
@@ -27,11 +27,12 @@
         "metadata": data["metadata"],
         "evm": {
             "bytecode": {"object": data["bytecode"], "opcodes": data["opcodes"]},
             "deployedBytecode": {
                 "object": data["bytecode_runtime"],
                 "opcodes": data["opcodes_runtime"],
                 "sourceMap": data["source_map"]["pc_pos_map_compressed"],
+                "sourceMapFull": data["source_map_full"],
             },
             "methodIdentifiers": data["method_identifiers"],
         },
     }
```

### Comparing `vyper-0.3.7/tests/cli/vyper_json/test_output_selection.py` & `vyper-0.3.8/tests/cli/vyper_json/test_output_selection.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/cli/vyper_json/test_parse_args_vyperjson.py` & `vyper-0.3.8/tests/cli/vyper_json/test_parse_args_vyperjson.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/compiler/ir/test_compile_ir.py` & `vyper-0.3.8/tests/compiler/ir/test_compile_ir.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,16 +1,16 @@
 import pytest
 
 from vyper.codegen.ir_node import IRnode
 from vyper.ir import compile_ir
 from vyper.ir.s_expressions import parse_s_exp
 
 fail_list = [
-    [-(2 ** 255) - 3],
-    [2 ** 256 + 3],
+    [-(2**255) - 3],
+    [2**256 + 3],
     ["set", "_poz"],
     [["set", "var_1", 0, 0]],
     ["with", "var_1", 0, ["set", 1, 1]],
     ["break"],  # invalid break
     ["continue"],  # invalid continue
     ["invalidllelement"],
 ]
@@ -64,8 +64,8 @@
     assert c.test(-123456) == -123456
 
 
 def test_pc_debugger():
     debugger_ir = ["seq", ["mstore", 0, 32], ["pc_debugger"]]
     ir_nodes = IRnode.from_list(debugger_ir)
     _, line_number_map = compile_ir.assembly_to_evm(compile_ir.compile_to_assembly(ir_nodes))
-    assert line_number_map["pc_breakpoints"][0] == 5
+    assert line_number_map["pc_breakpoints"][0] == 4
```

### Comparing `vyper-0.3.7/tests/compiler/ir/test_optimize_ir.py` & `vyper-0.3.8/tests/compiler/ir/test_optimize_ir.py`

 * *Files 16% similar despite different names*

```diff
@@ -30,65 +30,73 @@
     (["assert", ["eq", "x", "y"]], ["assert", ["iszero", ["xor", "x", "y"]]]),
     (["assert", ["ne", "x", "y"]], None),
     # nesting
     (["mstore", 0, ["eq", 1, 2]], ["mstore", 0, 0]),
     # conditions
     (["ge", "x", 0], [1]),  # x >= 0 == True
     (["ge", ["sload", 0], 0], None),  # no-op
-    (["gt", "x", 2 ** 256 - 1], [0]),  # x >= MAX_UINT256 == False
+    (["gt", "x", 2**256 - 1], [0]),  # x >= MAX_UINT256 == False
     # (x > 0) => x == 0
     (["iszero", ["gt", "x", 0]], ["iszero", ["iszero", ["iszero", "x"]]]),
     # !(x < MAX_UINT256) => x == MAX_UINT256
-    (["iszero", ["lt", "x", 2 ** 256 - 1]], ["iszero", ["iszero", ["iszero", ["not", "x"]]]]),
+    (["iszero", ["lt", "x", 2**256 - 1]], ["iszero", ["iszero", ["iszero", ["not", "x"]]]]),
     # !(x < MAX_INT256) => x == MAX_INT256
     (
-        ["iszero", ["slt", "x", 2 ** 255 - 1]],
-        ["iszero", ["iszero", ["iszero", ["xor", "x", 2 ** 255 - 1]]]],
+        ["iszero", ["slt", "x", 2**255 - 1]],
+        ["iszero", ["iszero", ["iszero", ["xor", "x", 2**255 - 1]]]],
     ),
     # !(x > MIN_INT256) => x == MIN_INT256
     (
-        ["iszero", ["sgt", "x", -(2 ** 255)]],
-        ["iszero", ["iszero", ["iszero", ["xor", "x", -(2 ** 255)]]]],
+        ["iszero", ["sgt", "x", -(2**255)]],
+        ["iszero", ["iszero", ["iszero", ["xor", "x", -(2**255)]]]],
     ),
-    (["sgt", "x", 2 ** 255 - 1], [0]),  # signed x > MAX_INT256 == False
-    (["sge", "x", 2 ** 255 - 1], ["eq", "x", 2 ** 255 - 1]),
+    (["sgt", "x", 2**255 - 1], [0]),  # signed x > MAX_INT256 == False
+    (["sge", "x", 2**255 - 1], ["eq", "x", 2**255 - 1]),
     (["eq", -1, "x"], ["iszero", ["not", "x"]]),
     (["iszero", ["eq", -1, "x"]], ["iszero", ["iszero", ["not", "x"]]]),
     (["le", "x", 0], ["iszero", "x"]),
     (["le", 0, "x"], [1]),
     (["le", 0, ["sload", 0]], None),  # no-op
     (["ge", "x", 0], [1]),
+    (["le", "x", "x"], [1]),
+    (["ge", "x", "x"], [1]),
+    (["sle", "x", "x"], [1]),
+    (["sge", "x", "x"], [1]),
+    (["lt", "x", "x"], [0]),
+    (["gt", "x", "x"], [0]),
+    (["slt", "x", "x"], [0]),
+    (["sgt", "x", "x"], [0]),
     # boundary conditions
-    (["slt", "x", -(2 ** 255)], [0]),
-    (["sle", "x", -(2 ** 255)], ["eq", "x", -(2 ** 255)]),
-    (["lt", "x", 2 ** 256 - 1], None),
-    (["le", "x", 2 ** 256 - 1], [1]),
+    (["slt", "x", -(2**255)], [0]),
+    (["sle", "x", -(2**255)], ["eq", "x", -(2**255)]),
+    (["lt", "x", 2**256 - 1], None),
+    (["le", "x", 2**256 - 1], [1]),
     (["gt", "x", 0], ["iszero", ["iszero", "x"]]),
     # x < 0 => false
     (["lt", "x", 0], [0]),
     # 0 < x => x != 0
     (["lt", 0, "x"], ["iszero", ["iszero", "x"]]),
     (["gt", 5, "x"], None),
     # x < 1 => x == 0
     (["lt", "x", 1], ["iszero", "x"]),
     (["slt", "x", 1], None),
     (["gt", "x", 1], None),
     (["sgt", "x", 1], None),
-    (["gt", "x", 2 ** 256 - 2], ["iszero", ["not", "x"]]),
-    (["lt", "x", 2 ** 256 - 2], None),
-    (["slt", "x", 2 ** 256 - 2], None),
-    (["sgt", "x", 2 ** 256 - 2], None),
-    (["slt", "x", -(2 ** 255) + 1], ["eq", "x", -(2 ** 255)]),
-    (["sgt", "x", -(2 ** 255) + 1], None),
-    (["lt", "x", -(2 ** 255) + 1], None),
-    (["gt", "x", -(2 ** 255) + 1], None),
-    (["sgt", "x", 2 ** 255 - 2], ["eq", "x", 2 ** 255 - 1]),
-    (["slt", "x", 2 ** 255 - 2], None),
-    (["gt", "x", 2 ** 255 - 2], None),
-    (["lt", "x", 2 ** 255 - 2], None),
+    (["gt", "x", 2**256 - 2], ["iszero", ["not", "x"]]),
+    (["lt", "x", 2**256 - 2], None),
+    (["slt", "x", 2**256 - 2], None),
+    (["sgt", "x", 2**256 - 2], None),
+    (["slt", "x", -(2**255) + 1], ["eq", "x", -(2**255)]),
+    (["sgt", "x", -(2**255) + 1], None),
+    (["lt", "x", -(2**255) + 1], None),
+    (["gt", "x", -(2**255) + 1], None),
+    (["sgt", "x", 2**255 - 2], ["eq", "x", 2**255 - 1]),
+    (["slt", "x", 2**255 - 2], None),
+    (["gt", "x", 2**255 - 2], None),
+    (["lt", "x", 2**255 - 2], None),
     # 5 > x; x < 5; x <= 4
     (["iszero", ["gt", 5, "x"]], ["iszero", ["le", "x", 4]]),
     (["iszero", ["ge", 5, "x"]], None),
     # 5 >= x; x <= 5; x < 6
     (["ge", 5, "x"], ["lt", "x", 6]),
     (["lt", 5, "x"], None),
     # 5 < x; x > 5; x >= 6
@@ -105,26 +113,26 @@
     (["slt", 5, "x"], None),
     # 5 < x; x > 5; x >= 6
     (["iszero", ["slt", 5, "x"]], ["iszero", ["sge", "x", 6]]),
     (["iszero", ["sle", 5, "x"]], None),
     # 5 <= x; x >= 5; x > 4
     (["sle", 5, "x"], ["sgt", "x", 4]),
     # tricky constant folds
-    (["sgt", 2 ** 256 - 1, 0], [0]),  # -1 > 0
-    (["gt", 2 ** 256 - 1, 0], [1]),  # -1 > 0
-    (["gt", 2 ** 255, 0], [1]),  # 0x80 > 0
-    (["sgt", 2 ** 255, 0], [0]),  # 0x80 > 0
-    (["sgt", 2 ** 255, 2 ** 255 - 1], [0]),  # 0x80 > 0x81
-    (["gt", -(2 ** 255), 2 ** 255 - 1], [1]),  # 0x80 > 0x81
-    (["slt", 2 ** 255, 2 ** 255 - 1], [1]),  # 0x80 < 0x7f
-    (["lt", -(2 ** 255), 2 ** 255 - 1], [0]),  # 0x80 < 0x7f
-    (["sle", -1, 2 ** 256 - 1], [1]),  # -1 <= -1
-    (["sge", -(2 ** 255), 2 ** 255], [1]),  # 0x80 >= 0x80
-    (["sgt", -(2 ** 255), 2 ** 255], [0]),  # 0x80 > 0x80
-    (["slt", 2 ** 255, -(2 ** 255)], [0]),  # 0x80 < 0x80
+    (["sgt", 2**256 - 1, 0], [0]),  # -1 > 0
+    (["gt", 2**256 - 1, 0], [1]),  # -1 > 0
+    (["gt", 2**255, 0], [1]),  # 0x80 > 0
+    (["sgt", 2**255, 0], [0]),  # 0x80 > 0
+    (["sgt", 2**255, 2**255 - 1], [0]),  # 0x80 > 0x81
+    (["gt", -(2**255), 2**255 - 1], [1]),  # 0x80 > 0x81
+    (["slt", 2**255, 2**255 - 1], [1]),  # 0x80 < 0x7f
+    (["lt", -(2**255), 2**255 - 1], [0]),  # 0x80 < 0x7f
+    (["sle", -1, 2**256 - 1], [1]),  # -1 <= -1
+    (["sge", -(2**255), 2**255], [1]),  # 0x80 >= 0x80
+    (["sgt", -(2**255), 2**255], [0]),  # 0x80 > 0x80
+    (["slt", 2**255, -(2**255)], [0]),  # 0x80 < 0x80
     # arithmetic
     (["ceil32", "x"], None),
     (["ceil32", 0], [0]),
     (["ceil32", 1], [32]),
     (["ceil32", 32], [32]),
     (["ceil32", 33], [64]),
     (["ceil32", 95], [96]),
@@ -155,25 +163,25 @@
     (["mod", ["sload", 0], 0], None),
     (["smod", "x", 0], [0]),
     (["mul", "x", 32], ["shl", 5, "x"]),
     (["div", "x", 64], ["shr", 6, "x"]),
     (["mod", "x", 128], ["and", "x", 127]),
     (["sdiv", "x", 64], None),
     (["smod", "x", 64], None),
-    (["exp", 3, 5], [3 ** 5]),
-    (["exp", 3, 256], [(3 ** 256) % (2 ** 256)]),
+    (["exp", 3, 5], [3**5]),
+    (["exp", 3, 256], [(3**256) % (2**256)]),
     (["exp", 2, 257], [0]),
     (["exp", "x", 0], [1]),
     (["exp", "x", 1], ["x"]),
     (["exp", 1, "x"], [1]),
     (["exp", 0, "x"], ["iszero", "x"]),
     # bitwise ops
-    (["xor", "x", 2 ** 256 - 1], ["not", "x"]),
-    (["and", "x", 2 ** 256 - 1], ["x"]),
-    (["or", "x", 2 ** 256 - 1], [2 ** 256 - 1]),
+    (["xor", "x", 2**256 - 1], ["not", "x"]),
+    (["and", "x", 2**256 - 1], ["x"]),
+    (["or", "x", 2**256 - 1], [2**256 - 1]),
     (["shr", 0, "x"], ["x"]),
     (["sar", 0, "x"], ["x"]),
     (["shl", 0, "x"], ["x"]),
     (["shr", 256, "x"], None),
     (["sar", 256, "x"], None),
     (["shl", 256, "x"], None),
     (["and", 1, 2], [0]),
@@ -191,20 +199,20 @@
     (["xor", 0, "x"], ["x"]),
     (["xor", "x", "x"], [0]),
     (["iszero", ["or", "x", 1]], [0]),
     (["iszero", ["or", 2, "x"]], [0]),
     (["iszero", ["or", 1, ["sload", 0]]], None),
     # nested optimizations
     (["eq", 0, ["sub", 1, 1]], [1]),
-    (["eq", 0, ["add", 2 ** 255, 2 ** 255]], [1]),  # test compile-time wrapping
-    (["eq", 0, ["add", 2 ** 255, -(2 ** 255)]], [1]),  # test compile-time wrapping
+    (["eq", 0, ["add", 2**255, 2**255]], [1]),  # test compile-time wrapping
+    (["eq", 0, ["add", 2**255, -(2**255)]], [1]),  # test compile-time wrapping
     (["eq", -1, ["add", 0, -1]], [1]),  # test compile-time wrapping
-    (["eq", -1, ["add", 2 ** 255, 2 ** 255 - 1]], [1]),  # test compile-time wrapping
-    (["eq", -1, ["add", -(2 ** 255), 2 ** 255 - 1]], [1]),  # test compile-time wrapping
-    (["eq", -2, ["add", 2 ** 256 - 1, 2 ** 256 - 1]], [1]),  # test compile-time wrapping
+    (["eq", -1, ["add", 2**255, 2**255 - 1]], [1]),  # test compile-time wrapping
+    (["eq", -1, ["add", -(2**255), 2**255 - 1]], [1]),  # test compile-time wrapping
+    (["eq", -2, ["add", 2**256 - 1, 2**256 - 1]], [1]),  # test compile-time wrapping
     (["eq", "x", "x"], [1]),
     (["eq", "callvalue", "callvalue"], None),
     (["ne", "x", "x"], [0]),
 ]
 
 
 @pytest.mark.parametrize("ir", optimize_list)
@@ -225,31 +233,38 @@
     ["assert", ["eq", 2, 1]],
     ["assert", ["ne", 1, 1]],
     ["assert", ["sub", 1, 1]],
     ["assert", ["lt", 2, 1]],
     ["assert", ["lt", 1, 1]],
     ["assert", ["lt", "x", 0]],  # +x < 0
     ["assert", ["le", 1, 0]],
-    ["assert", ["le", 2 ** 256 - 1, 0]],
+    ["assert", ["le", 2**256 - 1, 0]],
     ["assert", ["gt", 1, 2]],
     ["assert", ["gt", 1, 1]],
-    ["assert", ["gt", 0, 2 ** 256 - 1]],
-    ["assert", ["gt", "x", 2 ** 256 - 1]],
+    ["assert", ["gt", 0, 2**256 - 1]],
+    ["assert", ["gt", "x", 2**256 - 1]],
     ["assert", ["ge", 1, 2]],
     ["assert", ["ge", 1, 2]],
     ["assert", ["slt", 2, 1]],
     ["assert", ["slt", 1, 1]],
-    ["assert", ["slt", 0, 2 ** 256 - 1]],  # 0 < -1
-    ["assert", ["slt", -(2 ** 255), 2 ** 255]],  # 0x80 < 0x80
-    ["assert", ["sle", 0, 2 ** 255]],  # 0 < 0x80
+    ["assert", ["slt", 0, 2**256 - 1]],  # 0 < -1
+    ["assert", ["slt", -(2**255), 2**255]],  # 0x80 < 0x80
+    ["assert", ["sle", 0, 2**255]],  # 0 < 0x80
     ["assert", ["sgt", 1, 2]],
     ["assert", ["sgt", 1, 1]],
-    ["assert", ["sgt", 2 ** 256 - 1, 0]],  # -1 > 0
-    ["assert", ["sgt", 2 ** 255, -(2 ** 255)]],  # 0x80 > 0x80
-    ["assert", ["sge", 2 ** 255, 0]],  # 0x80 > 0
+    ["assert", ["sgt", 2**256 - 1, 0]],  # -1 > 0
+    ["assert", ["sgt", 2**255, -(2**255)]],  # 0x80 > 0x80
+    ["assert", ["sge", 2**255, 0]],  # 0x80 > 0
 ]
 
 
 @pytest.mark.parametrize("ir", static_assertions_list)
 def test_static_assertions(ir, assert_compile_failed):
     ir = IRnode.from_list(ir)
     assert_compile_failed(lambda: optimizer.optimize(ir), StaticAssertionException)
+
+
+def test_operator_set_values():
+    # some sanity checks
+    assert optimizer.COMPARISON_OPS == {"lt", "gt", "le", "ge", "slt", "sgt", "sle", "sge"}
+    assert optimizer.STRICT_COMPARISON_OPS == {"lt", "gt", "slt", "sgt"}
+    assert optimizer.UNSTRICT_COMPARISON_OPS == {"le", "ge", "sle", "sge"}
```

### Comparing `vyper-0.3.7/tests/compiler/ir/test_with.py` & `vyper-0.3.8/tests/compiler/ir/test_with.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/compiler/test_compile_code.py` & `vyper-0.3.8/tests/compiler/test_compile_code.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/compiler/test_opcodes.py` & `vyper-0.3.8/tests/compiler/test_opcodes.py`

 * *Files 12% similar despite different names*

```diff
@@ -4,17 +4,19 @@
 from vyper.evm import opcodes
 from vyper.exceptions import CompilerPanic
 
 
 @pytest.fixture(params=list(opcodes.EVM_VERSIONS))
 def evm_version(request):
     default = opcodes.active_evm_version
-    opcodes.active_evm_version = opcodes.EVM_VERSIONS[request.param]
-    yield request.param
-    opcodes.active_evm_version = default
+    try:
+        opcodes.active_evm_version = opcodes.EVM_VERSIONS[request.param]
+        yield request.param
+    finally:
+        opcodes.active_evm_version = default
 
 
 def test_opcodes():
     code = """
 @external
 def a() -> bool:
     return True
@@ -38,21 +40,27 @@
     if evm_version not in ("byzantium", "atlantis"):
         assert not opcodes.version_check(end="byzantium")
     istanbul_check = opcodes.version_check(begin="istanbul")
     assert istanbul_check == (opcodes.EVM_VERSIONS[evm_version] >= opcodes.EVM_VERSIONS["istanbul"])
 
 
 def test_get_opcodes(evm_version):
-    op = opcodes.get_opcodes()
-    if evm_version in ("paris", "berlin"):
-        assert "CHAINID" in op
-        assert op["SLOAD"][-1] == 2100
+    ops = opcodes.get_opcodes()
+    if evm_version in ("paris", "berlin", "shanghai", "cancun"):
+        assert "CHAINID" in ops
+        assert ops["SLOAD"][-1] == 2100
+        if evm_version in ("shanghai", "cancun"):
+            assert "PUSH0" in ops
+        if evm_version in ("cancun",):
+            assert "TLOAD" in ops
+            assert "TSTORE" in ops
     elif evm_version == "istanbul":
-        assert "CHAINID" in op
-        assert op["SLOAD"][-1] == 800
+        assert "CHAINID" in ops
+        assert ops["SLOAD"][-1] == 800
     else:
-        assert "CHAINID" not in op
-        assert op["SLOAD"][-1] == 200
+        assert "CHAINID" not in ops
+        assert ops["SLOAD"][-1] == 200
+
     if evm_version in ("byzantium", "atlantis"):
-        assert "CREATE2" not in op
+        assert "CREATE2" not in ops
     else:
-        assert op["CREATE2"][-1] == 32000
+        assert ops["CREATE2"][-1] == 32000
```

### Comparing `vyper-0.3.7/tests/compiler/test_pre_parser.py` & `vyper-0.3.8/tests/compiler/test_pre_parser.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/compiler/test_source_map.py` & `vyper-0.3.8/tests/compiler/test_source_map.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/conftest.py` & `vyper-0.3.8/tests/conftest.py`

 * *Files 12% similar despite different names*

```diff
@@ -46,22 +46,14 @@
 
 @pytest.fixture
 def keccak():
     return Web3.keccak
 
 
 @pytest.fixture
-def abi_encode(w3):
-    def f(abi_t, py_val):
-        return w3.codec.encode_single(abi_t, py_val)
-
-    return f
-
-
-@pytest.fixture
 def bytes_helper():
     def bytes_helper(str, length):
         return bytes(str, "utf-8") + bytearray(length - len(str))
 
     return bytes_helper
 
 
@@ -144,19 +136,18 @@
     func_with_decorator = gas_estimation_decorator(w3, tester, func_definition, source_code, func)
     setattr(contract, func, func_with_decorator)
 
 
 @pytest.fixture
 def get_contract_with_gas_estimation(tester, w3, no_optimize):
     def get_contract_with_gas_estimation(source_code, *args, **kwargs):
-
         contract = _get_contract(w3, source_code, no_optimize, *args, **kwargs)
-        for abi in contract._classic_contract.functions.abi:
-            if abi["type"] == "function":
-                set_decorator_to_contract_function(w3, tester, contract, source_code, abi["name"])
+        for abi_ in contract._classic_contract.functions.abi:
+            if abi_["type"] == "function":
+                set_decorator_to_contract_function(w3, tester, contract, source_code, abi_["name"])
         return contract
 
     return get_contract_with_gas_estimation
 
 
 @pytest.fixture
 def get_contract_with_gas_estimation_for_constants(w3, no_optimize):
@@ -197,7 +188,42 @@
         prefix = HexBytes("0xff")
         addr = HexBytes(_addr)
         salt = HexBytes(_salt)
         initcode = HexBytes(_initcode)
         return keccak(prefix + addr + salt + keccak(initcode))[12:]
 
     return _f
+
+
+@pytest.fixture
+def side_effects_contract(get_contract):
+    def generate(ret_type):
+        """
+        Generates a Vyper contract with an external `foo()` function, which
+        returns the specified return value of the specified return type, for
+        testing side effects using the `assert_side_effects_invoked` fixture.
+        """
+        code = f"""
+counter: public(uint256)
+
+@external
+def foo(s: {ret_type}) -> {ret_type}:
+    self.counter += 1
+    return s
+    """
+        contract = get_contract(code)
+        return contract
+
+    return generate
+
+
+@pytest.fixture
+def assert_side_effects_invoked():
+    def assert_side_effects_invoked(side_effects_contract, side_effects_trigger, n=1):
+        start_value = side_effects_contract.counter()
+
+        side_effects_trigger()
+
+        end_value = side_effects_contract.counter()
+        assert end_value == start_value + n
+
+    return assert_side_effects_invoked
```

### Comparing `vyper-0.3.7/tests/examples/auctions/test_blind_auction.py` & `vyper-0.3.8/tests/examples/auctions/test_blind_auction.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/examples/auctions/test_simple_open_auction.py` & `vyper-0.3.8/tests/examples/auctions/test_simple_open_auction.py`

 * *Files 3% similar despite different names*

```diff
@@ -52,17 +52,17 @@
     # Multiple bidders can bid
     auction_contract.bid(transact={"value": 3, "from": k3})
     auction_contract.bid(transact={"value": 4, "from": k4})
     auction_contract.bid(transact={"value": 5, "from": k5})
     # Check that highest bidder and highest bid have changed accordingly
     assert auction_contract.highestBidder() == k5
     assert auction_contract.highestBid() == 5
-    auction_contract.bid(transact={"value": 1 * 10 ** 10, "from": k1})
+    auction_contract.bid(transact={"value": 1 * 10**10, "from": k1})
     pending_return_before_outbid = auction_contract.pendingReturns(k1)
-    auction_contract.bid(transact={"value": 2 * 10 ** 10, "from": k2})
+    auction_contract.bid(transact={"value": 2 * 10**10, "from": k2})
     pending_return_after_outbid = auction_contract.pendingReturns(k1)
     # Account has a greater pending return balance after being outbid
     assert pending_return_after_outbid > pending_return_before_outbid
 
     balance_before_withdrawal = w3.eth.get_balance(k1)
     auction_contract.withdraw(transact={"from": k1})
     balance_after_withdrawal = w3.eth.get_balance(k1)
@@ -72,20 +72,20 @@
     assert auction_contract.pendingReturns(k1) == 0
 
 
 def test_end_auction(w3, tester, auction_contract, assert_tx_failed):
     k1, k2, k3, k4, k5 = w3.eth.accounts[:5]
     # Fails if auction end time has not been reached
     assert_tx_failed(lambda: auction_contract.endAuction())
-    auction_contract.bid(transact={"value": 1 * 10 ** 10, "from": k2})
+    auction_contract.bid(transact={"value": 1 * 10**10, "from": k2})
     # Move block timestamp foreward to reach auction end time
     # tester.time_travel(tester.get_block_by_number('latest')['timestamp'] + EXPIRY)
     w3.testing.mine(EXPIRY)
     balance_before_end = w3.eth.get_balance(k1)
     auction_contract.endAuction(transact={"from": k2})
     balance_after_end = w3.eth.get_balance(k1)
     # Beneficiary receives the highest bid
-    assert balance_after_end == balance_before_end + 1 * 10 ** 10
+    assert balance_after_end == balance_before_end + 1 * 10**10
     # Bidder cannot bid after auction end time has been reached
     assert_tx_failed(lambda: auction_contract.bid(transact={"value": 10, "from": k1}))
     # Auction cannot be ended twice
     assert_tx_failed(lambda: auction_contract.endAuction())
```

### Comparing `vyper-0.3.7/tests/examples/company/test_company.py` & `vyper-0.3.8/tests/examples/company/test_company.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 import pytest
 
 
 @pytest.fixture
 def c(w3, get_contract):
     with open("examples/stock/company.vy") as f:
         contract_code = f.read()
-        contract = get_contract(contract_code, *[w3.eth.accounts[0], 1000, 10 ** 6])
+        contract = get_contract(contract_code, *[w3.eth.accounts[0], 1000, 10**6])
     return contract
 
 
 def test_overbuy(w3, c, assert_tx_failed):
     # If all the stock has been bought, no one can buy more
     a1, a2 = w3.eth.accounts[1:3]
     test_shares = int(c.totalShares() / 2)
@@ -103,11 +103,11 @@
     # Transfer is logged
     logs = get_logs(c.transferStock(a2, 4, transact={"from": a1}), c, "Transfer")
     assert len(logs) == 1
     assert logs[0].event == "Transfer"
     assert logs[0].args.value == 4
 
     # Pay is logged
-    amount = 10 ** 4
+    amount = 10**4
     logs = get_logs(c.payBill(a3, amount, transact={}), c, "Pay")
     assert len(logs) == 1
     assert logs[0].args.amount == amount
```

### Comparing `vyper-0.3.7/tests/examples/crowdfund/test_crowdfund_example.py` & `vyper-0.3.8/tests/examples/crowdfund/test_crowdfund_example.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/examples/factory/test_factory.py` & `vyper-0.3.8/tests/examples/factory/test_factory.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/examples/market_maker/test_on_chain_market_maker.py` & `vyper-0.3.8/tests/examples/market_maker/test_on_chain_market_maker.py`

 * *Files 6% similar despite different names*

```diff
@@ -7,16 +7,16 @@
         contract_code = f.read()
     return get_contract(contract_code)
 
 
 TOKEN_NAME = "Vypercoin"
 TOKEN_SYMBOL = "FANG"
 TOKEN_DECIMALS = 18
-TOKEN_INITIAL_SUPPLY = 21 * 10 ** 6
-TOKEN_TOTAL_SUPPLY = TOKEN_INITIAL_SUPPLY * (10 ** TOKEN_DECIMALS)
+TOKEN_INITIAL_SUPPLY = 21 * 10**6
+TOKEN_TOTAL_SUPPLY = TOKEN_INITIAL_SUPPLY * (10**TOKEN_DECIMALS)
 
 
 @pytest.fixture
 def erc20(get_contract):
     with open("examples/tokens/ERC20.vy") as f:
         contract_code = f.read()
     return get_contract(
@@ -29,88 +29,88 @@
     assert market_maker.totalTokenQty() == 0
     assert market_maker.invariant() == 0
     assert market_maker.owner() is None
 
 
 def test_initiate(w3, market_maker, erc20, assert_tx_failed):
     a0 = w3.eth.accounts[0]
-    erc20.approve(market_maker.address, w3.toWei(2, "ether"), transact={})
+    erc20.approve(market_maker.address, w3.to_wei(2, "ether"), transact={})
     market_maker.initiate(
-        erc20.address, w3.toWei(1, "ether"), transact={"value": w3.toWei(2, "ether")}
+        erc20.address, w3.to_wei(1, "ether"), transact={"value": w3.to_wei(2, "ether")}
     )
-    assert market_maker.totalEthQty() == w3.toWei(2, "ether")
-    assert market_maker.totalTokenQty() == w3.toWei(1, "ether")
-    assert market_maker.invariant() == 2 * 10 ** 36
+    assert market_maker.totalEthQty() == w3.to_wei(2, "ether")
+    assert market_maker.totalTokenQty() == w3.to_wei(1, "ether")
+    assert market_maker.invariant() == 2 * 10**36
     assert market_maker.owner() == a0
     assert erc20.name() == TOKEN_NAME
     assert erc20.decimals() == TOKEN_DECIMALS
 
     # Initiate cannot be called twice
     assert_tx_failed(
         lambda: market_maker.initiate(
-            erc20.address, w3.toWei(1, "ether"), transact={"value": w3.toWei(2, "ether")}
+            erc20.address, w3.to_wei(1, "ether"), transact={"value": w3.to_wei(2, "ether")}
         )
     )  # noqa: E501
 
 
 def test_eth_to_tokens(w3, market_maker, erc20):
     a1 = w3.eth.accounts[1]
-    erc20.approve(market_maker.address, w3.toWei(2, "ether"), transact={})
+    erc20.approve(market_maker.address, w3.to_wei(2, "ether"), transact={})
     market_maker.initiate(
-        erc20.address, w3.toWei(1, "ether"), transact={"value": w3.toWei(2, "ether")}
+        erc20.address, w3.to_wei(1, "ether"), transact={"value": w3.to_wei(2, "ether")}
     )
-    assert erc20.balanceOf(market_maker.address) == w3.toWei(1, "ether")
+    assert erc20.balanceOf(market_maker.address) == w3.to_wei(1, "ether")
     assert erc20.balanceOf(a1) == 0
-    assert market_maker.totalTokenQty() == w3.toWei(1, "ether")
-    assert market_maker.totalEthQty() == w3.toWei(2, "ether")
+    assert market_maker.totalTokenQty() == w3.to_wei(1, "ether")
+    assert market_maker.totalEthQty() == w3.to_wei(2, "ether")
 
     market_maker.ethToTokens(transact={"value": 100, "from": a1})
     assert erc20.balanceOf(market_maker.address) == 999999999999999950
     assert erc20.balanceOf(a1) == 50
     assert market_maker.totalTokenQty() == 999999999999999950
     assert market_maker.totalEthQty() == 2000000000000000100
 
 
 def test_tokens_to_eth(w3, market_maker, erc20):
     a1 = w3.eth.accounts[1]
     a1_balance_before = w3.eth.get_balance(a1)
 
-    erc20.transfer(a1, w3.toWei(2, "ether"), transact={})
-    erc20.approve(market_maker.address, w3.toWei(2, "ether"), transact={"from": a1})
+    erc20.transfer(a1, w3.to_wei(2, "ether"), transact={})
+    erc20.approve(market_maker.address, w3.to_wei(2, "ether"), transact={"from": a1})
     market_maker.initiate(
-        erc20.address, w3.toWei(1, "ether"), transact={"value": w3.toWei(2, "ether"), "from": a1}
+        erc20.address, w3.to_wei(1, "ether"), transact={"value": w3.to_wei(2, "ether"), "from": a1}
     )
-    assert w3.eth.get_balance(market_maker.address) == w3.toWei(2, "ether")
+    assert w3.eth.get_balance(market_maker.address) == w3.to_wei(2, "ether")
     # sent 2 eth, with initiate.
-    assert w3.eth.get_balance(a1) == a1_balance_before - w3.toWei(2, "ether")
-    assert market_maker.totalTokenQty() == w3.toWei(1, "ether")
+    assert w3.eth.get_balance(a1) == a1_balance_before - w3.to_wei(2, "ether")
+    assert market_maker.totalTokenQty() == w3.to_wei(1, "ether")
 
-    erc20.approve(market_maker.address, w3.toWei(1, "ether"), transact={"from": a1})
-    market_maker.tokensToEth(w3.toWei(1, "ether"), transact={"from": a1})
+    erc20.approve(market_maker.address, w3.to_wei(1, "ether"), transact={"from": a1})
+    market_maker.tokensToEth(w3.to_wei(1, "ether"), transact={"from": a1})
     # 1 eth less in market.
-    assert w3.eth.get_balance(market_maker.address) == w3.toWei(1, "ether")
+    assert w3.eth.get_balance(market_maker.address) == w3.to_wei(1, "ether")
     # got 1 eth back, for trade.
-    assert w3.eth.get_balance(a1) == a1_balance_before - w3.toWei(1, "ether")
+    assert w3.eth.get_balance(a1) == a1_balance_before - w3.to_wei(1, "ether")
     # Tokens increased by 1
-    assert market_maker.totalTokenQty() == w3.toWei(2, "ether")
-    assert market_maker.totalEthQty() == w3.toWei(1, "ether")
+    assert market_maker.totalTokenQty() == w3.to_wei(2, "ether")
+    assert market_maker.totalEthQty() == w3.to_wei(1, "ether")
 
 
 def test_owner_withdraw(w3, market_maker, erc20, assert_tx_failed):
     a0, a1 = w3.eth.accounts[:2]
     a0_balance_before = w3.eth.get_balance(a0)
     # Approve 2 eth transfers.
-    erc20.approve(market_maker.address, w3.toWei(2, "ether"), transact={})
+    erc20.approve(market_maker.address, w3.to_wei(2, "ether"), transact={})
     # Initiate market with 2 eth value.
     market_maker.initiate(
-        erc20.address, w3.toWei(1, "ether"), transact={"value": w3.toWei(2, "ether")}
+        erc20.address, w3.to_wei(1, "ether"), transact={"value": w3.to_wei(2, "ether")}
     )
     # 2 eth was sent to market_maker contract.
-    assert w3.eth.get_balance(a0) == a0_balance_before - w3.toWei(2, "ether")
+    assert w3.eth.get_balance(a0) == a0_balance_before - w3.to_wei(2, "ether")
     # a0's balance is locked up in market_maker contract.
-    assert erc20.balanceOf(a0) == TOKEN_TOTAL_SUPPLY - w3.toWei(1, "ether")
+    assert erc20.balanceOf(a0) == TOKEN_TOTAL_SUPPLY - w3.to_wei(1, "ether")
 
     # Only owner can call ownerWithdraw
     assert_tx_failed(lambda: market_maker.ownerWithdraw(transact={"from": a1}))
     market_maker.ownerWithdraw(transact={})
     assert w3.eth.get_balance(a0) == a0_balance_before  # Eth balance restored.
     assert erc20.balanceOf(a0) == TOKEN_TOTAL_SUPPLY  # Tokens returned to a0.
```

### Comparing `vyper-0.3.7/tests/examples/safe_remote_purchase/test_safe_remote_purchase.py` & `vyper-0.3.8/tests/examples/safe_remote_purchase/test_safe_remote_purchase.py`

 * *Files 2% similar despite different names*

```diff
@@ -36,27 +36,27 @@
     assert_tx_failed(lambda: get_contract(contract_code, value=13))
     # Seller puts item up for sale
     a0_pre_bal, a1_pre_bal = get_balance()
     c = get_contract(contract_code, value_in_eth=2)
     # Check that the seller is set correctly
     assert c.seller() == w3.eth.accounts[0]
     # Check if item value is set correctly (Half of deposit)
-    assert c.value() == w3.toWei(1, "ether")
+    assert c.value() == w3.to_wei(1, "ether")
     # Check if unlocked() works correctly after initialization
     assert c.unlocked() is True
     # Check that sellers (and buyers) balance is correct
-    assert get_balance() == ((a0_pre_bal - w3.toWei(2, "ether")), a1_pre_bal)
+    assert get_balance() == ((a0_pre_bal - w3.to_wei(2, "ether")), a1_pre_bal)
 
 
 def test_abort(w3, assert_tx_failed, get_balance, get_contract, contract_code):
     a0, a1, a2 = w3.eth.accounts[:3]
 
     a0_pre_bal, a1_pre_bal = get_balance()
-    c = get_contract(contract_code, value=w3.toWei(2, "ether"))
-    assert c.value() == w3.toWei(1, "ether")
+    c = get_contract(contract_code, value=w3.to_wei(2, "ether"))
+    assert c.value() == w3.to_wei(1, "ether")
     # Only sender can trigger refund
     assert_tx_failed(lambda: c.abort(transact={"from": a2}))
     # Refund works correctly
     c.abort(transact={"from": a0})
     assert get_balance() == (a0_pre_bal, a1_pre_bal)
     # Purchase in process, no refund possible
     c = get_contract(contract_code, value=2)
@@ -96,15 +96,14 @@
     # Check if buyer can call receive
     c.received(transact={"from": a1})
     # Final check if everything worked. 1 value has been transferred
     assert get_balance() == (init_bal_a0 + 1, init_bal_a1 - 1)
 
 
 def test_received_reentrancy(w3, get_contract, assert_tx_failed, get_balance, contract_code):
-
     buyer_contract_code = """
 interface PurchaseContract:
 
     def received(): nonpayable
     def purchase(): payable
     def unlocked() -> bool: view
```

### Comparing `vyper-0.3.7/tests/examples/storage/test_advanced_storage.py` & `vyper-0.3.8/tests/examples/storage/test_advanced_storage.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/examples/storage/test_storage.py` & `vyper-0.3.8/tests/examples/storage/test_storage.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/examples/tokens/test_erc1155.py` & `vyper-0.3.8/tests/examples/tokens/test_erc1155.py`

 * *Files 6% similar despite different names*

```diff
@@ -15,14 +15,15 @@
 CONTRACT_DYNURI = "https://mydomain.io/NFTdata/"
 
 
 ERC165_INTERFACE_ID = "0x01ffc9a7"
 ERC1155_INTERFACE_ID = "0xd9b67a26"
 ERC1155_INTERFACE_ID_METADATA = "0x0e89341c"
 ZERO_ADDRESS = "0x0000000000000000000000000000000000000000"
+DUMMY_BYTES32_DATA = "0x0101010101010101010101010101010101010101010101010101010101010101"
 
 # minting test lists
 mintBatch = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
 mintBatch2 = [11, 12, 13, 14, 15, 16, 17, 19, 19, 20]
 minBatchSetOf10 = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
 mintConflictBatch = [1, 2, 3]
 
@@ -30,32 +31,32 @@
 @pytest.fixture
 def erc1155(get_contract, w3, assert_tx_failed):
     owner, a1, a2, a3, a4, a5 = w3.eth.accounts[0:6]
     with open("examples/tokens/ERC1155ownable.vy") as f:
         code = f.read()
     c = get_contract(code, *[CONTRACT_NAME, CONTRACT_SYMBOL, CONTRACT_URI, CONTRACT_METADATA_URI])
     assert c.owner() == owner
-    c.mintBatch(a1, mintBatch, minBatchSetOf10, "", transact={"from": owner})
-    c.mintBatch(a3, mintBatch2, minBatchSetOf10, "", transact={"from": owner})
+    c.mintBatch(a1, mintBatch, minBatchSetOf10, transact={"from": owner})
+    c.mintBatch(a3, mintBatch2, minBatchSetOf10, transact={"from": owner})
 
     assert c.balanceOf(a1, 1) == 1
     assert c.balanceOf(a1, 2) == 1
     assert c.balanceOf(a1, 3) == 1
     assert_tx_failed(
-        lambda: c.mintBatch(ZERO_ADDRESS, mintBatch, minBatchSetOf10, "", transact={"from": owner})
+        lambda: c.mintBatch(ZERO_ADDRESS, mintBatch, minBatchSetOf10, transact={"from": owner})
     )
-    assert_tx_failed(lambda: c.mintBatch(a1, [1, 2, 3], [1, 1], "", transact={"from": owner}))
+    assert_tx_failed(lambda: c.mintBatch(a1, [1, 2, 3], [1, 1], transact={"from": owner}))
 
-    c.mint(a1, 21, 1, "", transact={"from": owner})
-    c.mint(a1, 22, 1, "", transact={"from": owner})
-    c.mint(a1, 23, 1, "", transact={"from": owner})
-    c.mint(a1, 24, 1, "", transact={"from": owner})
+    c.mint(a1, 21, 1, transact={"from": owner})
+    c.mint(a1, 22, 1, transact={"from": owner})
+    c.mint(a1, 23, 1, transact={"from": owner})
+    c.mint(a1, 24, 1, transact={"from": owner})
 
-    assert_tx_failed(lambda: c.mint(a1, 24, 1, "", transact={"from": a3}))
-    assert_tx_failed(lambda: c.mint(ZERO_ADDRESS, 24, 1, "", transact={"from": owner}))
+    assert_tx_failed(lambda: c.mint(a1, 24, 1, transact={"from": a3}))
+    assert_tx_failed(lambda: c.mint(ZERO_ADDRESS, 24, 1, transact={"from": owner}))
 
     assert c.balanceOf(a1, 21) == 1
     assert c.balanceOf(a1, 22) == 1
     assert c.balanceOf(a1, 23) == 1
     assert c.balanceOf(a1, 24) == 1
 
     return c
@@ -99,24 +100,26 @@
     assert_tx_failed(lambda: erc1155.setURI(NEW_CONTRACT_URI))
 
     # test burn and burnbatch
     assert_tx_failed(lambda: erc1155.burn(21, 1))
     assert_tx_failed(lambda: erc1155.burnBatch([21, 22], [1, 1]))
 
     # check mint and mintbatch
-    assert_tx_failed(lambda: erc1155.mint(a1, 21, 1, "", transact={"from": owner}))
+    assert_tx_failed(lambda: erc1155.mint(a1, 21, 1, transact={"from": owner}))
     assert_tx_failed(
-        lambda: erc1155.mintBatch(a1, mintBatch, minBatchSetOf10, "", transact={"from": owner})
+        lambda: erc1155.mintBatch(a1, mintBatch, minBatchSetOf10, transact={"from": owner})
     )
 
     # check safetransferfrom and safebatchtransferfrom
-    assert_tx_failed(lambda: erc1155.safeTransferFrom(a1, a2, 21, 1, "", transact={"from": a1}))
+    assert_tx_failed(
+        lambda: erc1155.safeTransferFrom(a1, a2, 21, 1, DUMMY_BYTES32_DATA, transact={"from": a1})
+    )
     assert_tx_failed(
         lambda: erc1155.safeBatchTransferFrom(
-            a1, a2, [21, 22, 23], [1, 1, 1], "", transact={"from": a1}
+            a1, a2, [21, 22, 23], [1, 1, 1], DUMMY_BYTES32_DATA, transact={"from": a1}
         )
     )
 
     # check ownership functions
     assert_tx_failed(lambda: erc1155.transferOwnership(a1))
     assert_tx_failed(lambda: erc1155.renounceOwnership())
 
@@ -169,36 +172,48 @@
     assert erc1155.uri(0) == CONTRACT_DYNURI + str(0) + ".json"
 
 
 def test_safeTransferFrom_balanceOf_single(erc1155, w3, assert_tx_failed):
     owner, a1, a2, a3, a4, a5 = w3.eth.accounts[0:6]
     assert erc1155.balanceOf(a1, 24) == 1
     # transfer by non-owner
-    assert_tx_failed(lambda: erc1155.safeTransferFrom(a1, a2, 24, 1, "", transact={"from": a2}))
+    assert_tx_failed(
+        lambda: erc1155.safeTransferFrom(a1, a2, 24, 1, DUMMY_BYTES32_DATA, transact={"from": a2})
+    )
 
     # transfer to zero address
     assert_tx_failed(
-        lambda: erc1155.safeTransferFrom(a1, ZERO_ADDRESS, 24, 1, "", transact={"from": a1})
+        lambda: erc1155.safeTransferFrom(
+            a1, ZERO_ADDRESS, 24, 1, DUMMY_BYTES32_DATA, transact={"from": a1}
+        )
     )
 
     # transfer to self
-    assert_tx_failed(lambda: erc1155.safeTransferFrom(a1, a1, 24, 1, "", transact={"from": a1}))
+    assert_tx_failed(
+        lambda: erc1155.safeTransferFrom(a1, a1, 24, 1, DUMMY_BYTES32_DATA, transact={"from": a1})
+    )
 
     # transfer more than owned
-    assert_tx_failed(lambda: erc1155.safeTransferFrom(a1, a2, 24, 500, "", transact={"from": a1}))
+    assert_tx_failed(
+        lambda: erc1155.safeTransferFrom(a1, a2, 24, 500, DUMMY_BYTES32_DATA, transact={"from": a1})
+    )
 
     # transfer item not owned / not existing
-    assert_tx_failed(lambda: erc1155.safeTransferFrom(a1, a2, 500, 1, "", transact={"from": a1}))
+    assert_tx_failed(
+        lambda: erc1155.safeTransferFrom(a1, a2, 500, 1, DUMMY_BYTES32_DATA, transact={"from": a1})
+    )
 
-    erc1155.safeTransferFrom(a1, a2, 21, 1, "", transact={"from": a1})
+    erc1155.safeTransferFrom(a1, a2, 21, 1, DUMMY_BYTES32_DATA, transact={"from": a1})
 
     assert erc1155.balanceOf(a2, 21) == 1
 
     # try to transfer item again
-    assert_tx_failed(lambda: erc1155.safeTransferFrom(a1, a2, 21, 1, "", transact={"from": a1}))
+    assert_tx_failed(
+        lambda: erc1155.safeTransferFrom(a1, a2, 21, 1, DUMMY_BYTES32_DATA, transact={"from": a1})
+    )
     assert erc1155.balanceOf(a1, 21) == 0
 
 
 # TODO: mint 20 NFTs [1:20] and check the balance for each
 def test_mintBatch_balanceOf(erc1155, w3, assert_tx_failed):  # test_mint_batch
     owner, a1, a2, a3, a4, a5 = w3.eth.accounts[0:6]
     # Use the mint three fixture to mint the tokens.
@@ -215,58 +230,60 @@
     assert erc1155.balanceOf(a1, 22) == 1
     assert erc1155.balanceOf(a1, 23) == 1
     assert erc1155.balanceOf(a1, 23) == 1
 
     # try to transfer item from non item owner account
     assert_tx_failed(
         lambda: erc1155.safeBatchTransferFrom(
-            a1, a2, [21, 22, 23], [1, 1, 1], "", transact={"from": a2}
+            a1, a2, [21, 22, 23], [1, 1, 1], DUMMY_BYTES32_DATA, transact={"from": a2}
         )
     )
 
     # try to transfer item to zero address
     assert_tx_failed(
         lambda: erc1155.safeBatchTransferFrom(
-            a1, ZERO_ADDRESS, [21, 22, 23], [1, 1, 1], "", transact={"from": a1}
+            a1, ZERO_ADDRESS, [21, 22, 23], [1, 1, 1], DUMMY_BYTES32_DATA, transact={"from": a1}
         )
     )
 
     # try to transfer item to self
     assert_tx_failed(
         lambda: erc1155.safeBatchTransferFrom(
-            a1, a1, [21, 22, 23], [1, 1, 1], "", transact={"from": a1}
+            a1, a1, [21, 22, 23], [1, 1, 1], DUMMY_BYTES32_DATA, transact={"from": a1}
         )
     )
 
     # try to transfer more items than we own
     assert_tx_failed(
         lambda: erc1155.safeBatchTransferFrom(
-            a1, a2, [21, 22, 23], [1, 125, 1], "", transact={"from": a1}
+            a1, a2, [21, 22, 23], [1, 125, 1], DUMMY_BYTES32_DATA, transact={"from": a1}
         )
     )
 
     # mismatched item and amounts
     assert_tx_failed(
         lambda: erc1155.safeBatchTransferFrom(
-            a1, a2, [21, 22, 23], [1, 1], "", transact={"from": a1}
+            a1, a2, [21, 22, 23], [1, 1], DUMMY_BYTES32_DATA, transact={"from": a1}
         )
     )
 
     # try to transfer nonexisting item
     assert_tx_failed(
         lambda: erc1155.safeBatchTransferFrom(
-            a1, a2, [21, 22, 500], [1, 1, 1], "", transact={"from": a1}
+            a1, a2, [21, 22, 500], [1, 1, 1], DUMMY_BYTES32_DATA, transact={"from": a1}
         )
     )
-    assert erc1155.safeBatchTransferFrom(a1, a2, [21, 22, 23], [1, 1, 1], "", transact={"from": a1})
+    assert erc1155.safeBatchTransferFrom(
+        a1, a2, [21, 22, 23], [1, 1, 1], DUMMY_BYTES32_DATA, transact={"from": a1}
+    )
 
     # try to transfer again, our balances are zero now, should fail
     assert_tx_failed(
         lambda: erc1155.safeBatchTransferFrom(
-            a1, a2, [21, 22, 23], [1, 1, 1], "", transact={"from": a1}
+            a1, a2, [21, 22, 23], [1, 1, 1], DUMMY_BYTES32_DATA, transact={"from": a1}
         )
     )
     assert_tx_failed(
         lambda: erc1155.balanceOfBatch([a2, a2, a2], [21, 22], transact={"from": owner})
         == [1, 1, 1]
     )
 
@@ -274,15 +291,15 @@
     assert erc1155.balanceOf(a1, 21) == 0
 
 
 def test_mint_one_burn_one(erc1155, w3, assert_tx_failed):
     owner, a1, a2, a3, a4, a5 = w3.eth.accounts[0:6]
 
     # check the balance from an owner and non-owner account
-    erc1155.mint(owner, 25, 1, "", transact={"from": owner})
+    erc1155.mint(owner, 25, 1, transact={"from": owner})
 
     assert erc1155.balanceOf(owner, 25) == 1
     assert erc1155.balanceOf(owner, 25) == 1
 
     # try and burn an item we don't control
     assert_tx_failed(lambda: erc1155.burn(25, 1, transact={"from": a3}))
 
@@ -350,15 +367,15 @@
     TOTAL_BAD_BATCH = 200
     ids = []
     amounts = []
     for i in range(1, TOTAL_BAD_BATCH):
         ids.append(i)
         amounts.append(1)
 
-    assert_tx_failed(lambda: erc1155.mintBatch(a1, ids, amounts, "", transact={"from": owner}))
+    assert_tx_failed(lambda: erc1155.mintBatch(a1, ids, amounts, transact={"from": owner}))
 
 
 # Transferring back and forth
 
 
 def test_ownership_functions(erc1155, w3, assert_tx_failed, tester):
     owner, a1, a2, a3, a4, a5 = w3.eth.accounts[0:6]
```

### Comparing `vyper-0.3.7/tests/examples/tokens/test_erc20.py` & `vyper-0.3.8/tests/examples/tokens/test_erc20.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 # Author: Takayuki Jimba (@yudetamago), Ryuya Nakamura (@nrryuya)
 # Modified from Philip Daian's tests:
 # https://github.com/vyperlang/vyper/blob/v0.1.0-beta.5/tests/examples/tokens/ERC20_solidity_compatible/test/erc20_tests_1.py
 import pytest
 from web3.exceptions import ValidationError
 
 ZERO_ADDRESS = "0x0000000000000000000000000000000000000000"
-MAX_UINT256 = (2 ** 256) - 1  # Max uint256 value
+MAX_UINT256 = (2**256) - 1  # Max uint256 value
 TOKEN_NAME = "Vypercoin"
 TOKEN_SYMBOL = "FANG"
 TOKEN_DECIMALS = 18
 TOKEN_INITIAL_SUPPLY = 0
 
 
 @pytest.fixture
```

### Comparing `vyper-0.3.7/tests/examples/tokens/test_erc4626.py` & `vyper-0.3.8/tests/examples/tokens/test_erc4626.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 import pytest
 
-AMOUNT = 100 * 10 ** 18
+AMOUNT = 100 * 10**18
 TOKEN_NAME = "Vypercoin"
 TOKEN_SYMBOL = "FANG"
 TOKEN_DECIMALS = 18
 TOKEN_INITIAL_SUPPLY = 0
 
 
 @pytest.fixture
@@ -24,65 +24,65 @@
 def test_asset(vault, token):
     assert vault.asset() == token.address
 
 
 def test_max_methods(w3, vault):
     a = w3.eth.accounts[0]
 
-    assert vault.maxDeposit(a) == 2 ** 256 - 1
-    assert vault.maxMint(a) == 2 ** 256 - 1
-    assert vault.maxWithdraw(a) == 2 ** 256 - 1
-    assert vault.maxRedeem(a) == 2 ** 256 - 1
+    assert vault.maxDeposit(a) == 2**256 - 1
+    assert vault.maxMint(a) == 2**256 - 1
+    assert vault.maxWithdraw(a) == 2**256 - 1
+    assert vault.maxRedeem(a) == 2**256 - 1
 
 
 def test_preview_methods(w3, token, vault):
     a = w3.eth.accounts[0]
 
     assert vault.totalAssets() == 0
-    assert vault.convertToAssets(10 ** 18) == 0  # no assets
-    assert vault.convertToShares(10 ** 18) == 10 ** 18  # 1:1 price
+    assert vault.convertToAssets(10**18) == 0  # no assets
+    assert vault.convertToShares(10**18) == 10**18  # 1:1 price
     assert vault.previewDeposit(AMOUNT) == AMOUNT  # 1:1 price
     assert vault.previewMint(AMOUNT) == AMOUNT  # 1:1 price
     assert vault.previewWithdraw(AMOUNT) == 0  # but no assets
     assert vault.previewRedeem(AMOUNT) == 0  # but no assets
 
     token.mint(a, AMOUNT, transact={"from": a})
     token.approve(vault.address, AMOUNT, transact={"from": a})
     vault.deposit(AMOUNT, transact={"from": a})
 
     assert vault.totalAssets() == AMOUNT
-    assert vault.convertToAssets(10 ** 18) == 10 ** 18  # 1:1 price
-    assert vault.convertToShares(10 ** 18) == 10 ** 18  # 1:1 price
+    assert vault.convertToAssets(10**18) == 10**18  # 1:1 price
+    assert vault.convertToShares(10**18) == 10**18  # 1:1 price
     assert vault.previewDeposit(AMOUNT) == AMOUNT  # 1:1 price
     assert vault.previewMint(AMOUNT) == AMOUNT  # 1:1 price
     assert vault.previewWithdraw(AMOUNT) == AMOUNT  # 1:1 price
     assert vault.previewRedeem(AMOUNT) == AMOUNT  # 1:1 price
 
     token.mint(vault.address, AMOUNT, transact={"from": a})
 
     assert vault.totalAssets() == 2 * AMOUNT
-    assert vault.convertToAssets(10 ** 18) == 2 * 10 ** 18  # 2:1 price
-    assert vault.convertToShares(2 * 10 ** 18) == 10 ** 18  # 2:1 price
+    assert vault.convertToAssets(10**18) == 2 * 10**18  # 2:1 price
+    assert vault.convertToShares(2 * 10**18) == 10**18  # 2:1 price
     assert vault.previewDeposit(AMOUNT) == AMOUNT // 2  # 2:1 price
     assert vault.previewMint(AMOUNT // 2) == AMOUNT  # 2:1 price
     assert vault.previewWithdraw(AMOUNT) == AMOUNT // 2  # 2:1 price
     assert vault.previewRedeem(AMOUNT // 2) == AMOUNT  # 2:1 price
 
     vault.DEBUG_steal_tokens(AMOUNT, transact={"from": a})
 
     assert vault.totalAssets() == AMOUNT
-    assert vault.convertToAssets(10 ** 18) == 10 ** 18  # 1:1 price
-    assert vault.convertToShares(10 ** 18) == 10 ** 18  # 1:1 price
+    assert vault.convertToAssets(10**18) == 10**18  # 1:1 price
+    assert vault.convertToShares(10**18) == 10**18  # 1:1 price
     assert vault.previewDeposit(AMOUNT) == AMOUNT  # 1:1 price
     assert vault.previewMint(AMOUNT) == AMOUNT  # 1:1 price
     assert vault.previewWithdraw(AMOUNT) == AMOUNT  # 1:1 price
     assert vault.previewRedeem(AMOUNT) == AMOUNT  # 1:1 price
 
     vault.DEBUG_steal_tokens(AMOUNT // 2, transact={"from": a})
 
     assert vault.totalAssets() == AMOUNT // 2
-    assert vault.convertToAssets(10 ** 18) == 10 ** 18 // 2  # 1:2 price
-    assert vault.convertToShares(10 ** 18 // 2) == 10 ** 18  # 1:2 price
+    assert vault.convertToAssets(10**18) == 10**18 // 2  # 1:2 price
+    assert vault.convertToShares(10**18 // 2) == 10**18  # 1:2 price
     assert vault.previewDeposit(AMOUNT) == 2 * AMOUNT  # 1:2 price
     assert vault.previewMint(2 * AMOUNT) == AMOUNT  # 1:2 price
     assert vault.previewWithdraw(AMOUNT) == 2 * AMOUNT  # 1:2 price
     assert vault.previewRedeem(2 * AMOUNT) == AMOUNT  # 1:2 price
```

### Comparing `vyper-0.3.7/tests/examples/tokens/test_erc721.py` & `vyper-0.3.8/tests/examples/tokens/test_erc721.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/examples/voting/test_ballot.py` & `vyper-0.3.8/tests/examples/voting/test_ballot.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,15 +1,18 @@
 import pytest
 
+PROPOSAL_1_NAME = b"Clinton" + b"\x00" * 25
+PROPOSAL_2_NAME = b"Trump" + b"\x00" * 27
+
 
 @pytest.fixture
 def c(get_contract):
     with open("examples/voting/ballot.vy") as f:
         contract_code = f.read()
-    return get_contract(contract_code, *[[b"Clinton", b"Trump"]])
+    return get_contract(contract_code, *[[PROPOSAL_1_NAME, PROPOSAL_2_NAME]])
 
 
 z0 = "0x0000000000000000000000000000000000000000"
 
 
 def test_initial_state(w3, c):
     a0 = w3.eth.accounts[0]
@@ -227,11 +230,11 @@
     a0, a1, a2 = w3.eth.accounts[:3]
     c.giveRightToVote(a0, transact={})
     c.giveRightToVote(a1, transact={})
     c.giveRightToVote(a2, transact={})
     c.delegate(a1, transact={"from": a2})
     c.vote(0, transact={})
     # Proposal 0 is now winning
-    assert c.winnerName()[:7], b"Clinton"
+    assert c.winnerName()[:7] == b"Clinton"
     c.vote(1, transact={"from": a1})
     # Proposal 2 is now winning
-    assert c.winnerName()[:5], b"Trump"
+    assert c.winnerName()[:5] == b"Trump"
```

### Comparing `vyper-0.3.7/tests/examples/wallet/test_wallet.py` & `vyper-0.3.8/tests/examples/wallet/test_wallet.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,21 +1,22 @@
 import pytest
 from eth_account import Account
+from eth_account.messages import encode_defunct
 from eth_keys import KeyAPI
 from eth_utils import is_same_address
 
 
 @pytest.fixture
 def c(w3, get_contract):
     a0, a1, a2, a3, a4, a5, a6 = w3.eth.accounts[:7]
     with open("examples/wallet/wallet.vy") as f:
         code = f.read()
     # Sends wei to the contract for future transactions gas costs
     c = get_contract(code, *[[a1, a2, a3, a4, a5], 3])
-    w3.eth.send_transaction({"to": c.address, "value": 10 ** 17})
+    w3.eth.send_transaction({"to": c.address, "value": 10**17})
     return c
 
 
 @pytest.fixture
 def sign(keccak):
     def _sign(seq, to, value, data, key):
         keys = KeyAPI()
@@ -28,16 +29,16 @@
     return _sign
 
 
 def test_approve(w3, c, tester, assert_tx_failed, sign):
     a0, a1, a2, a3, a4, a5, a6 = w3.eth.accounts[:7]
     k0, k1, k2, k3, k4, k5, k6, k7 = tester.backend.account_keys[:8]
 
-    to, value, data = b"\x35" * 20, 10 ** 16, b""
-    to_address = w3.toChecksumAddress(to)
+    to, value, data = b"\x35" * 20, 10**16, b""
+    to_address = w3.to_checksum_address(to)
 
     def pack_and_sign(seq, *args):
         sigs = [sign(seq, to, value, data, k) if k else [0, 0, 0] for k in args]
         return sigs
 
     # Legitimate approval
     sigs = pack_and_sign(0, k1, 0, k3, 0, k5)
@@ -84,38 +85,38 @@
     raw_sigs = [
         "0x4a89507bf71749fb338ed13fba623a683d9ecab0fb9c389a4298525c043e38281a00ab65628bb18a382eb8c8b4fb4dae95ccc993cf49f617c60d8051180778601c",  # noqa: E501
         "0xc84fe5d2a600e033930e0cf73f26e78f4c65b134f9c9992f60f08ce0863abdbe0548a6e8aa2d952659f29c67106b59fdfcd64d67df03c1df620c70c85578ae701b",  # noqa: E501
     ]
 
     # Turns the raw sigs into sigs
     sigs = [
-        (w3.toInt(x[64:]), w3.toInt(x[:32]), w3.toInt(x[32:64]))  # v  # r  # s
-        for x in map(lambda z: w3.toBytes(hexstr=z[2:]), raw_sigs)
+        (w3.to_int(x[64:]), w3.to_int(x[:32]), w3.to_int(x[32:64]))  # v  # r  # s
+        for x in map(lambda z: w3.to_bytes(hexstr=z[2:]), raw_sigs)
     ]
 
     h = w3.keccak(
         (0).to_bytes(32, "big")
         + b"\x00" * 12
-        + w3.toBytes(hexstr=recipient[2:])
+        + w3.to_bytes(hexstr=recipient[2:])
         + (25).to_bytes(32, "big")
         + b""
     )  # noqa: E501
-    h2 = w3.keccak(b"\x19Ethereum Signed Message:\n32" + h)
+    h2 = encode_defunct(h)
 
     # Check to make sure the signatures are valid
-    assert is_same_address(Account.recoverHash(h2, sigs[0]), accounts[0])
-    assert is_same_address(Account.recoverHash(h2, sigs[1]), accounts[1])
+    assert is_same_address(Account.recover_message(h2, sigs[0]), accounts[0])
+    assert is_same_address(Account.recover_message(h2, sigs[1]), accounts[1])
 
     # Set the owners to zero addresses
     with open("examples/wallet/wallet.vy") as f:
-        owners = [w3.toChecksumAddress(x) for x in accounts + [a3, zero_address, zero_address]]
+        owners = [w3.to_checksum_address(x) for x in accounts + [a3, zero_address, zero_address]]
         x2 = get_contract(f.read(), *[owners, 2])
 
-    w3.eth.send_transaction({"to": x2.address, "value": 10 ** 17})
+    w3.eth.send_transaction({"to": x2.address, "value": 10**17})
 
     # There's no need to pass in signatures because the owners are 0 addresses
     # causing them to default to valid signatures
     x2.approve(
-        0, recipient, 25, b"", sigs + [[0, 0, 0]] * 3, call={"to": x2.address, "value": 10 ** 17}
+        0, recipient, 25, b"", sigs + [[0, 0, 0]] * 3, call={"to": x2.address, "value": 10**17}
     )
 
     print("Javascript signature tests passed")
```

### Comparing `vyper-0.3.7/tests/fixtures/memorymock.py` & `vyper-0.3.8/tests/fixtures/memorymock.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,23 +1,25 @@
 import pytest
 
 from vyper.codegen.context import Context
-from vyper.codegen.types import BaseType
+from vyper.codegen.core import get_type_for_exact_size
 
 
 class ContextMock(Context):
     def __init__(self, *args, **kwargs):
         super().__init__(*args, **kwargs)
         self._mock_vars = False
         self._size = 0
 
     def internal_memory_scope(self):
         if not self._mock_vars:
             for i in range(20):
-                self._new_variable(f"#mock{i}", BaseType(self._size), self._size, bool(i % 2))
+                self._new_variable(
+                    f"#mock{i}", get_type_for_exact_size(self._size), self._size, bool(i % 2)
+                )
             self._mock_vars = True
         return super().internal_memory_scope()
 
     @classmethod
     def set_mock_var_size(cls, size):
         cls._size = size * 32
```

### Comparing `vyper-0.3.7/tests/functional/codegen/test_struct_return.py` & `vyper-0.3.8/tests/functional/codegen/test_struct_return.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/functional/codegen/test_tuple_return.py` & `vyper-0.3.8/tests/functional/codegen/test_tuple_return.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/functional/context/conftest.py` & `vyper-0.3.8/tests/functional/semantics/conftest.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/functional/context/test_namespace.py` & `vyper-0.3.8/tests/functional/semantics/test_namespace.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 import pytest
 
 from vyper.exceptions import CompilerPanic, NamespaceCollision, UndeclaredDefinition
 from vyper.semantics import environment
 from vyper.semantics.namespace import get_namespace
-from vyper.semantics.types import get_types
+from vyper.semantics.types import PRIMITIVE_TYPES
 
 
 def test_get_namespace():
     ns = get_namespace()
     ns2 = get_namespace()
     assert ns == ns2
 
@@ -18,21 +18,21 @@
         namespace["bar"] = 1337
 
     assert namespace["foo"] == 42
     assert "bar" not in namespace
 
 
 def test_builtin_types(namespace):
-    for key, value in get_types().items():
+    for key, value in PRIMITIVE_TYPES.items():
         assert namespace[key] == value
 
 
 def test_builtin_types_persist_after_clear(namespace):
     namespace.clear()
-    for key, value in get_types().items():
+    for key, value in PRIMITIVE_TYPES.items():
         assert namespace[key] == value
 
 
 def test_context_manager_constant_vars(namespace):
     with namespace.enter_scope():
         for key in environment.CONSTANT_ENVIRONMENT_VARS.keys():
             assert key in namespace
```

### Comparing `vyper-0.3.7/tests/functional/context/types/test_event.py` & `vyper-0.3.8/tests/functional/semantics/types/test_event.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 import pytest
 
-from vyper.semantics.types.user.event import Event
+from vyper.semantics.types.user import EventT
 
 EVENT_ID_TESTS = [
     (
         "event MyLog: pass",
         # MyLog()
         0x375227D322F87546308335EBD7DD99C33B9D50E4DA37CE574E20471DA5E5CBE3,
     ),
@@ -86,10 +86,10 @@
     ),
 ]
 
 
 @pytest.mark.parametrize("source,signature_hash", EVENT_ID_TESTS)
 def test_event_id(build_node, source, signature_hash):
     node = build_node(source)
-    event = Event.from_EventDef(node)
+    event = EventT.from_EventDef(node)
 
     assert event.event_id == signature_hash
```

### Comparing `vyper-0.3.7/tests/functional/context/types/test_size_in_bytes.py` & `vyper-0.3.8/tests/functional/semantics/types/test_size_in_bytes.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,59 +1,52 @@
 import pytest
 
-from vyper.semantics.types.bases import DataLocation
-from vyper.semantics.types.utils import get_type_from_annotation
+from vyper.semantics.types.utils import type_from_annotation
 
 BASE_TYPES = ["int128", "uint256", "bool", "address", "bytes32"]
-ARRAY_VALUE_TYPES = ["String", "Bytes"]
-LOCATIONS = [DataLocation.STORAGE, DataLocation.MEMORY, DataLocation.STORAGE]
+BYTESTRING_TYPES = ["String", "Bytes"]
 
 
 @pytest.mark.parametrize("type_str", BASE_TYPES)
-@pytest.mark.parametrize("location", LOCATIONS)
-def test_base_types(build_node, type_str, location):
+def test_base_types(build_node, type_str):
     node = build_node(type_str)
-    type_definition = get_type_from_annotation(node, location)
+    type_definition = type_from_annotation(node)
 
     assert type_definition.size_in_bytes == 32
 
 
-@pytest.mark.parametrize("type_str", ARRAY_VALUE_TYPES)
-@pytest.mark.parametrize("location", LOCATIONS)
+@pytest.mark.parametrize("type_str", BYTESTRING_TYPES)
 @pytest.mark.parametrize("length,size", [(1, 64), (32, 64), (33, 96), (86, 128)])
-def test_array_value_types(build_node, type_str, location, length, size):
+def test_array_value_types(build_node, type_str, length, size):
     node = build_node(f"{type_str}[{length}]")
-    type_definition = get_type_from_annotation(node, location)
+    type_definition = type_from_annotation(node)
 
     assert type_definition.size_in_bytes == size
 
 
 @pytest.mark.parametrize("type_str", BASE_TYPES)
-@pytest.mark.parametrize("location", LOCATIONS)
 @pytest.mark.parametrize("length", range(1, 4))
-def test_dynamic_array_lengths(build_node, type_str, location, length):
+def test_dynamic_array_lengths(build_node, type_str, length):
     node = build_node(f"DynArray[{type_str}, {length}]")
-    type_definition = get_type_from_annotation(node, location)
+    type_definition = type_from_annotation(node)
 
     assert type_definition.size_in_bytes == 32 + length * 32
 
 
 @pytest.mark.parametrize("type_str", BASE_TYPES)
-@pytest.mark.parametrize("location", LOCATIONS)
 @pytest.mark.parametrize("length", range(1, 4))
-def test_base_types_as_arrays(build_node, type_str, location, length):
+def test_base_types_as_arrays(build_node, type_str, length):
     node = build_node(f"{type_str}[{length}]")
-    type_definition = get_type_from_annotation(node, location)
+    type_definition = type_from_annotation(node)
 
     assert type_definition.size_in_bytes == length * 32
 
 
 @pytest.mark.parametrize("type_str", BASE_TYPES)
-@pytest.mark.parametrize("location", LOCATIONS)
 @pytest.mark.parametrize("first", range(1, 4))
 @pytest.mark.parametrize("second", range(1, 4))
-def test_base_types_as_multidimensional_arrays(build_node, type_str, location, first, second):
+def test_base_types_as_multidimensional_arrays(build_node, type_str, first, second):
     node = build_node(f"{type_str}[{first}][{second}]")
 
-    type_definition = get_type_from_annotation(node, location)
+    type_definition = type_from_annotation(node)
 
     assert type_definition.size_in_bytes == first * second * 32
```

### Comparing `vyper-0.3.7/tests/functional/context/validation/test_array_index.py` & `vyper-0.3.8/tests/functional/semantics/analysis/test_array_index.py`

 * *Files 2% similar despite different names*

```diff
@@ -4,15 +4,15 @@
 from vyper.exceptions import (
     ArrayIndexException,
     InvalidReference,
     InvalidType,
     TypeMismatch,
     UndeclaredDefinition,
 )
-from vyper.semantics.validation import validate_semantics
+from vyper.semantics.analysis import validate_semantics
 
 
 @pytest.mark.parametrize("value", ["address", "Bytes[10]", "decimal", "bool"])
 def test_type_mismatch(namespace, value):
     code = f"""
 
 a: uint256[3]
@@ -37,15 +37,15 @@
     self.a[{value}] = 12
     """
     vyper_module = parse_to_ast(code)
     with pytest.raises(InvalidType):
         validate_semantics(vyper_module, {})
 
 
-@pytest.mark.parametrize("value", [-1, 3, -(2 ** 127), 2 ** 127 - 1, 2 ** 256 - 1])
+@pytest.mark.parametrize("value", [-1, 3, -(2**127), 2**127 - 1, 2**256 - 1])
 def test_out_of_bounds(namespace, value):
     code = f"""
 
 a: uint256[3]
 
 @internal
 def foo():
```

### Comparing `vyper-0.3.7/tests/functional/context/validation/test_cyclic_function_calls.py` & `vyper-0.3.8/tests/functional/semantics/analysis/test_cyclic_function_calls.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,13 +1,25 @@
 import pytest
 
 from vyper.ast import parse_to_ast
 from vyper.exceptions import CallViolation, StructureException
-from vyper.semantics.validation import validate_semantics
-from vyper.semantics.validation.module import ModuleNodeVisitor
+from vyper.semantics.analysis import validate_semantics
+from vyper.semantics.analysis.module import ModuleAnalyzer
+
+
+def test_self_function_call(namespace):
+    code = """
+@internal
+def foo():
+    self.foo()
+    """
+    vyper_module = parse_to_ast(code)
+    with namespace.enter_scope():
+        with pytest.raises(CallViolation):
+            ModuleAnalyzer(vyper_module, {}, namespace)
 
 
 def test_cyclic_function_call(namespace):
     code = """
 @internal
 def foo():
     self.bar()
@@ -15,15 +27,15 @@
 @internal
 def bar():
     self.foo()
     """
     vyper_module = parse_to_ast(code)
     with namespace.enter_scope():
         with pytest.raises(CallViolation):
-            ModuleNodeVisitor(vyper_module, {}, namespace)
+            ModuleAnalyzer(vyper_module, {}, namespace)
 
 
 def test_multi_cyclic_function_call(namespace):
     code = """
 @internal
 def foo():
     self.bar()
@@ -39,15 +51,15 @@
 @internal
 def potato():
     self.foo()
     """
     vyper_module = parse_to_ast(code)
     with namespace.enter_scope():
         with pytest.raises(CallViolation):
-            ModuleNodeVisitor(vyper_module, {}, namespace)
+            ModuleAnalyzer(vyper_module, {}, namespace)
 
 
 def test_global_ann_assign_callable_no_crash():
     code = """
 balanceOf: public(HashMap[address, uint256])
 
 @internal
```

### Comparing `vyper-0.3.7/tests/functional/context/validation/test_for_loop.py` & `vyper-0.3.8/tests/functional/semantics/analysis/test_for_loop.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 import pytest
 
 from vyper.ast import parse_to_ast
-from vyper.exceptions import ImmutableViolation
-from vyper.semantics.validation import validate_semantics
+from vyper.exceptions import ImmutableViolation, TypeMismatch
+from vyper.semantics.analysis import validate_semantics
 
 
 def test_modify_iterator_function_outside_loop(namespace):
     code = """
 
 a: uint256[3]
 
@@ -95,7 +95,48 @@
 def baz():
     for i in self.a:
         self.bar()
     """
     vyper_module = parse_to_ast(code)
     with pytest.raises(ImmutableViolation):
         validate_semantics(vyper_module, {})
+
+
+iterator_inference_codes = [
+    """
+@external
+def main():
+    for j in range(3):
+        x: uint256 = j
+        y: uint16 = j
+    """,  # GH issue 3212
+    """
+@external
+def foo():
+    for i in [1]:
+        a:uint256 = i
+        b:uint16 = i
+    """,  # GH issue 3374
+    """
+@external
+def foo():
+    for i in [1]:
+        for j in [1]:
+            a:uint256 = i
+        b:uint16 = i
+    """,  # GH issue 3374
+    """
+@external
+def foo():
+    for i in [1,2,3]:
+        for j in [1,2,3]:
+            b:uint256 = j + i
+        c:uint16 = i
+    """,  # GH issue 3374
+]
+
+
+@pytest.mark.parametrize("code", iterator_inference_codes)
+def test_iterator_type_inference_checker(namespace, code):
+    vyper_module = parse_to_ast(code)
+    with pytest.raises(TypeMismatch):
+        validate_semantics(vyper_module, {})
```

### Comparing `vyper-0.3.7/tests/functional/context/validation/test_potential_types.py` & `vyper-0.3.8/tests/functional/semantics/analysis/test_potential_types.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,80 +1,77 @@
 import pytest
 
 from vyper.exceptions import (
     ArrayIndexException,
     InvalidOperation,
     InvalidReference,
-    StructureException,
     TypeMismatch,
     UndeclaredDefinition,
     UnknownAttribute,
 )
-from vyper.semantics.types.indexable.sequence import ArrayDefinition, DynamicArrayDefinition
-from vyper.semantics.types.value.address import AddressDefinition
-from vyper.semantics.types.value.boolean import BoolDefinition
-from vyper.semantics.types.value.numeric import Int128Definition
-from vyper.semantics.validation.utils import get_possible_types_from_node
+from vyper.semantics.analysis.base import VarInfo
+from vyper.semantics.analysis.utils import get_possible_types_from_node
+from vyper.semantics.types import AddressT, BoolT, DArrayT, SArrayT
+from vyper.semantics.types.shortcuts import INT128_T
 
-INTEGER_LITERALS = [(42, 31337), (-1, 1), (69, 2 ** 128)]
+INTEGER_LITERALS = [(42, 31337), (-1, 1), (69, 2**128)]
 DECIMAL_LITERALS = [("4.2", "-1.337")]
 BOOL_LITERALS = [(True, False), (True, True), (False, False)]
 STRING_LITERALS = [("'hi'", "'there'"), ("'foo'", "'bar'"), ("'longer'", "'short'")]
 
 
 def test_attribute(build_node, namespace):
     node = build_node("self.foo")
-    type_def = Int128Definition()
     with namespace.enter_scope():
-        namespace["self"].add_member("foo", type_def)
-        assert get_possible_types_from_node(node) == [type_def]
+        namespace["self"].typ.add_member("foo", INT128_T)
+        assert get_possible_types_from_node(node) == [INT128_T]
 
 
 def test_attribute_missing_self(build_node, namespace):
     node = build_node("foo")
     with namespace.enter_scope():
-        namespace["self"].add_member("foo", Int128Definition())
+        namespace["self"].typ.add_member("foo", INT128_T)
         with pytest.raises(InvalidReference):
             get_possible_types_from_node(node)
 
 
 def test_attribute_not_in_self(build_node, namespace):
     node = build_node("self.foo")
     with namespace.enter_scope():
-        namespace["foo"] = Int128Definition()
+        namespace["foo"] = INT128_T
         with pytest.raises(InvalidReference):
             get_possible_types_from_node(node)
 
 
 def test_attribute_unknown(build_node, namespace):
     node = build_node("foo.bar")
     with namespace.enter_scope():
-        namespace["foo"] = AddressDefinition()
+        namespace["foo"] = AddressT()
         with pytest.raises(UnknownAttribute):
             get_possible_types_from_node(node)
 
 
 def test_attribute_not_member_type(build_node, namespace):
     node = build_node("foo.bar")
     with namespace.enter_scope():
-        namespace["foo"] = Int128Definition()
-        with pytest.raises(StructureException):
+        namespace["foo"] = INT128_T
+        with pytest.raises(UnknownAttribute):
             get_possible_types_from_node(node)
 
 
 @pytest.mark.parametrize("op", "+-*/%")
 @pytest.mark.parametrize("left,right", INTEGER_LITERALS + DECIMAL_LITERALS)
 def test_binop(build_node, namespace, op, left, right):
     node = build_node(f"{left}{op}{right}")
     with namespace.enter_scope():
         get_possible_types_from_node(node)
 
 
 @pytest.mark.parametrize("op", "+-*/%")
-@pytest.mark.parametrize("left,right", [(42, "2.3"), (-1, 2 ** 255)])
+@pytest.mark.parametrize("left,right", [(42, "2.3"), (-1, 2**255)])
 def test_binop_type_mismatch(build_node, namespace, op, left, right):
     node = build_node(f"{left}{op}{right}")
     with namespace.enter_scope():
         with pytest.raises(TypeMismatch):
             get_possible_types_from_node(node)
 
 
@@ -97,16 +94,15 @@
 @pytest.mark.parametrize("left, right", BOOL_LITERALS)
 @pytest.mark.parametrize("op", ["and", "or"])
 def test_boolop(build_node, namespace, op, left, right):
     node = build_node(f"{left} {op} {right}")
     with namespace.enter_scope():
         types_list = get_possible_types_from_node(node)
 
-    assert len(types_list) == 1
-    assert isinstance(types_list[0], BoolDefinition)
+    assert types_list == [BoolT()]
 
 
 @pytest.mark.parametrize("left, right", INTEGER_LITERALS + DECIMAL_LITERALS + STRING_LITERALS)
 @pytest.mark.parametrize("op", ["and", "or"])
 def test_boolop_invalid_op(build_node, namespace, op, left, right):
     node = build_node(f"{left} {op} {right}")
     with namespace.enter_scope():
@@ -117,44 +113,42 @@
 @pytest.mark.parametrize("left, right", INTEGER_LITERALS + DECIMAL_LITERALS)
 @pytest.mark.parametrize("op", ["<", "<=", ">", ">="])
 def test_compare_lt_gt(build_node, namespace, op, left, right):
     node = build_node(f"{left} {op} {right}")
     with namespace.enter_scope():
         types_list = get_possible_types_from_node(node)
 
-    assert len(types_list) == 1
-    assert isinstance(types_list[0], BoolDefinition)
+    assert types_list == [BoolT()]
 
 
 @pytest.mark.parametrize(
     "left, right", INTEGER_LITERALS + DECIMAL_LITERALS + BOOL_LITERALS + STRING_LITERALS
 )
 @pytest.mark.parametrize("op", ["==", "!="])
 def test_compare_eq_ne(build_node, namespace, op, left, right):
     node = build_node(f"{left} {op} {right}")
     with namespace.enter_scope():
         types_list = get_possible_types_from_node(node)
 
-    assert len(types_list) == 1
-    assert isinstance(types_list[0], BoolDefinition)
+    assert types_list == [BoolT()]
 
 
 @pytest.mark.parametrize("left, right", BOOL_LITERALS + STRING_LITERALS)
 @pytest.mark.parametrize("op", ["<", "<=", ">", ">="])
 def test_compare_invalid_op(build_node, namespace, op, left, right):
     node = build_node(f"{left} {op} {right}")
     with namespace.enter_scope():
         with pytest.raises(InvalidOperation):
             get_possible_types_from_node(node)
 
 
 def test_name(build_node, namespace):
     node = build_node("foo")
-    type_def = Int128Definition()
-    namespace["foo"] = type_def
+    type_def = INT128_T
+    namespace["foo"] = VarInfo(type_def)
 
     assert get_possible_types_from_node(node) == [type_def]
 
 
 def test_name_unknown(build_node, namespace):
     node = build_node("foo")
     with pytest.raises(UndeclaredDefinition):
@@ -166,54 +160,54 @@
     node = build_node(f"[{left}, {right}]")
 
     with namespace.enter_scope():
         types_list = get_possible_types_from_node(node)
 
     assert types_list
     for item in types_list:
-        assert isinstance(item, (DynamicArrayDefinition, ArrayDefinition))
+        assert isinstance(item, (DArrayT, SArrayT))
 
 
 def test_subscript(build_node, namespace):
     node = build_node("foo[1]")
-    type_def = Int128Definition()
+    type_ = INT128_T
 
-    namespace["foo"] = ArrayDefinition(type_def, 3)
-    assert get_possible_types_from_node(node) == [type_def]
+    namespace["foo"] = VarInfo(SArrayT(type_, 3))
+    assert get_possible_types_from_node(node) == [type_]
 
 
 def test_subscript_out_of_bounds(build_node, namespace):
     node = build_node("foo[5]")
-    type_def = Int128Definition()
+    type_def = INT128_T
 
-    namespace["foo"] = ArrayDefinition(type_def, 3)
+    namespace["foo"] = VarInfo(SArrayT(type_def, 3))
     with pytest.raises(ArrayIndexException):
         get_possible_types_from_node(node)
 
 
 def test_subscript_negative(build_node, namespace):
     node = build_node("foo[-1]")
-    type_def = Int128Definition()
+    type_def = INT128_T
 
-    namespace["foo"] = ArrayDefinition(type_def, 3)
+    namespace["foo"] = VarInfo(SArrayT(type_def, 3))
     with pytest.raises(ArrayIndexException):
         get_possible_types_from_node(node)
 
 
 def test_tuple(build_node, namespace):
     node = build_node("(foo, bar)")
 
-    namespace["foo"] = Int128Definition()
-    namespace["bar"] = AddressDefinition()
+    namespace["foo"] = VarInfo(INT128_T)
+    namespace["bar"] = VarInfo(AddressT())
     types_list = get_possible_types_from_node(node)
 
-    assert types_list[0].value_type == [namespace["foo"], namespace["bar"]]
+    assert types_list[0].member_types == [namespace["foo"].typ, namespace["bar"].typ]
 
 
 def test_tuple_subscript(build_node, namespace):
     node = build_node("(foo, bar)[1]")
 
-    namespace["foo"] = Int128Definition()
-    namespace["bar"] = AddressDefinition()
+    namespace["foo"] = VarInfo(INT128_T)
+    namespace["bar"] = VarInfo(AddressT())
     types_list = get_possible_types_from_node(node)
 
-    assert types_list == [namespace["bar"]]
+    assert types_list == [namespace["bar"].typ]
```

### Comparing `vyper-0.3.7/tests/functional/test_storage_slots.py` & `vyper-0.3.8/tests/functional/test_storage_slots.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,7 +1,11 @@
+import pytest
+
+from vyper.exceptions import StorageLayoutException
+
 code = """
 
 struct StructOne:
     a: String[33]
     b: uint256[3]
 
 struct StructTwo:
@@ -93,7 +97,19 @@
         b"gbye",
         [1337, 888],
         "whatifthisstringtakesuptheentirelengthwouldthatbesobadidothinkso",
     )
     assert [c.foo(0, i) for i in range(3)] == [987, 654, 321]
     assert [c.foo(1, i) for i in range(3)] == [123, 456, 789]
     assert c.h(0) == 123456789
+
+
+def test_allocator_overflow(get_contract):
+    code = """
+x: uint256
+y: uint256[max_value(uint256)]
+    """
+    with pytest.raises(
+        StorageLayoutException,
+        match=f"Invalid storage slot for var y, tried to allocate slots 1 through {2**256}\n",
+    ):
+        get_contract(code)
```

### Comparing `vyper-0.3.7/tests/functions/folding/test_abs.py` & `vyper-0.3.8/tests/builtins/folding/test_abs.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,19 +1,19 @@
 import pytest
 from hypothesis import example, given, settings
 from hypothesis import strategies as st
 
 from vyper import ast as vy_ast
-from vyper import builtin_functions as vy_fn
+from vyper.builtins import functions as vy_fn
 from vyper.exceptions import OverflowException
 
 
 @pytest.mark.fuzzing
 @settings(max_examples=50, deadline=1000)
-@given(a=st.integers(min_value=-(2 ** 255) + 1, max_value=2 ** 255 - 1))
+@given(a=st.integers(min_value=-(2**255) + 1, max_value=2**255 - 1))
 @example(a=0)
 def test_abs(get_contract, a):
     source = """
 @external
 def foo(a: int256) -> int256:
     return abs(a)
     """
@@ -24,15 +24,15 @@
     new_node = vy_fn.DISPATCH_TABLE["abs"].evaluate(old_node)
 
     assert contract.foo(a) == new_node.value == abs(a)
 
 
 @pytest.mark.fuzzing
 @settings(max_examples=50, deadline=1000)
-@given(a=st.integers(min_value=2 ** 255, max_value=2 ** 256 - 1))
+@given(a=st.integers(min_value=2**255, max_value=2**256 - 1))
 def test_abs_upper_bound_folding(get_contract, a):
     source = f"""
 @external
 def foo(a: int256) -> int256:
     return abs({a})
     """
     with pytest.raises(OverflowException):
@@ -43,15 +43,15 @@
     source = """
 @external
 def foo(a: int256) -> int256:
     return abs(a)
     """
     contract = get_contract(source)
 
-    assert_tx_failed(lambda: contract.foo(-(2 ** 255)))
+    assert_tx_failed(lambda: contract.foo(-(2**255)))
 
 
 def test_abs_lower_bound_folded(get_contract, assert_tx_failed):
     source = """
 @external
 def foo() -> int256:
     return abs(-2**255)
```

### Comparing `vyper-0.3.7/tests/functions/folding/test_addmod_mulmod.py` & `vyper-0.3.8/tests/builtins/folding/test_addmod_mulmod.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 import pytest
 from hypothesis import assume, given, settings
 from hypothesis import strategies as st
 
 from vyper import ast as vy_ast
-from vyper import builtin_functions as vy_fn
+from vyper.builtins import functions as vy_fn
 
-st_uint256 = st.integers(min_value=0, max_value=2 ** 256 - 1)
+st_uint256 = st.integers(min_value=0, max_value=2**256 - 1)
 
 
 @pytest.mark.fuzzing
 @settings(max_examples=50, deadline=1000)
 @given(a=st_uint256, b=st_uint256, c=st_uint256)
 @pytest.mark.parametrize("fn_name", ["uint256_addmod", "uint256_mulmod"])
 def test_modmath(get_contract, a, b, c, fn_name):
```

### Comparing `vyper-0.3.7/tests/functions/folding/test_bitwise.py` & `vyper-0.3.8/tests/builtins/folding/test_min_max.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,66 +1,74 @@
 import pytest
 from hypothesis import given, settings
 from hypothesis import strategies as st
 
 from vyper import ast as vy_ast
-from vyper import builtin_functions as vy_fn
+from vyper.builtins import functions as vy_fn
+from vyper.utils import SizeLimits
 
-st_uint256 = st.integers(min_value=0, max_value=2 ** 256 - 1)
+st_decimals = st.decimals(
+    min_value=SizeLimits.MIN_AST_DECIMAL,
+    max_value=SizeLimits.MAX_AST_DECIMAL,
+    allow_nan=False,
+    allow_infinity=False,
+    places=10,
+)
+st_int128 = st.integers(min_value=-(2**127), max_value=2**127 - 1)
+st_uint256 = st.integers(min_value=0, max_value=2**256 - 1)
 
 
 @pytest.mark.fuzzing
 @settings(max_examples=50, deadline=1000)
-@given(a=st_uint256, b=st_uint256)
-@pytest.mark.parametrize("op", ["&", "|", "^"])
-def test_bitwise_and_or(get_contract, a, b, op):
-
+@given(left=st_decimals, right=st_decimals)
+@pytest.mark.parametrize("fn_name", ["min", "max"])
+def test_decimal(get_contract, left, right, fn_name):
     source = f"""
 @external
-def foo(a: uint256, b: uint256) -> uint256:
-    return a {op} b
+def foo(a: decimal, b: decimal) -> decimal:
+    return {fn_name}(a, b)
     """
     contract = get_contract(source)
 
-    vyper_ast = vy_ast.parse_to_ast(f"{a} {op} {b}")
+    vyper_ast = vy_ast.parse_to_ast(f"{fn_name}({left}, {right})")
     old_node = vyper_ast.body[0].value
-    new_node = old_node.evaluate()
+    new_node = vy_fn.DISPATCH_TABLE[fn_name].evaluate(old_node)
 
-    assert contract.foo(a, b) == new_node.value
+    assert contract.foo(left, right) == new_node.value
 
 
 @pytest.mark.fuzzing
 @settings(max_examples=50, deadline=1000)
-@given(value=st_uint256)
-def test_bitwise_not(get_contract, value):
-
-    source = """
+@given(left=st_int128, right=st_int128)
+@pytest.mark.parametrize("fn_name", ["min", "max"])
+def test_int128(get_contract, left, right, fn_name):
+    source = f"""
 @external
-def foo(a: uint256) -> uint256:
-    return ~a
+def foo(a: int128, b: int128) -> int128:
+    return {fn_name}(a, b)
     """
     contract = get_contract(source)
 
-    vyper_ast = vy_ast.parse_to_ast(f"bitwise_not({value})")
+    vyper_ast = vy_ast.parse_to_ast(f"{fn_name}({left}, {right})")
     old_node = vyper_ast.body[0].value
-    new_node = vy_fn.BitwiseNot().evaluate(old_node)
+    new_node = vy_fn.DISPATCH_TABLE[fn_name].evaluate(old_node)
 
-    assert contract.foo(value) == new_node.value
+    assert contract.foo(left, right) == new_node.value
 
 
 @pytest.mark.fuzzing
 @settings(max_examples=50, deadline=1000)
-@given(value=st_uint256, steps=st.integers(min_value=-256, max_value=256))
-def test_shift(get_contract, value, steps):
-
-    source = """
+@given(left=st_uint256, right=st_uint256)
+@pytest.mark.parametrize("fn_name", ["min", "max"])
+def test_min_uint256(get_contract, left, right, fn_name):
+    source = f"""
 @external
-def foo(a: uint256, b: int128) -> uint256:
-    return shift(a, b)
+def foo(a: uint256, b: uint256) -> uint256:
+    return {fn_name}(a, b)
     """
     contract = get_contract(source)
 
-    vyper_ast = vy_ast.parse_to_ast(f"shift({value}, {steps})")
+    vyper_ast = vy_ast.parse_to_ast(f"{fn_name}({left}, {right})")
     old_node = vyper_ast.body[0].value
-    new_node = vy_fn.Shift().evaluate(old_node)
+    new_node = vy_fn.DISPATCH_TABLE[fn_name].evaluate(old_node)
 
-    assert contract.foo(value, steps) == new_node.value
+    assert contract.foo(left, right) == new_node.value
```

### Comparing `vyper-0.3.7/tests/functions/folding/test_epsilon.py` & `vyper-0.3.8/tests/builtins/folding/test_epsilon.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 import pytest
 
 from vyper import ast as vy_ast
-from vyper import builtin_functions as vy_fn
+from vyper.builtins import functions as vy_fn
 
 
 @pytest.mark.parametrize("typ_name", ["decimal"])
 def test_epsilon(get_contract, typ_name):
     source = f"""
 @external
 def foo() -> {typ_name}:
```

### Comparing `vyper-0.3.7/tests/functions/folding/test_floor_ceil.py` & `vyper-0.3.8/tests/builtins/folding/test_floor_ceil.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,18 +1,18 @@
 from decimal import Decimal
 
 import pytest
 from hypothesis import example, given, settings
 from hypothesis import strategies as st
 
 from vyper import ast as vy_ast
-from vyper import builtin_functions as vy_fn
+from vyper.builtins import functions as vy_fn
 
 st_decimals = st.decimals(
-    min_value=-(2 ** 32), max_value=2 ** 32, allow_nan=False, allow_infinity=False, places=10
+    min_value=-(2**32), max_value=2**32, allow_nan=False, allow_infinity=False, places=10
 )
 
 
 @pytest.mark.fuzzing
 @settings(max_examples=50, deadline=1000)
 @given(value=st_decimals)
 @example(value=Decimal("0.9999999999"))
```

### Comparing `vyper-0.3.7/tests/functions/folding/test_fold_as_wei_value.py` & `vyper-0.3.8/tests/builtins/folding/test_fold_as_wei_value.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,19 +1,24 @@
 import pytest
 from hypothesis import given, settings
 from hypothesis import strategies as st
 
 from vyper import ast as vy_ast
-from vyper import builtin_functions as vy_fn
+from vyper.builtins import functions as vy_fn
+from vyper.utils import SizeLimits
 
 denoms = [x for k in vy_fn.AsWeiValue.wei_denoms.keys() for x in k]
 
 
 st_decimals = st.decimals(
-    min_value=0, max_value=2 ** 32, allow_nan=False, allow_infinity=False, places=10
+    min_value=0,
+    max_value=SizeLimits.MAX_AST_DECIMAL,
+    allow_nan=False,
+    allow_infinity=False,
+    places=10,
 )
 
 
 @pytest.mark.fuzzing
 @settings(max_examples=10, deadline=1000)
 @given(value=st_decimals)
 @pytest.mark.parametrize("denom", denoms)
@@ -30,15 +35,15 @@
     new_node = vy_fn.AsWeiValue().evaluate(old_node)
 
     assert contract.foo(value) == new_node.value
 
 
 @pytest.mark.fuzzing
 @settings(max_examples=10, deadline=1000)
-@given(value=st.integers(min_value=0, max_value=2 ** 128))
+@given(value=st.integers(min_value=0, max_value=2**128))
 @pytest.mark.parametrize("denom", denoms)
 def test_integer(get_contract, value, denom):
     source = f"""
 @external
 def foo(a: uint256) -> uint256:
     return as_wei_value(a, '{denom}')
     """
```

### Comparing `vyper-0.3.7/tests/functions/folding/test_keccak_sha.py` & `vyper-0.3.8/tests/builtins/folding/test_keccak_sha.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,23 +1,22 @@
 import pytest
 from hypothesis import given, settings
 from hypothesis import strategies as st
 
 from vyper import ast as vy_ast
-from vyper import builtin_functions as vy_fn
+from vyper.builtins import functions as vy_fn
 
 alphabet = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!"#$%&()*+,-./:;<=>?@[]^_`{|}~'  # NOQA: E501
 
 
 @pytest.mark.fuzzing
 @given(value=st.text(alphabet=alphabet, min_size=0, max_size=100))
 @settings(max_examples=50, deadline=1000)
 @pytest.mark.parametrize("fn_name", ["keccak256", "sha256"])
 def test_string(get_contract, value, fn_name):
-
     source = f"""
 @external
 def foo(a: String[100]) -> bytes32:
     return {fn_name}(a)
     """
     contract = get_contract(source)
```

### Comparing `vyper-0.3.7/tests/functions/folding/test_len.py` & `vyper-0.3.8/tests/builtins/folding/test_len.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 import pytest
 
 from vyper import ast as vy_ast
-from vyper import builtin_functions as vy_fn
+from vyper.builtins import functions as vy_fn
 
 
 @pytest.mark.parametrize("length", [0, 1, 32, 33, 64, 65, 1024])
 def test_len_string(get_contract, length):
     source = """
 @external
 def foo(a: String[1024]) -> uint256:
```

### Comparing `vyper-0.3.7/tests/functions/folding/test_powmod.py` & `vyper-0.3.8/tests/builtins/folding/test_powmod.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 import pytest
 from hypothesis import given, settings
 from hypothesis import strategies as st
 
 from vyper import ast as vy_ast
-from vyper import builtin_functions as vy_fn
+from vyper.builtins import functions as vy_fn
 
-st_uint256 = st.integers(min_value=0, max_value=256)
+st_uint256 = st.integers(min_value=0, max_value=2**256)
 
 
 @pytest.mark.fuzzing
 @settings(max_examples=100, deadline=1000)
 @given(a=st_uint256, b=st_uint256)
 def test_powmod_uint256(get_contract, a, b):
     source = """
```

### Comparing `vyper-0.3.7/tests/fuzzing/test_exponents.py` & `vyper-0.3.8/tests/fuzzing/test_exponents.py`

 * *Files 21% similar despite different names*

```diff
@@ -10,16 +10,16 @@
 def test_exp_uint256(get_contract, assert_tx_failed, power):
     code = f"""
 @external
 def foo(a: uint256) -> uint256:
     return a ** {power}
     """
     _min_base, max_base = calculate_largest_base(power, 256, False)
-    assert max_base ** power < 2 ** 256
-    assert (max_base + 1) ** power >= 2 ** 256
+    assert max_base**power < 2**256
+    assert (max_base + 1) ** power >= 2**256
 
     c = get_contract(code)
 
     c.foo(max_base)
     assert_tx_failed(lambda: c.foo(max_base + 1))
 
 
@@ -29,19 +29,19 @@
     code = f"""
 @external
 def foo(a: int128) -> int128:
     return a ** {power}
     """
     min_base, max_base = calculate_largest_base(power, 128, True)
 
-    assert -(2 ** 127) <= max_base ** power < 2 ** 127
-    assert -(2 ** 127) <= min_base ** power < 2 ** 127
+    assert -(2**127) <= max_base**power < 2**127
+    assert -(2**127) <= min_base**power < 2**127
 
-    assert not -(2 ** 127) <= (max_base + 1) ** power < 2 ** 127
-    assert not -(2 ** 127) <= (min_base - 1) ** power < 2 ** 127
+    assert not -(2**127) <= (max_base + 1) ** power < 2**127
+    assert not -(2**127) <= (min_base - 1) ** power < 2**127
 
     c = get_contract(code)
 
     c.foo(max_base)
     c.foo(min_base)
 
     assert_tx_failed(lambda: c.foo(max_base + 1))
@@ -54,93 +54,93 @@
     code = f"""
 @external
 def foo(a: int16) -> int16:
     return a ** {power}
     """
     min_base, max_base = calculate_largest_base(power, 16, True)
 
-    assert -(2 ** 15) <= max_base ** power < 2 ** 15
-    assert -(2 ** 15) <= min_base ** power < 2 ** 15
+    assert -(2**15) <= max_base**power < 2**15
+    assert -(2**15) <= min_base**power < 2**15
 
-    assert not -(2 ** 15) <= (max_base + 1) ** power < 2 ** 15
-    assert not -(2 ** 15) <= (min_base - 1) ** power < 2 ** 15
+    assert not -(2**15) <= (max_base + 1) ** power < 2**15
+    assert not -(2**15) <= (min_base - 1) ** power < 2**15
 
     c = get_contract(code)
 
     c.foo(max_base)
     c.foo(min_base)
 
     assert_tx_failed(lambda: c.foo(max_base + 1))
     assert_tx_failed(lambda: c.foo(min_base - 1))
 
 
 @pytest.mark.fuzzing
-@given(a=st.integers(min_value=2, max_value=2 ** 256 - 1))
+@given(a=st.integers(min_value=2, max_value=2**256 - 1))
 # 8 bits
-@example(a=2 ** 7)
-@example(a=2 ** 7 - 1)
+@example(a=2**7)
+@example(a=2**7 - 1)
 # 16 bits
-@example(a=2 ** 15)
-@example(a=2 ** 15 - 1)
+@example(a=2**15)
+@example(a=2**15 - 1)
 # 32 bits
-@example(a=2 ** 31)
-@example(a=2 ** 31 - 1)
+@example(a=2**31)
+@example(a=2**31 - 1)
 # 64 bits
-@example(a=2 ** 63)
-@example(a=2 ** 63 - 1)
+@example(a=2**63)
+@example(a=2**63 - 1)
 # 128 bits
-@example(a=2 ** 127)
-@example(a=2 ** 127 - 1)
+@example(a=2**127)
+@example(a=2**127 - 1)
 # 256 bits
-@example(a=2 ** 256 - 1)
+@example(a=2**256 - 1)
 @settings(max_examples=200, deadline=1000)
 def test_max_exp(get_contract, assert_tx_failed, a):
     code = f"""
 @external
 def foo(b: uint256) -> uint256:
     return {a} ** b
     """
 
     c = get_contract(code)
 
     max_power = calculate_largest_power(a, 256, False)
 
-    assert a ** max_power < 2 ** 256
-    assert a ** (max_power + 1) >= 2 ** 256
+    assert a**max_power < 2**256
+    assert a ** (max_power + 1) >= 2**256
 
     c.foo(max_power)
     assert_tx_failed(lambda: c.foo(max_power + 1))
 
 
 @pytest.mark.fuzzing
-@given(a=st.integers(min_value=2, max_value=2 ** 127 - 1))
+@given(a=st.integers(min_value=2, max_value=2**127 - 1))
 # 8 bits
-@example(a=2 ** 7)
-@example(a=2 ** 7 - 1)
+@example(a=2**7)
+@example(a=2**7 - 1)
 # 16 bits
-@example(a=2 ** 15)
-@example(a=2 ** 15 - 1)
+@example(a=2**15)
+@example(a=2**15 - 1)
 # 32 bits
-@example(a=2 ** 31)
-@example(a=2 ** 31 - 1)
+@example(a=2**31)
+@example(a=2**31 - 1)
 # 64 bits
-@example(a=2 ** 63)
-@example(a=2 ** 63 - 1)
+@example(a=2**63)
+@example(a=2**63 - 1)
 # 128 bits
-@example(a=2 ** 127 - 1)
+@example(a=2**127 - 1)
 @settings(max_examples=200, deadline=1000)
 def test_max_exp_int128(get_contract, assert_tx_failed, a):
     code = f"""
 @external
 def foo(b: int128) -> int128:
     return {a} ** b
     """
 
     c = get_contract(code)
 
     max_power = calculate_largest_power(a, 128, True)
 
-    assert -(2 ** 127) <= a ** max_power < 2 ** 127
-    assert not -(2 ** 127) <= a ** (max_power + 1) < 2 ** 127
+    assert -(2**127) <= a**max_power < 2**127
+    assert not -(2**127) <= a ** (max_power + 1) < 2**127
 
     c.foo(max_power)
     assert_tx_failed(lambda: c.foo(max_power + 1))
```

### Comparing `vyper-0.3.7/tests/grammar/test_grammar.py` & `vyper-0.3.8/tests/grammar/test_grammar.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/parser/ast_utils/test_ast.py` & `vyper-0.3.8/tests/parser/ast_utils/test_ast.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/parser/ast_utils/test_ast_dict.py` & `vyper-0.3.8/tests/parser/ast_utils/test_ast_dict.py`

 * *Files 24% similar despite different names*

```diff
@@ -69,14 +69,59 @@
             "node_id": 2,
             "src": "1:1:0",
         },
         "value": None,
         "is_constant": False,
         "is_immutable": False,
         "is_public": False,
+        "is_transient": False,
+    }
+
+
+def test_implements_ast():
+    code = """
+interface Foo:
+    def foo() -> uint256: view
+
+implements: Foo
+
+@external
+@view
+def foo() -> uint256:
+    return 1
+    """
+    dict_out = compiler.compile_code(code, ["ast_dict"])
+    assert dict_out["ast_dict"]["ast"]["body"][1] == {
+        "col_offset": 0,
+        "annotation": {
+            "col_offset": 12,
+            "end_col_offset": 15,
+            "node_id": 12,
+            "src": "60:3:0",
+            "ast_type": "Name",
+            "end_lineno": 5,
+            "lineno": 5,
+            "id": "Foo",
+        },
+        "end_col_offset": 15,
+        "node_id": 9,
+        "src": "48:15:0",
+        "ast_type": "ImplementsDecl",
+        "target": {
+            "col_offset": 0,
+            "end_col_offset": 10,
+            "node_id": 10,
+            "src": "48:10:0",
+            "ast_type": "Name",
+            "end_lineno": 5,
+            "lineno": 5,
+            "id": "implements",
+        },
+        "end_lineno": 5,
+        "lineno": 5,
     }
 
 
 def test_dict_to_ast():
     code = """
 @external
 def test() -> int128:
```

### Comparing `vyper-0.3.7/tests/parser/exceptions/test_argument_exception.py` & `vyper-0.3.8/tests/parser/exceptions/test_argument_exception.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/parser/exceptions/test_call_violation.py` & `vyper-0.3.8/tests/parser/exceptions/test_call_violation.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/parser/exceptions/test_constancy_exception.py` & `vyper-0.3.8/tests/parser/exceptions/test_constancy_exception.py`

 * *Files 9% similar despite different names*

```diff
@@ -95,13 +95,33 @@
 
 @pytest.mark.parametrize(
     "bad_code",
     [
         """
 @external
 def foo(x: int128):
-    x = 5"""
+    x = 5
+        """,
+        """
+@external
+def test(a: uint256[4]):
+    a[0] = 1
+        """,
+        """
+@external
+def test(a: uint256[4][4]):
+    a[0][1] = 1
+        """,
+        """
+struct Foo:
+    a: DynArray[DynArray[uint256, 2], 2]
+
+@external
+def foo(f: Foo) -> Foo:
+    f.a[1] = [0, 1]
+    return f
+        """,
     ],
 )
 def test_immutability_violations(bad_code):
     with raises(ImmutableViolation):
         compiler.compile_code(bad_code)
```

### Comparing `vyper-0.3.7/tests/parser/exceptions/test_function_declaration_exception.py` & `vyper-0.3.8/tests/parser/exceptions/test_function_declaration_exception.py`

 * *Files 14% similar despite different names*

```diff
@@ -44,14 +44,37 @@
     return 1
     """,
     """
 @external
 def __init__() -> bool:
     pass
     """,
+    """
+a: immutable(uint256)
+
+@internal
+def __init__():
+    a = 1
+    """,
+    """
+a: immutable(uint256)
+
+@external
+@pure
+def __init__():
+    a = 1
+    """,
+    """
+a: immutable(uint256)
+
+@external
+@view
+def __init__():
+    a = 1
+    """,
 ]
 
 
 @pytest.mark.parametrize("bad_code", fail_list)
 def test_function_declaration_exception(bad_code):
     with pytest.raises(FunctionDeclarationException):
         compiler.compile_code(bad_code)
```

### Comparing `vyper-0.3.7/tests/parser/exceptions/test_invalid_literal_exception.py` & `vyper-0.3.8/tests/parser/exceptions/test_invalid_literal_exception.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/parser/exceptions/test_invalid_payable.py` & `vyper-0.3.8/tests/parser/exceptions/test_invalid_payable.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/parser/exceptions/test_invalid_reference.py` & `vyper-0.3.8/tests/parser/syntax/test_code_size.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,41 +1,48 @@
 import pytest
 
 from vyper import compiler
-from vyper.exceptions import InvalidReference
+from vyper.exceptions import StructureException
 
 fail_list = [
     """
-x: uint256
-
 @external
-def foo():
-    send(0x1234567890123456789012345678901234567890, x)
-    """,
+def foo() -> int128:
+    x: int128 = 45
+    return x.codesize
     """
-@external
-def bar(x: int128) -> int128:
-    return 3 * x
+]
+
 
+@pytest.mark.parametrize("bad_code", fail_list)
+def test_block_fail(bad_code):
+    with pytest.raises(StructureException):
+        compiler.compile_code(bad_code)
+
+
+valid_list = [
+    """
 @external
-def foo() -> int128:
-    return bar(20)
+def foo() -> uint256:
+    x: address = 0x1234567890123456789012345678901234567890
+    return x.codesize
     """,
     """
-b: int128
 @external
-def foo():
-    b = 7
+def foo() -> uint256:
+    return self.codesize
     """,
     """
-x: int128
+struct Foo:
+    t: address
+foo: Foo
+
 @external
-def foo():
-    x = 5
+def bar() -> uint256:
+    return self.foo.t.codesize
     """,
 ]
 
 
-@pytest.mark.parametrize("bad_code", fail_list)
-def test_invalid_reference_exception(bad_code):
-    with pytest.raises(InvalidReference):
-        compiler.compile_code(bad_code)
+@pytest.mark.parametrize("good_code", valid_list)
+def test_block_success(good_code):
+    assert compiler.compile_code(good_code) is not None
```

### Comparing `vyper-0.3.7/tests/parser/exceptions/test_invalid_type_exception.py` & `vyper-0.3.8/tests/parser/exceptions/test_invalid_type_exception.py`

 * *Files 16% similar despite different names*

```diff
@@ -6,20 +6,14 @@
     """
 x: bat
     """,
     """
 x: HashMap[int, int128]
     """,
     """
-x: [bar, baz]
-    """,
-    """
-x: [bar(int128), baz(baffle)]
-    """,
-    """
 struct A:
     b: B
     """,
 ]
 
 
 @pytest.mark.parametrize("bad_code", fail_list)
@@ -65,13 +59,22 @@
     """
 b: HashMap[(int128, decimal), int128]
     """,
     # Address literal must be checksummed
     """
 a: constant(address) = 0x3cd751e6b0078be393132286c442345e5dc49699
     """,
+    """
+x: String <= 33
+    """,
+    """
+x: Bytes <= wei
+    """,
+    """
+x: 5
+    """,
 ]
 
 
 @pytest.mark.parametrize("bad_code", invalid_list)
 def test_invalid_type_exception(bad_code, get_contract, assert_compile_failed):
     assert_compile_failed(lambda: get_contract(bad_code), InvalidType)
```

### Comparing `vyper-0.3.7/tests/parser/exceptions/test_namespace_collision.py` & `vyper-0.3.8/tests/parser/exceptions/test_namespace_collision.py`

 * *Files 14% similar despite different names*

```diff
@@ -36,19 +36,14 @@
     """,
     """
 @external
 def foo():
     msg: bool = True
     """,
     """
-@external
-def foo():
-    struct: bool = True
-    """,
-    """
 int128: Bytes[3]
     """,
 ]
 
 
 @pytest.mark.parametrize("bad_code", fail_list)
 def test_insufficient_arguments(bad_code):
```

### Comparing `vyper-0.3.7/tests/parser/exceptions/test_overflow_exception.py` & `vyper-0.3.8/tests/parser/exceptions/test_overflow_exception.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/parser/exceptions/test_structure_exception.py` & `vyper-0.3.8/tests/parser/exceptions/test_structure_exception.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,23 +1,29 @@
 import pytest
 
 from vyper import compiler
-from vyper.exceptions import StructureException
+from vyper.exceptions import InvalidType, StructureException
 
 fail_list = [
     """
 x[5] = 4
     """,
     """
 send(0x1234567890123456789012345678901234567890, 5)
     """,
     """
 send(0x1234567890123456789012345678901234567890, 5)
     """,
     """
+x: [bar, baz]
+    """,
+    """
+x: [bar(int128), baz(baffle)]
+    """,
+    """
 x: int128
 @external
 @view(123)
 def foo() -> int128:
     pass
     """,
     """
@@ -52,41 +58,24 @@
 @external
 @nonreentrant("B")
 @nonreentrant("C")
 def double_nonreentrant():
     pass
     """,
     """
-x: 5
-    """,
-    """
-x: Bytes <= wei
-    """,
-    """
-x: String <= 33
-    """,
-    """
-CALLDATACOPY: int128
-    """,
-    """
-@external
-def foo():
-    BALANCE: int128 = 45
-    """,
-    """
 @external
 def foo():
     true: int128 = 3
     """,
     """
 n: HashMap[uint256, bool][3]
     """,
     """
 a: constant(uint256) = 3
-n: public(HashMap[uint256, Y][a])
+n: public(HashMap[uint256, uint256][a])
     """,
     """
 a: immutable(uint256)
 n: public(HashMap[uint256, bool][a])
 
 @external
 def __init__():
@@ -111,15 +100,15 @@
     self.m1 = 234
     """,
 ]
 
 
 @pytest.mark.parametrize("bad_code", fail_list)
 def test_invalid_type_exception(bad_code):
-    with pytest.raises(StructureException):
+    with pytest.raises((StructureException, InvalidType)):
         compiler.compile_code(bad_code)
 
 
 del_fail_list = [
     """
 x: int128(address)
     """,
```

### Comparing `vyper-0.3.7/tests/parser/exceptions/test_syntax_exception.py` & `vyper-0.3.8/tests/parser/exceptions/test_syntax_exception.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,11 +1,9 @@
 import pytest
-from pytest import raises
 
-from vyper import compiler
 from vyper.exceptions import SyntaxException
 
 fail_list = [
     """
 x: Bytes[1:3]
     """,
     """
@@ -70,14 +68,27 @@
 @external
 def foo():
     x: address = 0x123456789012345678901234567890123456789
     """,
     """
 a: internal(uint256)
     """,
+    """
+@external
+def foo():
+    x: uint256 = +1  # test UAdd ast blocked
+    """,
+    """
+@internal
+def f(a:uint256,/):  # test posonlyargs blocked
+    return
+
+@external
+def g():
+    self.f()
+    """,
 ]
 
 
 @pytest.mark.parametrize("bad_code", fail_list)
-def test_syntax_exception(bad_code):
-    with raises(SyntaxException):
-        compiler.compile_code(bad_code)
+def test_syntax_exception(assert_compile_failed, get_contract, bad_code):
+    assert_compile_failed(lambda: get_contract(bad_code), SyntaxException)
```

### Comparing `vyper-0.3.7/tests/parser/exceptions/test_type_mismatch_exception.py` & `vyper-0.3.8/tests/parser/exceptions/test_type_mismatch_exception.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/parser/exceptions/test_undeclared_definition.py` & `vyper-0.3.8/tests/parser/exceptions/test_undeclared_definition.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/parser/exceptions/test_variable_declaration_exception.py` & `vyper-0.3.8/tests/parser/exceptions/test_variable_declaration_exception.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/parser/exceptions/test_vyper_exception_pos.py` & `vyper-0.3.8/tests/parser/exceptions/test_vyper_exception_pos.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/parser/features/arithmetic/test_division.py` & `vyper-0.3.8/tests/parser/features/arithmetic/test_division.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/parser/features/arithmetic/test_modulo.py` & `vyper-0.3.8/tests/parser/features/arithmetic/test_modulo.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/parser/features/decorators/test_nonreentrant.py` & `vyper-0.3.8/tests/parser/features/decorators/test_nonreentrant.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,12 +1,14 @@
 import pytest
 
 from vyper.exceptions import FunctionDeclarationException
 
 
+# TODO test functions in this module across all evm versions
+# once we have cancun support.
 def test_nonreentrant_decorator(get_contract, assert_tx_failed):
     calling_contract_code = """
 interface SpecialContract:
     def unprotected_function(val: String[100], do_callback: bool): nonpayable
     def protected_function(val: String[100], do_callback: bool): nonpayable
     def special_value() -> String[100]: nonpayable
```

### Comparing `vyper-0.3.7/tests/parser/features/decorators/test_payable.py` & `vyper-0.3.8/tests/parser/features/decorators/test_payable.py`

 * *Files 9% similar despite different names*

```diff
@@ -173,19 +173,22 @@
 def baz() -> bool:
     return True
     """,
 ]
 
 
 @pytest.mark.parametrize("code", nonpayable_code)
-def test_nonpayable_runtime_assertion(assert_tx_failed, get_contract, code):
+def test_nonpayable_runtime_assertion(w3, keccak, assert_tx_failed, get_contract, code):
     c = get_contract(code)
 
     c.foo(transact={"value": 0})
-    assert_tx_failed(lambda: c.foo(transact={"value": 10 ** 18}))
+    sig = keccak("foo()".encode()).hex()[:10]
+    assert_tx_failed(
+        lambda: w3.eth.send_transaction({"to": c.address, "data": sig, "value": 10**18})
+    )
 
 
 payable_code = [
     """
 # single function, payable
 @payable
 @external
@@ -328,15 +331,15 @@
 ]
 
 
 @pytest.mark.parametrize("code", payable_code)
 def test_payable_runtime_assertion(get_contract, code):
     c = get_contract(code)
 
-    c.foo(transact={"value": 10 ** 18})
+    c.foo(transact={"value": 10**18})
     c.foo(transact={"value": 0})
 
 
 def test_payable_default_func_invalid_calldata(get_contract, w3):
     code = """
 @external
 def foo() -> bool:
@@ -365,7 +368,28 @@
     """
 
     c = get_contract(code)
     w3.eth.send_transaction({"to": c.address, "value": 0, "data": "0x12345678"})
     assert_tx_failed(
         lambda: w3.eth.send_transaction({"to": c.address, "value": 100, "data": "0x12345678"})
     )
+
+
+def test_batch_nonpayable(get_contract, w3, assert_tx_failed):
+    code = """
+@external
+def foo() -> bool:
+    return True
+
+@external
+def __default__():
+    pass
+    """
+
+    c = get_contract(code)
+    w3.eth.send_transaction({"to": c.address, "value": 0, "data": "0x12345678"})
+    data = bytes([1, 2, 3, 4])
+    for i in range(5):
+        calldata = "0x" + data[:i].hex()
+        assert_tx_failed(
+            lambda: w3.eth.send_transaction({"to": c.address, "value": 100, "data": calldata})
+        )
```

### Comparing `vyper-0.3.7/tests/parser/features/decorators/test_private.py` & `vyper-0.3.8/tests/parser/features/decorators/test_private.py`

 * *Files 2% similar despite different names*

```diff
@@ -312,16 +312,16 @@
 @external
 def test2(a: bytes32) -> (bytes32, uint256, int128):
     return self._test(a)
     """
 
     c = get_contract_with_gas_estimation(code)
 
-    assert c.test(b"test") == [b"test" + 28 * b"\x00", 1000, -1200]
-    assert c.test2(b"test") == [b"test" + 28 * b"\x00", 1000, -1200]
+    assert c.test(b"test" + b"\x00" * 28) == [b"test" + 28 * b"\x00", 1000, -1200]
+    assert c.test2(b"test" + b"\x00" * 28) == [b"test" + 28 * b"\x00", 1000, -1200]
 
 
 def test_private_return_tuple_bytes(get_contract_with_gas_estimation):
     code = """
 @internal
 def _test(a: int128, b: Bytes[50]) -> (int128, Bytes[100]):
     return a + 2, concat(b"badabing:", b)
@@ -404,21 +404,21 @@
 @payable
 def __default__():
     pass
     """
 
     c = get_contract_with_gas_estimation(code)
 
-    w3.eth.send_transaction({"to": c.address, "value": w3.toWei(1, "ether")})
-    assert w3.eth.get_balance(c.address) == w3.toWei(1, "ether")
+    w3.eth.send_transaction({"to": c.address, "value": w3.to_wei(1, "ether")})
+    assert w3.eth.get_balance(c.address) == w3.to_wei(1, "ether")
     a3 = w3.eth.accounts[2]
-    assert w3.eth.get_balance(a3) == w3.toWei(1000000, "ether")
-    c.test(True, a3, w3.toWei(0.05, "ether"), transact={})
-    assert w3.eth.get_balance(a3) == w3.toWei(1000000.05, "ether")
-    assert w3.eth.get_balance(c.address) == w3.toWei(0.95, "ether")
+    assert w3.eth.get_balance(a3) == w3.to_wei(1000000, "ether")
+    c.test(True, a3, w3.to_wei(0.05, "ether"), transact={})
+    assert w3.eth.get_balance(a3) == w3.to_wei(1000000.05, "ether")
+    assert w3.eth.get_balance(c.address) == w3.to_wei(0.95, "ether")
 
 
 def test_private_msg_sender(get_contract, w3):
     code = """
 event Addr:
     addr: address
 
@@ -429,27 +429,27 @@
 
 @external
 @view
 def i_am_me() -> bool:
     return msg.sender == self._whoami()
 
 @external
-@view
+@nonpayable
 def whoami() -> address:
     log Addr(self._whoami())
     return self._whoami()
     """
 
     c = get_contract(code)
     assert c.i_am_me()
 
     addr = w3.eth.accounts[1]
     txhash = c.whoami(transact={"from": addr})
     receipt = w3.eth.wait_for_transaction_receipt(txhash)
-    logged_addr = w3.toChecksumAddress(receipt.logs[0].data[-40:])
+    logged_addr = w3.to_checksum_address(receipt.logs[0].data[-20:])
     assert logged_addr == addr, "oh no"
 
 
 def test_nested_static_params_only(get_contract, assert_tx_failed):
     code1 = """
 @internal
 @view
```

### Comparing `vyper-0.3.7/tests/parser/features/decorators/test_public.py` & `vyper-0.3.8/tests/parser/features/decorators/test_public.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/parser/features/decorators/test_pure.py` & `vyper-0.3.8/tests/parser/features/decorators/test_pure.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/parser/features/decorators/test_view.py` & `vyper-0.3.8/tests/parser/features/decorators/test_view.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/parser/features/external_contracts/test_erc20_abi.py` & `vyper-0.3.8/tests/parser/features/external_contracts/test_erc20_abi.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 import pytest
 from web3.exceptions import ValidationError
 
 TOKEN_NAME = "Vypercoin"
 TOKEN_SYMBOL = "FANG"
 TOKEN_DECIMALS = 18
-TOKEN_INITIAL_SUPPLY = 21 * 10 ** 6
-TOKEN_TOTAL_SUPPLY = TOKEN_INITIAL_SUPPLY * (10 ** TOKEN_DECIMALS)
+TOKEN_INITIAL_SUPPLY = 21 * 10**6
+TOKEN_TOTAL_SUPPLY = TOKEN_INITIAL_SUPPLY * (10**TOKEN_DECIMALS)
 
 
 @pytest.fixture
 def erc20(get_contract):
     with open("examples/tokens/ERC20.vy") as f:
         contract = get_contract(
             f.read(), *[TOKEN_NAME, TOKEN_SYMBOL, TOKEN_DECIMALS, TOKEN_INITIAL_SUPPLY]
@@ -78,15 +78,14 @@
     assert erc20_caller.balanceOf(w3.eth.accounts[1]) == 0
     assert erc20_caller.name() == TOKEN_NAME
     assert erc20_caller.symbol() == TOKEN_SYMBOL
     assert erc20_caller.decimals() == TOKEN_DECIMALS
 
 
 def test_call_transfer(w3, erc20, erc20_caller, assert_tx_failed):
-
     # Basic transfer.
     erc20.transfer(erc20_caller.address, 10, transact={})
     assert erc20.balanceOf(erc20_caller.address) == 10
     erc20_caller.transfer(w3.eth.accounts[1], 10, transact={})
     assert erc20.balanceOf(erc20_caller.address) == 0
     assert erc20.balanceOf(w3.eth.accounts[1]) == 10
```

### Comparing `vyper-0.3.7/tests/parser/features/external_contracts/test_external_contract_calls.py` & `vyper-0.3.8/tests/parser/features/external_contracts/test_external_contract_calls.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,11 @@
 from decimal import Decimal
 
 import pytest
+from eth.codecs import abi
 
 from vyper.exceptions import (
     ArgumentException,
     InvalidType,
     StateAccessViolation,
     StructureException,
     UndeclaredDefinition,
@@ -811,15 +812,15 @@
     b: Bytes[3] = b""
     c: address = ZERO_ADDRESS
     a, b, c = Foo(arg1).foo()
     return a, b, c
 """
 
     c2 = get_contract(contract_2)
-    assert c.foo() == [(2 ** 160) - 1, b"dog", (2 ** 160) - 2]
+    assert c.foo() == [(2**160) - 1, b"dog", (2**160) - 2]
     result = c2.bar(c.address)
     assert len(result) == 3
     assert result[0].lower() == "0xffffffffffffffffffffffffffffffffffffffff"
     assert result[1] == b"dog"
     assert result[2].lower() == "0xfffffffffffffffffffffffffffffffffffffffe"
 
 
@@ -844,15 +845,15 @@
     b: Bytes[3] = b""
     c: address = ZERO_ADDRESS
     a, b, c = Foo(arg1).foo()
     return a, b, c
 """
 
     c2 = get_contract(contract_2)
-    assert c.foo() == [(2 ** 160) - 1, b"dog", 2 ** 160]
+    assert c.foo() == [(2**160) - 1, b"dog", 2**160]
     assert_tx_failed(lambda: c2.bar(c.address))
 
 
 def test_external_contract_call_state_change(get_contract):
     contract_1 = """
 lucky: public(int128)
 
@@ -1296,15 +1297,15 @@
 
 @external
 def foo(contract_address: contract(Boo)) -> int128:
     self.bar_contract = Bar(contract_address)
     return self.bar_contract.bar()
     """
 
-    assert_compile_failed(lambda: get_contract(contract_1), UnknownType)
+    assert_compile_failed(lambda: get_contract(contract_1), InvalidType)
 
 
 def test_invalid_external_contract_call_declaration_2(assert_compile_failed, get_contract):
     contract_1 = """
 interface Bar:
     def bar() -> int128: view
 
@@ -1434,15 +1435,14 @@
     c1 = get_contract_with_gas_estimation(contract_1)
     c2 = get_contract_with_gas_estimation(contract_2)
     c1.call_bar(c2.address)
     c1.call_baz()
 
 
 def test_invalid_keyword_on_call(assert_compile_failed, get_contract_with_gas_estimation):
-
     contract_1 = """
 interface Bar:
     def set_lucky(arg1: int128): nonpayable
     def get_lucky() -> int128: view
 
 bar_contract: Bar
 
@@ -1451,15 +1451,14 @@
     return self.bar_contract.get_lucky(gass=1)
     """
 
     assert_compile_failed(lambda: get_contract_with_gas_estimation(contract_1), ArgumentException)
 
 
 def test_invalid_contract_declaration(assert_compile_failed, get_contract_with_gas_estimation):
-
     contract_1 = """
 interface Bar:
     def set_lucky(arg1: int128): nonpayable
 
 bar_contract: Barr
 
     """
@@ -1504,15 +1503,14 @@
     Bar(a).bar(x, y=y)
     """,
 ]
 
 
 @pytest.mark.parametrize("bad_code", FAILING_CONTRACTS_STRUCTURE_EXCEPTION)
 def test_bad_code_struct_exc(assert_compile_failed, get_contract_with_gas_estimation, bad_code):
-
     assert_compile_failed(lambda: get_contract_with_gas_estimation(bad_code), ArgumentException)
 
 
 def test_bad_skip_contract_check(assert_compile_failed, get_contract_with_gas_estimation):
     code = """
 # variable value for skip_contract_check
 interface Bar:
@@ -2454,47 +2452,47 @@
     assert c1.do_stuff(c2.address) == 1
 
 
 TEST_ADDR = b"".join(chr(i).encode("utf-8") for i in range(20)).hex()
 
 
 @pytest.mark.parametrize("typ,val", [("address", TEST_ADDR)])
-def test_calldata_clamp(w3, get_contract, assert_tx_failed, abi_encode, keccak, typ, val):
+def test_calldata_clamp(w3, get_contract, assert_tx_failed, keccak, typ, val):
     code = f"""
 @external
 def foo(a: {typ}):
     pass
     """
     c1 = get_contract(code)
     sig = keccak(f"foo({typ})".encode()).hex()[:10]
-    encoded = abi_encode(f"({typ})", (val,)).hex()
+    encoded = abi.encode(f"({typ})", (val,)).hex()
     data = f"{sig}{encoded}"
 
     # Static size is short by 1 byte
     malformed = data[:-2]
     assert_tx_failed(lambda: w3.eth.send_transaction({"to": c1.address, "data": malformed}))
 
     # Static size is exact
     w3.eth.send_transaction({"to": c1.address, "data": data})
 
     # Static size exceeds by 1 byte, ok
     w3.eth.send_transaction({"to": c1.address, "data": data + "ff"})
 
 
 @pytest.mark.parametrize("typ,val", [("address", ([TEST_ADDR] * 3, "vyper"))])
-def test_dynamic_calldata_clamp(w3, get_contract, assert_tx_failed, abi_encode, keccak, typ, val):
+def test_dynamic_calldata_clamp(w3, get_contract, assert_tx_failed, keccak, typ, val):
     code = f"""
 @external
 def foo(a: DynArray[{typ}, 3], b: String[5]):
     pass
     """
 
     c1 = get_contract(code)
     sig = keccak(f"foo({typ}[],string)".encode()).hex()[:10]
-    encoded = abi_encode(f"({typ}[],string)", val).hex()
+    encoded = abi.encode(f"({typ}[],string)", val).hex()
     data = f"{sig}{encoded}"
 
     # Dynamic size is short by 1 byte
     malformed = data[:264]
     assert_tx_failed(lambda: w3.eth.send_transaction({"to": c1.address, "data": malformed}))
 
     # Dynamic size is at least minimum (132 bytes * 2 + 2 (for 0x) = 266)
```

### Comparing `vyper-0.3.7/tests/parser/features/external_contracts/test_modifiable_external_contract_calls.py` & `vyper-0.3.8/tests/parser/features/external_contracts/test_modifiable_external_contract_calls.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/parser/features/external_contracts/test_self_call_struct.py` & `vyper-0.3.8/tests/parser/features/external_contracts/test_self_call_struct.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/parser/features/iteration/test_for_in_list.py` & `vyper-0.3.8/tests/parser/features/iteration/test_for_in_list.py`

 * *Files 0% similar despite different names*

```diff
@@ -654,14 +654,28 @@
     ),
     """
 @external
 def foo():
     for i in range(0):
         pass
     """,
+    """
+@external
+def foo():
+    for i in []:
+        pass
+    """,
+    """
+FOO: constant(DynArray[uint256, 3]) = []
+
+@external
+def foo():
+    for i in FOO:
+        pass
+    """,
     (
         """
 @external
 def foo():
     for i in range(5,3):
         pass
     """,
```

### Comparing `vyper-0.3.7/tests/parser/features/iteration/test_range_in.py` & `vyper-0.3.8/tests/parser/features/iteration/test_range_in.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/parser/features/iteration/test_repeater.py` & `vyper-0.3.8/tests/parser/features/iteration/test_for_range.py`

 * *Files 4% similar despite different names*

```diff
@@ -124,14 +124,53 @@
     """
 
     c = get_contract(code)
     assert c.foo(6) == 7
     assert c.foo(100) == 31337
 
 
+# test that we can get to the upper range of an integer
+@pytest.mark.parametrize("typ", ["uint8", "int128", "uint256"])
+def test_for_range_edge(get_contract, typ):
+    code = f"""
+@external
+def test():
+    found: bool = False
+    x: {typ} = max_value({typ})
+    for i in range(x, x + 1):
+        if i == max_value({typ}):
+            found = True
+
+    assert found
+
+    found = False
+    x = max_value({typ}) - 1
+    for i in range(x, x + 2):
+        if i == max_value({typ}):
+            found = True
+
+    assert found
+    """
+    c = get_contract(code)
+    c.test()
+
+
+@pytest.mark.parametrize("typ", ["uint8", "int128", "uint256"])
+def test_for_range_oob_check(get_contract, assert_tx_failed, typ):
+    code = f"""
+@external
+def test():
+    x: {typ} = max_value({typ})
+    for i in range(x, x+2):
+        pass
+    """
+    c = get_contract(code)
+    assert_tx_failed(lambda: c.test())
+
+
 @pytest.mark.parametrize("typ", ["int128", "uint256"])
 def test_return_inside_nested_repeater(get_contract, typ):
     code = f"""
 @internal
 def _final(a: {typ}) -> {typ}:
     for i in range(10):
         for x in range(10):
```

### Comparing `vyper-0.3.7/tests/parser/features/test_assert.py` & `vyper-0.3.8/tests/parser/features/test_assert.py`

 * *Files 2% similar despite different names*

```diff
@@ -12,15 +12,15 @@
     code = """
 @external
 def foo():
     raise
     """
     c = get_contract_with_gas_estimation(code)
     a0 = w3.eth.accounts[0]
-    gas_sent = 10 ** 6
+    gas_sent = 10**6
     tx_hash = c.foo(transact={"from": a0, "gas": gas_sent, "gasPrice": 10})
     # More info on receipt status:
     # https://github.com/ethereum/EIPs/blob/master/EIPS/eip-658.md#specification.
     tx_receipt = w3.eth.get_transaction_receipt(tx_hash)
     assert tx_receipt["status"] == 0
     # Checks for gas refund from revert
     assert tx_receipt["gasUsed"] < gas_sent
```

### Comparing `vyper-0.3.7/tests/parser/features/test_assert_unreachable.py` & `vyper-0.3.8/tests/parser/features/test_assert_unreachable.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,17 +1,17 @@
-def test_assure_refund(w3, get_contract):
+def test_unreachable_refund(w3, get_contract):
     code = """
 @external
 def foo():
     assert msg.sender != msg.sender, UNREACHABLE
     """
 
     c = get_contract(code)
     a0 = w3.eth.accounts[0]
-    gas_sent = 10 ** 6
+    gas_sent = 10**6
     tx_hash = c.foo(transact={"from": a0, "gas": gas_sent, "gasPrice": 10})
     tx_receipt = w3.eth.get_transaction_receipt(tx_hash)
 
     assert tx_receipt["status"] == 0
     assert tx_receipt["gasUsed"] == gas_sent  # Drains all gains sent
 
 
@@ -48,9 +48,20 @@
     """
 
     c = get_contract(code)
 
     assert c.foo(33) == -123
 
     assert_tx_failed(lambda: c.foo(1), exc_text="Invalid opcode 0xfe")
-    assert_tx_failed(lambda: c.foo(1), exc_text="Invalid opcode 0xfe")
     assert_tx_failed(lambda: c.foo(-1), exc_text="Invalid opcode 0xfe")
+
+
+def test_raise_unreachable(w3, get_contract, assert_tx_failed):
+    code = """
+@external
+def foo():
+    raise UNREACHABLE
+    """
+
+    c = get_contract(code)
+
+    assert_tx_failed(lambda: c.foo(), exc_text="Invalid opcode 0xfe")
```

### Comparing `vyper-0.3.7/tests/parser/features/test_assignment.py` & `vyper-0.3.8/tests/parser/features/test_assignment.py`

 * *Files 12% similar despite different names*

```diff
@@ -251,7 +251,67 @@
     pass
 
 @external
 def foo():
     ret : bool = self.bar()
 """
     assert_compile_failed(lambda: get_contract_with_gas_estimation(code), InvalidType)
+
+
+def test_assign_rhs_lhs_overlap(get_contract):
+    # GH issue 2418
+    code = """
+@external
+def bug(xs: uint256[2]) -> uint256[2]:
+    # Initial value
+    ys: uint256[2] = xs
+    ys = [ys[1], ys[0]]
+    return ys
+    """
+    c = get_contract(code)
+
+    assert c.bug([1, 2]) == [2, 1]
+
+
+def test_assign_rhs_lhs_partial_overlap(get_contract):
+    # GH issue 2418, generalize when lhs is not only dependency of rhs.
+    code = """
+@external
+def bug(xs: uint256[2]) -> uint256[2]:
+    # Initial value
+    ys: uint256[2] = xs
+    ys = [xs[1], ys[0]]
+    return ys
+    """
+    c = get_contract(code)
+
+    assert c.bug([1, 2]) == [2, 1]
+
+
+def test_assign_rhs_lhs_overlap_dynarray(get_contract):
+    # GH issue 2418, generalize to dynarrays
+    code = """
+@external
+def bug(xs: DynArray[uint256, 2]) -> DynArray[uint256, 2]:
+    ys: DynArray[uint256, 2] = xs
+    ys = [ys[1], ys[0]]
+    return ys
+    """
+    c = get_contract(code)
+    assert c.bug([1, 2]) == [2, 1]
+
+
+def test_assign_rhs_lhs_overlap_struct(get_contract):
+    # GH issue 2418, generalize to structs
+    code = """
+struct Point:
+    x: uint256
+    y: uint256
+
+@external
+def bug(p: Point) -> Point:
+    t: Point = p
+    t = Point({x: t.y, y: t.x})
+    return t
+    """
+    c = get_contract(code)
+    assert c.bug((1, 2)) == (2, 1)
```

### Comparing `vyper-0.3.7/tests/parser/features/test_bytes_map_keys.py` & `vyper-0.3.8/tests/parser/features/test_bytes_map_keys.py`

 * *Files 0% similar despite different names*

```diff
@@ -54,15 +54,15 @@
 @external
 def get(k: Bytes[34]) -> int128:
     return self.mapped_bytes[k]
     """
 
     c = get_contract(code)
 
-    c.set(b"a" * 34, 6789, transact={"gas": 10 ** 6})
+    c.set(b"a" * 34, 6789, transact={"gas": 10**6})
 
     assert c.get(b"a" * 34) == 6789
 
 
 def test_mismatched_byte_length(get_contract):
     code = """
 mapped_bytes: HashMap[Bytes[34], int128]
```

### Comparing `vyper-0.3.7/tests/parser/features/test_clampers.py` & `vyper-0.3.8/tests/parser/features/test_clampers.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,27 +1,28 @@
 from decimal import Decimal
 
 import pytest
+from eth.codecs import abi
 from eth_utils import keccak
 
 from vyper.evm.opcodes import EVM_VERSIONS
 from vyper.utils import int_bounds
 
 
 def _make_tx(w3, address, signature, values):
     # helper function to broadcast transactions that fail clamping check
     sig = keccak(signature.encode()).hex()[:8]
     data = "".join(int(i).to_bytes(32, "big", signed=i < 0).hex() for i in values)
     w3.eth.send_transaction({"to": address, "data": f"0x{sig}{data}"})
 
 
-def _make_abi_encode_tx(w3, abi_encode, address, signature, input_types, values):
+def _make_abi_encode_tx(w3, address, signature, input_types, values):
     # helper function to broadcast transactions where data is constructed from abi_encode
     sig = keccak(signature.encode()).hex()[:8]
-    data = abi_encode(input_types, values).hex()
+    data = abi.encode(input_types, values).hex()
     w3.eth.send_transaction({"to": address, "data": f"0x{sig}{data}"})
 
 
 def _make_dynarray_data(offset, length, values):
     input = [offset] + [length] + values
     data = "".join(int(i).to_bytes(32, "big", signed=i < 0).hex() for i in input)
     return data
@@ -88,15 +89,16 @@
 @external
 def foo(s: bytes{n}) -> bytes{n}:
     return s
     """
 
     c = get_contract(code, evm_version=evm_version)
     for v in values:
-        assert c.foo(v) == v.ljust(n, b"\x00")
+        v = v.ljust(n, b"\x00")
+        assert c.foo(v) == v
 
 
 @pytest.mark.parametrize("evm_version", list(EVM_VERSIONS))
 @pytest.mark.parametrize("n", list(range(1, 32)))  # bytes32 always passes
 def test_bytes_m_clamper_failing(w3, get_contract, assert_tx_failed, n, evm_version):
     values = []
     values.append(b"\x00" * n + b"\x80")  # just one bit set
@@ -138,15 +140,15 @@
 
 
 @pytest.mark.parametrize("evm_version", list(EVM_VERSIONS))
 @pytest.mark.parametrize("n", list(range(31)))  # int256 does not clamp
 def test_sint_clamper_failing(w3, assert_tx_failed, get_contract, n, evm_version):
     bits = 8 * (n + 1)
     lo, hi = int_bounds(True, bits)
-    values = [-(2 ** 255), 2 ** 255 - 1, lo - 1, hi + 1]
+    values = [-(2**255), 2**255 - 1, lo - 1, hi + 1]
     code = f"""
 @external
 def foo(s: int{bits}) -> int{bits}:
     return s
     """
 
     c = get_contract(code, evm_version=evm_version)
@@ -164,28 +166,28 @@
     """
 
     c = get_contract(code, evm_version=evm_version)
     assert c.foo(value) == value
 
 
 @pytest.mark.parametrize("evm_version", list(EVM_VERSIONS))
-@pytest.mark.parametrize("value", [2, 3, 4, 8, 16, 2 ** 256 - 1])
+@pytest.mark.parametrize("value", [2, 3, 4, 8, 16, 2**256 - 1])
 def test_bool_clamper_failing(w3, assert_tx_failed, get_contract, value, evm_version):
     code = """
 @external
 def foo(s: bool) -> bool:
     return s
     """
 
     c = get_contract(code, evm_version=evm_version)
     assert_tx_failed(lambda: _make_tx(w3, c.address, "foo(bool)", [value]))
 
 
 @pytest.mark.parametrize("evm_version", list(EVM_VERSIONS))
-@pytest.mark.parametrize("value", [0] + [2 ** i for i in range(5)])
+@pytest.mark.parametrize("value", [0] + [2**i for i in range(5)])
 def test_enum_clamper_passing(w3, get_contract, value, evm_version):
     code = """
 enum Roles:
     USER
     STAFF
     ADMIN
     MANAGER
@@ -197,15 +199,15 @@
     """
 
     c = get_contract(code, evm_version=evm_version)
     assert c.foo(value) == value
 
 
 @pytest.mark.parametrize("evm_version", list(EVM_VERSIONS))
-@pytest.mark.parametrize("value", [2 ** i for i in range(5, 256)])
+@pytest.mark.parametrize("value", [2**i for i in range(5, 256)])
 def test_enum_clamper_failing(w3, assert_tx_failed, get_contract, value, evm_version):
     code = """
 enum Roles:
     USER
     STAFF
     ADMIN
     MANAGER
@@ -220,15 +222,15 @@
     assert_tx_failed(lambda: _make_tx(w3, c.address, "foo(uint256)", [value]))
 
 
 @pytest.mark.parametrize("evm_version", list(EVM_VERSIONS))
 @pytest.mark.parametrize("n", list(range(32)))
 def test_uint_clamper_passing(w3, get_contract, evm_version, n):
     bits = 8 * (n + 1)
-    values = [0, 1, 2 ** bits - 1]
+    values = [0, 1, 2**bits - 1]
     code = f"""
 @external
 def foo(s: uint{bits}) -> uint{bits}:
     return s
     """
 
     c = get_contract(code, evm_version=evm_version)
@@ -236,15 +238,15 @@
         assert c.foo(v) == v
 
 
 @pytest.mark.parametrize("evm_version", list(EVM_VERSIONS))
 @pytest.mark.parametrize("n", list(range(31)))  # uint256 has no failing cases
 def test_uint_clamper_failing(w3, assert_tx_failed, get_contract, evm_version, n):
     bits = 8 * (n + 1)
-    values = [-1, -(2 ** 255), 2 ** bits]
+    values = [-1, -(2**255), 2**bits]
     code = f"""
 @external
 def foo(s: uint{bits}) -> uint{bits}:
     return s
     """
     c = get_contract(code, evm_version=evm_version)
     for v in values:
@@ -274,15 +276,15 @@
     """
 
     c = get_contract(code, evm_version=evm_version)
     assert c.foo(value) == expected
 
 
 @pytest.mark.parametrize("evm_version", list(EVM_VERSIONS))
-@pytest.mark.parametrize("value", [2 ** 160, 2 ** 256 - 1])
+@pytest.mark.parametrize("value", [2**160, 2**256 - 1])
 def test_address_clamper_failing(w3, assert_tx_failed, get_contract, value, evm_version):
     code = """
 @external
 def foo(s: address) -> address:
     return s
     """
 
@@ -293,16 +295,16 @@
 @pytest.mark.parametrize("evm_version", list(EVM_VERSIONS))
 @pytest.mark.parametrize(
     "value",
     [
         0,
         1,
         -1,
-        Decimal(2 ** 167 - 1) / 10 ** 10,
-        -Decimal(2 ** 167) / 10 ** 10,
+        Decimal(2**167 - 1) / 10**10,
+        -Decimal(2**167) / 10**10,
         "0.0",
         "1.0",
         "-1.0",
         "0.0000000001",
         "0.9999999999",
         "-0.0000000001",
         "-0.9999999999",
@@ -322,16 +324,16 @@
     assert c.foo(Decimal(value)) == Decimal(value)
 
 
 @pytest.mark.parametrize("evm_version", list(EVM_VERSIONS))
 @pytest.mark.parametrize(
     "value",
     [
-        2 ** 167,
-        -(2 ** 167 + 1),
+        2**167,
+        -(2**167 + 1),
         187072209578355573530071658587684226515959365500928,  # 2 ** 167
         -187072209578355573530071658587684226515959365500929,  # - (2 ** 127 - 1e-10)
     ],
 )
 def test_decimal_clamper_failing(w3, assert_tx_failed, get_contract, value, evm_version):
     code = """
 @external
@@ -340,30 +342,30 @@
     """
 
     c = get_contract(code, evm_version=evm_version)
 
     assert_tx_failed(lambda: _make_tx(w3, c.address, "foo(fixed168x10)", [value]))
 
 
-@pytest.mark.parametrize("value", [0, 1, -1, 2 ** 127 - 1, -(2 ** 127)])
+@pytest.mark.parametrize("value", [0, 1, -1, 2**127 - 1, -(2**127)])
 def test_int128_array_clamper_passing(w3, get_contract, value):
     code = """
 @external
 def foo(a: uint256, b: int128[5], c: uint256) -> int128[5]:
     return b
     """
 
     # on both ends of the array we place a `uint256` that would fail the clamp check,
     # to ensure there are no off-by-one errors
     d = [value] * 5
     c = get_contract(code)
-    assert c.foo(2 ** 127, [value] * 5, 2 ** 127) == d
+    assert c.foo(2**127, [value] * 5, 2**127) == d
 
 
-@pytest.mark.parametrize("bad_value", [2 ** 127, -(2 ** 127) - 1, 2 ** 255 - 1, -(2 ** 255)])
+@pytest.mark.parametrize("bad_value", [2**127, -(2**127) - 1, 2**255 - 1, -(2**255)])
 @pytest.mark.parametrize("idx", range(5))
 def test_int128_array_clamper_failing(w3, assert_tx_failed, get_contract, bad_value, idx):
     # ensure the invalid value is detected at all locations in the array
     code = """
 @external
 def foo(b: int128[5]) -> int128[5]:
     return b
@@ -372,29 +374,29 @@
     values = [0] * 5
     values[idx] = bad_value
 
     c = get_contract(code)
     assert_tx_failed(lambda: _make_tx(w3, c.address, "foo(int128[5])", values))
 
 
-@pytest.mark.parametrize("value", [0, 1, -1, 2 ** 127 - 1, -(2 ** 127)])
+@pytest.mark.parametrize("value", [0, 1, -1, 2**127 - 1, -(2**127)])
 def test_int128_array_looped_clamper_passing(w3, get_contract, value):
     # when an array is > 5 items, the arg clamper runs in a loop to reduce bytecode size
     code = """
 @external
 def foo(a: uint256, b: int128[10], c: uint256) -> int128[10]:
     return b
     """
 
     d = [value] * 10
     c = get_contract(code)
-    assert c.foo(2 ** 127, d, 2 ** 127) == d
+    assert c.foo(2**127, d, 2**127) == d
 
 
-@pytest.mark.parametrize("bad_value", [2 ** 127, -(2 ** 127) - 1, 2 ** 255 - 1, -(2 ** 255)])
+@pytest.mark.parametrize("bad_value", [2**127, -(2**127) - 1, 2**255 - 1, -(2**255)])
 @pytest.mark.parametrize("idx", range(10))
 def test_int128_array_looped_clamper_failing(w3, assert_tx_failed, get_contract, bad_value, idx):
     code = """
 @external
 def foo(b: int128[10]) -> int128[10]:
     return b
     """
@@ -402,29 +404,29 @@
     values = [0] * 10
     values[idx] = bad_value
 
     c = get_contract(code)
     assert_tx_failed(lambda: _make_tx(w3, c.address, "foo(int128[10])", values))
 
 
-@pytest.mark.parametrize("value", [0, 1, -1, 2 ** 127 - 1, -(2 ** 127)])
+@pytest.mark.parametrize("value", [0, 1, -1, 2**127 - 1, -(2**127)])
 def test_multidimension_array_clamper_passing(w3, get_contract, value):
     code = """
 @external
 def foo(a: uint256, b: int128[6][3][1][8], c: uint256) -> int128[6][3][1][8]:
     return b
     """
 
     # 6 * 3 * 1 * 8 = 144, the total number of values in our multidimensional array
     d = [[[[value] * 6] * 3] * 1] * 8
     c = get_contract(code)
-    assert c.foo(2 ** 127, d, 2 ** 127, call={"gasPrice": 0}) == d
+    assert c.foo(2**127, d, 2**127, call={"gasPrice": 0}) == d
 
 
-@pytest.mark.parametrize("bad_value", [2 ** 127, -(2 ** 127) - 1, 2 ** 255 - 1, -(2 ** 255)])
+@pytest.mark.parametrize("bad_value", [2**127, -(2**127) - 1, 2**255 - 1, -(2**255)])
 @pytest.mark.parametrize("idx", range(12))
 def test_multidimension_array_clamper_failing(w3, assert_tx_failed, get_contract, bad_value, idx):
     code = """
 @external
 def foo(b: int128[6][1][2]) -> int128[6][1][2]:
     return b
     """
@@ -432,34 +434,32 @@
     values = [0] * 12
     values[idx] = bad_value
 
     c = get_contract(code)
     assert_tx_failed(lambda: _make_tx(w3, c.address, "foo(int128[6][1][2]])", values))
 
 
-@pytest.mark.parametrize("value", [0, 1, -1, 2 ** 127 - 1, -(2 ** 127)])
+@pytest.mark.parametrize("value", [0, 1, -1, 2**127 - 1, -(2**127)])
 def test_int128_dynarray_clamper_passing(w3, get_contract, value):
     code = """
 @external
 def foo(a: uint256, b: DynArray[int128, 5], c: uint256) -> DynArray[int128, 5]:
     return b
     """
 
     # on both ends of the array we place a `uint256` that would fail the clamp check,
     # to ensure there are no off-by-one errors
     d = [value] * 5
     c = get_contract(code)
-    assert c.foo(2 ** 127, d, 2 ** 127) == d
+    assert c.foo(2**127, d, 2**127) == d
 
 
-@pytest.mark.parametrize("bad_value", [2 ** 127, -(2 ** 127) - 1, 2 ** 255 - 1, -(2 ** 255)])
+@pytest.mark.parametrize("bad_value", [2**127, -(2**127) - 1, 2**255 - 1, -(2**255)])
 @pytest.mark.parametrize("idx", range(5))
-def test_int128_dynarray_clamper_failing(
-    w3, abi_encode, assert_tx_failed, get_contract, bad_value, idx
-):
+def test_int128_dynarray_clamper_failing(w3, assert_tx_failed, get_contract, bad_value, idx):
     # ensure the invalid value is detected at all locations in the array
     code = """
 @external
 def foo(b: int128[5]) -> int128[5]:
     return b
     """
 
@@ -469,28 +469,28 @@
 
     c = get_contract(code)
 
     data = _make_dynarray_data(32, 5, values)
     assert_tx_failed(lambda: _make_invalid_dynarray_tx(w3, c.address, signature, data))
 
 
-@pytest.mark.parametrize("value", [0, 1, -1, 2 ** 127 - 1, -(2 ** 127)])
+@pytest.mark.parametrize("value", [0, 1, -1, 2**127 - 1, -(2**127)])
 def test_int128_dynarray_looped_clamper_passing(w3, get_contract, value):
     # when an array is > 5 items, the arg clamper runs in a loop to reduce bytecode size
     code = """
 @external
 def foo(a: uint256, b: DynArray[int128, 10], c: uint256) -> DynArray[int128, 10]:
     return b
     """
     d = [value] * 10
     c = get_contract(code)
-    assert c.foo(2 ** 127, d, 2 ** 127) == d
+    assert c.foo(2**127, d, 2**127) == d
 
 
-@pytest.mark.parametrize("bad_value", [2 ** 127, -(2 ** 127) - 1, 2 ** 255 - 1, -(2 ** 255)])
+@pytest.mark.parametrize("bad_value", [2**127, -(2**127) - 1, 2**255 - 1, -(2**255)])
 @pytest.mark.parametrize("idx", range(10))
 def test_int128_dynarray_looped_clamper_failing(w3, assert_tx_failed, get_contract, bad_value, idx):
     code = """
 @external
 def foo(b: DynArray[int128, 10]) -> DynArray[int128, 10]:
     return b
     """
@@ -501,35 +501,35 @@
     c = get_contract(code)
 
     data = _make_dynarray_data(32, 10, values)
     signature = "foo(int128[])"
     assert_tx_failed(lambda: _make_invalid_dynarray_tx(w3, c.address, signature, data))
 
 
-@pytest.mark.parametrize("value", [0, 1, -1, 2 ** 127 - 1, -(2 ** 127)])
+@pytest.mark.parametrize("value", [0, 1, -1, 2**127 - 1, -(2**127)])
 def test_multidimension_dynarray_clamper_passing(w3, get_contract, value):
     code = """
 @external
 def foo(
     a: uint256,
     b: DynArray[DynArray[DynArray[DynArray[int128, 5], 6], 7], 8],
     c: uint256
 ) -> DynArray[DynArray[DynArray[DynArray[int128, 5], 6], 7], 8]:
     return b
     """
     # Out of gas exception if outermost length is 6 and greater
     d = [[[[value] * 5] * 6] * 7] * 8
     c = get_contract(code)
-    assert c.foo(2 ** 127, d, 2 ** 127, call={"gasPrice": 0}) == d
+    assert c.foo(2**127, d, 2**127, call={"gasPrice": 0}) == d
 
 
-@pytest.mark.parametrize("bad_value", [2 ** 127, -(2 ** 127) - 1, 2 ** 255 - 1, -(2 ** 255)])
+@pytest.mark.parametrize("bad_value", [2**127, -(2**127) - 1, 2**255 - 1, -(2**255)])
 @pytest.mark.parametrize("idx", range(4))
 def test_multidimension_dynarray_clamper_failing(
-    w3, abi_encode, assert_tx_failed, get_contract, bad_value, idx
+    w3, assert_tx_failed, get_contract, bad_value, idx
 ):
     code = """
 @external
 def foo(b: DynArray[DynArray[int128, 2], 2]) -> DynArray[DynArray[int128, 2], 2]:
     return b
     """
 
@@ -545,35 +545,33 @@
 
     signature = "foo(int128[][])"
 
     c = get_contract(code)
     assert_tx_failed(lambda: _make_invalid_dynarray_tx(w3, c.address, signature, data))
 
 
-@pytest.mark.parametrize("value", [0, 1, -1, 2 ** 127 - 1, -(2 ** 127)])
-def test_dynarray_list_clamper_passing(w3, abi_encode, get_contract, value):
+@pytest.mark.parametrize("value", [0, 1, -1, 2**127 - 1, -(2**127)])
+def test_dynarray_list_clamper_passing(w3, get_contract, value):
     code = """
 @external
 def foo(
     a: uint256,
     b: DynArray[int128[5], 6],
     c: uint256
 ) -> DynArray[int128[5], 6]:
     return b
     """
     d = [[value] * 5] * 6
     c = get_contract(code)
-    assert c.foo(2 ** 127, d, 2 ** 127) == d
+    assert c.foo(2**127, d, 2**127) == d
 
 
-@pytest.mark.parametrize("bad_value", [2 ** 127, -(2 ** 127) - 1, 2 ** 255 - 1, -(2 ** 255)])
+@pytest.mark.parametrize("bad_value", [2**127, -(2**127) - 1, 2**255 - 1, -(2**255)])
 @pytest.mark.parametrize("idx", range(10))
-def test_dynarray_list_clamper_failing(
-    w3, abi_encode, assert_tx_failed, get_contract, bad_value, idx
-):
+def test_dynarray_list_clamper_failing(w3, assert_tx_failed, get_contract, bad_value, idx):
     # ensure the invalid value is detected at all locations in the array
     code = """
 @external
 def foo(b: DynArray[int128[5], 2]) -> DynArray[int128[5], 2]:
     return b
     """
```

### Comparing `vyper-0.3.7/tests/parser/features/test_comparison.py` & `vyper-0.3.8/tests/parser/features/test_comparison.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 # test syntactic comparisons
 # most tests under tests/ast/nodes/test_evaluate_compare.py
 import pytest
 
 
 def test_3034_verbatim(get_contract):
-    # test issue #3034 exactly
+    # test GH issue 3034 exactly
     code = """
 @view
 @external
 def showError():
     adr1: address = 0xFbEEa1C75E4c4465CB2FCCc9c6d6afe984558E20
     adr2: address = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2
     adr3: address = 0xFbEEa1C75E4c4465CB2FCCc9c6d6afe984558E20
```

### Comparing `vyper-0.3.7/tests/parser/features/test_conditionals.py` & `vyper-0.3.8/tests/parser/features/test_conditionals.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/parser/features/test_constructor.py` & `vyper-0.3.8/tests/parser/features/test_constructor.py`

 * *Files 2% similar despite different names*

```diff
@@ -78,18 +78,18 @@
 @external
 def foo(x: int128) -> int128:
     return 3
     """
 
     c = get_contract_with_gas_estimation(large_input_code)
     c.foo(1274124)
-    c.foo(2 ** 120)
+    c.foo(2**120)
 
     with pytest.raises(ValidationError):
-        c.foo(2 ** 130)
+        c.foo(2**130)
 
 
 def test_large_input_code_2(w3, get_contract_with_gas_estimation):
     large_input_code_2 = """
 @external
 def __init__(x: int128):
     y: int128 = x
@@ -98,15 +98,15 @@
 def foo() -> int128:
     return 5
     """
 
     get_contract_with_gas_estimation(large_input_code_2, *[17])
 
     with pytest.raises(TypeError):
-        get_contract_with_gas_estimation(large_input_code_2, *[2 ** 130])
+        get_contract_with_gas_estimation(large_input_code_2, *[2**130])
 
     print("Passed invalid input tests")
 
 
 def test_initialise_array_with_constant_key(get_contract_with_gas_estimation):
     contract = """
 X: constant(uint256) = 4
```

### Comparing `vyper-0.3.7/tests/parser/features/test_immutable.py` & `vyper-0.3.8/tests/parser/features/test_immutable.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,16 +1,16 @@
 import pytest
 
 
 @pytest.mark.parametrize(
     "typ,value",
     [
         ("uint256", 42),
-        ("int256", -(2 ** 200)),
-        ("int128", -(2 ** 126)),
+        ("int256", -(2**200)),
+        ("int128", -(2**126)),
         ("address", "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE"),
         ("bytes32", b"deadbeef" * 4),
         ("bool", True),
         ("String[10]", "Vyper hiss"),
         ("Bytes[10]", b"Vyper hiss"),
     ],
 )
@@ -28,15 +28,15 @@
     return VALUE
     """
 
     c = get_contract(code, value)
     assert c.get_value() == value
 
 
-@pytest.mark.parametrize("val", [0, 1, 2 ** 256 - 1])
+@pytest.mark.parametrize("val", [0, 1, 2**256 - 1])
 def test_usage_in_constructor(get_contract, val):
     code = """
 A: immutable(uint256)
 a: public(uint256)
 
 
 @external
@@ -97,15 +97,15 @@
     })
 
 @view
 @external
 def get_my_struct() -> MyStruct:
     return my_struct
     """
-    values = (100, 42, "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE", -(2 ** 200))
+    values = (100, 42, "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE", -(2**200))
     c = get_contract(code, *values)
     assert c.get_my_struct() == values
 
 
 def test_list_immutable(get_contract):
     code = """
 my_list: immutable(uint256[3])
@@ -235,7 +235,144 @@
 @external
 def get_immutable() -> uint256:
     return VALUE
     """
 
     c = get_contract(code, n)
     assert c.get_immutable() == n + 2
+
+
+# GH issue 3101
+def test_immutables_initialized(get_contract):
+    dummy_code = """
+@external
+def foo() -> uint256:
+    return 1
+    """
+    dummy_contract = get_contract(dummy_code)
+
+    code = """
+a: public(immutable(uint256))
+b: public(uint256)
+
+@payable
+@external
+def __init__(to_copy: address):
+    c: address = create_copy_of(to_copy)
+    self.b = a
+    a = 12
+    """
+    c = get_contract(code, dummy_contract.address)
+
+    assert c.b() == 0
+
+
+# GH issue 3101, take 2
+def test_immutables_initialized2(get_contract, get_contract_from_ir):
+    dummy_contract = get_contract_from_ir(
+        ["deploy", 0, ["seq"] + ["invalid"] * 600, 0], no_optimize=True
+    )
+
+    # rekt because immutables section extends past allocated memory
+    code = """
+a0: immutable(uint256[10])
+a: public(immutable(uint256))
+b: public(uint256)
+
+@payable
+@external
+def __init__(to_copy: address):
+    c: address = create_copy_of(to_copy)
+    self.b = a
+    a = 12
+    a0 = empty(uint256[10])
+    """
+    c = get_contract(code, dummy_contract.address)
+
+    assert c.b() == 0
+
+
+# GH issue 3292
+def test_internal_functions_called_by_ctor_location(get_contract):
+    code = """
+d: uint256
+x: immutable(uint256)
+
+@external
+def __init__():
+    self.d = 1
+    x = 2
+    self.a()
+
+@external
+def test() -> uint256:
+    return self.d
+
+@internal
+def a():
+    self.d = x
+    """
+    c = get_contract(code)
+    assert c.test() == 2
+
+
+# GH issue 3292, extended to nested internal functions
+def test_nested_internal_function_immutables(get_contract):
+    code = """
+d: public(uint256)
+x: public(immutable(uint256))
+
+@external
+def __init__():
+    self.d = 1
+    x = 2
+    self.a()
+
+@internal
+def a():
+    self.b()
+
+@internal
+def b():
+    self.d = x
+    """
+    c = get_contract(code)
+    assert c.x() == 2
+    assert c.d() == 2
+
+
+# GH issue 3292, test immutable read from both ctor and runtime
+def test_immutable_read_ctor_and_runtime(get_contract):
+    code = """
+d: public(uint256)
+x: public(immutable(uint256))
+
+@external
+def __init__():
+    self.d = 1
+    x = 2
+    self.a()
+
+@internal
+def a():
+    self.d = x
+
+@external
+def thrash():
+    self.d += 5
+
+@external
+def fix():
+    self.a()
+    """
+    c = get_contract(code)
+    assert c.x() == 2
+    assert c.d() == 2
+
+    c.thrash(transact={})
+
+    assert c.x() == 2
+    assert c.d() == 2 + 5
+
+    c.fix(transact={})
+    assert c.x() == 2
+    assert c.d() == 2
```

### Comparing `vyper-0.3.7/tests/parser/features/test_init.py` & `vyper-0.3.8/tests/parser/features/test_init.py`

 * *Files 18% similar despite different names*

```diff
@@ -11,20 +11,21 @@
     """
 
     c = get_contract(code, *[123])
 
     assert c.val() == 123
 
     # Make sure the init code does not access calldata
-    opcodes = vyper.compile_code(code, ["opcodes"])["opcodes"].split(" ")
-    ir_return_idx = opcodes.index("JUMP")
-
-    assert "CALLDATALOAD" in opcodes
-    assert "CALLDATACOPY" not in opcodes[:ir_return_idx]
-    assert "CALLDATALOAD" not in opcodes[:ir_return_idx]
+    assembly = vyper.compile_code(code, ["asm"])["asm"].split(" ")
+    ir_return_idx_start = assembly.index("{")
+    ir_return_idx_end = assembly.index("}")
+
+    assert "CALLDATALOAD" in assembly
+    assert "CALLDATACOPY" not in assembly[:ir_return_idx_start] + assembly[ir_return_idx_end:]
+    assert "CALLDATALOAD" not in assembly[:ir_return_idx_start] + assembly[ir_return_idx_end:]
 
 
 def test_init_calls_internal(get_contract, assert_compile_failed, assert_tx_failed):
     code = """
 foo: public(uint8)
 @internal
 def bar(x: uint256) -> uint8:
@@ -48,7 +49,33 @@
     assert_tx_failed(lambda: c.baz())
 
     n = 255
     assert_compile_failed(lambda: get_contract(code, n))
 
     n = 256
     assert_compile_failed(lambda: get_contract(code, n))
+
+
+# GH issue 3206
+def test_nested_internal_call_from_ctor(get_contract):
+    code = """
+x: uint256
+
+@external
+def __init__():
+    self.a()
+
+@internal
+def a():
+    self.x += 1
+    self.b()
+
+@internal
+def b():
+    self.x += 2
+
+@external
+def test() -> uint256:
+    return self.x
+    """
+    c = get_contract(code)
+    assert c.test() == 3
```

### Comparing `vyper-0.3.7/tests/parser/features/test_internal_call.py` & `vyper-0.3.8/tests/parser/features/test_internal_call.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,10 +1,13 @@
+import string
 from decimal import Decimal
 
+import hypothesis.strategies as st
 import pytest
+from hypothesis import given, settings
 
 from vyper.compiler import compile_code
 from vyper.exceptions import ArgumentException, CallViolation
 
 pytestmark = pytest.mark.usefixtures("memory_mocker")
 
 
@@ -638,7 +641,66 @@
     _X: X = X({x: 1, y: "hello"})
     return self._foo(_X.y)
     """
 
     c = get_contract_with_gas_estimation(contract)
 
     assert c.bar() == "hello"
+
+
+# TODO probably want to refactor these into general test utils
+st_uint256 = st.integers(min_value=0, max_value=2**256 - 1)
+st_string65 = st.text(max_size=65, alphabet=string.printable)
+st_bytes65 = st.binary(max_size=65)
+st_sarray3 = st.lists(st_uint256, min_size=3, max_size=3)
+st_darray3 = st.lists(st_uint256, max_size=3)
+
+internal_call_kwargs_cases = [
+    ("uint256", st_uint256),
+    ("String[65]", st_string65),
+    ("Bytes[65]", st_bytes65),
+    ("uint256[3]", st_sarray3),
+    ("DynArray[uint256, 3]", st_darray3),
+]
+
+
+@pytest.mark.parametrize("typ1,strategy1", internal_call_kwargs_cases)
+@pytest.mark.parametrize("typ2,strategy2", internal_call_kwargs_cases)
+def test_internal_call_kwargs(get_contract, typ1, strategy1, typ2, strategy2):
+    # GHSA-ph9x-4vc9-m39g
+
+    @given(kwarg1=strategy1, default1=strategy1, kwarg2=strategy2, default2=strategy2)
+    @settings(deadline=None, max_examples=5)  # len(cases) * len(cases) * 5 * 5
+    def fuzz(kwarg1, kwarg2, default1, default2):
+        code = f"""
+@internal
+def foo(a: {typ1} = {repr(default1)}, b: {typ2} = {repr(default2)}) -> ({typ1}, {typ2}):
+    return a, b
+
+@external
+def test0() -> ({typ1}, {typ2}):
+    return self.foo()
+
+@external
+def test1() -> ({typ1}, {typ2}):
+    return self.foo({repr(kwarg1)})
+
+@external
+def test2() -> ({typ1}, {typ2}):
+    return self.foo({repr(kwarg1)}, {repr(kwarg2)})
+
+@external
+def test3(x1: {typ1}) -> ({typ1}, {typ2}):
+    return self.foo(x1)
+
+@external
+def test4(x1: {typ1}, x2: {typ2}) -> ({typ1}, {typ2}):
+    return self.foo(x1, x2)
+        """
+        c = get_contract(code)
+        assert c.test0() == [default1, default2]
+        assert c.test1() == [kwarg1, default2]
+        assert c.test2() == [kwarg1, kwarg2]
+        assert c.test3(kwarg1) == [kwarg1, default2]
+        assert c.test4(kwarg1, kwarg2) == [kwarg1, kwarg2]
+
+    fuzz()
```

### Comparing `vyper-0.3.7/tests/parser/features/test_logging.py` & `vyper-0.3.8/tests/parser/features/test_logging.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 from decimal import Decimal
 
-import eth_abi
 import pytest
+from eth.codecs import abi
 
 from vyper.exceptions import (
     ArgumentException,
     EventDeclarationException,
     InvalidType,
     NamespaceCollision,
     StructureException,
@@ -548,15 +548,15 @@
     logs = get_logs(tx_hash, c, "MyLog")
     args = logs[0].args
     assert args.arg1 == 1
     assert args.arg2 == b"bar"
     logs = get_logs(tx_hash, c, "YourLog")
     args = logs[0].args
     assert args.arg1 == c.address
-    assert args.arg2 == (1, b"abc", ("house", Decimal("13.5")))
+    assert args.arg2 == {"x": 1, "y": b"abc", "z": {"t": "house", "w": Decimal("13.5")}}
 
 
 def test_fails_when_input_is_the_wrong_type(assert_tx_failed, get_contract_with_gas_estimation):
     loggy_code = """
 event MyLog:
     arg1: indexed(int128)
 
@@ -760,32 +760,32 @@
 
     c = get_contract_with_gas_estimation(loggy_code)
 
     tx_hash = c.foo(transact={})
     receipt = tester.get_transaction_receipt(tx_hash.hex())
     logs = receipt["logs"]
 
-    assert w3.toText(logs[0]["data"]) == "moo"
+    assert w3.to_text(logs[0]["data"]) == "moo"
     tx_hash = c.goo(transact={})
     receipt = tester.get_transaction_receipt(tx_hash.hex())
     logs = receipt["logs"]
-    assert w3.toText(logs[0]["data"]) == "moo2"
+    assert w3.to_text(logs[0]["data"]) == "moo2"
     assert (
         logs[0]["topics"][0] == "0x1234567812345678123456781234567812345678123456781234567812345678"
     )  # noqa: E501
 
     tx_hash = c.hoo(transact={})
     receipt = tester.get_transaction_receipt(tx_hash.hex())
     logs = receipt["logs"]
-    assert w3.toText(logs[0]["data"]) == "moo3"
+    assert w3.to_text(logs[0]["data"]) == "moo3"
 
     tx_hash = c.ioo(b"moo4", transact={})
     receipt = tester.get_transaction_receipt(tx_hash.hex())
     logs = receipt["logs"]
-    assert w3.toText(logs[0]["data"]) == "moo4"
+    assert w3.to_text(logs[0]["data"]) == "moo4"
 
     print("Passed raw log tests")
 
 
 def test_raw_call_bytes32_data(w3, tester, get_contract_with_gas_estimation):
     code = """
 b: uint256
@@ -799,22 +799,21 @@
     raw_log([], convert(b"testmessage", bytes32))
     raw_log([], keccak256(b""))
     """
     c = get_contract_with_gas_estimation(code)
     tx_hash = c.foo(transact={})
     receipt = tester.get_transaction_receipt(tx_hash.hex())
     logs = receipt["logs"]
-    assert logs[0]["data"] == w3.toHex((1234).to_bytes(32, "big"))
-    assert logs[1]["data"] == w3.toHex((4321).to_bytes(32, "big"))
-    assert logs[2]["data"] == w3.toHex(b"testmessage").ljust(32 * 2 + 2, "0")
-    assert logs[3]["data"] == w3.toHex(keccak256(b""))
+    assert logs[0]["data"] == w3.to_hex((1234).to_bytes(32, "big"))
+    assert logs[1]["data"] == w3.to_hex((4321).to_bytes(32, "big"))
+    assert logs[2]["data"] == w3.to_hex(b"testmessage").ljust(32 * 2 + 2, "0")
+    assert logs[3]["data"] == w3.to_hex(keccak256(b""))
 
 
 def test_variable_list_packing(get_logs, get_contract_with_gas_estimation):
-
     code = """
 event Bar:
     _value: int128[4]
 
 @external
 def foo():
     a: int128[4] = [1, 2, 3, 4]
@@ -824,15 +823,14 @@
 
     tx_hash = c.foo(transact={})
     logs = get_logs(tx_hash, c, "Bar")
     assert logs[0].args._value == [1, 2, 3, 4]
 
 
 def test_literal_list_packing(get_logs, get_contract_with_gas_estimation):
-
     code = """
 event Bar:
     _value: int128[4]
 
 @external
 def foo():
     log Bar([1, 2, 3, 4])
@@ -841,15 +839,14 @@
 
     tx_hash = c.foo(transact={})
     logs = get_logs(tx_hash, c, "Bar")
     assert logs[0].args._value == [1, 2, 3, 4]
 
 
 def test_storage_list_packing(get_logs, bytes_helper, get_contract_with_gas_estimation):
-
     code = """
 event Bar:
     _value: int128[4]
 
 x: int128[4]
 
 @external
@@ -868,15 +865,14 @@
     c.set_list(transact={})
     tx_hash = c.foo(transact={})
     logs = get_logs(tx_hash, c, "Bar")
     assert logs[0].args._value == [1, 2, 3, 4]
 
 
 def test_passed_list_packing(get_logs, get_contract_with_gas_estimation):
-
     code = """
 event Bar:
     _value: int128[4]
 
 @external
 def foo(barbaric: int128[4]):
     log Bar(barbaric)
@@ -906,15 +902,14 @@
         Decimal("2.22"),
         Decimal("3.33"),
         Decimal("4.44"),
     ]
 
 
 def test_storage_byte_packing(get_logs, bytes_helper, get_contract_with_gas_estimation):
-
     code = """
 event MyLog:
     arg1: Bytes[29]
 
 x:Bytes[5]
 
 @external
@@ -933,15 +928,14 @@
     c.setbytez(transact={})
     tx_hash = c.foo(0, transact={})
     logs = get_logs(tx_hash, c, "MyLog")
     assert logs[0].args.arg1 == b"hello"
 
 
 def test_storage_decimal_list_packing(get_logs, bytes_helper, get_contract_with_gas_estimation):
-
     code = """
 event Bar:
     _value: decimal[4]
 
 x: decimal[4]
 
 @external
@@ -1083,15 +1077,15 @@
     # Event id is always the first topic
     event_id = keccak(b"MyLog(bytes,int128,string)")
     assert receipt["logs"][0]["topics"][0] == event_id.hex()
 
     topic1 = f"0x{keccak256(b'bar').hex()}"
     assert receipt["logs"][0]["topics"][1] == topic1
 
-    topic2 = f"0x{eth_abi.encode_single('int128', 1).hex()}"
+    topic2 = f"0x{abi.encode('int128', 1).hex()}"
     assert receipt["logs"][0]["topics"][2] == topic2
 
     topic3 = f"0x{keccak256(b'weird').hex()}"
     assert receipt["logs"][0]["topics"][3] == topic3
 
     # Event abi is created correctly
     assert c._classic_contract.abi[0] == {
@@ -1128,15 +1122,15 @@
     # Event id is always the first topic
     event_id = keccak(b"MyLog(bytes,int128,string)")
     assert receipt["logs"][0]["topics"][0] == event_id.hex()
 
     topic1 = f"0x{keccak256(b'potato').hex()}"
     assert receipt["logs"][0]["topics"][1] == topic1
 
-    topic2 = f"0x{eth_abi.encode_single('int128', -777).hex()}"
+    topic2 = f"0x{abi.encode('int128', -777).hex()}"
     assert receipt["logs"][0]["topics"][2] == topic2
 
     topic3 = f"0x{keccak256(b'why hello, neighbor! how are you today?').hex()}"
     assert receipt["logs"][0]["topics"][3] == topic3
 
     # Event abi is created correctly
     assert c._classic_contract.abi[0] == {
@@ -1182,15 +1176,15 @@
     # Event id is always the first topic
     event_id = keccak(b"MyLog(bytes,int128,string)")
     assert receipt["logs"][0]["topics"][0] == event_id.hex()
 
     topic1 = f"0x{keccak256(b'zonk').hex()}"
     assert receipt["logs"][0]["topics"][1] == topic1
 
-    topic2 = f"0x{eth_abi.encode_single('int128', -2109).hex()}"
+    topic2 = f"0x{abi.encode('int128', -2109).hex()}"
     assert receipt["logs"][0]["topics"][2] == topic2
 
     topic3 = f"0x{keccak256(b'yessir').hex()}"
     assert receipt["logs"][0]["topics"][3] == topic3
 
     # Event abi is created correctly
     assert c._classic_contract.abi[0] == {
@@ -1224,15 +1218,15 @@
     # Event id is always the first topic
     event_id = keccak(b"MyLog(bytes,int128,string)")
     assert receipt["logs"][0]["topics"][0] == event_id.hex()
 
     topic1 = f"0x{keccak256(b'wow').hex()}"
     assert receipt["logs"][0]["topics"][1] == topic1
 
-    topic2 = f"0x{eth_abi.encode_single('int128', 666).hex()}"
+    topic2 = f"0x{abi.encode('int128', 666).hex()}"
     assert receipt["logs"][0]["topics"][2] == topic2
 
     topic3 = f"0x{keccak256(b'madness!').hex()}"
     assert receipt["logs"][0]["topics"][3] == topic3
 
 
 fail_list = [
```

### Comparing `vyper-0.3.7/tests/parser/features/test_logging_bytes_extended.py` & `vyper-0.3.8/tests/parser/features/test_logging_bytes_extended.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/parser/features/test_logging_from_call.py` & `vyper-0.3.8/tests/parser/features/test_logging_from_call.py`

 * *Files 4% similar despite different names*

```diff
@@ -33,20 +33,20 @@
     c = get_contract_with_gas_estimation(code)
 
     tx_hash = c.test_func(123, transact={})
 
     logs = get_logs(tx_hash, c, "TestLog")
 
     log = logs[0].args
-    assert w3.toInt(log.testData1) == 123
-    assert w3.toInt(log.testData2[:32]) == 123
+    assert w3.to_int(log.testData1) == 123
+    assert w3.to_int(log.testData2[:32]) == 123
     assert log.testData2[-7:] == b"testing"
     assert log.testData2[32:] == b"\x00\x00\x00\x00\x00\x00\x00{testing"
     assert log.testData3 == b"\x00\x00\x00\x00\x00\x00\x00{"
-    assert w3.toInt(log.testData3) == 123
+    assert w3.to_int(log.testData3) == 123
 
     assert logs[0].args == logs[1].args
 
 
 def test_log_dynamic_static_combo2(get_logs, get_contract, w3):
     code = """
 event TestLog:
@@ -79,15 +79,15 @@
     tx_hash = c.test_func(1234444, b"x" * 129, transact={})
     tx_receipt = w3.eth.get_transaction_receipt(tx_hash)
     print(tx_receipt)
     logs = get_logs(tx_hash, c, "TestLog")
 
     print(logs[0].args)
 
-    assert w3.toInt(logs[0].args.testData1) == 1234444
+    assert w3.to_int(logs[0].args.testData1) == 1234444
     assert logs[0].args.testData3 == "bababa"
     assert logs[0].args.testData2 == b"x" * 129
 
 
 def test_log_single_function_call(get_logs, get_contract, w3):
     code = """
 event TestLog:
@@ -110,15 +110,15 @@
     """
 
     c = get_contract(code)
 
     tx_hash = c.test_func(1234444, b"x" * 129, transact={})
     logs = get_logs(tx_hash, c, "TestLog")
 
-    assert w3.toInt(logs[0].args.testData1) == 1234444
+    assert w3.to_int(logs[0].args.testData1) == 1234444
     assert logs[0].args.testData2 == b"x" * 129
 
 
 def test_original_problem_function(get_logs, get_contract, w3):
     # See #1205 for further details, this is kept as test case as it introduces very specific
     # edge cases to the ABI encoder when logging.
     code = """
@@ -156,15 +156,15 @@
     tx_hash = c.test_func(333, b"x" * 132, transact={})
     tx_receipt = w3.eth.get_transaction_receipt(tx_hash)
     print(tx_receipt)
     logs = get_logs(tx_hash, c, "TestLog")
 
     print(logs[0].args)
 
-    assert w3.toInt(logs[0].args.testData1) == 333
+    assert w3.to_int(logs[0].args.testData1) == 333
 
-    assert w3.toInt(logs[0].args.testData2[0:8]) == 333
-    assert w3.toInt(logs[0].args.testData2[8:16]) == 333
+    assert w3.to_int(logs[0].args.testData2[0:8]) == 333
+    assert w3.to_int(logs[0].args.testData2[8:16]) == 333
     assert logs[0].args.testData2[16:] == b"x" * 132
-    assert w3.toInt(logs[0].args.testData3) == 333
+    assert w3.to_int(logs[0].args.testData3) == 333
 
     assert logs[0].args == logs[1].args
```

### Comparing `vyper-0.3.7/tests/parser/features/test_memory_dealloc.py` & `vyper-0.3.8/tests/parser/features/test_memory_dealloc.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/parser/features/test_packing.py` & `vyper-0.3.8/tests/parser/features/test_packing.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/parser/features/test_short_circuiting.py` & `vyper-0.3.8/tests/parser/features/test_short_circuiting.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/parser/functions/test_abi.py` & `vyper-0.3.8/tests/parser/functions/test_abi.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/parser/functions/test_abi_decode.py` & `vyper-0.3.8/tests/parser/functions/test_abi_decode.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,18 +1,18 @@
 from decimal import Decimal
 
 import pytest
+from eth.codecs import abi
 
 from vyper.exceptions import ArgumentException, StructureException
 
-TEST_ADDR = b"".join(chr(i).encode("utf-8") for i in range(20))
-EXPECTED_TEST_ADDR = "0x" + TEST_ADDR.hex()
+TEST_ADDR = "0x" + b"".join(chr(i).encode("utf-8") for i in range(20)).hex()
 
 
-def test_abi_decode_complex(get_contract, abi_encode):
+def test_abi_decode_complex(get_contract):
     contract = """
 struct Animal:
   name: String[5]
   address_: address
   id_: int128
   is_furry: bool
   price: decimal
@@ -52,34 +52,28 @@
     """
 
     c = get_contract(contract)
 
     test_bytes32 = b"".join(chr(i).encode("utf-8") for i in range(32))
     args = (TEST_ADDR, -1, True, Decimal("-123.4"), test_bytes32)
     encoding = "(address,int128,bool,fixed168x10,bytes32)"
-    encoded = abi_encode(encoding, args)
-    assert tuple(c.abi_decode(encoded)) == (
-        EXPECTED_TEST_ADDR,
-        -1,
-        True,
-        Decimal("-123.4"),
-        test_bytes32,
-    )
+    encoded = abi.encode(encoding, args)
+    assert tuple(c.abi_decode(encoded)) == (TEST_ADDR, -1, True, Decimal("-123.4"), test_bytes32)
 
     test_bytes32 = b"".join(chr(i).encode("utf-8") for i in range(32))
     human_tuple = (
         "foobar",
         ("vyper", TEST_ADDR, 123, True, Decimal("123.4"), [123, 456, 789], test_bytes32),
     )
     args = tuple([human_tuple[0]] + list(human_tuple[1]))
     human_t = "((string,(string,address,int128,bool,fixed168x10,uint256[3],bytes32)))"
-    human_encoded = abi_encode(human_t, (human_tuple,))
+    human_encoded = abi.encode(human_t, (human_tuple,))
     assert tuple(c.abi_decode_struct(human_encoded)) == (
         "foobar",
-        ("vyper", EXPECTED_TEST_ADDR, 123, True, Decimal("123.4"), [123, 456, 789], test_bytes32),
+        ("vyper", TEST_ADDR, 123, True, Decimal("123.4"), [123, 456, 789], test_bytes32),
     )
 
 
 @pytest.mark.parametrize(
     "expected,input_len,output_typ,abi_typ,unwrap_tuple",
     [
         (123, 32, "uint256", "uint256", False),
@@ -89,71 +83,63 @@
         ([123, 456, 789], 96, "uint256[3]", "uint256[3]", False),
         ([123, 456, 789], 96, "uint256[3]", "(uint256[3])", True),
         ([123, 456, 789], 128, "DynArray[uint256, 3]", "uint256[]", False),
         ([123, 456, 789], 160, "DynArray[uint256, 3]", "(uint256[])", True),
     ],
 )
 def test_abi_decode_single(
-    get_contract, abi_encode, expected, input_len, output_typ, abi_typ, unwrap_tuple
+    w3, get_contract, expected, input_len, output_typ, abi_typ, unwrap_tuple
 ):
     contract = f"""
 @external
 def foo(x: Bytes[{input_len}]) -> {output_typ}:
     a: {output_typ} = _abi_decode(x, {output_typ}, unwrap_tuple={unwrap_tuple})
     return a
     """
     c = get_contract(contract)
 
     encode_arg = expected
     if unwrap_tuple is True:
         encode_arg = (expected,)
 
-    encoded = abi_encode(abi_typ, encode_arg)
+    encoded = abi.encode(abi_typ, encode_arg)
     assert c.foo(encoded) == expected
 
 
 @pytest.mark.parametrize(
     "arg,expected,input_len,output_typ1,output_typ2,abi_typ",
     [
         ((123, 456), (123, 456), 64, "uint256", "uint256", "(uint256,uint256)"),
-        ((TEST_ADDR, 123), (EXPECTED_TEST_ADDR, 123), 64, "address", "int128", "(address,int128)"),
+        ((TEST_ADDR, 123), (TEST_ADDR, 123), 64, "address", "int128", "(address,int128)"),
         (
             ("vyper", TEST_ADDR),
-            ("vyper", EXPECTED_TEST_ADDR),
+            ("vyper", TEST_ADDR),
             128,
             "String[5]",
             "address",
             "(string,address)",
         ),
         ((1, b"234"), (1, b"234"), 128, "uint256", "Bytes[32]", ("(uint256,bytes)")),
     ],
 )
 @pytest.mark.parametrize("unwrap_tuple", (True, False))
 def test_abi_decode_double(
-    get_contract,
-    abi_encode,
-    arg,
-    expected,
-    input_len,
-    output_typ1,
-    output_typ2,
-    abi_typ,
-    unwrap_tuple,
+    get_contract, arg, expected, input_len, output_typ1, output_typ2, abi_typ, unwrap_tuple
 ):
     contract = f"""
 @external
 def foo(x: Bytes[{input_len}]) -> ({output_typ1}, {output_typ2}):
     a: {output_typ1} = empty({output_typ1})
     b: {output_typ2} = empty({output_typ2})
     a, b = _abi_decode(x, ({output_typ1}, {output_typ2}), unwrap_tuple={unwrap_tuple})
     return a, b
     """
 
     c = get_contract(contract)
-    encoded = abi_encode(abi_typ, arg)
+    encoded = abi.encode(abi_typ, arg)
     assert tuple(c.foo(encoded)) == expected
 
 
 nested_2d_array_args = [
     [[123, 456, 789], [234, 567, 891], [345, 678, 912]],
     [[], [], []],
     [[123, 456], [234, 567, 891]],
@@ -166,20 +152,20 @@
     [[]],
     [[123], [234]],
 ]
 
 
 @pytest.mark.parametrize("args", nested_2d_array_args)
 @pytest.mark.parametrize("unwrap_tuple", (True, False))
-def test_abi_decode_nested_dynarray(get_contract, abi_encode, args, unwrap_tuple):
+def test_abi_decode_nested_dynarray(get_contract, args, unwrap_tuple):
     if unwrap_tuple is True:
-        encoded = abi_encode("(uint256[][])", (args,))
+        encoded = abi.encode("(uint256[][])", (args,))
         len = 544
     else:
-        encoded = abi_encode("uint256[][]", args)
+        encoded = abi.encode("uint256[][]", args)
         len = 512
 
     code = f"""
 @external
 def abi_decode(x: Bytes[{len}]) -> DynArray[DynArray[uint256, 3], 3]:
     a: DynArray[DynArray[uint256, 3], 3] = []
     a = _abi_decode(x, DynArray[DynArray[uint256, 3], 3], unwrap_tuple={unwrap_tuple})
@@ -206,20 +192,20 @@
     [[[123, 456, 789], [234, 567]], [[234]], [[567], [912], [345]]],
     [[[]]],
 ]
 
 
 @pytest.mark.parametrize("args", nested_3d_array_args)
 @pytest.mark.parametrize("unwrap_tuple", (True, False))
-def test_abi_decode_nested_dynarray2(get_contract, abi_encode, args, unwrap_tuple):
+def test_abi_decode_nested_dynarray2(get_contract, args, unwrap_tuple):
     if unwrap_tuple is True:
-        encoded = abi_encode("(uint256[][][])", (args,))
+        encoded = abi.encode("(uint256[][][])", (args,))
         len = 1696
     else:
-        encoded = abi_encode("uint256[][][]", args)
+        encoded = abi.encode("uint256[][][]", args)
         len = 1664
 
     code = f"""
 @external
 def abi_decode(x: Bytes[{len}]) -> DynArray[DynArray[DynArray[uint256, 3], 3], 3]:
     a: DynArray[DynArray[DynArray[uint256, 3], 3], 3] = []
     a = _abi_decode(
@@ -230,15 +216,15 @@
     return a
     """
 
     c = get_contract(code)
     assert c.abi_decode(encoded) == args
 
 
-def test_side_effects_evaluation(get_contract, abi_encode):
+def test_side_effects_evaluation(get_contract):
     contract_1 = """
 counter: uint256
 
 @external
 def __init__():
     self.counter = 0
 
@@ -263,15 +249,15 @@
     """
 
     c2 = get_contract(contract_2)
 
     assert tuple(c2.foo(c.address)) == (1, "hello")
 
 
-def test_abi_decode_private_dynarray(get_contract, abi_encode):
+def test_abi_decode_private_dynarray(get_contract):
     code = """
 bytez: DynArray[uint256, 3]
 
 @internal
 def _foo(bs: Bytes[160]):
     self.bytez = _abi_decode(bs, DynArray[uint256, 3])
 
@@ -279,19 +265,19 @@
 def foo(bs: Bytes[160]) -> (uint256, DynArray[uint256, 3]):
     dont_clobber_me: uint256 = max_value(uint256)
     self._foo(bs)
     return dont_clobber_me, self.bytez
     """
     c = get_contract(code)
     bs = [1, 2, 3]
-    encoded = abi_encode("(uint256[])", (bs,))
-    assert c.foo(encoded) == [2 ** 256 - 1, bs]
+    encoded = abi.encode("(uint256[])", (bs,))
+    assert c.foo(encoded) == [2**256 - 1, bs]
 
 
-def test_abi_decode_private_nested_dynarray(get_contract, abi_encode):
+def test_abi_decode_private_nested_dynarray(get_contract):
     code = """
 bytez: DynArray[DynArray[DynArray[uint256, 3], 3], 3]
 
 @internal
 def _foo(bs: Bytes[1696]):
     self.bytez = _abi_decode(bs, DynArray[DynArray[DynArray[uint256, 3], 3], 3])
 
@@ -303,53 +289,53 @@
     """
     c = get_contract(code)
     bs = [
         [[1, 2, 3], [4, 5, 6], [7, 8, 9]],
         [[10, 11, 12], [13, 14, 15], [16, 17, 18]],
         [[19, 20, 21], [22, 23, 24], [25, 26, 27]],
     ]
-    encoded = abi_encode("(uint256[][][])", (bs,))
-    assert c.foo(encoded) == [2 ** 256 - 1, bs]
+    encoded = abi.encode("(uint256[][][])", (bs,))
+    assert c.foo(encoded) == [2**256 - 1, bs]
 
 
-def test_abi_decode_return(get_contract, abi_encode):
+def test_abi_decode_return(get_contract):
     contract = """
 @external
 def abi_decode(x: Bytes[64]) -> (address, int128):
     return _abi_decode(x, (address, int128))
     """
 
     c = get_contract(contract)
 
-    encoded = abi_encode("(address,int128)", (TEST_ADDR, 123))
+    encoded = abi.encode("(address,int128)", (TEST_ADDR, 123))
 
-    assert tuple(c.abi_decode(encoded)) == (EXPECTED_TEST_ADDR, 123)
+    assert tuple(c.abi_decode(encoded)) == (TEST_ADDR, 123)
 
 
-def test_abi_decode_annassign(get_contract, abi_encode):
+def test_abi_decode_annassign(get_contract):
     contract = """
 @external
 def abi_decode(x: Bytes[32]) -> uint256:
     a: uint256 = _abi_decode(x, uint256, unwrap_tuple=False)
     return a
     """
     c = get_contract(contract)
 
-    encoded = abi_encode("uint256", 123)
+    encoded = abi.encode("uint256", 123)
     assert c.abi_decode(encoded) == 123
 
 
 @pytest.mark.parametrize(
     "input_",
     [
         b"",  # Length of byte array is below minimum size of output type
         b"\x01" * 96,  # Length of byte array is beyond size bound of output type
     ],
 )
-def test_clamper(get_contract, assert_tx_failed, abi_encode, input_):
+def test_clamper(get_contract, assert_tx_failed, input_):
     contract = """
 @external
 def abi_decode(x: Bytes[96]) -> (uint256, uint256):
     a: uint256 = empty(uint256)
     b: uint256 = empty(uint256)
     a, b = _abi_decode(x, (uint256, uint256))
     return a, b
@@ -363,58 +349,56 @@
     [
         ("DynArray[uint256, 3]", b""),
         ("DynArray[uint256, 3]", b"\x01" * 192),
         ("Bytes[5]", b""),
         ("Bytes[5]", b"\x01" * 192),
     ],
 )
-def test_clamper_dynamic(get_contract, assert_tx_failed, abi_encode, output_typ, input_):
+def test_clamper_dynamic(get_contract, assert_tx_failed, output_typ, input_):
     contract = f"""
 @external
 def abi_decode(x: Bytes[192]) -> {output_typ}:
     a: {output_typ} = empty({output_typ})
     a = _abi_decode(x, {output_typ})
     return a
     """
     c = get_contract(contract)
     assert_tx_failed(lambda: c.abi_decode(input_))
 
 
 @pytest.mark.parametrize(
     "arg,encoding,expected", [(123, "(uint256)", 123), ([123, 456, 789], "(uint256[])", 789)]
 )
-def test_abi_decode_conditional(get_contract, abi_encode, arg, encoding, expected):
+def test_abi_decode_conditional(get_contract, arg, encoding, expected):
     contract = """
 @external
 def abi_decode(x: Bytes[160]) -> uint256:
     if len(x) == 32:
         a: uint256 = _abi_decode(x, uint256)
         return a
     elif len(x) == 160:
         b: DynArray[uint256, 3] = _abi_decode(x, DynArray[uint256, 3])
         return b[2]
     return 0
     """
     c = get_contract(contract)
-    encoded = abi_encode(encoding, (arg,))
+    encoded = abi.encode(encoding, (arg,))
     assert c.abi_decode(encoded) == expected
 
 
 @pytest.mark.parametrize(
     "output_typ1,output_typ2,input_",
     [
         ("DynArray[uint256, 3]", "uint256", b""),
         ("DynArray[uint256, 3]", "uint256", b"\x01" * 128),
         ("Bytes[5]", "address", b""),
         ("Bytes[5]", "address", b"\x01" * 128),
     ],
 )
-def test_clamper_dynamic_tuple(
-    get_contract, assert_tx_failed, abi_encode, output_typ1, output_typ2, input_
-):
+def test_clamper_dynamic_tuple(get_contract, assert_tx_failed, output_typ1, output_typ2, input_):
     contract = f"""
 @external
 def abi_decode(x: Bytes[224]) -> ({output_typ1}, {output_typ2}):
     a: {output_typ1} = empty({output_typ1})
     b: {output_typ2} = empty({output_typ2})
     a, b = _abi_decode(x, ({output_typ1}, {output_typ2}))
     return a, b
```

### Comparing `vyper-0.3.7/tests/parser/functions/test_abi_encode.py` & `vyper-0.3.8/tests/parser/functions/test_abi_encode.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,14 +1,15 @@
 from decimal import Decimal
 
 import pytest
+from eth.codecs import abi
 
 
 # @pytest.mark.parametrize("string", ["a", "abc", "abcde", "potato"])
-def test_abi_encode(get_contract, abi_encode):
+def test_abi_encode(get_contract):
     code = """
 struct Animal:
   name: String[5]
   address_: address
   id_: int128
   is_furry: bool
   price: decimal
@@ -78,47 +79,47 @@
         if not include_method_id:
             return _abi_encode(x, ensure_tuple=False)
 
         return _abi_encode(x, ensure_tuple=False, method_id=0xdeadbeef)
     """
     c = get_contract(code)
 
-    method_id = 0xDEADBEEF .to_bytes(4, "big")
+    method_id = 0xDEADBEEF.to_bytes(4, "big")
 
     # test each method once each with ensure_tuple set to True and False
 
     arg = 123
-    assert c.abi_encode3(arg, False, False).hex() == abi_encode("uint256", arg).hex()
-    assert c.abi_encode3(arg, True, False).hex() == abi_encode("(uint256)", (arg,)).hex()
-    assert c.abi_encode3(arg, False, True).hex() == (method_id + abi_encode("uint256", arg)).hex()
+    assert c.abi_encode3(arg, False, False).hex() == abi.encode("uint256", arg).hex()
+    assert c.abi_encode3(arg, True, False).hex() == abi.encode("(uint256)", (arg,)).hex()
+    assert c.abi_encode3(arg, False, True).hex() == (method_id + abi.encode("uint256", arg)).hex()
     assert (
-        c.abi_encode3(arg, True, True).hex() == (method_id + abi_encode("(uint256)", (arg,))).hex()
+        c.abi_encode3(arg, True, True).hex() == (method_id + abi.encode("(uint256)", (arg,))).hex()
     )
 
     arg = "some string"
-    assert c.abi_encode2(arg, False, False).hex() == abi_encode("string", arg).hex()
-    assert c.abi_encode2(arg, True, False).hex() == abi_encode("(string)", (arg,)).hex()
-    assert c.abi_encode2(arg, False, True).hex() == (method_id + abi_encode("string", arg)).hex()
+    assert c.abi_encode2(arg, False, False).hex() == abi.encode("string", arg).hex()
+    assert c.abi_encode2(arg, True, False).hex() == abi.encode("(string)", (arg,)).hex()
+    assert c.abi_encode2(arg, False, True).hex() == (method_id + abi.encode("string", arg)).hex()
     assert (
-        c.abi_encode2(arg, True, True).hex() == (method_id + abi_encode("(string)", (arg,))).hex()
+        c.abi_encode2(arg, True, True).hex() == (method_id + abi.encode("(string)", (arg,))).hex()
     )
 
-    test_addr = b"".join(chr(i).encode("utf-8") for i in range(20))
+    test_addr = "0x" + b"".join(chr(i).encode("utf-8") for i in range(20)).hex()
     test_bytes32 = b"".join(chr(i).encode("utf-8") for i in range(32))
     human_tuple = (
         "foobar",
         ("vyper", test_addr, 123, True, Decimal("123.4"), [123, 456, 789], test_bytes32),
     )
     args = tuple([human_tuple[0]] + list(human_tuple[1]))
     human_t = "(string,(string,address,int128,bool,fixed168x10,uint256[3],bytes32))"
-    human_encoded = abi_encode(human_t, human_tuple)
+    human_encoded = abi.encode(human_t, human_tuple)
     assert c.abi_encode(*args, False, False).hex() == human_encoded.hex()
     assert c.abi_encode(*args, False, True).hex() == (method_id + human_encoded).hex()
 
-    human_encoded = abi_encode(f"({human_t})", (human_tuple,))
+    human_encoded = abi.encode(f"({human_t})", (human_tuple,))
     assert c.abi_encode(*args, True, False).hex() == human_encoded.hex()
     assert c.abi_encode(*args, True, True).hex() == (method_id + human_encoded).hex()
 
 
 @pytest.mark.parametrize("type,value", [("Bytes", b"hello"), ("String", "hello")])
 def test_abi_encode_length_failing(get_contract, assert_compile_failed, type, value):
     code = f"""
@@ -130,37 +131,37 @@
     x: WrappedBytes = WrappedBytes({{bs: {value}}})
     y: {type}[96] = _abi_encode(x, ensure_tuple=True) # should be Bytes[128]
     """
 
     assert_compile_failed(lambda: get_contract(code))
 
 
-def test_abi_encode_dynarray(get_contract, abi_encode):
+def test_abi_encode_dynarray(get_contract):
     code = """
 @external
 def abi_encode(d: DynArray[uint256, 3], ensure_tuple: bool, include_method_id: bool) -> Bytes[164]:
     if ensure_tuple:
         if not include_method_id:
             return _abi_encode(d) # default ensure_tuple=True
         return _abi_encode(d, method_id=0xdeadbeef)
     else:
         if not include_method_id:
             return _abi_encode(d, ensure_tuple=False)
         return _abi_encode(d, ensure_tuple=False, method_id=0xdeadbeef)
     """
     c = get_contract(code)
 
-    method_id = 0xDEADBEEF .to_bytes(4, "big")
+    method_id = 0xDEADBEEF.to_bytes(4, "big")
 
     arg = [123, 456, 789]
-    assert c.abi_encode(arg, False, False).hex() == abi_encode("uint256[]", arg).hex()
-    assert c.abi_encode(arg, True, False).hex() == abi_encode("(uint256[])", (arg,)).hex()
-    assert c.abi_encode(arg, False, True).hex() == (method_id + abi_encode("uint256[]", arg)).hex()
+    assert c.abi_encode(arg, False, False).hex() == abi.encode("uint256[]", arg).hex()
+    assert c.abi_encode(arg, True, False).hex() == abi.encode("(uint256[])", (arg,)).hex()
+    assert c.abi_encode(arg, False, True).hex() == (method_id + abi.encode("uint256[]", arg)).hex()
     assert (
-        c.abi_encode(arg, True, True).hex() == (method_id + abi_encode("(uint256[])", (arg,))).hex()
+        c.abi_encode(arg, True, True).hex() == (method_id + abi.encode("(uint256[])", (arg,))).hex()
     )
 
 
 nested_2d_array_args = [
     [[123, 456, 789], [234, 567, 891], [345, 678, 912]],
     [[], [], []],
     [[123, 456], [234, 567, 891]],
@@ -172,15 +173,15 @@
     [[], [234, 567, 891], []],
     [[]],
     [[123], [234]],
 ]
 
 
 @pytest.mark.parametrize("args", nested_2d_array_args)
-def test_abi_encode_nested_dynarray(get_contract, abi_encode, args):
+def test_abi_encode_nested_dynarray(get_contract, args):
     code = """
 @external
 def abi_encode(
     d: DynArray[DynArray[uint256, 3], 3], ensure_tuple: bool, include_method_id: bool
 ) -> Bytes[548]:
     if ensure_tuple:
         if not include_method_id:
@@ -189,24 +190,24 @@
     else:
         if not include_method_id:
             return _abi_encode(d, ensure_tuple=False)
         return _abi_encode(d, ensure_tuple=False, method_id=0xdeadbeef)
     """
     c = get_contract(code)
 
-    method_id = 0xDEADBEEF .to_bytes(4, "big")
+    method_id = 0xDEADBEEF.to_bytes(4, "big")
 
-    assert c.abi_encode(args, False, False).hex() == abi_encode("uint256[][]", args).hex()
-    assert c.abi_encode(args, True, False).hex() == abi_encode("(uint256[][])", (args,)).hex()
+    assert c.abi_encode(args, False, False).hex() == abi.encode("uint256[][]", args).hex()
+    assert c.abi_encode(args, True, False).hex() == abi.encode("(uint256[][])", (args,)).hex()
     assert (
-        c.abi_encode(args, False, True).hex() == (method_id + abi_encode("uint256[][]", args)).hex()
+        c.abi_encode(args, False, True).hex() == (method_id + abi.encode("uint256[][]", args)).hex()
     )
     assert (
         c.abi_encode(args, True, True).hex()
-        == (method_id + abi_encode("(uint256[][])", (args,))).hex()
+        == (method_id + abi.encode("(uint256[][])", (args,))).hex()
     )
 
 
 nested_3d_array_args = [
     [
         [[123, 456, 789], [234, 567, 891], [345, 678, 912]],
         [[234, 567, 891], [345, 678, 912], [123, 456, 789]],
@@ -221,15 +222,15 @@
     [[[]], [[123]], [[]]],
     [[[123, 456, 789], [234, 567]], [[234]], [[567], [912], [345]]],
     [[[]]],
 ]
 
 
 @pytest.mark.parametrize("args", nested_3d_array_args)
-def test_abi_encode_nested_dynarray_2(get_contract, abi_encode, args):
+def test_abi_encode_nested_dynarray_2(get_contract, args):
     code = """
 @external
 def abi_encode(
     d: DynArray[DynArray[DynArray[uint256, 3], 3], 3],
     ensure_tuple: bool,
     include_method_id: bool
 ) -> Bytes[1700]:
@@ -240,29 +241,29 @@
     else:
         if not include_method_id:
             return _abi_encode(d, ensure_tuple=False)
         return _abi_encode(d, ensure_tuple=False, method_id=0xdeadbeef)
     """
     c = get_contract(code)
 
-    method_id = 0xDEADBEEF .to_bytes(4, "big")
+    method_id = 0xDEADBEEF.to_bytes(4, "big")
 
-    assert c.abi_encode(args, False, False).hex() == abi_encode("uint256[][][]", args).hex()
-    assert c.abi_encode(args, True, False).hex() == abi_encode("(uint256[][][])", (args,)).hex()
+    assert c.abi_encode(args, False, False).hex() == abi.encode("uint256[][][]", args).hex()
+    assert c.abi_encode(args, True, False).hex() == abi.encode("(uint256[][][])", (args,)).hex()
     assert (
         c.abi_encode(args, False, True).hex()
-        == (method_id + abi_encode("uint256[][][]", args)).hex()
+        == (method_id + abi.encode("uint256[][][]", args)).hex()
     )
     assert (
         c.abi_encode(args, True, True).hex()
-        == (method_id + abi_encode("(uint256[][][])", (args,))).hex()
+        == (method_id + abi.encode("(uint256[][][])", (args,))).hex()
     )
 
 
-def test_side_effects_evaluation(get_contract, abi_encode):
+def test_side_effects_evaluation(get_contract):
     contract_1 = """
 counter: uint256
 
 @external
 def __init__():
     self.counter = 0
 
@@ -281,59 +282,59 @@
 @external
 def foo(addr: address) -> Bytes[164]:
     return _abi_encode(Foo(addr).get_counter(), method_id=0xdeadbeef)
     """
 
     c2 = get_contract(contract_2)
 
-    method_id = 0xDEADBEEF .to_bytes(4, "big")
+    method_id = 0xDEADBEEF.to_bytes(4, "big")
 
     # call to get_counter() should be evaluated only once
-    get_counter_encoded = abi_encode("((uint256,string))", ((1, "hello"),))
+    get_counter_encoded = abi.encode("((uint256,string))", ((1, "hello"),))
 
     assert c2.foo(c.address).hex() == (method_id + get_counter_encoded).hex()
 
 
 # test _abi_encode in private functions to check buffer overruns
-def test_abi_encode_private(get_contract, abi_encode):
+def test_abi_encode_private(get_contract):
     code = """
 bytez: Bytes[96]
 @internal
 def _foo(bs: Bytes[32]):
     self.bytez = _abi_encode(bs)
 
 @external
 def foo(bs: Bytes[32]) -> (uint256, Bytes[96]):
     dont_clobber_me: uint256 = max_value(uint256)
     self._foo(bs)
     return dont_clobber_me, self.bytez
     """
     c = get_contract(code)
-    bs = "0" * 32
-    assert c.foo(bs) == [2 ** 256 - 1, abi_encode("(bytes)", (bs,))]
+    bs = b"\x00" * 32
+    assert c.foo(bs) == [2**256 - 1, abi.encode("(bytes)", (bs,))]
 
 
-def test_abi_encode_private_dynarray(get_contract, abi_encode):
+def test_abi_encode_private_dynarray(get_contract):
     code = """
 bytez: Bytes[160]
 @internal
 def _foo(bs: DynArray[uint256, 3]):
     self.bytez = _abi_encode(bs)
 @external
 def foo(bs: DynArray[uint256, 3]) -> (uint256, Bytes[160]):
     dont_clobber_me: uint256 = max_value(uint256)
     self._foo(bs)
     return dont_clobber_me, self.bytez
     """
     c = get_contract(code)
     bs = [1, 2, 3]
-    assert c.foo(bs) == [2 ** 256 - 1, abi_encode("(uint256[])", (bs,))]
+    assert c.foo(bs) == [2**256 - 1, abi.encode("(uint256[])", (bs,))]
 
 
-def test_abi_encode_private_nested_dynarray(get_contract, abi_encode):
+def test_abi_encode_private_nested_dynarray(get_contract):
     code = """
 bytez: Bytes[1696]
 @internal
 def _foo(bs: DynArray[DynArray[DynArray[uint256, 3], 3], 3]):
     self.bytez = _abi_encode(bs)
 
 @external
@@ -344,19 +345,19 @@
     """
     c = get_contract(code)
     bs = [
         [[1, 2, 3], [4, 5, 6], [7, 8, 9]],
         [[10, 11, 12], [13, 14, 15], [16, 17, 18]],
         [[19, 20, 21], [22, 23, 24], [25, 26, 27]],
     ]
-    assert c.foo(bs) == [2 ** 256 - 1, abi_encode("(uint256[][][])", (bs,))]
+    assert c.foo(bs) == [2**256 - 1, abi.encode("(uint256[][][])", (bs,))]
 
 
 @pytest.mark.parametrize("empty_literal", ('b""', '""', "empty(Bytes[1])", "empty(String[1])"))
-def test_abi_encode_empty_string(get_contract, abi_encode, empty_literal):
+def test_abi_encode_empty_string(get_contract, empty_literal):
     code = f"""
 @external
 def foo(ensure_tuple: bool) -> Bytes[96]:
     if ensure_tuple:
         return _abi_encode({empty_literal}) # default ensure_tuple=True
     else:
         return _abi_encode({empty_literal}, ensure_tuple=False)
```

### Comparing `vyper-0.3.7/tests/parser/functions/test_block.py` & `vyper-0.3.8/tests/parser/functions/test_block.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/parser/functions/test_ceil.py` & `vyper-0.3.8/tests/parser/functions/test_ceil.py`

 * *Files 10% similar despite different names*

```diff
@@ -39,20 +39,20 @@
     """
 
     c = get_contract_with_gas_estimation(code)
 
     assert c.x_ceil() == 505
     assert c.foo() == 1
     assert c.fop() == 1
-    assert c.foq() == math.ceil(Decimal(2 ** 167) / 10 ** 10)
+    assert c.foq() == math.ceil(Decimal(2**167) / 10**10)
     assert c.fos() == 0
     assert c.fou() == 4
 
 
-# ceil(x) should yeild the smallest integer greater than or equal to x
+# ceil(x) should yield the smallest integer greater than or equal to x
 def test_ceil_negative(get_contract_with_gas_estimation):
     code = """
 x: decimal
 
 @external
 def __init__():
     self.x = -504.0000000001
@@ -96,11 +96,45 @@
     c = get_contract_with_gas_estimation(code)
 
     assert c.x_ceil() == -504
     assert c.foo() == -11
     assert c.fop() == -5
     assert c.foq() == 0
     assert c.fos() == -5472
-    assert c.fot() == math.ceil(-(Decimal(2 ** 167 - 1)) / 10 ** 10)
+    assert c.fot() == math.ceil(-(Decimal(2**167 - 1)) / 10**10)
     assert c.fou() == -3
     assert c.ceil_param(Decimal("-0.5")) == 0
     assert c.ceil_param(Decimal("-7777777.7777777")) == -7777777
+
+
+def test_ceil_ext_call(w3, side_effects_contract, assert_side_effects_invoked, get_contract):
+    code = """
+@external
+def foo(a: Foo) -> int256:
+    return ceil(a.foo(2.5))
+
+interface Foo:
+    def foo(x: decimal) -> decimal: payable
+    """
+
+    c1 = side_effects_contract("decimal")
+    c2 = get_contract(code)
+
+    assert c2.foo(c1.address) == 3
+
+    assert_side_effects_invoked(c1, lambda: c2.foo(c1.address, transact={}))
+
+
+def test_ceil_internal_call(get_contract_with_gas_estimation):
+    code = """
+@external
+def foo() -> int256:
+    return ceil(self.bar())
+
+@internal
+def bar() -> decimal:
+    return 2.5
+    """
+
+    c = get_contract_with_gas_estimation(code)
+
+    assert c.foo() == 3
```

### Comparing `vyper-0.3.7/tests/parser/functions/test_concat.py` & `vyper-0.3.8/tests/parser/functions/test_concat.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/parser/functions/test_convert.py` & `vyper-0.3.8/tests/parser/functions/test_convert.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,171 +1,133 @@
 import enum
 import itertools
 
 # import random
-from dataclasses import dataclass
 from decimal import Decimal
-from typing import Any
 
-import eth_abi.exceptions
+import eth.codecs.abi as abi
+import eth.codecs.abi.exceptions
 import pytest
-from eth_abi import decode_single, encode_single
 
-from vyper.codegen.types import (
-    BASE_TYPES,
-    INTEGER_TYPES,
-    parse_bytes_m_info,
-    parse_decimal_info,
-    parse_integer_typeinfo,
-)
 from vyper.exceptions import InvalidLiteral, InvalidType, TypeMismatch
+from vyper.semantics.types import AddressT, BoolT, BytesM_T, BytesT, DecimalT, IntegerT, StringT
+from vyper.semantics.types.shortcuts import BYTES20_T, BYTES32_T, UINT, UINT160_T, UINT256_T
 from vyper.utils import (
     DECIMAL_DIVISOR,
-    SizeLimits,
     checksum_encode,
     int_bounds,
     is_checksum_encoded,
     round_towards_zero,
     unsigned_to_signed,
 )
 
-TEST_TYPES = BASE_TYPES | {"Bytes[32]"}
+BASE_TYPES = set(IntegerT.all()) | set(BytesM_T.all()) | {DecimalT(), AddressT(), BoolT()}
+
+TEST_TYPES = BASE_TYPES | {BytesT(32)} | {StringT(32)}
 
 ZERO_ADDRESS = "0x0000000000000000000000000000000000000000"
 
 # decimal increment, aka smallest decimal > 0
 DECIMAL_EPSILON = Decimal(1) / DECIMAL_DIVISOR
 
 
-@dataclass
-class TestType:
-    """
-    Simple class to model Vyper types.
-    """
-
-    type_name: str
-    type_bytes: int  # number of nonzero bytes this type can take
-    type_class: str  # e.g. int, bytes, String, decimal
-    info: Any  # e.g. DecimalInfo
-
-    @property
-    def abi_type(self):
-        if self.type_name == "decimal":
-            return "fixed168x10"
-        if self.type_class in ("Bytes", "String"):
-            return self.type_class.lower()
-        return self.type_name
+def _bits_of_type(typ):
+    if isinstance(typ, (IntegerT, DecimalT)):
+        return typ.bits
+    if isinstance(typ, BoolT):
+        return 8
+    if isinstance(typ, AddressT):
+        return 160
+    if isinstance(typ, BytesM_T):
+        return typ.m_bits
+    if isinstance(typ, BytesT):
+        return typ.length * 8
+
+    raise Exception(f"Unknown type {typ}")
+
+
+def bytes_of_type(typ):
+    ret = _bits_of_type(typ)
+    assert ret % 8 == 0
+    return ret // 8
 
 
 class _OutOfBounds(Exception):
     """
     A Python-level conversion is out of bounds
     """
 
     pass
 
 
-def _parse_type(typename):
-    if typename.startswith(("uint", "int")):
-        info = parse_integer_typeinfo(typename)
-        assert info.bits % 8 == 0
-        return TestType(typename, info.bits // 8, "int", info)
-    elif typename == "decimal":
-        info = parse_decimal_info(typename)
-        assert info.bits % 8 == 0
-        return TestType(typename, info.bits // 8, "decimal", info)
-    elif typename.startswith("bytes"):
-        info = parse_bytes_m_info(typename)
-        return TestType(typename, info.m, "bytes", info)
-    elif typename.startswith("Bytes"):
-        assert typename == "Bytes[32]"  # TODO test others
-        return TestType(typename, 32, "Bytes", None)
-    elif typename.startswith("String"):
-        assert typename == "String[32]"  # TODO test others
-        return TestType(typename, 32, "String", None)
-    elif typename == "address":
-        return TestType(typename, 20, "address", None)
-    elif typename == "bool":
-        return TestType(typename, 1, "bool", None)
-
-    raise AssertionError(f"no info {typename}")
-
-
 def can_convert(i_typ, o_typ):
     """
     Checks whether conversion from one type to another is valid.
     """
     if i_typ == o_typ:
         return False
 
-    i_detail = _parse_type(i_typ)
-    o_detail = _parse_type(o_typ)
-
-    if o_typ == "bool":
+    if isinstance(o_typ, BoolT):
         return True
-    if i_typ == "bool":
-        return o_typ not in {"address"}
+    if isinstance(i_typ, BoolT):
+        return not isinstance(o_typ, AddressT)
 
-    if i_detail.type_class == "int":
-        if o_detail.type_class == "bytes":
-            return i_detail.type_bytes <= o_detail.type_bytes
-
-        ret = o_detail.type_class in ("int", "decimal", "bytes", "Bytes")
-        if not i_detail.info.is_signed:
-            ret |= o_typ == "address"
+    if isinstance(i_typ, IntegerT):
+        if isinstance(o_typ, BytesM_T):
+            return bytes_of_type(i_typ) <= bytes_of_type(o_typ)
+
+        ret = isinstance(o_typ, (IntegerT, DecimalT, BytesM_T, BytesT))
+        if not i_typ.is_signed:
+            ret |= isinstance(o_typ, AddressT)
         return ret
 
-    elif i_detail.type_class == "bytes":
-        if o_detail.type_class == "Bytes":
+    if isinstance(i_typ, BytesM_T):
+        if isinstance(o_typ, BytesT):
             # bytesN must be of equal or smaller size to the input
-            return i_detail.type_bytes <= o_detail.type_bytes
+            return bytes_of_type(i_typ) <= bytes_of_type(o_typ)
 
-        return o_detail.type_class in ("decimal", "bytes", "int", "address")
+        return isinstance(o_typ, (DecimalT, BytesM_T, IntegerT, AddressT))
 
-    elif i_detail.type_class == "Bytes":
-        return o_detail.type_class in ("int", "decimal", "address")
+    if isinstance(i_typ, BytesT):
+        return isinstance(o_typ, (IntegerT, DecimalT, AddressT))
 
-    elif i_typ == "decimal":
-        if o_detail.type_class == "bytes":
-            return i_detail.type_bytes <= o_detail.type_bytes
+    if isinstance(i_typ, DecimalT):
+        if isinstance(o_typ, BytesM_T):
+            return bytes_of_type(i_typ) <= bytes_of_type(o_typ)
 
-        return o_detail.type_class in ("int", "bool")
+        return isinstance(o_typ, (IntegerT, BoolT))
 
-    elif i_typ == "address":
-        if o_detail.type_class == "bytes":
-            return i_detail.type_bytes <= o_detail.type_bytes
-        elif o_detail.type_class == "int":
-            return not o_detail.info.is_signed
+    if isinstance(i_typ, AddressT):
+        if isinstance(o_typ, BytesM_T):
+            return bytes_of_type(i_typ) <= bytes_of_type(o_typ)
+        if isinstance(o_typ, IntegerT):
+            return not o_typ.is_signed
         return False
 
     raise AssertionError(f"unreachable {i_typ} {o_typ}")
 
 
 def uniq(xs):
     return list(set(xs))
 
 
 def _cases_for_int(typ):
-    info = parse_integer_typeinfo(typ)
-
-    lo, hi = info.bounds
+    lo, hi = typ.ast_bounds
 
     ret = [lo - 1, lo, lo + 1, -1, 0, 1, hi - 1, hi, hi + 1]
 
     # random cases cause reproducibility issues. TODO fixme
     # NUM_RANDOM_CASES = 6
     # ret.extend(random.randrange(lo, hi) for _ in range(NUM_RANDOM_CASES))
 
     return ret
 
 
 def _cases_for_decimal(typ):
-    info = parse_decimal_info(typ)
-
-    lo, hi = info.decimal_bounds
+    lo, hi = typ.ast_bounds
 
     ret = [Decimal(i) for i in [-1, 0, 1]]
     ret.extend([lo - 1, lo, lo + 1, hi - 1, hi, hi + 1])
 
     ret.extend(
         [lo - DECIMAL_EPSILON, lo + DECIMAL_EPSILON, hi - DECIMAL_EPSILON, hi + DECIMAL_EPSILON]
     )
@@ -177,81 +139,90 @@
     # DIVISOR = info.divisor
     # ret.extend(random.randrange(int_lo, int_hi) / DIVISOR for _ in range(NUM_RANDOM_CASES))
 
     return ret
 
 
 def _cases_for_address(_typ):
-    cases = _filter_cases(_cases_for_int("uint160"), "uint160")
-    return [_py_convert(c, "uint160", "address") for c in cases]
+    cases = _filter_cases(_cases_for_int(UINT160_T), UINT160_T)
+    return [_py_convert(c, UINT160_T, AddressT()) for c in cases]
 
 
 def _cases_for_bool(_typ):
     return [True, False]
 
 
 def _cases_for_bytes(typ):
-    detail = _parse_type(typ)
-    m_bits = detail.info.m_bits
     # reuse the cases for the equivalent int type
-    equiv_int_type = f"uint{m_bits}"
+    equiv_int_type = UINT(typ.m_bits)
     cases = _filter_cases(_cases_for_int(equiv_int_type), equiv_int_type)
     return [_py_convert(c, equiv_int_type, typ) for c in cases]
 
 
 def _cases_for_Bytes(typ):
     ret = []
     # would not need this if we tested all Bytes[1]...Bytes[32] types.
     for i in range(32):
-        ret.extend(_cases_for_bytes(f"bytes{i+1}"))
+        ret.extend(_cases_for_bytes(BytesM_T(i + 1)))
+
+    ret.append(b"")
+    return uniq(ret)
+
+
+def _cases_for_String(typ):
+    ret = []
+    # would not need this if we tested all Bytes[1]...Bytes[32] types.
+    for i in range(32):
+        ret.extend([str(c, "utf-8") for c in _cases_for_bytes(BytesM_T(i + 1))])
+    ret.append("")
     return uniq(ret)
 
 
 # generate all cases of interest for a type, potentially including invalid cases
 def interesting_cases_for_type(typ):
-    detail = _parse_type(typ)
-    if detail.type_class == "int":
+    if isinstance(typ, IntegerT):
         return _cases_for_int(typ)
-    if detail.type_class == "decimal":
+    if isinstance(typ, DecimalT):
         return _cases_for_decimal(typ)
-    if detail.type_class == "bytes":
+    if isinstance(typ, BytesM_T):
         return _cases_for_bytes(typ)
-    if detail.type_class == "Bytes":
+    if isinstance(typ, BytesT):
         return _cases_for_Bytes(typ)
-    if detail.type_class == "bool":
+    if isinstance(typ, StringT):
+        return _cases_for_String(typ)
+    if isinstance(typ, BoolT):
         return _cases_for_bool(typ)
-    if detail.type_class == "address":
+    if isinstance(typ, AddressT):
         return _cases_for_address(typ)
 
 
 def _filter_cases(cases, i_typ):
     cases = uniq(cases)
 
     def _in_bounds(c):
         try:
             return _py_convert(c, i_typ, i_typ) is not None
-        except eth_abi.exceptions.ValueOutOfBounds:
+        except eth.codecs.abi.exceptions.EncodeError:
             return False
 
     return [c for c in cases if _in_bounds(c)]
 
 
 class _PadDirection(enum.Enum):
     Left = enum.auto()
     Right = enum.auto()
 
 
 def _padding_direction(typ):
-    detail = _parse_type(typ)
-    if detail.type_class in ("bytes", "String", "Bytes"):
+    if isinstance(typ, (BytesM_T, StringT, BytesT)):
         return _PadDirection.Right
     return _PadDirection.Left
 
 
-# TODO this could be a function in vyper.builtin_functions.convert
+# TODO this could be a function in vyper.builtins._convert
 # which implements literal folding and also serves as a reference/spec
 def _padconvert(val_bits, direction, n, padding_byte=None):
     """
     Takes the ABI representation of a value, and convert the padding if needed.
     If fill_zeroes is false, the two halves of the bytestring are just swapped
     and the dirty bytes remain dirty. If fill_zeroes is true, the the padding
     bytes get set to 0
@@ -271,102 +242,103 @@
         if padding_byte is not None:
             head = padding_byte * len(head)
         return head + val_bits[:n]
 
 
 def _from_bits(val_bits, o_typ):
     # o_typ: the type to convert to
-    detail = _parse_type(o_typ)
     try:
-        return decode_single(detail.abi_type, val_bits)
-    except eth_abi.exceptions.NonEmptyPaddingBytes:
+        return abi.decode(o_typ.abi_type.selector_name(), val_bits)
+    except eth.codecs.abi.exceptions.DecodeError:
         raise _OutOfBounds() from None
 
 
 def _to_bits(val, i_typ):
     # i_typ: the type to convert from
-    detail = _parse_type(i_typ)
-    return encode_single(detail.abi_type, val)
+    return abi.encode(i_typ.abi_type.selector_name(), val)
 
 
 def _signextend(val_bytes, bits):
     as_uint = int.from_bytes(val_bytes, byteorder="big")
 
     as_sint = unsigned_to_signed(as_uint, bits)
 
-    return (as_sint % 2 ** 256).to_bytes(32, byteorder="big")
+    return (as_sint % 2**256).to_bytes(32, byteorder="big")
+
+
+def _convert_int_to_int(val, o_typ):
+    lo, hi = o_typ.int_bounds
+    if not lo <= val <= hi:
+        return None
+    return val
 
 
 def _convert_decimal_to_int(val, o_typ):
     # note special behavior for decimal: catch OOB before truncation.
-    if not SizeLimits.in_bounds(o_typ, val):
+    lo, hi = o_typ.int_bounds
+    if not lo <= val <= hi:
         return None
 
     return round_towards_zero(val)
 
 
 def _convert_int_to_decimal(val, o_typ):
-    detail = _parse_type(o_typ)
     ret = Decimal(val)
-    # note: SizeLimits.in_bounds is for the EVM int value, not the python value
-    lo, hi = detail.info.decimal_bounds
+    lo, hi = o_typ.ast_bounds
+
     if not lo <= ret <= hi:
         return None
 
     return ret
 
 
 def _py_convert(val, i_typ, o_typ):
     """
     Perform conversion on the Python representation of a Vyper value.
     Returns None if the conversion is invalid (i.e., would revert in Vyper)
     """
-    i_detail = _parse_type(i_typ)
-    o_detail = _parse_type(o_typ)
 
-    if i_detail.type_class == "int" and o_detail.type_class == "int":
-        if not SizeLimits.in_bounds(o_typ, val):
-            return None
-        return val
+    if isinstance(i_typ, IntegerT) and isinstance(o_typ, IntegerT):
+        return _convert_int_to_int(val, o_typ)
 
-    if i_typ == "decimal" and o_typ in INTEGER_TYPES:
+    if isinstance(i_typ, DecimalT) and isinstance(o_typ, IntegerT):
         return _convert_decimal_to_int(val, o_typ)
 
-    if i_detail.type_class in ("bool", "int") and o_typ == "decimal":
+    if isinstance(i_typ, (BoolT, IntegerT)) and isinstance(o_typ, DecimalT):
         # Note: Decimal(True) == Decimal("1")
         return _convert_int_to_decimal(val, o_typ)
 
     val_bits = _to_bits(val, i_typ)
 
-    if i_detail.type_class in ("Bytes", "String"):
+    if isinstance(i_typ, (BytesT, StringT)):
         val_bits = val_bits[32:]
 
     if _padding_direction(i_typ) != _padding_direction(o_typ):
         # subtle! the padding conversion follows the bytes argument
-        if i_detail.type_class in ("bytes", "Bytes"):
-            n = i_detail.type_bytes
+        if isinstance(i_typ, (BytesM_T, BytesT)):
+            n = bytes_of_type(i_typ)
             padding_byte = None
         else:
             # output type is bytes
-            n = o_detail.type_bytes
+            n = bytes_of_type(o_typ)
             padding_byte = b"\x00"
 
         val_bits = _padconvert(val_bits, _padding_direction(o_typ), n, padding_byte)
 
-    if getattr(o_detail.info, "is_signed", False) and i_detail.type_class == "bytes":
-        n_bits = i_detail.type_bytes * 8
+    if getattr(o_typ, "is_signed", False) and isinstance(i_typ, BytesM_T):
+        n_bits = _bits_of_type(i_typ)
         val_bits = _signextend(val_bits, n_bits)
 
     try:
-        if o_typ == "bool":
-            return _from_bits(val_bits, "uint256") != 0
+        if isinstance(o_typ, BoolT):
+            return _from_bits(val_bits, UINT256_T) != 0
 
         ret = _from_bits(val_bits, o_typ)
 
-        if o_typ == "address":
+        if isinstance(o_typ, AddressT):
             return checksum_encode(ret)
         return ret
 
     except _OutOfBounds:
         return None
 
 
@@ -403,15 +375,15 @@
 
     for c in interesting_cases_for_type(o_typ):
         # convert back into i_typ
         try:
             c = _py_convert(c, o_typ, i_typ)
             if c is not None:
                 cases.append(c)
-        except eth_abi.exceptions.ValueOutOfBounds:
+        except eth.codecs.abi.exceptions.EncodeError:
             pass
 
     # _CASES_CACHE[(i_typ, o_typ)] = cases
 
     return cases
 
 
@@ -433,51 +405,49 @@
         for c in cases:
             if _py_convert(c, i_typ, o_typ) is None:
                 ret.append((i_typ, o_typ, c))
     return sorted(ret)
 
 
 def _vyper_literal(val, typ):
-    detail = _parse_type(typ)
-    if detail.type_class == "bytes":
+    if isinstance(typ, BytesM_T):
         return "0x" + val.hex()
-    if detail.type_class == "decimal":
+    if isinstance(typ, DecimalT):
         tmp = val
         val = val.quantize(DECIMAL_EPSILON)
         assert tmp == val
     return str(val)
 
 
 @pytest.mark.parametrize("i_typ,o_typ,val", generate_passing_cases())
 @pytest.mark.fuzzing
 def test_convert_passing(
     get_contract_with_gas_estimation, assert_compile_failed, i_typ, o_typ, val
 ):
-
     expected_val = _py_convert(val, i_typ, o_typ)
-    if o_typ == "address" and expected_val == "0x" + "00" * 20:
+    if isinstance(o_typ, AddressT) and expected_val == "0x" + "00" * 20:
         # web3 has special formatter for zero address
         expected_val = None
 
     contract_1 = f"""
 @external
 def test_convert() -> {o_typ}:
     return convert({_vyper_literal(val, i_typ)}, {o_typ})
     """
 
     c1_exception = None
     skip_c1 = False
 
     # Skip bytes20 literals when there is ambiguity with `address` since address takes precedence.
     # generally happens when there are only digits in the literal.
-    if i_typ == "bytes20" and is_checksum_encoded(_vyper_literal(val, "bytes20")):
+    if i_typ == BYTES20_T and is_checksum_encoded(_vyper_literal(val, BYTES20_T)):
         skip_c1 = True
 
     # typechecker inference borked, ambiguity with bytes20
-    if i_typ == "address" and o_typ == "bytes20" and val == val.lower():
+    if isinstance(i_typ, AddressT) and o_typ == BYTES20_T and val == val.lower():
         skip_c1 = True
 
     if c1_exception is not None:
         assert_compile_failed(lambda: get_contract_with_gas_estimation(contract_1), c1_exception)
     elif not skip_c1:
         c1 = get_contract_with_gas_estimation(contract_1)
         assert c1.test_convert() == expected_val
@@ -511,15 +481,15 @@
     """
 
     c4 = get_contract_with_gas_estimation(contract_4)
     assert c4.test_memory_variable_convert(val) == expected_val
 
 
 @pytest.mark.parametrize("typ", ["uint8", "int128", "int256", "uint256"])
-@pytest.mark.parametrize("val", [1, 2, 2 ** 128, 2 ** 256 - 1, 2 ** 256 - 2])
+@pytest.mark.parametrize("val", [1, 2, 2**128, 2**256 - 1, 2**256 - 2])
 def test_enum_conversion(get_contract_with_gas_estimation, assert_compile_failed, val, typ):
     roles = "\n    ".join([f"ROLE_{i}" for i in range(256)])
     contract = f"""
 enum Roles:
     {roles}
 
 @external
@@ -535,15 +505,15 @@
         assert c.foo(val) == val
         assert c.bar(val) == val
     else:
         assert_compile_failed(lambda: get_contract_with_gas_estimation(contract), TypeMismatch)
 
 
 @pytest.mark.parametrize("typ", ["uint8", "int128", "int256", "uint256"])
-@pytest.mark.parametrize("val", [1, 2, 3, 4, 2 ** 128, 2 ** 256 - 1, 2 ** 256 - 2])
+@pytest.mark.parametrize("val", [1, 2, 3, 4, 2**128, 2**256 - 1, 2**256 - 2])
 def test_enum_conversion_2(
     get_contract_with_gas_estimation, assert_compile_failed, assert_tx_failed, val, typ
 ):
     contract = f"""
 enum Status:
     STARTED
     PAUSED
@@ -568,28 +538,27 @@
 @pytest.mark.parametrize(
     "builtin_constant,out_type,out_value",
     [("ZERO_ADDRESS", "bool", False), ("msg.sender", "bool", True)],
 )
 def test_convert_builtin_constant(
     get_contract_with_gas_estimation, builtin_constant, out_type, out_value
 ):
-
     contract = f"""
 @external
 def convert_builtin_constant() -> {out_type}:
     return convert({builtin_constant}, {out_type})
     """
 
     c = get_contract_with_gas_estimation(contract)
     assert c.convert_builtin_constant() == out_value
 
 
 # uint256 conversion is currently valid due to type inference on literals
 # not quite working yet
-same_type_conversion_blocked = sorted(TEST_TYPES - {"uint256"})
+same_type_conversion_blocked = sorted(TEST_TYPES - {UINT256_T})
 
 
 @pytest.mark.parametrize("typ", same_type_conversion_blocked)
 def test_same_type_conversion_blocked(get_contract, assert_compile_failed, typ):
     code = f"""
 @external
 def foo(x: {typ}) -> {typ}:
@@ -667,29 +636,29 @@
 @external
 def foo() -> {o_typ}:
     return convert({_vyper_literal(val, i_typ)}, {o_typ})
     """
 
     c1_exception = InvalidLiteral
 
-    if i_typ.startswith(("int", "uint")) and o_typ.startswith("bytes"):
+    if isinstance(i_typ, IntegerT) and isinstance(o_typ, BytesM_T):
         # integer literals get upcasted to uint256 / int256 types, so the convert
         # will not compile unless it is bytes32
-        if o_typ != "bytes32":
+        if o_typ != BYTES32_T:
             c1_exception = TypeMismatch
 
     # compile-time folding not implemented for these:
     skip_c1 = False
-    # if o_typ.startswith("int") and i_typ == "address":
+    # if isinstance(o_typ, IntegerT.signeds()) and isinstance(i_typ, Address()):
     #    skip_c1 = True
 
-    if o_typ.startswith("bytes"):
+    if isinstance(o_typ, BytesM_T):
         skip_c1 = True
 
-    # if o_typ in ("address", "bytes20"):
+    # if o_typ in (AddressT(), BYTES20_T):
     #    skip_c1 = True
 
     if not skip_c1:
         assert_compile_failed(lambda: get_contract_with_gas_estimation(contract_1), c1_exception)
 
     contract_2 = f"""
 @external
```

### Comparing `vyper-0.3.7/tests/parser/functions/test_create_functions.py` & `vyper-0.3.8/tests/parser/functions/test_create_functions.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 import pytest
 import rlp
-from eth_abi import encode_single
+from eth.codecs import abi
 from hexbytes import HexBytes
 
 from vyper.utils import EIP_170_LIMIT, checksum_encode, keccak256
 
 
 # initcode used by create_minimal_proxy_to
 def eip1167_initcode(_addr):
@@ -326,15 +326,15 @@
     d.test2(f.address, FOO, BAR, salt, transact={})
 
     test = FooContract(d.created_address())
     assert w3.eth.get_code(test.address) == expected_runtime_code
     assert test.foo() == FOO
     assert test.bar() == BAR
 
-    encoded_args = encode_single("(string,(string))", (FOO, BAR))
+    encoded_args = abi.encode("(string,(string))", (FOO, BAR))
     assert HexBytes(test.address) == create2_address_of(d.address, salt, initcode + encoded_args)
 
     d.test3(f.address, encoded_args, transact={})
     test = FooContract(d.created_address())
     assert w3.eth.get_code(test.address) == expected_runtime_code
     assert test.foo() == FOO
     assert test.bar() == BAR
@@ -354,17 +354,19 @@
     FOO = "bar"
     d.test2(f.address, FOO, BAR, salt, transact={})
     # just for kicks
     assert FooContract(d.created_address()).foo() == FOO
     assert FooContract(d.created_address()).bar() == BAR
 
     # Foo constructor should fail
-    FOO = b"\x01" * 129
+    FOO = "01" * 129
     BAR = ("",)
-    assert_tx_failed(lambda: d.should_fail(f.address, FOO, BAR))
+    sig = keccak("should_fail(address,string,(string))".encode()).hex()[:10]
+    encoded = abi.encode("(address,string,(string))", (f.address, FOO, BAR)).hex()
+    assert_tx_failed(lambda: w3.eth.send_transaction({"to": d.address, "data": f"{sig}{encoded}"}))
 
 
 def test_create_copy_of(get_contract, w3, keccak, create2_address_of, assert_tx_failed):
     code = """
 created_address: public(address)
 @internal
 def _create_copy_of(target: address):
```

### Comparing `vyper-0.3.7/tests/parser/functions/test_default_parameters.py` & `vyper-0.3.8/tests/parser/functions/test_default_parameters.py`

 * *Files 1% similar despite different names*

```diff
@@ -163,16 +163,16 @@
     assert c.bar(100, 100) == [100, 100]
 
     def validate_value(cls, value):
         pass
 
     monkeypatch.setattr("eth_abi.encoding.NumberEncoder.validate_value", validate_value)
 
-    assert c.bar(200, 2 ** 127 - 1) == [200, 2 ** 127 - 1]
-    assert_tx_failed(lambda: c.bar(200, 2 ** 127))
+    assert c.bar(200, 2**127 - 1) == [200, 2**127 - 1]
+    assert_tx_failed(lambda: c.bar(200, 2**127))
 
 
 def test_default_param_private(get_contract):
     code = """
 @internal
 def fooBar(a: Bytes[100], b: uint256, c: Bytes[20] = b"crazy") -> (Bytes[100], uint256, Bytes[20]):
     return a, b, c
```

### Comparing `vyper-0.3.7/tests/parser/functions/test_ecrecover.py` & `vyper-0.3.8/tests/parser/functions/test_ecrecover.py`

 * *Files 8% similar despite different names*

```diff
@@ -27,15 +27,15 @@
                      6577251522710269046055727877571505144084475024240851440410274049870970796685)
 
     """
 
     c = get_contract_with_gas_estimation(ecrecover_test)
 
     h = b"\x35" * 32
-    local_account = Account.privateKeyToAccount(b"\x46" * 32)
+    local_account = Account.from_key(b"\x46" * 32)
     sig = local_account.signHash(h)
 
     assert c.test_ecrecover(h, sig.v, to_bytes32(sig.r), to_bytes32(sig.s)) == local_account.address
     assert c.test_ecrecover_uints(h, sig.v, sig.r, sig.s) == local_account.address
     assert c.test_ecrecover2() == local_account.address
     assert c.test_ecrecover_uints2() == local_account.address
```

### Comparing `vyper-0.3.7/tests/parser/functions/test_empty.py` & `vyper-0.3.8/tests/parser/functions/test_empty.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 import pytest
 
-from vyper.exceptions import TypeMismatch
+from vyper.exceptions import InstantiationException, TypeMismatch
 
 
 @pytest.mark.parametrize(
     "contract",
     [
         """
 foobar: int128
@@ -521,19 +521,22 @@
 @external
 def delete(key: bytes32):
     self.big_storage[key] = empty(bytes32)
     """
 
     c = get_contract_with_gas_estimation(code)
 
-    assert c.get(b"test") == b"\x00" * 32
-    c.set(b"test", b"value", transact={})
-    assert c.get(b"test")[:5] == b"value"
-    c.delete(b"test", transact={})
-    assert c.get(b"test") == b"\x00" * 32
+    key = b"test".ljust(32)
+    val = b"value".ljust(32)
+
+    assert c.get(key) == b"\x00" * 32
+    c.set(key, val, transact={})
+    assert c.get(key)[:5] == b"value"
+    c.delete(key, transact={})
+    assert c.get(key) == b"\x00" * 32
 
 
 def test_map_clear_nested(get_contract_with_gas_estimation):
     code = """
 big_storage: HashMap[bytes32, HashMap[bytes32, bytes32]]
 
 @external
@@ -547,19 +550,23 @@
 @external
 def delete(key1: bytes32, key2: bytes32):
     self.big_storage[key1][key2] = empty(bytes32)
     """
 
     c = get_contract_with_gas_estimation(code)
 
-    assert c.get(b"test1", b"test2") == b"\x00" * 32
-    c.set(b"test1", b"test2", b"value", transact={})
-    assert c.get(b"test1", b"test2")[:5] == b"value"
-    c.delete(b"test1", b"test2", transact={})
-    assert c.get(b"test1", b"test2") == b"\x00" * 32
+    key1 = b"test1".ljust(32)
+    key2 = b"test2".ljust(32)
+    val = b"value".ljust(32)
+
+    assert c.get(key1, key2) == b"\x00" * 32
+    c.set(key1, key2, val, transact={})
+    assert c.get(key1, key2)[:5] == b"value"
+    c.delete(key1, key2, transact={})
+    assert c.get(key1, key2) == b"\x00" * 32
 
 
 def test_map_clear_struct(get_contract_with_gas_estimation):
     code = """
 struct X:
     a: int128
     b: int128
@@ -687,7 +694,21 @@
     log = get_logs(c.foo(transact={}), c, "MyLog")[0]
 
     assert log.args.arg1 == b"hello" * 9
     assert log.args.arg2 == [[0, 0], [0, 0], [0, 0]]
     assert log.args.arg3 == 314159
     assert log.args.arg4 == b"help" * 11
     assert log.args.arg5 == [0, 0, 0]
+
+
+@pytest.mark.parametrize(
+    "contract",
+    [
+        """
+@external
+def test():
+    a: uint256 = empty(HashMap[uint256, uint256])[0]
+    """
+    ],
+)
+def test_invalid_types(contract, get_contract, assert_compile_failed):
+    assert_compile_failed(lambda: get_contract(contract), InstantiationException)
```

### Comparing `vyper-0.3.7/tests/parser/functions/test_extract32.py` & `vyper-0.3.8/tests/parser/functions/test_extract32.py`

 * *Files 0% similar despite different names*

```diff
@@ -70,15 +70,15 @@
 
     c = get_contract_with_gas_estimation(extract32_code)
     assert c.foo(b"\x00" * 30 + b"\x01\x01") == 257
     assert c.bar(b"\x00" * 30 + b"\x01\x01") == 257
 
     assert_tx_failed(lambda: c.foo(b"\x80" + b"\x00" * 30))
 
-    assert c.bar(b"\x80" + b"\x00" * 31) == 2 ** 255
+    assert c.bar(b"\x80" + b"\x00" * 31) == 2**255
 
     assert c.baz(b"crow" * 8) == b"crow" * 8
     assert c.fop(b"crow" * 8) == b"crow" * 8
     assert c.foq(b"\x00" * 12 + b"3" * 20) == "0x" + "3" * 40
 
     assert_tx_failed(lambda: c.foq(b"crow" * 8))
```

### Comparing `vyper-0.3.7/tests/parser/functions/test_floor.py` & `vyper-0.3.8/tests/parser/functions/test_floor.py`

 * *Files 26% similar despite different names*

```diff
@@ -41,15 +41,15 @@
     c: decimal = a / b
     return floor(c)
 """
     c = get_contract_with_gas_estimation(code)
     assert c.x_floor() == 504
     assert c.foo() == 1
     assert c.fop() == 1
-    assert c.foq() == math.floor(Decimal(2 ** 167 - 1) / 10 ** 10)
+    assert c.foq() == math.floor(Decimal(2**167 - 1) / 10**10)
     assert c.fos() == 0
     assert c.fot() == 0
     assert c.fou() == 3
 
 
 def test_floor_negative(get_contract_with_gas_estimation):
     code = """
@@ -100,11 +100,45 @@
     c = get_contract_with_gas_estimation(code)
 
     assert c.x_floor() == -505
     assert c.foo() == -7
     assert c.fop() == -27
     assert c.foq() == -9001
     assert c.fos() == -1
-    assert c.fot() == math.floor(-Decimal(2 ** 167) / 10 ** 10)
+    assert c.fot() == math.floor(-Decimal(2**167) / 10**10)
     assert c.fou() == -4
     assert c.floor_param(Decimal("-5.6")) == -6
     assert c.floor_param(Decimal("-0.0000000001")) == -1
+
+
+def test_floor_ext_call(w3, side_effects_contract, assert_side_effects_invoked, get_contract):
+    code = """
+@external
+def foo(a: Foo) -> int256:
+    return floor(a.foo(2.5))
+
+interface Foo:
+    def foo(x: decimal) -> decimal: nonpayable
+    """
+
+    c1 = side_effects_contract("decimal")
+    c2 = get_contract(code)
+
+    assert c2.foo(c1.address) == 2
+
+    assert_side_effects_invoked(c1, lambda: c2.foo(c1.address, transact={}))
+
+
+def test_floor_internal_call(get_contract_with_gas_estimation):
+    code = """
+@external
+def foo() -> int256:
+    return floor(self.bar())
+
+@internal
+def bar() -> decimal:
+    return 2.5
+    """
+
+    c = get_contract_with_gas_estimation(code)
+
+    assert c.foo() == 2
```

### Comparing `vyper-0.3.7/tests/parser/functions/test_interfaces.py` & `vyper-0.3.8/tests/parser/functions/test_interfaces.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,13 +1,11 @@
 from decimal import Decimal
 
 import pytest
 
-from vyper.ast.signatures.interface import extract_sigs
-from vyper.builtin_interfaces import ERC20, ERC721
 from vyper.cli.utils import extract_file_interface_imports
 from vyper.compiler import compile_code, compile_codes
 from vyper.exceptions import ArgumentException, InterfaceViolation, StructureException
 
 
 def test_basic_extract_interface():
     code = """
@@ -74,35 +72,14 @@
 def test() -> bool:
     return True
     """
 
     assert_compile_failed(lambda: compile_code(code), InterfaceViolation)
 
 
-def test_builtin_interfaces_parse():
-    assert len(extract_sigs({"type": "vyper", "code": ERC20.interface_code})) == 6
-    assert len(extract_sigs({"type": "vyper", "code": ERC721.interface_code})) == 9
-
-
-def test_extract_sigs_ignores_imports():
-    interface_code = """
-{}
-
-@external
-def foo() -> uint256:
-    pass
-    """
-
-    base = extract_sigs({"type": "vyper", "code": interface_code.format("")})
-
-    for stmt in ("import x as x", "from x import y"):
-        sigs = extract_sigs({"type": "vyper", "code": interface_code.format(stmt)})
-        assert [type(i) for i in base] == [type(i) for i in sigs]
-
-
 def test_external_interface_parsing(assert_compile_failed):
     interface_code = """
 @external
 def foo() -> uint256:
     pass
 
 @external
@@ -206,15 +183,14 @@
     ("from .a import Foo", "./a/Foo"),
     ("from ..a import Foo", "../a/Foo"),
 ]
 
 
 @pytest.mark.parametrize("code", VALID_IMPORT_CODE)
 def test_extract_file_interface_imports(code):
-
     assert extract_file_interface_imports(code[0]) == {"Foo": code[1]}
 
 
 BAD_IMPORT_CODE = [
     "import a",  # must alias absolute imports
     "import a as A\nimport a as A",  # namespace collisions
     "from b import a\nfrom a import a",
@@ -268,16 +244,16 @@
     test_c.test(transact={})
     assert erc20.balanceOf(sender) == 1000
 
 
 @pytest.mark.parametrize(
     "kwarg,typ,expected",
     [
-        ("max_value(uint256)", "uint256", 2 ** 256 - 1),
-        ("min_value(int128)", "int128", -(2 ** 127)),
+        ("max_value(uint256)", "uint256", 2**256 - 1),
+        ("min_value(int128)", "int128", -(2**127)),
         ("empty(uint8[2])", "uint8[2]", [0, 0]),
         ('method_id("vyper()", output_type=bytes4)', "bytes4", b"\x82\xcbE\xfb"),
         ("epsilon(decimal)", "decimal", Decimal("1E-10")),
     ],
 )
 def test_external_call_to_interface_kwarg(get_contract, kwarg, typ, expected):
     code_a = f"""
@@ -341,14 +317,31 @@
     sender = w3.eth.accounts[0]
     assert erc20.balanceOf(sender) == 0
 
     test_c.test(transact={})
     assert erc20.balanceOf(sender) == 1000
 
 
+def test_address_member(w3, get_contract):
+    code = """
+interface Foo:
+    def foo(): payable
+
+f: Foo
+
+@external
+def test(addr: address):
+    self.f = Foo(addr)
+    assert self.f.address == addr
+    """
+    c = get_contract(code)
+    for address in w3.eth.accounts:
+        c.test(address)
+
+
 # test data returned from external interface gets clamped
 @pytest.mark.parametrize("typ", ("int128", "uint8"))
 def test_external_interface_int_clampers(get_contract, assert_tx_failed, typ):
     external_contract = f"""
 @external
 def ok() -> {typ}:
     return 1
@@ -391,15 +384,15 @@
     bad_c = get_contract(external_contract)
     c = get_contract(
         code,
         bad_c.address,
         interface_codes={"BadCode": {"type": "vyper", "code": external_contract}},
     )
     assert bad_c.ok() == 1
-    assert bad_c.should_fail() == -(2 ** 255)
+    assert bad_c.should_fail() == -(2**255)
 
     assert c.test_ok() == 1
     assert_tx_failed(lambda: c.test_fail())
     assert_tx_failed(lambda: c.test_fail2())
     assert_tx_failed(lambda: c.test_fail3())
 
 
@@ -530,15 +523,15 @@
 @view
 def balanceOf(owner: address) -> uint256:
     pass
     """
     interface_codes = {"BalanceOf": {"type": "vyper", "code": interface_code}}
     c = get_contract(code, interface_codes=interface_codes)
 
-    assert c.balanceOf(w3.eth.accounts[0]) == w3.toWei(1, "ether")
+    assert c.balanceOf(w3.eth.accounts[0]) == w3.to_wei(1, "ether")
 
 
 def test_local_and_global_interface_namespaces():
     interface_code = """
 @external
 def foo() -> uint256:
     pass
```

### Comparing `vyper-0.3.7/tests/parser/functions/test_is_contract.py` & `vyper-0.3.8/tests/parser/functions/test_is_contract.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/parser/functions/test_keccak256.py` & `vyper-0.3.8/tests/parser/functions/test_keccak256.py`

 * *Files 2% similar despite different names*

```diff
@@ -60,15 +60,14 @@
     """
     c = get_contract_with_gas_estimation(hash_code3)
     c.set_test(b"", transact={})
     assert c.tryy(b"") is True
     assert c.tryy_str("") is True
     assert c.trymem(b"") is True
     assert c.tryy(b"cow") is False
-    assert c.tryy_str(b"cow") is False
     c.set_test(b"cow", transact={})
     assert c.tryy(b"") is False
     assert c.tryy(b"cow") is True
     assert c.tryy_str("cow") is True
     c.set_test(b"\x35" * 32, transact={})
     assert c.tryy(b"\x35" * 32) is True
     assert c.trymem(b"\x35" * 32) is True
```

### Comparing `vyper-0.3.7/tests/parser/functions/test_method_id.py` & `vyper-0.3.8/tests/parser/functions/test_method_id.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/parser/functions/test_minmax.py` & `vyper-0.3.8/tests/parser/functions/test_minmax.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 from decimal import Decimal
 
 import pytest
 
-from vyper.codegen.types import INTEGER_TYPES, parse_integer_typeinfo
+from vyper.semantics.types import IntegerT
 
 
 def test_minmax(get_contract_with_gas_estimation):
     minmax_test = """
 @external
 def foo() -> decimal:
     return min(3.0, 5.0) + max(10.0, 20.0) + min(200.1, 400.0) + max(3000.0, 8000.02) + min(50000.003, 70000.004)  # noqa: E501
@@ -19,21 +19,21 @@
     c = get_contract_with_gas_estimation(minmax_test)
     assert c.foo() == Decimal("58223.123")
     assert c.goo() == 83
 
     print("Passed min/max test")
 
 
-@pytest.mark.parametrize("return_type", sorted(INTEGER_TYPES))
-def test_minmax_var_and_literal(get_contract_with_gas_estimation, return_type):
+@pytest.mark.parametrize("return_type", sorted(IntegerT.all()))
+def test_minmax_var_and_literal_and_bultin(get_contract_with_gas_estimation, return_type):
     """
     Tests to verify that min and max work as expected when a variable/literal
     and a literal are passed for all integer types.
     """
-    lo, hi = parse_integer_typeinfo(return_type).bounds
+    lo, hi = return_type.ast_bounds
 
     code = f"""
 @external
 def foo() -> {return_type}:
     a: {return_type} = {hi}
     b: {return_type} = 5
     return max(a, 5)
@@ -47,20 +47,30 @@
 @external
 def both_literals_max() -> {return_type}:
     return max({hi}, 2)
 
 @external
 def both_literals_min() -> {return_type}:
     return min({lo}, 2)
+
+@external
+def both_builtins_max() -> {return_type}:
+    return max(min_value({return_type}), max_value({return_type}))
+
+@external
+def both_builtins_min() -> {return_type}:
+    return min(min_value({return_type}), max_value({return_type}))
 """
     c = get_contract_with_gas_estimation(code)
     assert c.foo() == hi
     assert c.bar() == lo
     assert c.both_literals_max() == hi
     assert c.both_literals_min() == lo
+    assert c.both_builtins_max() == hi
+    assert c.both_builtins_min() == lo
 
 
 def test_max_var_uint256_literal_int128(get_contract_with_gas_estimation):
     """
     Tests to verify that max works as expected when a variable/literal uint256
     and a literal int128 are passed.
     """
@@ -90,19 +100,19 @@
     return max(5, a) + max(5, b)
 
 @external
 def both_literals() -> uint256:
     return max(2 ** 200, 2)
 """
     c = get_contract_with_gas_estimation(code)
-    assert c.foo() == 2 ** 200 + 5
-    assert c.goo() == 2 ** 200 + 5
+    assert c.foo() == 2**200 + 5
+    assert c.goo() == 2**200 + 5
     assert c.bar() == 5 + 5
     assert c.baz() == 5 + 5
-    assert c.both_literals() == 2 ** 200
+    assert c.both_literals() == 2**200
 
 
 def test_min_var_uint256_literal_int128(get_contract_with_gas_estimation):
     """
     Tests to verify that max works as expected when a variable/literal uint256
     and a literal int128 are passed.
     """
@@ -227,16 +237,16 @@
 def foo4() -> uint256:
     return max(2**255, 0)
     """
 
     c = get_contract_with_gas_estimation(code)
     assert c.foo1() == 0
     assert c.foo2() == 0
-    assert c.foo3() == 2 ** 255
-    assert c.foo4() == 2 ** 255
+    assert c.foo3() == 2**255
+    assert c.foo4() == 2**255
 
 
 def test_signed(get_contract_with_gas_estimation):
     code = """
 @external
 def foo1() -> int128:
     return min(min_value(int128), max_value(int128))
@@ -251,11 +261,11 @@
 
 @external
 def foo4() -> int128:
     return max(max_value(int128), min_value(int128))
     """
 
     c = get_contract_with_gas_estimation(code)
-    assert c.foo1() == -(2 ** 127)
-    assert c.foo2() == -(2 ** 127)
-    assert c.foo3() == 2 ** 127 - 1
-    assert c.foo4() == 2 ** 127 - 1
+    assert c.foo1() == -(2**127)
+    assert c.foo2() == -(2**127)
+    assert c.foo3() == 2**127 - 1
+    assert c.foo4() == 2**127 - 1
```

### Comparing `vyper-0.3.7/tests/parser/functions/test_minmax_value.py` & `vyper-0.3.8/tests/parser/functions/test_minmax_value.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,81 +1,57 @@
 import pytest
 
-from vyper.codegen.types import (
-    DECIMAL_TYPES,
-    INTEGER_TYPES,
-    parse_decimal_info,
-    parse_integer_typeinfo,
-)
 from vyper.exceptions import InvalidType, OverflowException
-from vyper.utils import int_bounds
+from vyper.semantics.types import DecimalT, IntegerT
+from vyper.semantics.types.shortcuts import INT256_T, UINT256_T
 
 
-@pytest.mark.parametrize("typ", sorted(INTEGER_TYPES))
+@pytest.mark.parametrize("typ", sorted(IntegerT.all() + (DecimalT(),)))
 @pytest.mark.parametrize("op", ("min_value", "max_value"))
-def test_minmax_value_int(get_contract, op, typ):
+def test_minmax_value(get_contract, op, typ):
     code = f"""
 @external
 def foo() -> {typ}:
     return {op}({typ})
     """
     c = get_contract(code)
 
-    typ_info = parse_integer_typeinfo(typ)
-    (lo, hi) = int_bounds(typ_info.is_signed, typ_info.bits)
+    lo, hi = typ.ast_bounds
     if op == "min_value":
         assert c.foo() == lo
     elif op == "max_value":
         assert c.foo() == hi
 
 
-@pytest.mark.parametrize("typ", sorted(INTEGER_TYPES))
+@pytest.mark.parametrize("typ", sorted(IntegerT.all()))
 def test_minmax_value_int_oob(get_contract, assert_compile_failed, typ):
     upper = f"""
 @external
 def foo():
     a: {typ} = max_value({typ}) + 1
     """
 
     lower = f"""
 @external
 def foo():
     a: {typ} = min_value({typ}) - 1
     """
 
-    if typ == "uint256":
+    if typ == UINT256_T:
         assert_compile_failed(lambda: get_contract(upper), OverflowException)
     else:
         assert_compile_failed(lambda: get_contract(upper), InvalidType)
 
-    if typ == "int256":
+    if typ == INT256_T:
         assert_compile_failed(lambda: get_contract(lower), OverflowException)
     else:
         assert_compile_failed(lambda: get_contract(lower), InvalidType)
 
 
-@pytest.mark.parametrize("typ", sorted(DECIMAL_TYPES))
-@pytest.mark.parametrize("op", ("min_value", "max_value"))
-def test_minmax_value_decimal(get_contract, op, typ):
-    code = f"""
-@external
-def foo() -> {typ}:
-    return {op}({typ})
-    """
-    c = get_contract(code)
-
-    typ_info = parse_decimal_info(typ)
-    (lo, hi) = typ_info.decimal_bounds
-    if op == "min_value":
-        assert c.foo() == lo
-    elif op == "max_value":
-        assert c.foo() == hi
-
-
-@pytest.mark.parametrize("typ", sorted(DECIMAL_TYPES))
+@pytest.mark.parametrize("typ", [DecimalT()])
 def test_minmax_value_decimal_oob(get_contract, assert_compile_failed, typ):
     upper = f"""
 @external
 def foo():
     a: {typ} = max_value({typ}) + 1e-10
     """
```

### Comparing `vyper-0.3.7/tests/parser/functions/test_mkstr.py` & `vyper-0.3.8/tests/parser/functions/test_mkstr.py`

 * *Files 3% similar despite different names*

```diff
@@ -11,15 +11,15 @@
     code = f"""
 @external
 def foo(inp: uint{bits}) -> String[{n_digits}]:
     return uint2str(inp)
     """
 
     c = get_contract_with_gas_estimation(code)
-    for i in [1, 2, 2 ** bits - 1, 0]:
+    for i in [1, 2, 2**bits - 1, 0]:
         assert c.foo(i) == str(i), (i, c.foo(i))
 
 
 # test for buffer overflow
 @pytest.mark.parametrize("bits", VALID_BITS)
 def test_mkstr_buffer(get_contract, bits):
     n_digits = math.ceil(bits * math.log(2) / math.log(10))
@@ -32,8 +32,8 @@
 @external
 def foo(x: uint{bits}) -> uint256:
     y: uint256 = 0
     self._foo(x)
     return y
     """
     c = get_contract(code)
-    assert c.foo(2 ** bits - 1) == 0, bits
+    assert c.foo(2**bits - 1) == 0, bits
```

### Comparing `vyper-0.3.7/tests/parser/functions/test_raw_call.py` & `vyper-0.3.8/tests/parser/functions/test_raw_call.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 import pytest
 from hexbytes import HexBytes
 
-from vyper.builtin_functions import eip1167_bytecode
+from vyper.builtins.functions import eip1167_bytecode
 from vyper.exceptions import ArgumentException, InvalidType, StateAccessViolation
 
 pytestmark = pytest.mark.usefixtures("memory_mocker")
 
 
 def test_max_outsize_exceeds_returndatasize(get_contract):
     source_code = """
@@ -76,15 +76,15 @@
     c2.create_and_call_returnten(c.address, transact={})
 
     _, preamble, callcode = eip1167_bytecode()
 
     c3 = c2.create_and_return_proxy(c.address, call={})
     c2.create_and_return_proxy(c.address, transact={})
 
-    c3_contract_code = w3.toBytes(w3.eth.get_code(c3))
+    c3_contract_code = w3.to_bytes(w3.eth.get_code(c3))
 
     assert c3_contract_code[:10] == HexBytes(preamble)
     assert c3_contract_code[-15:] == HexBytes(callcode)
 
     print("Passed proxy test")
     # TODO: This one is special
     # print(f'Gas consumed: {(chain.head_state.receipts[-1].gas_used - chain.head_state.receipts[-2].gas_used - chain.last_tx.intrinsic_gas_used)}')  # noqa: E501
@@ -201,15 +201,14 @@
 
     # manually specifying an insufficient amount should fail
     outer_contract = get_contract(outer_code.format(", gas=15000"))
     assert_tx_failed(lambda: outer_contract.foo_call(inner_contract.address))
 
 
 def test_static_call(get_contract):
-
     target_source = """
 @external
 @view
 def foo() -> int128:
     return 42
 """
 
@@ -258,15 +257,14 @@
 
     # manually construct msg.data for `caller` contract
     sig = keccak("foo()".encode()).hex()[:10]
     w3.eth.send_transaction({"to": caller.address, "data": sig})
 
 
 def test_static_call_fails_nonpayable(get_contract, assert_tx_failed):
-
     target_source = """
 baz: int128
 
 @external
 def foo() -> int128:
     self.baz = 31337
     return self.baz
@@ -288,23 +286,24 @@
     target = get_contract(target_source)
     caller = get_contract(caller_source)
 
     assert_tx_failed(lambda: caller.foo(target.address))
 
 
 def test_checkable_raw_call(get_contract, assert_tx_failed):
-
     target_source = """
 baz: int128
 @external
 def fail1(should_raise: bool):
     if should_raise:
         raise "fail"
+
 # test both paths for raw_call -
 # they are different depending if callee has or doesn't have returntype
+# (fail2 fails because of staticcall)
 @external
 def fail2(should_raise: bool) -> int128:
     if should_raise:
         self.baz = self.baz + 1
     return self.baz
 """
 
@@ -319,37 +318,53 @@
         _abi_encode(should_raise, method_id=method_id("fail1(bool)")),
         max_outsize=32,
         is_static_call=True,
         revert_on_failure=False,
     )
     assert success == (not should_raise)
     return 1
+
 @external
 @view
 def bar(_addr: address, should_raise: bool) -> uint256:
     success: bool = True
     response: Bytes[32] = b""
     success, response = raw_call(
         _addr,
         _abi_encode(should_raise, method_id=method_id("fail2(bool)")),
         max_outsize=32,
         is_static_call=True,
         revert_on_failure=False,
     )
     assert success == (not should_raise)
     return 2
+
+# test max_outsize not set case
+@external
+@nonpayable
+def baz(_addr: address, should_raise: bool) -> uint256:
+    success: bool = True
+    success = raw_call(
+        _addr,
+        _abi_encode(should_raise, method_id=method_id("fail1(bool)")),
+        revert_on_failure=False,
+    )
+    assert success == (not should_raise)
+    return 3
     """
 
     target = get_contract(target_source)
     caller = get_contract(caller_source)
 
     assert caller.foo(target.address, True) == 1
     assert caller.foo(target.address, False) == 1
     assert caller.bar(target.address, True) == 2
     assert caller.bar(target.address, False) == 2
+    assert caller.baz(target.address, True) == 3
+    assert caller.baz(target.address, False) == 3
 
 
 uncompilable_code = [
     (
         """
 @external
 @view
```

### Comparing `vyper-0.3.7/tests/parser/functions/test_return.py` & `vyper-0.3.8/tests/parser/functions/test_return.py`

 * *Files 1% similar despite different names*

```diff
@@ -8,20 +8,20 @@
     c = get_contract_with_gas_estimation(selfcall_code_6)
 
     assert c.hardtest(b"hello" * 5, b"hello" * 10) == b"hello" * 15
 
     # Make sure underlying structe is correctly right padded
     classic_contract = c._classic_contract
     func = classic_contract.functions.hardtest(b"hello" * 5, b"hello" * 10)
-    tx = func.buildTransaction({"gasPrice": 0})
+    tx = func.build_transaction({"gasPrice": 0})
     del tx["chainId"]
     del tx["gasPrice"]
 
     tx["from"] = w3.eth.accounts[0]
-    res = w3.toBytes(hexstr=tester.call(tx))
+    res = w3.to_bytes(hexstr=tester.call(tx))
 
     static_offset = int.from_bytes(res[:32], "big")
     assert static_offset == 32
 
     dyn_section = res[static_offset:]
     assert len(dyn_section) % 32 == 0  # first right pad assert
```

### Comparing `vyper-0.3.7/tests/parser/functions/test_return_struct.py` & `vyper-0.3.8/tests/parser/functions/test_return_struct.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/parser/functions/test_return_tuple.py` & `vyper-0.3.8/tests/parser/functions/test_return_tuple.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/parser/functions/test_sha256.py` & `vyper-0.3.8/tests/parser/functions/test_sha256.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/parser/functions/test_slice.py` & `vyper-0.3.8/tests/parser/functions/test_slice.py`

 * *Files 3% similar despite different names*

```diff
@@ -109,14 +109,16 @@
         foo = "IMMUTABLE_BYTES"
     elif location == "literal":
         spliced_code = ""
         foo = f"{bytesdata}"
     elif location == "calldata":
         spliced_code = ""
         foo = "inp"
+    else:
+        raise Exception("unreachable")
 
     _start = start if literal_start else "start"
     _length = length if literal_length else "length"
 
     code = f"""
 foo: Bytes[100]
 IMMUTABLE_BYTES: immutable(Bytes[100])
@@ -159,20 +161,20 @@
 def foo(x: uint256, y: uint256) -> (uint256, String[12]):
     self.bytez = "hello, world"
     dont_clobber_me: uint256 = max_value(uint256)
     self._slice(x, y)
     return dont_clobber_me, self.bytez
     """
     c = get_contract(code)
-    assert c.foo(0, 12) == [2 ** 256 - 1, "hello, world"]
-    assert c.foo(12, 0) == [2 ** 256 - 1, ""]
-    assert c.foo(7, 5) == [2 ** 256 - 1, "world"]
-    assert c.foo(0, 5) == [2 ** 256 - 1, "hello"]
-    assert c.foo(0, 1) == [2 ** 256 - 1, "h"]
-    assert c.foo(11, 1) == [2 ** 256 - 1, "d"]
+    assert c.foo(0, 12) == [2**256 - 1, "hello, world"]
+    assert c.foo(12, 0) == [2**256 - 1, ""]
+    assert c.foo(7, 5) == [2**256 - 1, "world"]
+    assert c.foo(0, 5) == [2**256 - 1, "hello"]
+    assert c.foo(0, 1) == [2**256 - 1, "h"]
+    assert c.foo(11, 1) == [2**256 - 1, "d"]
 
 
 def test_slice_storage_bytes32(get_contract):
     code = """
 bytez: bytes32
 @external
 def dice() -> Bytes[1]:
@@ -181,14 +183,31 @@
     return c
     """
 
     c = get_contract(code)
     assert c.dice() == b"A"
 
 
+def test_slice_immutable_length_arg(get_contract_with_gas_estimation):
+    code = """
+LENGTH: immutable(uint256)
+
+@external
+def __init__():
+    LENGTH = 5
+
+@external
+def do_slice(inp: Bytes[50]) -> Bytes[50]:
+    return slice(inp, 0, LENGTH)
+    """
+    c = get_contract_with_gas_estimation(code)
+    x = c.do_slice(b"abcdefghijklmnopqrstuvwxyz1234")
+    assert x == b"abcde", x
+
+
 def test_slice_at_end(get_contract):
     code = """
 @external
 def ret10_slice() -> Bytes[10]:
     b: Bytes[32] = concat(convert(65, bytes32), b'')
     c: Bytes[10] = slice(b, 31, 1)
     return c
@@ -303,15 +322,14 @@
     """,
 ]
 
 
 @pytest.mark.parametrize("code", code_bytes32)
 @pytest.mark.parametrize("start,length", _fun_bytes32_bounds)
 def test_slice_bytes32(get_contract, code, start, length):
-
     c = get_contract(code.format(start=start, length=length))
     assert c.bar() == _generate_bytes(32)[start : start + length]
 
 
 code_bytes32_calldata = [
     """
 @external
@@ -327,15 +345,14 @@
     """,
 ]
 
 
 @pytest.mark.parametrize("code", code_bytes32_calldata)
 @pytest.mark.parametrize("start,length", _fun_bytes32_bounds)
 def test_slice_bytes32_calldata(get_contract, code, start, length):
-
     c = get_contract(code.format(start=start, length=length))
     assert c.bar(_generate_bytes(32)) == _generate_bytes(32)[start : start + length]
 
 
 code_bytes32_calldata_extended = [
     (
         """
@@ -370,13 +387,12 @@
         "0001020304050607",
     ),
 ]
 
 
 @pytest.mark.parametrize("code,result", code_bytes32_calldata_extended)
 def test_slice_bytes32_calldata_extended(get_contract, code, result):
-
     c = get_contract(code)
     assert (
         c.bar(3, "0x0001020304050607080910111213141516171819202122232425262728293031", 5).hex()
         == result
     )
```

### Comparing `vyper-0.3.7/tests/parser/functions/test_unary.py` & `vyper-0.3.8/tests/parser/functions/test_unary.py`

 * *Files 8% similar despite different names*

```diff
@@ -16,29 +16,29 @@
 def test_unary_sub_int128_fail(get_contract, assert_tx_failed):
     code = """@external
 def negate(a: int128) -> int128:
     return -(a)
     """
     c = get_contract(code)
     # This test should revert on overflow condition
-    assert_tx_failed(lambda: c.negate(-(2 ** 127)))
+    assert_tx_failed(lambda: c.negate(-(2**127)))
 
 
-@pytest.mark.parametrize("val", [-(2 ** 127) + 1, 0, 2 ** 127 - 1])
+@pytest.mark.parametrize("val", [-(2**127) + 1, 0, 2**127 - 1])
 def test_unary_sub_int128_pass(get_contract, val):
     code = """@external
 def negate(a: int128) -> int128:
     return -(a)
     """
     c = get_contract(code)
     assert c.negate(val) == -val
 
 
-min_decimal = -(2 ** 127) + 1
-max_decimal = 2 ** 127 - 1
+min_decimal = -(2**127) + 1
+max_decimal = 2**127 - 1
 
 
 @pytest.mark.parametrize("val", [min_decimal, 0, max_decimal])
 def test_unary_sub_decimal_pass(get_contract, val):
     code = """@external
 def negate(a: decimal) -> decimal:
     return -(a)
@@ -75,9 +75,9 @@
     return -2**127
 
 @external
 def bar() -> int128:
     return -(a+1)
     """
     c = get_contract(code)
-    assert c.foo() == -(2 ** 127)
-    assert c.bar() == 2 ** 127 - 1
+    assert c.foo() == -(2**127)
+    assert c.bar() == 2**127 - 1
```

### Comparing `vyper-0.3.7/tests/parser/functions/test_unsafe_math.py` & `vyper-0.3.8/tests/parser/functions/test_unsafe_math.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,18 +1,18 @@
 import itertools
 import operator
 import random
 
 import pytest
 
-from vyper.codegen.types.types import INTEGER_TYPES, parse_integer_typeinfo
-from vyper.utils import evm_div, int_bounds, unsigned_to_signed
+from vyper.semantics.types import IntegerT
+from vyper.utils import evm_div, unsigned_to_signed
 
 # TODO something less janky
-integer_types = sorted(list(INTEGER_TYPES))
+integer_types = sorted(list(IntegerT.all()))
 
 
 @pytest.mark.parametrize("typ", integer_types)
 @pytest.mark.parametrize("op", ["add", "sub", "mul", "div"])
 @pytest.mark.fuzzing
 def test_unsafe_op_int(get_contract, typ, op):
     contract_1 = f"""
@@ -26,44 +26,43 @@
 def foo(x: {typ}) -> {typ}:
     return unsafe_{op}(x, {literal})
     """
 
     fns = {"add": operator.add, "sub": operator.sub, "mul": operator.mul, "div": evm_div}
     fn = fns[op]
 
-    int_info = parse_integer_typeinfo(typ)
     c1 = get_contract(contract_1)
 
-    lo, hi = int_bounds(int_info.is_signed, int_info.bits)
+    lo, hi = typ.ast_bounds
     # (roughly 8k cases total generated)
     # TODO refactor to use fixtures
     NUM_CASES = 15
     xs = [random.randrange(lo, hi) for _ in range(NUM_CASES)]
     ys = [random.randrange(lo, hi) for _ in range(NUM_CASES)]
 
-    mod_bound = 2 ** int_info.bits
+    mod_bound = 2**typ.bits
 
     # poor man's fuzzing - hypothesis doesn't make it easy
     # with the parametrized strategy
-    if int_info.is_signed:
+    if typ.is_signed:
         xs += [lo, lo + 1, -1, 0, 1, hi - 1, hi]
         ys += [lo, lo + 1, -1, 0, 1, hi - 1, hi]
-        for (x, y) in itertools.product(xs, ys):
-            expected = unsigned_to_signed(fn(x, y) % mod_bound, int_info.bits)
+        for x, y in itertools.product(xs, ys):
+            expected = unsigned_to_signed(fn(x, y) % mod_bound, typ.bits)
 
             assert c1.foo(x, y) == expected
 
             c2 = get_contract(contract_2.format(typ=typ, op=op, literal=y))
             assert c2.foo(x) == expected
 
     else:
         # 0x80 has some weird properties, like
         # it's a fixed point of multiplication by 0xFF
-        fixed_pt = 2 ** (int_info.bits - 1)
+        fixed_pt = 2 ** (typ.bits - 1)
         xs += [0, 1, hi - 1, hi, fixed_pt]
         ys += [0, 1, hi - 1, hi, fixed_pt]
-        for (x, y) in itertools.product(xs, ys):
+        for x, y in itertools.product(xs, ys):
             expected = fn(x, y) % mod_bound
             assert c1.foo(x, y) == expected
 
             c2 = get_contract(contract_2.format(typ=typ, op=op, literal=y))
             assert c2.foo(x) == expected
```

### Comparing `vyper-0.3.7/tests/parser/globals/test_getters.py` & `vyper-0.3.8/tests/parser/globals/test_getters.py`

 * *Files 8% similar despite different names*

```diff
@@ -28,50 +28,66 @@
     g: uint256
 x: public(uint256)
 y: public(int128[5])
 z: public(Bytes[100])
 w: public(HashMap[int128, W])
 a: public(uint256[10][10])
 b: public(HashMap[uint256, HashMap[address, uint256[4]]])
+c: public(constant(uint256)) = 1
+d: public(immutable(uint256))
+e: public(immutable(uint256[2]))
 
 @external
 def __init__():
     self.x = as_wei_value(7, "wei")
     self.y[1] = 9
     self.z = b"cow"
     self.w[1].a = 11
     self.w[1].b[2] = 13
     self.w[1].c = b"horse"
     self.w[2].e[1][2] = 17
     self.w[3].f = 750
     self.w[3].g = 751
     self.a[1][4] = 666
     self.b[42][self] = [5,6,7,8]
+    d = 1729
+    e = [2, 3]
     """
 
     c = get_contract_with_gas_estimation_for_constants(getter_code)
     assert c.x() == 7
     assert c.y(1) == 9
     assert c.z() == b"cow"
     assert c.w(1)[0] == 11  # W.a
     assert c.w(1)[1][2] == 13  # W.b[2]
     assert c.w(1)[2] == b"horse"  # W.c
     assert c.w(2)[3][1][2] == 17  # W.e[1][2]
     assert c.w(3)[4] == 750  # W.f
     assert c.w(3)[5] == 751  # W.g
     assert c.a(1, 4) == 666
     assert c.b(42, c.address, 2) == 7
+    assert c.c() == 1
+    assert c.d() == 1729
+    assert c.e(0) == 2
 
 
 def test_getter_mutability(get_contract):
     code = """
 foo: public(uint256)
 goo: public(String[69])
 bar: public(uint256[4][5])
 baz: public(HashMap[address, Bytes[100]])
 potatoes: public(HashMap[uint256, HashMap[bytes32, uint256[4]]])
+nyoro: public(constant(uint256)) = 2
+kune: public(immutable(uint256))
+
+@external
+def __init__():
+    kune = 2
 """
 
     contract = get_contract(code)
 
     for item in contract._classic_contract.abi:
+        if item["type"] == "constructor":
+            continue
         assert item["stateMutability"] == "view"
```

### Comparing `vyper-0.3.7/tests/parser/globals/test_globals.py` & `vyper-0.3.8/tests/parser/globals/test_globals.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/parser/globals/test_setters.py` & `vyper-0.3.8/tests/parser/globals/test_setters.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/parser/integration/test_crowdfund.py` & `vyper-0.3.8/tests/parser/integration/test_crowdfund.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/parser/integration/test_escrow.py` & `vyper-0.3.8/tests/parser/integration/test_escrow.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/parser/parser_utils/test_annotate_and_optimize_ast.py` & `vyper-0.3.8/tests/parser/parser_utils/test_annotate_and_optimize_ast.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/parser/syntax/test_abi_encode.py` & `vyper-0.3.8/tests/parser/syntax/test_abi_encode.py`

 * *Files 0% similar despite different names*

```diff
@@ -47,15 +47,14 @@
         InvalidType,  # len(method_id) must be less than 4
     ),
 ]
 
 
 @pytest.mark.parametrize("bad_code,exc", fail_list)
 def test_abi_encode_fail(bad_code, exc):
-
     with pytest.raises(exc):
         compiler.compile_code(bad_code)
 
 
 valid_list = [
     """
 @external
```

### Comparing `vyper-0.3.7/tests/parser/syntax/test_address_code.py` & `vyper-0.3.8/tests/parser/syntax/test_address_code.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 from typing import Type
 
 import pytest
 from eth_tester.exceptions import TransactionFailed
 from web3 import Web3
 
 from vyper import compiler
-from vyper.exceptions import StructureException, VyperException
+from vyper.exceptions import NamespaceCollision, StructureException, VyperException
 
 # For reproducibility, use precompiled data of `hello: public(uint256)` using vyper 0.3.1
 PRECOMPILED_ABI = """[{"stateMutability": "view", "type": "function", "name": "hello", "inputs": [], "outputs": [{"name": "", "type": "uint256"}], "gas": 2460}]"""  # noqa: E501
 PRECOMPILED_BYTECODE = """0x61004456600436101561000d57610035565b60046000601c376000513461003b576319ff1d2181186100335760005460e052602060e0f35b505b60006000fd5b600080fd5b61000461004403610004600039610004610044036000f3"""  # noqa: E501
 PRECOMPILED_BYTECODE_RUNTIME = """0x600436101561000d57610035565b60046000601c376000513461003b576319ff1d2181186100335760005460e052602060e0f35b505b60006000fd5b600080fd"""  # noqa: E501
 PRECOMPILED = bytes.fromhex(PRECOMPILED_BYTECODE_RUNTIME[2:])
 
@@ -73,14 +73,25 @@
     y: uint256 = convert(x.code, uint256)
     return y
 """,
             StructureException,
             "(address).code is only allowed inside of a slice function with a constant length",
         ),
         (
+            """
+a: HashMap[Bytes[4], uint256]
+
+@external
+def foo(x: address):
+    self.a[x.code] += 1
+""",
+            StructureException,
+            "(address).code is only allowed inside of a slice function with a constant length",
+        ),
+        (
             # `len` not supported
             """
 @external
 def code_slice(x: address) -> uint256:
     y: uint256 = len(x.code)
     return y
 """,
@@ -99,25 +110,16 @@
             "(address).code is only allowed inside of a slice function with a constant length",
         ),
         (
             # `self.code` is already defined since `self` is address
             """
 code: public(Bytes[4])
 """,
-            StructureException,
-            "'code' is a reserved keyword",
-        ),
-        (
-            # User defined struct with `code` attribute
-            """
-struct S:
-    code: Bytes[4]
-""",
-            StructureException,
-            "'code' is a reserved keyword",
+            NamespaceCollision,
+            "Value 'code' has already been declared",
         ),
     ],
 )
 def test_address_code_compile_error(
     bad_code: str, error_type: Type[VyperException], error_message: str
 ):
     with pytest.raises(error_type) as excinfo:
```

### Comparing `vyper-0.3.7/tests/parser/syntax/test_ann_assign.py` & `vyper-0.3.8/tests/parser/syntax/test_ann_assign.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/parser/syntax/test_as_uint256.py` & `vyper-0.3.8/tests/parser/syntax/test_as_uint256.py`

 * *Files 16% similar despite different names*

```diff
@@ -33,10 +33,9 @@
         InvalidType,
     ),
 ]
 
 
 @pytest.mark.parametrize("bad_code,exc", fail_list)
 def test_as_uint256_fail(bad_code, exc):
-
     with pytest.raises(exc):
         compiler.compile_code(bad_code)
```

### Comparing `vyper-0.3.7/tests/parser/syntax/test_as_wei_value.py` & `vyper-0.3.8/tests/parser/syntax/test_as_wei_value.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/parser/syntax/test_block.py` & `vyper-0.3.8/tests/parser/syntax/test_block.py`

 * *Files 0% similar despite different names*

```diff
@@ -81,15 +81,14 @@
         Exception,
     ),
 ]
 
 
 @pytest.mark.parametrize("bad_code", fail_list)
 def test_block_fail(bad_code):
-
     if isinstance(bad_code, tuple):
         with raises(bad_code[1]):
             compiler.compile_code(bad_code[0])
     else:
         with raises(TypeMismatch):
             compiler.compile_code(bad_code)
```

### Comparing `vyper-0.3.7/tests/parser/syntax/test_blockscope.py` & `vyper-0.3.8/tests/parser/syntax/test_blockscope.py`

 * *Files 0% similar despite different names*

```diff
@@ -46,15 +46,14 @@
     a += 1
     """,
 ]
 
 
 @pytest.mark.parametrize("bad_code", fail_list)
 def test_fail_undeclared(bad_code):
-
     with raises(UndeclaredDefinition):
         compiler.compile_code(bad_code)
 
 
 fail_list_collision = [
     """
 @external
@@ -63,15 +62,14 @@
     a: int128 = 7
     """
 ]
 
 
 @pytest.mark.parametrize("bad_code", fail_list_collision)
 def test_fail_collision(bad_code):
-
     with raises(NamespaceCollision):
         compiler.compile_code(bad_code)
 
 
 valid_list = [
     """
 @external
```

### Comparing `vyper-0.3.7/tests/parser/syntax/test_bool.py` & `vyper-0.3.8/tests/parser/syntax/test_bool.py`

 * *Files 10% similar despite different names*

```diff
@@ -59,47 +59,28 @@
         """
 @external
 def foo(a: address) -> bool:
     return not a
     """,
         InvalidOperation,
     ),
-    """
-@external
-def foo() -> bool:
-    b: int128 = 0
-    return not b
-    """,
-    """
-@external
-def foo() -> bool:
-    b: uint256 = 0
-    return not b
-    """,
-    """
-@external
-def foo() -> bool:
-    b: uint256 = 0
-    return not b
-    """,
     (
         """
 @external
 def test(a: address) -> bool:
     assert(a)
     return True
     """,
         TypeMismatch,
     ),
 ]
 
 
 @pytest.mark.parametrize("bad_code", fail_list)
 def test_bool_fail(bad_code):
-
     if isinstance(bad_code, tuple):
         with raises(bad_code[1]):
             compiler.compile_code(bad_code[0])
     else:
         with raises(TypeMismatch):
             compiler.compile_code(bad_code)
```

### Comparing `vyper-0.3.7/tests/parser/syntax/test_bool_ops.py` & `vyper-0.3.8/tests/parser/syntax/test_bool_ops.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/parser/syntax/test_bytes.py` & `vyper-0.3.8/tests/parser/syntax/test_bytes.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,11 +1,17 @@
 import pytest
 
 from vyper import compiler
-from vyper.exceptions import InvalidOperation, InvalidType, SyntaxException, TypeMismatch
+from vyper.exceptions import (
+    InvalidOperation,
+    InvalidType,
+    StructureException,
+    SyntaxException,
+    TypeMismatch,
+)
 
 fail_list = [
     (
         """
 @external
 def baa():
     x: Bytes[50] = b""
@@ -73,14 +79,22 @@
 @external
 def test() -> Bytes[1]:
     a: Bytes[1] = 0b0000001  # needs multiple of 8 bits.
     return a
     """,
         SyntaxException,
     ),
+    (
+        """
+@external
+def foo():
+    a: Bytes = b"abc"
+    """,
+        StructureException,
+    ),
 ]
 
 
 @pytest.mark.parametrize("bad_code", fail_list)
 def test_bytes_fail(bad_code):
     if isinstance(bad_code, tuple):
         with pytest.raises(bad_code[1]):
```

### Comparing `vyper-0.3.7/tests/parser/syntax/test_chainid.py` & `vyper-0.3.8/tests/parser/syntax/test_chainid.py`

 * *Files 0% similar despite different names*

```diff
@@ -65,15 +65,14 @@
         InvalidType,
     ),
 ]
 
 
 @pytest.mark.parametrize("bad_code", fail_list)
 def test_chain_fail(bad_code):
-
     if isinstance(bad_code, tuple):
         with pytest.raises(bad_code[1]):
             compiler.compile_code(bad_code[0], evm_version="istanbul")
     else:
         with pytest.raises(TypeMismatch):
             compiler.compile_code(bad_code, evm_version="istanbul")
```

### Comparing `vyper-0.3.7/tests/parser/syntax/test_code_size.py` & `vyper-0.3.8/tests/parser/syntax/test_string.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,49 +1,58 @@
 import pytest
 
 from vyper import compiler
 from vyper.exceptions import StructureException
 
-fail_list = [
+valid_list = [
     """
 @external
-def foo() -> int128:
-    x: int128 = 45
-    return x.codesize
+def foo() -> String[10]:
+    return "badminton"
+    """,
     """
-]
-
-
-@pytest.mark.parametrize("bad_code", fail_list)
-def test_block_fail(bad_code):
-
-    with pytest.raises(StructureException):
-        compiler.compile_code(bad_code)
-
-
-valid_list = [
+@external
+def foo():
+    x: String[11] = "trs bien!"
+    """,
     """
 @external
-def foo() -> uint256:
-    x: address = 0x1234567890123456789012345678901234567890
-    return x.codesize
+def foo() -> bool:
+    x: String[15] = "trs bien!"
+    y: String[15] = "test"
+    return x != y
     """,
     """
 @external
-def foo() -> uint256:
-    return self.codesize
+def foo() -> bool:
+    x: String[15] = "trs bien!"
+    y: String[12] = "test"
+    return x != y
     """,
     """
-struct Foo:
-    t: address
-foo: Foo
-
 @external
-def bar() -> uint256:
-    return self.foo.t.codesize
+def test() -> String[100]:
+    return "hello world!"
     """,
 ]
 
 
 @pytest.mark.parametrize("good_code", valid_list)
-def test_block_success(good_code):
+def test_string_success(good_code):
     assert compiler.compile_code(good_code) is not None
+
+
+invalid_list = [
+    (
+        """
+@external
+def foo():
+    a: String = "abc"
+    """,
+        StructureException,
+    )
+]
+
+
+@pytest.mark.parametrize("bad_code,exc", invalid_list)
+def test_string_fail(assert_compile_failed, get_contract_with_gas_estimation, bad_code, exc):
+    assert_compile_failed(lambda: get_contract_with_gas_estimation(bad_code), exc)
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `vyper-0.3.7/tests/parser/syntax/test_codehash.py` & `vyper-0.3.8/tests/parser/syntax/test_codehash.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/parser/syntax/test_concat.py` & `vyper-0.3.8/tests/parser/syntax/test_concat.py`

 * *Files 0% similar despite different names*

```diff
@@ -86,15 +86,14 @@
         ArgumentException,
     ),
 ]
 
 
 @pytest.mark.parametrize("bad_code,exc", fail_list)
 def test_block_fail(assert_compile_failed, get_contract_with_gas_estimation, bad_code, exc):
-
     assert_compile_failed(lambda: get_contract_with_gas_estimation(bad_code), exc)
 
 
 valid_list = [
     """
 @external
 def cat(i1: Bytes[10], i2: Bytes[30]) -> Bytes[40]:
```

### Comparing `vyper-0.3.7/tests/parser/syntax/test_constants.py` & `vyper-0.3.8/tests/parser/syntax/test_constants.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,13 +1,14 @@
 import pytest
 from pytest import raises
 
 from vyper import compiler
 from vyper.exceptions import (
     ArgumentException,
+    ImmutableViolation,
     InvalidType,
     NamespaceCollision,
     StateAccessViolation,
     StructureException,
     SyntaxException,
     VariableDeclarationException,
 )
@@ -67,14 +68,54 @@
     (
         """
 VAL: constant(Bytes[4]) = b"t"
 VAL: uint256
     """,
         NamespaceCollision,
     ),
+    # global with same type and name
+    (
+        """
+VAL: constant(uint256) = 1
+VAL: uint256
+    """,
+        NamespaceCollision,
+    ),
+    # global with same type and name, different order
+    (
+        """
+VAL: uint256
+VAL: constant(uint256) = 1
+    """,
+        NamespaceCollision,
+    ),
+    # global with same type and name
+    (
+        """
+VAL: immutable(uint256)
+VAL: uint256
+
+@external
+def __init__():
+    VAL = 1
+    """,
+        NamespaceCollision,
+    ),
+    # global with same type and name, different order
+    (
+        """
+VAL: uint256
+VAL: immutable(uint256)
+
+@external
+def __init__():
+    VAL = 1
+    """,
+        NamespaceCollision,
+    ),
     # signature variable with same name
     (
         """
 VAL: constant(Bytes[4]) = b"t"
 
 @external
 def test(VAL: uint256):
@@ -112,14 +153,28 @@
     (
         # constant(public()) banned
         """
 S: constant(public(uint256)) = 3
     """,
         SyntaxException,
     ),
+    # cannot re-assign constant value
+    (
+        """
+struct Foo:
+    a : uint256
+
+x: constant(Foo) = Foo({a: 1})
+
+@external
+def hello() :
+    x.a =  2
+    """,
+        ImmutableViolation,
+    ),
 ]
 
 
 @pytest.mark.parametrize("bad_code", fail_list)
 def test_constants_fail(bad_code):
     if isinstance(bad_code, tuple):
         with raises(bad_code[1]):
```

### Comparing `vyper-0.3.7/tests/parser/syntax/test_create_with_code_of.py` & `vyper-0.3.8/tests/parser/syntax/test_create_with_code_of.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/parser/syntax/test_enum.py` & `vyper-0.3.8/tests/parser/syntax/test_enum.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,15 +1,17 @@
 import pytest
 
 from vyper import compiler
 from vyper.exceptions import (
     EnumDeclarationException,
     InvalidOperation,
     NamespaceCollision,
+    StructureException,
     TypeMismatch,
+    UnknownAttribute,
 )
 
 fail_list = [
     (
         """
 event Action:
     pass
@@ -53,24 +55,84 @@
         """
 enum Roles:
     USER
     STAFF
     ADMIN
 
 @external
+def foo(x: Roles) -> Roles:
+    return x.USER  # can't dereference on enum instance
+    """,
+        StructureException,
+    ),
+    (
+        """
+enum Roles:
+    USER
+    STAFF
+    ADMIN
+
+@external
 def foo(x: Roles) -> bool:
     return x >= Roles.STAFF
     """,
         InvalidOperation,
     ),
+    (
+        """
+enum Functions:
+    def foo():nonpayable
+    """,
+        EnumDeclarationException,
+    ),
+    (
+        """
+enum Numbers:
+    a:constant(uint256) = a
+    """,
+        EnumDeclarationException,
+    ),
+    (
+        """
+enum Numbers:
+    12
+    """,
+        EnumDeclarationException,
+    ),
+    (
+        """
+enum Roles:
+    ADMIN
+    USER
+
+@external
+def foo() -> Roles:
+    return Roles.GUEST
+    """,
+        UnknownAttribute,
+    ),
+    (
+        """
+enum A:
+    a
+enum B:
+    a
+    b
+
+@internal
+def foo():
+    a: A = B.b
+    """,
+        TypeMismatch,
+    ),
 ]
 
 
 @pytest.mark.parametrize("bad_code", fail_list)
-def test_interfaces_fail(bad_code):
+def test_fail_cases(bad_code):
     with pytest.raises(bad_code[1]):
         compiler.compile_code(bad_code[0])
 
 
 valid_list = [
     """
 enum Action:
@@ -98,13 +160,19 @@
 def run() -> Order:
     return Order({
         action: Action.BUY,
         amount: 10**18
         })
     """,
     "enum Foo:\n" + "\n".join([f"    member{i}" for i in range(256)]),
+    """
+a: constant(uint256) = 1
+
+enum A:
+    a
+    """,
 ]
 
 
 @pytest.mark.parametrize("good_code", valid_list)
 def test_enum_success(good_code):
     assert compiler.compile_code(good_code) is not None
```

### Comparing `vyper-0.3.7/tests/parser/syntax/test_extract32.py` & `vyper-0.3.8/tests/parser/syntax/test_extract32.py`

 * *Files 0% similar despite different names*

```diff
@@ -45,15 +45,14 @@
         InvalidType,  # output_type can't be bool
     ),
 ]
 
 
 @pytest.mark.parametrize("bad_code,exc", fail_list)
 def test_extract32_fail(assert_compile_failed, get_contract_with_gas_estimation, bad_code, exc):
-
     assert_compile_failed(lambda: get_contract_with_gas_estimation(bad_code), exc)
 
 
 valid_list = [
     """
 @external
 def foo() -> uint256:
```

### Comparing `vyper-0.3.7/tests/parser/syntax/test_functions_call.py` & `vyper-0.3.8/tests/parser/syntax/test_functions_call.py`

 * *Files identical despite different names*

```diff
@@ -37,15 +37,14 @@
         UnknownAttribute,
     ),
 ]
 
 
 @pytest.mark.parametrize("bad_code,exc", fail_list)
 def test_functions_call_fail(bad_code, exc):
-
     with pytest.raises(exc):
         compiler.compile_code(bad_code)
 
 
 valid_list = [
     """
 @external
```

### Comparing `vyper-0.3.7/tests/parser/syntax/test_immutables.py` & `vyper-0.3.8/tests/parser/syntax/test_immutables.py`

 * *Files 8% similar despite different names*

```diff
@@ -152,14 +152,31 @@
 @external
 def report():
     y: uint256 = imm
     z: uint256 = self.imm
     """,
         "'imm' is not a storage variable, it should not be prepended with self",
     ),
+    (
+        """
+struct Foo:
+    a : uint256
+
+x: immutable(Foo)
+
+@external
+def __init__():
+    x = Foo({a:1})
+
+@external
+def hello() :
+    x.a =  2
+    """,
+        "Immutable value cannot be written to",
+    ),
 ]
 
 
 @pytest.mark.parametrize(["bad_code", "message"], fail_list_with_messages)
 def test_compilation_fails_with_exception_message(bad_code: str, message: str):
     with pytest.raises(VyperException) as excinfo:
         compile_code(bad_code)
```

### Comparing `vyper-0.3.7/tests/parser/syntax/test_interfaces.py` & `vyper-0.3.8/tests/parser/syntax/test_interfaces.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,13 +1,15 @@
 import pytest
 
 from vyper import compiler
 from vyper.exceptions import (
     ArgumentException,
+    InterfaceViolation,
     InvalidReference,
+    InvalidType,
     StructureException,
     SyntaxException,
     TypeMismatch,
     UnknownAttribute,
 )
 
 fail_list = [
@@ -43,15 +45,15 @@
         """
 from vyper.interfaces import ERC20
 
 @external
 def test():
     a: address(ERC20) = ZERO_ADDRESS
     """,
-        (StructureException, SyntaxException),
+        InvalidType,
     ),
     (
         """
 a: address
 
 @external
 def test():  # may not call normal address
@@ -64,14 +66,78 @@
 from vyper.interfaces import ERC20
 @external
 def test(a: address):
     my_address: address = ERC20()
     """,
         ArgumentException,
     ),
+    (
+        """
+from vyper.interfaces import ERC20
+
+implements: ERC20 = 1
+    """,
+        SyntaxException,
+    ),
+    (
+        """
+interface A:
+    @external
+    def foo(): nonpayable
+    """,
+        StructureException,
+    ),
+    (
+        """
+implements: self.x
+    """,
+        StructureException,
+    ),
+    (
+        """
+implements: 123
+    """,
+        StructureException,
+    ),
+    (
+        """
+struct Foo:
+    a: uint256
+
+implements: Foo
+    """,
+        StructureException,
+    ),
+    (
+        """
+from vyper.interfaces import ERC20
+
+interface A:
+    def f(): view
+
+@internal
+def foo():
+    a: ERC20 = A(empty(address))
+    """,
+        TypeMismatch,
+    ),
+    (
+        """
+interface A:
+    def f(a: uint256): view
+
+implements: A
+
+@external
+@nonpayable
+def f(a: uint256): # visibility is nonpayable instead of view
+    pass
+    """,
+        InterfaceViolation,
+    ),
 ]
 
 
 @pytest.mark.parametrize("bad_code", fail_list)
 def test_interfaces_fail(bad_code):
     with pytest.raises(bad_code[1]):
         compiler.compile_code(bad_code[0])
@@ -168,14 +234,66 @@
     """,
     """
 interface MyInterface:
     def kick(): payable
 
 kickers: HashMap[address, MyInterface]
     """,
+    """
+interface Foo:
+    def append(a: uint256): payable
+
+@external
+def bar(x: address):
+    a: Foo = Foo(x)
+    a.append(1)
+    """,
+    """
+interface Foo:
+    def pop(): payable
+
+@external
+def foo(x: address):
+    a: Foo = Foo(x)
+    a.pop()
+    """,
+    """
+interface ITestInterface:
+    def foo() -> uint256: view
+
+implements: ITestInterface
+
+foo: public(constant(uint256)) = 1
+    """,
+    """
+interface ITestInterface:
+    def foo() -> uint256: view
+
+implements: ITestInterface
+
+foo: public(immutable(uint256))
+
+@external
+def __init__(x: uint256):
+    foo = x
+    """,
+    # no namespace collision of interface after storage variable
+    """
+a: constant(uint256) = 1
+
+interface A:
+    def f(a: uint128): view
+    """,
+    # no namespace collision of storage variable after interface
+    """
+interface A:
+    def f(a: uint256): view
+
+a: constant(uint128) = 1
+    """,
 ]
 
 
 @pytest.mark.parametrize("good_code", valid_list)
 def test_interfaces_success(good_code):
     assert compiler.compile_code(good_code) is not None
```

### Comparing `vyper-0.3.7/tests/parser/syntax/test_invalids.py` & `vyper-0.3.8/tests/parser/syntax/test_invalids.py`

 * *Files 2% similar despite different names*

```diff
@@ -359,14 +359,21 @@
 @external
 def a():
     x: int128 = StructX({y: 1})
 """,
     UnknownAttribute,
 )
 
+must_fail(
+    """
+a: HashMap
+""",
+    StructureException,
+)
+
 
 @pytest.mark.parametrize("bad_code,exception_type", fail_list)
 def test_compilation_fails_with_exception(bad_code, exception_type):
     with pytest.raises(exception_type):
         compiler.compile_code(bad_code)
```

### Comparing `vyper-0.3.7/tests/parser/syntax/test_keccak256.py` & `vyper-0.3.8/tests/parser/syntax/test_keccak256.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/parser/syntax/test_len.py` & `vyper-0.3.8/tests/parser/syntax/test_len.py`

 * *Files 1% similar despite different names*

```diff
@@ -16,15 +16,14 @@
     return len(inp)
     """,
 ]
 
 
 @pytest.mark.parametrize("bad_code", fail_list)
 def test_block_fail(bad_code):
-
     if isinstance(bad_code, tuple):
         with raises(bad_code[1]):
             compiler.compile_code(bad_code[0])
     else:
         with raises(TypeMismatch):
             compiler.compile_code(bad_code)
```

### Comparing `vyper-0.3.7/tests/parser/syntax/test_list.py` & `vyper-0.3.8/tests/parser/syntax/test_list.py`

 * *Files 1% similar despite different names*

```diff
@@ -227,15 +227,14 @@
         TypeMismatch,
     ),
 ]
 
 
 @pytest.mark.parametrize("bad_code,exc", fail_list)
 def test_block_fail(bad_code, exc):
-
     with pytest.raises(exc):
         compiler.compile_code(bad_code)
 
 
 valid_list = [
     """
 @external
@@ -299,13 +298,19 @@
     """,
     """
 b: decimal[5]
 @external
 def foo():
     self.b[0] = 7.0
     """,
+    """
+@external
+def foo():
+    for i in [[], []]:
+        pass
+    """,
 ]
 
 
 @pytest.mark.parametrize("good_code", valid_list)
 def test_list_success(good_code):
     assert compiler.compile_code(good_code) is not None
```

### Comparing `vyper-0.3.7/tests/parser/syntax/test_logging.py` & `vyper-0.3.8/tests/parser/syntax/test_logging.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 import pytest
 
 from vyper import compiler
-from vyper.exceptions import InvalidType, TypeMismatch
+from vyper.exceptions import InvalidType, StructureException, TypeMismatch
 
 fail_list = [
     """
 event Bar:
     _value: int128[4]
 
 x: decimal[4]
@@ -35,14 +35,29 @@
         InvalidType,
     ),
 ]
 
 
 @pytest.mark.parametrize("bad_code", fail_list)
 def test_logging_fail(bad_code):
-
     if isinstance(bad_code, tuple):
         with pytest.raises(bad_code[1]):
             compiler.compile_code(bad_code[0])
     else:
         with pytest.raises(TypeMismatch):
             compiler.compile_code(bad_code)
+
+
+@pytest.mark.parametrize("mutability", ["@pure", "@view"])
+@pytest.mark.parametrize("visibility", ["@internal", "@external"])
+def test_logging_from_non_mutable(mutability, visibility):
+    code = f"""
+event Test:
+    n: uint256
+
+{visibility}
+{mutability}
+def test():
+    log Test(1)
+    """
+    with pytest.raises(StructureException):
+        compiler.compile_code(code)
```

### Comparing `vyper-0.3.7/tests/parser/syntax/test_msg_data.py` & `vyper-0.3.8/tests/parser/syntax/test_msg_data.py`

 * *Files 2% similar despite different names*

```diff
@@ -38,21 +38,21 @@
     data: Bytes[36] = slice(msg.data, 0, 36)
     return data
 """
     contract = get_contract(code)
 
     # 2fbebd38000000000000000000000000000000000000000000000000000000000000002a
     method_id = keccak(text="foo(uint256)").hex()[2:10]  # 2fbebd38
-    encoded_42 = w3.toBytes(42).hex()  # 2a
+    encoded_42 = w3.to_bytes(42).hex()  # 2a
     expected_result = method_id + "00" * 31 + encoded_42
 
     assert contract.foo(42).hex() == expected_result
 
 
-@pytest.mark.parametrize("bar", [0, 1, 42, 2 ** 256 - 1])
+@pytest.mark.parametrize("bar", [0, 1, 42, 2**256 - 1])
 def test_calldata_private(get_contract, bar):
     code = """
 @external
 def foo(bar: uint256) -> uint256:
     data: Bytes[32] = slice(msg.data, 4, 32)
     return convert(data, uint256)
     """
@@ -69,15 +69,15 @@
     b: Bytes[4] = slice(msg.data, 0, 4)
     c: uint256 = max_value(uint256)
 
     return (a, b, c)
 """
     contract = get_contract(code)
 
-    assert contract.foo() == [2 ** 256 - 1, bytes(keccak(text="foo()")[:4]), 2 ** 256 - 1]
+    assert contract.foo() == [2**256 - 1, bytes(keccak(text="foo()")[:4]), 2**256 - 1]
 
 
 def test_assignment_to_storage(w3, get_contract, keccak):
     code = """
 cache: public(Bytes[4])
 
 @external
@@ -128,14 +128,24 @@
     bar: uint256 = convert(msg.data, uint256)
     return bar
     """,
         StructureException,
     ),
     (
         """
+a: HashMap[Bytes[10], uint256]
+
+@external
+def foo():
+    self.a[msg.data] += 1
+    """,
+        StructureException,
+    ),
+    (
+        """
 @external
 def foo(bar: uint256) -> bytes32:
     ret_val: bytes32 = slice(msg.data, 4, 32)
     return ret_val
     """,
         TypeMismatch,
     ),
```

### Comparing `vyper-0.3.7/tests/parser/syntax/test_nested_list.py` & `vyper-0.3.8/tests/parser/syntax/test_nested_list.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/parser/syntax/test_no_none.py` & `vyper-0.3.8/tests/parser/syntax/test_no_none.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/parser/syntax/test_print.py` & `vyper-0.3.8/tests/parser/syntax/test_print.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/parser/syntax/test_raw_call.py` & `vyper-0.3.8/tests/parser/syntax/test_raw_call.py`

 * *Files 0% similar despite different names*

```diff
@@ -34,15 +34,14 @@
         InvalidType,
     ),
 ]
 
 
 @pytest.mark.parametrize("bad_code,exc", fail_list)
 def test_raw_call_fail(bad_code, exc):
-
     with pytest.raises(exc):
         compiler.compile_code(bad_code)
 
 
 valid_list = [
     """
 @external
```

### Comparing `vyper-0.3.7/tests/parser/syntax/test_return_tuple.py` & `vyper-0.3.8/tests/parser/syntax/test_return_tuple.py`

 * *Files 1% similar despite different names*

```diff
@@ -12,15 +12,14 @@
     return "test", 123
     """
 ]
 
 
 @pytest.mark.parametrize("bad_code", fail_list)
 def test_tuple_return_fail(bad_code):
-
     with pytest.raises(FunctionDeclarationException):
         compiler.compile_code(bad_code)
 
 
 def test_self_call_in_return_tuple(get_contract):
     code = """
 @internal
```

### Comparing `vyper-0.3.7/tests/parser/syntax/test_self_balance.py` & `vyper-0.3.8/tests/parser/syntax/test_self_balance.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/parser/syntax/test_selfdestruct.py` & `vyper-0.3.8/tests/parser/syntax/test_selfdestruct.py`

 * *Files 16% similar despite different names*

```diff
@@ -10,15 +10,14 @@
     selfdestruct(7)
     """
 ]
 
 
 @pytest.mark.parametrize("bad_code", fail_list)
 def test_block_fail(bad_code):
-
     with pytest.raises(InvalidType):
         compiler.compile_code(bad_code)
 
 
 valid_list = [
     """
 @external
```

### Comparing `vyper-0.3.7/tests/parser/syntax/test_send.py` & `vyper-0.3.8/tests/parser/syntax/test_send.py`

 * *Files 15% similar despite different names*

```diff
@@ -54,14 +54,52 @@
 
 @external
 def foo():
     send(0x1234567890123456789012345678901234567890, self.x)
     """,
         TypeMismatch,
     ),
+    # Tests for sending gas stipend
+    (
+        """
+@external
+def foo():
+    send(0x1234567890123456789012345678901234567890, 5, gas=1.5)
+    """,
+        InvalidType,
+    ),
+    (
+        """
+@external
+def foo():
+    send(0x1234567890123456789012345678901234567890, 5, gas=-2)
+    """,
+        InvalidType,
+    ),
+    (
+        """
+x: int128
+
+@external
+def foo():
+    send(0x1234567890123456789012345678901234567890, 5, gas=self.x)
+    """,
+        TypeMismatch,
+    ),
+    (
+        """
+x: decimal
+
+@external
+def foo():
+    send(0x1234567890123456789012345678901234567890, 5, gas=self.x)
+    """,
+        TypeMismatch,
+    ),
+    # End tests for sending gas stipend
 ]
 
 
 @pytest.mark.parametrize("bad_code,exc", fail_list)
 def test_send_fail(bad_code, exc):
     with pytest.raises(exc):
         compiler.compile_code(bad_code)
@@ -105,13 +143,27 @@
     send(0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe, 1)
 
 @external
 @payable
 def foo():
     self.send(msg.sender, msg.value)
     """,
+    """
+#Test send gas stipend
+@external
+def foo():
+    send(0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe, 5, gas=5000)
+    """,
+    """
+x: uint256
+
+#Test send gas stipend
+@external
+def foo():
+    send(0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe, 5, gas=self.x)
+    """,
 ]
 
 
 @pytest.mark.parametrize("good_code", valid_list)
 def test_block_success(good_code):
     assert compiler.compile_code(good_code) is not None
```

### Comparing `vyper-0.3.7/tests/parser/syntax/test_slice.py` & `vyper-0.3.8/tests/parser/syntax/test_slice.py`

 * *Files 1% similar despite different names*

```diff
@@ -29,15 +29,14 @@
         InvalidType,
     ),
 ]
 
 
 @pytest.mark.parametrize("bad_code,exc", fail_list)
 def test_slice_fail(bad_code, exc):
-
     with pytest.raises(exc):
         compiler.compile_code(bad_code)
 
 
 valid_list = [
     """
 @external
```

### Comparing `vyper-0.3.7/tests/parser/syntax/test_structs.py` & `vyper-0.3.8/tests/parser/syntax/test_structs.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 import pytest
 
 from vyper import compiler
 from vyper.exceptions import (
+    InstantiationException,
     InvalidType,
-    NamespaceCollision,
     StructureException,
     TypeMismatch,
     UnknownAttribute,
     VariableDeclarationException,
 )
 
 fail_list = [
@@ -294,15 +294,15 @@
         """
 struct C:
     c: int128
 struct Nom:
     a: HashMap[int128, C]
     b: int128
     """,
-        StructureException,
+        InstantiationException,
     ),
     """
 struct C1:
     c: int128
 struct C2:
     c: decimal
 struct Mom:
@@ -417,27 +417,32 @@
 def foo():
     x: int128 = self.b[0]
     """,
         StructureException,
     ),
     (
         """
-struct X:
-    bar: int128
-    decimal: int128
+struct Foo:
+    a: uint256
+
+@external
+def foo():
+    Foo({a: 1})
     """,
-        NamespaceCollision,
+        StructureException,
     ),
     (
         """
-struct B:
-    num: int128
-    address: address
+event Foo:
+    a: uint256
+
+struct Bar:
+    a: Foo
     """,
-        NamespaceCollision,
+        InstantiationException,
     ),
 ]
 
 
 @pytest.mark.parametrize("bad_code", fail_list)
 def test_block_fail(bad_code):
     if isinstance(bad_code, tuple):
```

### Comparing `vyper-0.3.7/tests/parser/syntax/test_tuple_assign.py` & `vyper-0.3.8/tests/parser/syntax/test_tuple_assign.py`

 * *Files 7% similar despite different names*

```diff
@@ -86,14 +86,33 @@
     assert d == 123
     return a, b, c
     """,
         ImmutableViolation,
     ),
     (
         """
+B: immutable(uint256)
+
+@external
+def __init__(b: uint256):
+    B = b
+
+@internal
+def foo() -> (uint256, uint256):
+    return (1, 2)
+
+@external
+def bar():
+    a: uint256 = 1
+    a, B = self.foo()
+    """,
+        ImmutableViolation,
+    ),
+    (
+        """
 x: public(uint256)
 
 @internal
 @view
 def return_two() -> (uint256, uint256):
     return 1, 2
```

### Comparing `vyper-0.3.7/tests/parser/syntax/test_unbalanced_return.py` & `vyper-0.3.8/tests/parser/syntax/test_unbalanced_return.py`

 * *Files 6% similar despite different names*

```diff
@@ -60,14 +60,44 @@
         selfdestruct(sender)
         _sender: address = sender
     else:
         return False
     """,
         StructureException,
     ),
+    (
+        """
+@internal
+def foo() -> bool:
+    raw_revert(b"vyper")
+    return True
+    """,
+        StructureException,
+    ),
+    (
+        """
+@internal
+def foo() -> bool:
+    raw_revert(b"vyper")
+    x: uint256 = 3
+    """,
+        StructureException,
+    ),
+    (
+        """
+@internal
+def foo(x: uint256) -> bool:
+    if x == 2:
+        raw_revert(b"vyper")
+        a: uint256 = 3
+    else:
+        return False
+    """,
+        StructureException,
+    ),
 ]
 
 
 @pytest.mark.parametrize("bad_code,exc", fail_list)
 def test_return_mismatch(bad_code, exc):
     with pytest.raises(exc):
         compiler.compile_code(bad_code)
@@ -122,13 +152,21 @@
             x = keccak256(x)
             return 1
     else:
         x = keccak256(x)
         return 1
     return 1
     """,
+    """
+@external
+def foo() -> int128:
+    if True:
+        return 123
+    else:
+        raw_revert(b"vyper")
+    """,
 ]
 
 
 @pytest.mark.parametrize("good_code", valid_list)
 def test_return_success(good_code):
     assert compiler.compile_code(good_code) is not None
```

### Comparing `vyper-0.3.7/tests/parser/syntax/utils/test_event_names.py` & `vyper-0.3.8/tests/parser/syntax/utils/test_event_names.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 import pytest
 from pytest import raises
 
 from vyper import compiler
-from vyper.exceptions import NamespaceCollision, StructureException, SyntaxException, UnknownType
+from vyper.exceptions import InvalidType, NamespaceCollision, StructureException, SyntaxException
 
 fail_list = [  # noqa: E122
     (
         """
 event ssign:
     variable: int128
 
@@ -79,15 +79,15 @@
     (
         """
 event Transfer:
     _from: i.dexed(address)
     _to: indexed(address)
     lue: uint256
     """,
-        UnknownType,
+        InvalidType,
     ),
 ]
 
 
 @pytest.mark.parametrize("bad_code,exc", fail_list)
 def test_varname_validity_fail(bad_code, exc):
     with raises(exc):
```

### Comparing `vyper-0.3.7/tests/parser/syntax/utils/test_function_names.py` & `vyper-0.3.8/tests/parser/syntax/utils/test_function_names.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,43 +1,31 @@
 import pytest
 from pytest import raises
 
 from vyper import compiler
 from vyper.exceptions import NamespaceCollision, StructureException
 
-fail_list = [  # noqa: E122
+fail_list = [
     """
 @external
 def 1qwerty(i: int128) -> int128:
     temp_var : int128 = i
     return temp_var
     """,
     """
 @external
-def int128(i: int128) -> int128:
-    temp_var : int128 = i
-    return temp_var
-    """,
-    """
-@external
-def decimal(i: int128) -> int128:
+def false(i: int128) -> int128:
     temp_var : int128 = i
     return temp_var
     """,
     """
 @external
 def wei(i: int128) -> int128:
     temp_var : int128 = i
-    return temp_var
-    """,
-    """
-@external
-def false(i: int128) -> int128:
-    temp_var : int128 = i
-    return temp_var
+    return temp_var1
     """,
 ]
 
 
 @pytest.mark.parametrize("bad_code", fail_list)
 def test_varname_validity_fail(bad_code):
     with raises((StructureException, NamespaceCollision)):
@@ -59,13 +47,39 @@
     """,
     """
 @external
 def first1(i: int128) -> int128:
     _var123 : int128 = i
     return _var123
     """,
+    """
+@external
+def int128(i: int128) -> int128:
+    temp_var : int128 = i
+    return temp_var
+    """,
+    """
+@external
+def decimal(i: int128) -> int128:
+    temp_var : int128 = i
+    return temp_var
+    """,
+    """
+@external
+def floor():
+    pass
+    """,
+    """
+@internal
+def append():
+    pass
+
+@external
+def foo():
+    self.append()
+    """,
 ]
 
 
 @pytest.mark.parametrize("good_code", valid_list)
 def test_varname_validity_success(good_code):
     assert compiler.compile_code(good_code) is not None
```

### Comparing `vyper-0.3.7/tests/parser/syntax/utils/test_variable_names.py` & `vyper-0.3.8/tests/parser/syntax/utils/test_variable_names.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/parser/types/numbers/test_constants.py` & `vyper-0.3.8/tests/parser/types/numbers/test_constants.py`

 * *Files 6% similar despite different names*

```diff
@@ -44,31 +44,31 @@
 
     assert c.test_empty_bytes32(b"\x00" * 32) is True
     assert c.test_empty_bytes32(b"\x0F" * 32) is False
 
     assert c.test_zaddress("0x0000000000000000000000000000000000000000") is True
     assert c.test_zaddress("0x0000000000000000000000000000000000000012") is False
 
-    assert c.test_int128(2 ** 127 - 1) == [True, False]
-    assert c.test_int128(-(2 ** 127)) == [False, True]
+    assert c.test_int128(2**127 - 1) == [True, False]
+    assert c.test_int128(-(2**127)) == [False, True]
     assert c.test_int128(0) == [False, False]
 
     assert c.test_decimal(Decimal("18707220957835557353007165858768422651595.9365500927")) == [
         True,
         False,
     ]
     assert c.test_decimal(Decimal("-18707220957835557353007165858768422651595.9365500928")) == [
         False,
         True,
     ]
     assert c.test_decimal(Decimal("0.1")) == [False, False]
 
-    assert c.test_uint256(2 ** 256 - 1) is True
+    assert c.test_uint256(2**256 - 1) is True
 
-    assert c.test_arithmetic(5000) == 2 ** 127 - 1 - 5000
+    assert c.test_arithmetic(5000) == 2**127 - 1 - 5000
 
 
 def test_builtin_constants_assignment(get_contract_with_gas_estimation):
     code = """
 @external
 def foo() -> int128:
     bar: int128 = max_value(int128)
@@ -103,25 +103,25 @@
 def zoo() -> uint256:
     bar: uint256 = max_value(uint256)
     return bar
     """
 
     c = get_contract_with_gas_estimation(code)
 
-    assert c.foo() == 2 ** 127 - 1
-    assert c.goo() == -(2 ** 127)
+    assert c.foo() == 2**127 - 1
+    assert c.goo() == -(2**127)
 
     assert c.hoo() == b"\x00" * 32
 
     assert c.joo() is None
 
-    assert c.koo() == Decimal(2 ** 167 - 1) / 10 ** 10
-    assert c.loo() == Decimal(-(2 ** 167)) / 10 ** 10
+    assert c.koo() == Decimal(2**167 - 1) / 10**10
+    assert c.loo() == Decimal(-(2**167)) / 10**10
 
-    assert c.zoo() == 2 ** 256 - 1
+    assert c.zoo() == 2**256 - 1
 
 
 def test_custom_constants(get_contract):
     code = """
 X_VALUE: constant(uint256) = 33
 
 @external
@@ -204,15 +204,15 @@
     # in bytecode
     ret: uint256 = 2**SOME_CONSTANT * SOME_PRIME
     return ret
     """
 
     ir = compile_code(code, ["ir"])["ir"]
     assert search_for_sublist(
-        ir, ["mstore", [MemoryPositions.RESERVED_MEMORY], [2 ** 12 * some_prime]]
+        ir, ["mstore", [MemoryPositions.RESERVED_MEMORY], [2**12 * some_prime]]
     )
 
 
 def test_constant_lists(get_contract):
     code = """
 BYTE32_LIST: constant(bytes32[2]) = [
     0x0000000000000000000000000000000000000000000000000000000000001321,
```

### Comparing `vyper-0.3.7/tests/parser/types/numbers/test_decimals.py` & `vyper-0.3.8/tests/parser/types/numbers/test_decimals.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 import warnings
 from decimal import ROUND_DOWN, Decimal, getcontext
 
 import pytest
 
-from vyper.exceptions import DecimalOverrideException, TypeMismatch
+from vyper.exceptions import DecimalOverrideException, InvalidOperation, TypeMismatch
 from vyper.utils import DECIMAL_EPSILON, SizeLimits
 
 
 def test_decimal_override():
     getcontext().prec = 78  # setting prec to 78 is ok
 
     # consumers of vyper, even as a library, are not allowed to reduce Decimal precision
@@ -19,14 +19,34 @@
         # check warnings were issued
         assert len(w) == 1
         assert (
             str(w[-1].message) == "Changing decimals precision could have unintended side effects!"
         )
 
 
+@pytest.mark.parametrize("op", ["**", "&", "|", "^"])
+def test_invalid_ops(get_contract, assert_compile_failed, op):
+    code = f"""
+@external
+def foo(x: decimal, y: decimal) -> decimal:
+    return x {op} y
+    """
+    assert_compile_failed(lambda: get_contract(code), InvalidOperation)
+
+
+@pytest.mark.parametrize("op", ["not"])
+def test_invalid_unary_ops(get_contract, assert_compile_failed, op):
+    code = f"""
+@external
+def foo(x: decimal) -> decimal:
+    return {op} x
+    """
+    assert_compile_failed(lambda: get_contract(code), InvalidOperation)
+
+
 def quantize(x: Decimal) -> Decimal:
     return x.quantize(DECIMAL_EPSILON, rounding=ROUND_DOWN)
 
 
 def test_decimal_test(get_contract_with_gas_estimation):
     decimal_test = """
 @external
```

### Comparing `vyper-0.3.7/tests/parser/types/numbers/test_isqrt.py` & `vyper-0.3.8/tests/parser/types/numbers/test_isqrt.py`

 * *Files 1% similar despite different names*

```diff
@@ -36,15 +36,15 @@
     """
 
     c = get_contract_with_gas_estimation(code)
 
     val = 3333
     assert c.test(val) == math.isqrt(val)
 
-    val = 10 ** 17
+    val = 10**17
     assert c.test(val) == math.isqrt(val)
     assert c.test(0) == 0
 
 
 def test_isqrt_internal_variable(get_contract_with_gas_estimation):
     val = 44001
     code = f"""
@@ -71,15 +71,14 @@
     val = 1221
     assert c.test(val) == math.isqrt(val + 1)
     val = 10001
     assert c.test(val) == math.isqrt(val + 1)
 
 
 def test_isqrt_storage_internal_variable(get_contract_with_gas_estimation):
-
     val = 44444
     code = f"""
 s_var: uint256
 
 @external
 def test2() -> uint256:
     self.s_var = {val}
```

### Comparing `vyper-0.3.7/tests/parser/types/numbers/test_signed_ints.py` & `vyper-0.3.8/tests/parser/types/numbers/test_signed_ints.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,47 +1,47 @@
 import itertools
 import operator
 import random
 
 import pytest
 
-from vyper.codegen.types.types import SIGNED_INTEGER_TYPES, parse_integer_typeinfo
-from vyper.exceptions import InvalidType, OverflowException, ZeroDivisionException
-from vyper.utils import SizeLimits, evm_div, evm_mod, int_bounds
-
-PARAMS = []
-for t in sorted(SIGNED_INTEGER_TYPES):
-    info = parse_integer_typeinfo(t)
-    lo, hi = int_bounds(bits=info.bits, signed=info.is_signed)
-    PARAMS.append((t, lo, hi, info.bits))
+from vyper.exceptions import InvalidOperation, InvalidType, OverflowException, ZeroDivisionException
+from vyper.semantics.types import IntegerT
+from vyper.utils import evm_div, evm_mod
 
+types = sorted(IntegerT.signeds())
 
-@pytest.mark.parametrize("typ,lo,hi,bits", PARAMS)
-def test_exponent_base_zero(get_contract, assert_tx_failed, typ, lo, hi, bits):
+
+@pytest.mark.parametrize("typ", types)
+def test_exponent_base_zero(get_contract, assert_tx_failed, typ):
     code = f"""
 @external
 def foo(x: {typ}) -> {typ}:
     return 0 ** x
     """
+    lo, hi = typ.ast_bounds
+
     c = get_contract(code)
     assert c.foo(0) == 1
     assert c.foo(1) == 0
     assert c.foo(hi) == 0
 
     assert_tx_failed(lambda: c.foo(-1))
     assert_tx_failed(lambda: c.foo(lo))  # note: lo < 0
 
 
-@pytest.mark.parametrize("typ,lo,hi,bits", PARAMS)
-def test_exponent_base_one(get_contract, assert_tx_failed, typ, lo, hi, bits):
+@pytest.mark.parametrize("typ", types)
+def test_exponent_base_one(get_contract, assert_tx_failed, typ):
     code = f"""
 @external
 def foo(x: {typ}) -> {typ}:
     return 1 ** x
     """
+    lo, hi = typ.ast_bounds
+
     c = get_contract(code)
     assert c.foo(0) == 1
     assert c.foo(1) == 1
     assert c.foo(hi) == 1
 
     assert_tx_failed(lambda: c.foo(-1))
     assert_tx_failed(lambda: c.foo(lo))
@@ -82,49 +82,51 @@
 @external
 def foo() -> int16:
     x: int16 = -8
     y: int16 = x ** 5
     return y
     """
     c = get_contract(code)
-    assert c.foo() == -(2 ** 15)
+    assert c.foo() == -(2**15)
 
 
 @pytest.mark.parametrize("base,power", itertools.product((-2, -1, 0, 1, 2), (0, 1)))
 def test_exponent_power_zero_one(get_contract, base, power):
     # #2989
     code = f"""
 @external
 def foo() -> int256:
     x: int256 = {base}
     return x ** {power}
     """
     c = get_contract(code)
-    assert c.foo() == base ** power
+    assert c.foo() == base**power
 
 
-@pytest.mark.parametrize("typ,lo,hi,bits", PARAMS)
-def test_exponent(get_contract, assert_tx_failed, typ, lo, hi, bits):
+@pytest.mark.parametrize("typ", types)
+def test_exponent(get_contract, assert_tx_failed, typ):
     code = f"""
 @external
 def foo(x: {typ}) -> {typ}:
     return 4 ** x
     """
+    lo, hi = typ.ast_bounds
+
     c = get_contract(code)
 
     test_cases = [0, 1, 3, 4, 126, 127, -1, lo, hi]
     for x in test_cases:
-        if x * 2 >= bits or x < 0:  # out of bounds
+        if x * 2 >= typ.bits or x < 0:  # out of bounds
             assert_tx_failed(lambda: c.foo(x))
         else:
-            assert c.foo(x) == 4 ** x
+            assert c.foo(x) == 4**x
 
 
-@pytest.mark.parametrize("typ,lo,hi,bits", PARAMS)
-def test_negative_nums(get_contract_with_gas_estimation, typ, lo, hi, bits):
+@pytest.mark.parametrize("typ", types)
+def test_negative_nums(get_contract_with_gas_estimation, typ):
     negative_nums_code = f"""
 @external
 def negative_one() -> {typ}:
     return -1
 
 @external
 def negative_three() -> {typ}:
@@ -138,16 +140,18 @@
 
     c = get_contract_with_gas_estimation(negative_nums_code)
     assert c.negative_one() == -1
     assert c.negative_three() == -3
     assert c.negative_four() == -4
 
 
-@pytest.mark.parametrize("typ,lo,hi,bits", PARAMS)
-def test_num_bound(assert_tx_failed, get_contract_with_gas_estimation, typ, lo, hi, bits):
+@pytest.mark.parametrize("typ", types)
+def test_num_bound(assert_tx_failed, get_contract_with_gas_estimation, typ):
+    lo, hi = typ.ast_bounds
+
     num_bound_code = f"""
 @external
 def _num(x: {typ}) -> {typ}:
     return x
 
 @external
 def _num_add(x: {typ}, y: {typ}) -> {typ}:
@@ -185,23 +189,23 @@
 
     assert_tx_failed(lambda: c._num_add3(hi, 1, -1))
     assert c._num_add3(hi, -1, 1) == hi - 1 + 1
     assert_tx_failed(lambda: c._num_add3(lo, -1, 1))
     assert c._num_add3(lo, 1, -1) == lo + 1 - 1
 
 
-@pytest.mark.parametrize("typ,lo,hi,bits", PARAMS)
-def test_overflow_out_of_range(get_contract, assert_compile_failed, typ, lo, hi, bits):
+@pytest.mark.parametrize("typ", types)
+def test_overflow_out_of_range(get_contract, assert_compile_failed, typ):
     code = f"""
 @external
 def num_sub() -> {typ}:
-    return 1-2**{bits}
+    return 1-2**{typ.bits}
     """
 
-    if bits == 256:
+    if typ.bits == 256:
         assert_compile_failed(lambda: get_contract(code), OverflowException)
     else:
         assert_compile_failed(lambda: get_contract(code), InvalidType)
 
 
 ARITHMETIC_OPS = {
     "+": operator.add,
@@ -209,19 +213,17 @@
     "*": operator.mul,
     "/": evm_div,
     "%": evm_mod,
 }
 
 
 @pytest.mark.parametrize("op", sorted(ARITHMETIC_OPS.keys()))
-@pytest.mark.parametrize("typ,lo,hi,bits", PARAMS)
+@pytest.mark.parametrize("typ", types)
 @pytest.mark.fuzzing
-def test_arithmetic_thorough(
-    get_contract, assert_tx_failed, assert_compile_failed, op, typ, lo, hi, bits
-):
+def test_arithmetic_thorough(get_contract, assert_tx_failed, assert_compile_failed, op, typ):
     # both variables
     code_1 = f"""
 @external
 def foo(x: {typ}, y: {typ}) -> {typ}:
     return x {op} y
     """
     # right is literal
@@ -238,14 +240,15 @@
     """
     # both literals
     code_4_template = """
 @external
 def foo() -> {typ}:
     return {x} {op} {y}
     """
+    lo, hi = typ.ast_bounds
 
     fns = {"+": operator.add, "-": operator.sub, "*": operator.mul, "/": evm_div, "%": evm_mod}
     fn = fns[op]
 
     c = get_contract(code_1)
 
     # TODO refactor to use fixtures
@@ -278,17 +281,17 @@
     # with the parametrized strategy
     xs += [random.randrange(lo, hi) for _ in range(NUM_CASES)]
     ys += [random.randrange(lo, hi) for _ in range(NUM_CASES)]
 
     # edge cases that are tricky to reason about and MUST be tested
     assert lo in xs and -1 in ys
 
-    for (x, y) in itertools.product(xs, ys):
+    for x, y in itertools.product(xs, ys):
         expected = fn(x, y)
-        in_bounds = SizeLimits.in_bounds(typ, expected)
+        in_bounds = lo <= expected <= hi
 
         # safediv and safemod disallow divisor == 0
         div_by_zero = y == 0 and op in ("/", "%")
 
         ok = in_bounds and not div_by_zero
 
         code_2 = code_2_template.format(typ=typ, op=op, y=y)
@@ -319,25 +322,26 @@
     ">=": operator.ge,
     "<": operator.lt,
     "<=": operator.le,
 }
 
 
 @pytest.mark.parametrize("op", sorted(COMPARISON_OPS.keys()))
-@pytest.mark.parametrize("typ,lo,hi,bits", PARAMS)
+@pytest.mark.parametrize("typ", types)
 @pytest.mark.fuzzing
-def test_comparators(get_contract, op, typ, lo, hi, bits):
+def test_comparators(get_contract, op, typ):
     code_1 = f"""
 @external
 def foo(x: {typ}, y: {typ}) -> bool:
     return x {op} y
     """
 
-    fn = COMPARISON_OPS[op]
+    lo, hi = typ.ast_bounds
 
+    fn = COMPARISON_OPS[op]
     c = get_contract(code_1)
 
     # note: constant folding is tested in tests/ast/folding
     special_cases = [
         lo,
         lo + 1,
         lo // 2,
@@ -361,25 +365,38 @@
     ys = special_cases.copy()
 
     for x, y in itertools.product(xs, ys):
         expected = fn(x, y)
         assert c.foo(x, y) is expected
 
 
-@pytest.mark.parametrize("typ,lo,hi,bits", PARAMS)
-def test_negation(get_contract, assert_tx_failed, typ, lo, hi, bits):
+@pytest.mark.parametrize("typ", types)
+def test_negation(get_contract, assert_tx_failed, typ):
     code = f"""
 @external
 def foo(a: {typ}) -> {typ}:
     return -a
     """
 
+    lo, hi = typ.ast_bounds
+
     c = get_contract(code)
 
     assert c.foo(hi) == lo + 1
     assert c.foo(-1) == 1
     assert c.foo(1) == -1
     assert c.foo(0) == 0
     assert c.foo(2) == -2
     assert c.foo(-2) == 2
 
     assert_tx_failed(lambda: c.foo(lo))
+
+
+@pytest.mark.parametrize("typ", types)
+@pytest.mark.parametrize("op", ["not"])
+def test_invalid_unary_ops(get_contract, assert_compile_failed, typ, op):
+    code = f"""
+@external
+def foo(a: {typ}) -> {typ}:
+    return {op} a
+    """
+    assert_compile_failed(lambda: get_contract(code), InvalidOperation)
```

### Comparing `vyper-0.3.7/tests/parser/types/numbers/test_sqrt.py` & `vyper-0.3.8/tests/parser/types/numbers/test_sqrt.py`

 * *Files 2% similar despite different names*

```diff
@@ -139,28 +139,28 @@
 
 @pytest.mark.fuzzing
 @hypothesis.given(
     value=hypothesis.strategies.decimals(
         min_value=Decimal(0), max_value=Decimal(SizeLimits.MAX_INT128), places=DECIMAL_PLACES
     )
 )
-@hypothesis.example(Decimal(SizeLimits.MAX_INT128))
-@hypothesis.example(Decimal(0))
+@hypothesis.example(value=Decimal(SizeLimits.MAX_INT128))
+@hypothesis.example(value=Decimal(0))
 @hypothesis.settings(deadline=1000)
 def test_sqrt_valid_range(sqrt_contract, value):
     vyper_sqrt = sqrt_contract.test(value)
     actual_sqrt = decimal_sqrt(value)
     assert vyper_sqrt == actual_sqrt
 
 
 @pytest.mark.fuzzing
 @hypothesis.given(
     value=hypothesis.strategies.decimals(
         min_value=Decimal(SizeLimits.MIN_INT128), max_value=Decimal("-1E10"), places=DECIMAL_PLACES
     )
 )
 @hypothesis.settings(deadline=400)
-@hypothesis.example(Decimal(SizeLimits.MIN_INT128))
-@hypothesis.example(Decimal("-1E10"))
+@hypothesis.example(value=Decimal(SizeLimits.MIN_INT128))
+@hypothesis.example(value=Decimal("-1E10"))
 def test_sqrt_invalid_range(sqrt_contract, value):
     with pytest.raises(TransactionFailed):
         sqrt_contract.test(value)
```

### Comparing `vyper-0.3.7/tests/parser/types/numbers/test_unsigned_ints.py` & `vyper-0.3.8/tests/parser/types/test_enum.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,255 +1,295 @@
-import itertools
-import operator
-import random
+def test_values_should_be_increasing_ints(get_contract):
+    code = """
+enum Action:
+    BUY
+    SELL
+    CANCEL
 
-import pytest
-
-from vyper.codegen.types.types import UNSIGNED_INTEGER_TYPES, parse_integer_typeinfo
-from vyper.exceptions import InvalidType, OverflowException, ZeroDivisionException
-from vyper.utils import SizeLimits, evm_div, evm_mod, int_bounds
-
-PARAMS = []
-for t in sorted(UNSIGNED_INTEGER_TYPES):
-    info = parse_integer_typeinfo(t)
-    lo, hi = int_bounds(bits=info.bits, signed=info.is_signed)
-    PARAMS.append((t, lo, hi, info.bits))
+@external
+@view
+def buy() -> Action:
+    return Action.BUY
 
+@external
+@view
+def sell() -> Action:
+    return Action.SELL
 
-@pytest.mark.parametrize("typ,lo,hi,bits", PARAMS)
-def test_exponent_base_zero(get_contract, typ, lo, hi, bits):
-    code = f"""
 @external
-def foo(x: {typ}) -> {typ}:
-    return 0 ** x
+@view
+def cancel() -> Action:
+    return Action.CANCEL
     """
     c = get_contract(code)
-    assert c.foo(0) == 1
-    assert c.foo(1) == 0
-    assert c.foo(42) == 0
-    assert c.foo(hi) == 0
+    assert c.buy() == 1
+    assert c.sell() == 2
+    assert c.cancel() == 4
+
+
+def test_enum_storage(get_contract):
+    code = """
+enum Actions:
+    BUY
+    SELL
+    CANCEL
 
+action: public(Actions)
 
-@pytest.mark.parametrize("typ,lo,hi,bits", PARAMS)
-def test_exponent_base_one(get_contract, typ, lo, hi, bits):
-    code = f"""
 @external
-def foo(x: {typ}) -> {typ}:
-    return 1 ** x
+def set_and_get(a: Actions) -> Actions:
+    self.action = a
+    return self.action
     """
     c = get_contract(code)
-    assert c.foo(0) == 1
-    assert c.foo(1) == 1
-    assert c.foo(42) == 1
-    assert c.foo(hi) == 1
+    for i in range(5):
+        assert c.set_and_get(i) == i
+        c.set_and_get(i, transact={})
+        assert c.action() == i
 
 
-@pytest.mark.parametrize("typ,lo,hi,bits", PARAMS)
-def test_exponent_power_zero(get_contract, typ, lo, hi, bits):
-    # #2984
-    code = f"""
+def test_eq_neq(get_contract):
+    code = """
+enum Roles:
+    USER
+    STAFF
+    ADMIN
+    MANAGER
+    CEO
+
+@external
+def is_boss(a: Roles) -> bool:
+    return a == Roles.CEO
+
 @external
-def foo(x: {typ}) -> {typ}:
-    return x ** 0
+def is_not_boss(a: Roles) -> bool:
+    return a != Roles.CEO
     """
     c = get_contract(code)
-    assert c.foo(0) == 1
-    assert c.foo(1) == 1
-    assert c.foo(42) == 1
-    assert c.foo(hi) == 1
 
+    for i in range(4):
+        assert c.is_boss(2**i) is False
+        assert c.is_not_boss(2**i) is True
+
+    assert c.is_boss(2**4) is True
+    assert c.is_not_boss(2**4) is False
+
+
+def test_bitwise(get_contract, assert_tx_failed):
+    code = """
+enum Roles:
+    USER
+    STAFF
+    ADMIN
+    MANAGER
+    CEO
 
-@pytest.mark.parametrize("typ,lo,hi,bits", PARAMS)
-def test_exponent_power_one(get_contract, typ, lo, hi, bits):
-    # #2984
-    code = f"""
 @external
-def foo(x: {typ}) -> {typ}:
-    return x ** 1
-    """
-    c = get_contract(code)
-    assert c.foo(0) == 0
-    assert c.foo(1) == 1
-    assert c.foo(42) == 42
-    assert c.foo(hi) == hi
+def bor() -> Roles:
+    return Roles.USER | Roles.CEO
 
+@external
+def band() -> Roles:
+    c: Roles = Roles.USER | Roles.CEO
+    return c & Roles.USER
 
-ARITHMETIC_OPS = {
-    "+": operator.add,
-    "-": operator.sub,
-    "*": operator.mul,
-    "/": evm_div,
-    "%": evm_mod,
-}
+@external
+def bxor() -> Roles:
+    c: Roles = Roles.USER | Roles.CEO
+    return c ^ Roles.USER
 
+@external
+def binv() -> Roles:
+    c: Roles = Roles.USER
+    return ~c
 
-@pytest.mark.parametrize("op", sorted(ARITHMETIC_OPS.keys()))
-@pytest.mark.parametrize("typ,lo,hi,bits", PARAMS)
-@pytest.mark.fuzzing
-def test_arithmetic_thorough(
-    get_contract, assert_tx_failed, assert_compile_failed, op, typ, lo, hi, bits
-):
-    # both variables
-    code_1 = f"""
 @external
-def foo(x: {typ}, y: {typ}) -> {typ}:
-    return x {op} y
-    """
-    # right is literal
-    code_2_template = """
+def bor_arg(a: Roles, b: Roles) -> Roles:
+    return a | b
+
 @external
-def foo(x: {typ}) -> {typ}:
-    return x {op} {y}
-    """
-    # left is literal
-    code_3_template = """
+def band_arg(a: Roles, b: Roles) -> Roles:
+    return a & b
+
 @external
-def foo(y: {typ}) -> {typ}:
-    return {x} {op} y
-    """
-    # both literals
-    code_4_template = """
+def bxor_arg(a: Roles, b: Roles) -> Roles:
+    return a ^ b
+
 @external
-def foo() -> {typ}:
-    return {x} {op} {y}
+def binv_arg(a: Roles) -> Roles:
+    return ~a
     """
+    c = get_contract(code)
+    assert c.bor() == 17
+    assert c.band() == 1
+    assert c.bxor() == 16
 
-    c = get_contract(code_1)
+    assert c.bor_arg(0b00001, 0b00100) == 0b00001 | 0b00100 == 0b00101
+    # LHS: USER | ADMIN | CEO; RHS: USER | MANAGER | CEO
+    assert c.band_arg(0b10101, 0b11001) == 0b10101 & 0b11001 == 0b10001
 
-    fn = ARITHMETIC_OPS[op]
+    assert c.bxor_arg(0b10101, 0b11001) == 0b10101 ^ 0b11001 == 0b01100
 
-    special_cases = [0, 1, 2, 3, hi // 2 - 1, hi // 2, hi // 2 + 1, hi - 2, hi - 1, hi]
-    xs = special_cases.copy()
-    ys = special_cases.copy()
-    NUM_CASES = 5
-    # poor man's fuzzing - hypothesis doesn't make it easy
-    # with the parametrized strategy
-    xs += [random.randrange(lo, hi) for _ in range(NUM_CASES)]
-    ys += [random.randrange(lo, hi) for _ in range(NUM_CASES)]
+    assert c.binv_arg(0b01101) == ~0b01101 % 32 == 0b10010
+    assert c.binv_arg(0b11111) == 0b00000
+    assert c.binv_arg(0b00000) == 0b11111
 
-    # mirror signed integer tests
-    assert 2 ** (bits - 1) in xs and (2 ** bits) - 1 in ys
+    # LHS is out of bound
+    assert_tx_failed(lambda: c.bor_arg(32, 3))
+    assert_tx_failed(lambda: c.band_arg(32, 3))
+    assert_tx_failed(lambda: c.bxor_arg(32, 3))
+    assert_tx_failed(lambda: c.binv_arg(32))
 
-    for (x, y) in itertools.product(xs, ys):
-        expected = fn(x, y)
-        in_bounds = SizeLimits.in_bounds(typ, expected)
-        # safediv and safemod disallow divisor == 0
-        div_by_zero = y == 0 and op in ("/", "%")
+    # RHS
+    assert_tx_failed(lambda: c.bor_arg(3, 32))
+    assert_tx_failed(lambda: c.band_arg(3, 32))
+    assert_tx_failed(lambda: c.bxor_arg(3, 32))
 
-        ok = in_bounds and not div_by_zero
 
-        code_2 = code_2_template.format(typ=typ, op=op, y=y)
-        code_3 = code_3_template.format(typ=typ, op=op, x=x)
-        code_4 = code_4_template.format(typ=typ, op=op, x=x, y=y)
+def test_augassign_storage(get_contract, w3, assert_tx_failed):
+    code = """
+enum Roles:
+    ADMIN
+    MINTER
 
-        if ok:
-            assert c.foo(x, y) == expected
-            assert get_contract(code_2).foo(x) == expected
-            assert get_contract(code_3).foo(y) == expected
-            assert get_contract(code_4).foo() == expected
-        elif div_by_zero:
-            assert_tx_failed(lambda: c.foo(x, y))
-            assert_compile_failed(lambda: get_contract(code_2), ZeroDivisionException)
-            assert_tx_failed(lambda: get_contract(code_3).foo(y))
-            assert_compile_failed(lambda: get_contract(code_4), ZeroDivisionException)
-        else:
-            assert_tx_failed(lambda: c.foo(x, y))
-            assert_tx_failed(lambda: get_contract(code_2).foo(x))
-            assert_tx_failed(lambda: get_contract(code_3).foo(y))
-            assert_compile_failed(lambda: get_contract(code_4), (InvalidType, OverflowException))
+roles: public(HashMap[address, Roles])
 
+@external
+def __init__():
+    self.roles[msg.sender] = Roles.ADMIN
+
+@external
+def addMinter(minter: address):
+    assert self.roles[msg.sender] in Roles.ADMIN
+    self.roles[minter] |= Roles.MINTER
 
-COMPARISON_OPS = {
-    "==": operator.eq,
-    "!=": operator.ne,
-    ">": operator.gt,
-    ">=": operator.ge,
-    "<": operator.lt,
-    "<=": operator.le,
-}
+@external
+def revokeMinter(minter: address):
+    assert self.roles[msg.sender] in Roles.ADMIN
+    self.roles[minter] &= ~Roles.MINTER
 
+@external
+def flipMinter(minter: address):
+    assert self.roles[msg.sender] in Roles.ADMIN
+    self.roles[minter] ^= Roles.MINTER
 
-@pytest.mark.parametrize("op", sorted(COMPARISON_OPS.keys()))
-@pytest.mark.parametrize("typ,lo,hi,bits", PARAMS)
-@pytest.mark.fuzzing
-def test_comparators(get_contract, op, typ, lo, hi, bits):
-    code_1 = f"""
 @external
-def foo(x: {typ}, y: {typ}) -> bool:
-    return x {op} y
+def checkMinter(minter: address):
+    assert Roles.MINTER in self.roles[minter]
     """
+    c = get_contract(code)
 
-    fn = COMPARISON_OPS[op]
+    # check admin
+    admin_address = w3.eth.accounts[0]
+    minter_address = w3.eth.accounts[1]
 
-    c = get_contract(code_1)
+    # add minter
+    c.addMinter(minter_address, transact={})
+    c.checkMinter(minter_address)
 
-    # note: constant folding is tested in tests/ast/folding
+    assert c.roles(admin_address) == 0b01
+    assert c.roles(minter_address) == 0b10
 
-    special_cases = [0, 1, 2, 3, hi // 2 - 1, hi // 2, hi // 2 + 1, hi - 2, hi - 1, hi]
-    xs = special_cases.copy()
-    ys = special_cases.copy()
+    # admin is not a minter
+    assert_tx_failed(lambda: c.checkMinter(admin_address))
 
-    for x, y in itertools.product(xs, ys):
-        expected = fn(x, y)
-        assert c.foo(x, y) is expected
+    c.addMinter(admin_address, transact={})
 
+    # now, admin is a minter
+    assert c.roles(admin_address) == 0b11
+    c.checkMinter(admin_address)
+
+    # revoke minter
+    c.revokeMinter(admin_address, transact={})
+    assert c.roles(admin_address) == 0b01
+    assert_tx_failed(lambda: c.checkMinter(admin_address))
+
+    # flip minter
+    c.flipMinter(admin_address, transact={})
+    assert c.roles(admin_address) == 0b11
+    c.checkMinter(admin_address)
+
+    # flip minter
+    c.flipMinter(admin_address, transact={})
+    assert c.roles(admin_address) == 0b01
+    assert_tx_failed(lambda: c.checkMinter(admin_address))
+
+
+def test_in_enum(get_contract_with_gas_estimation):
+    code = """
+enum Roles:
+    USER
+    STAFF
+    ADMIN
+    MANAGER
+    CEO
 
-# TODO move to tests/parser/functions/test_mulmod.py and test_addmod.py
-def test_uint256_mod(assert_tx_failed, get_contract_with_gas_estimation):
-    uint256_code = """
 @external
-def _uint256_addmod(x: uint256, y: uint256, z: uint256) -> uint256:
-    return uint256_addmod(x, y, z)
+def foo() -> bool:
+    return Roles.USER in (Roles.USER | Roles.ADMIN)
 
 @external
-def _uint256_mulmod(x: uint256, y: uint256, z: uint256) -> uint256:
-    return uint256_mulmod(x, y, z)
+def bar(a: Roles) -> bool:
+    return a in (Roles.USER | Roles.ADMIN)
+
+@external
+def bar2(a: Roles) -> bool:
+    return a not in (Roles.USER | Roles.ADMIN)
+
+@external
+def baz(a: Roles) -> bool:
+    x: Roles = Roles.USER | Roles.ADMIN | Roles.CEO
+    y: Roles = x ^ (Roles.MANAGER | Roles.CEO)  # flip off CEO, flip on MANAGER
+    return a in (x & y)
+
     """
+    c = get_contract_with_gas_estimation(code)
+    assert c.foo() is True
 
-    c = get_contract_with_gas_estimation(uint256_code)
+    # CEO MANAGER ADMIN STAFF USER
+    #   1       1     1     1    1
 
-    assert c._uint256_addmod(1, 2, 2) == 1
-    assert c._uint256_addmod(32, 2, 32) == 2
-    assert c._uint256_addmod((2 ** 256) - 1, 0, 2) == 1
-    assert c._uint256_addmod(2 ** 255, 2 ** 255, 6) == 4
-    assert_tx_failed(lambda: c._uint256_addmod(1, 2, 0))
-    assert c._uint256_mulmod(3, 1, 2) == 1
-    assert c._uint256_mulmod(200, 3, 601) == 600
-    assert c._uint256_mulmod(2 ** 255, 1, 3) == 2
-    assert c._uint256_mulmod(2 ** 255, 2, 6) == 4
-    assert_tx_failed(lambda: c._uint256_mulmod(2, 2, 0))
+    assert c.bar(0b00001) is True  # Roles.USER should pass
+    assert c.bar(0b00010) is False  # Roles.STAFF should fail
 
+    assert c.bar2(0b00001) is False  # Roles.USER should fail
+    assert c.bar2(0b00010) is True  # Roles.STAFF should pass
 
-def test_uint256_modmul(get_contract_with_gas_estimation):
-    modexper = """
-@external
-def exponential(base: uint256, exponent: uint256, modulus: uint256) -> uint256:
-    o: uint256 = 1
-    for i in range(256):
-        o = uint256_mulmod(o, o, modulus)
-        if exponent & shift(1, 255 - i) != 0:
-            o = uint256_mulmod(o, base, modulus)
-    return o
-    """
+    assert c.baz(0b00001) is True  # Roles.USER should pass
+    assert c.baz(0b00100) is True  # Roles.ADMIN should pass
+    assert c.baz(0b01000) is False  # Roles.MANAGER should fail
 
-    c = get_contract_with_gas_estimation(modexper)
-    assert c.exponential(3, 5, 100) == 43
-    assert c.exponential(2, 997, 997) == 2
 
+def test_struct_with_enum(get_contract_with_gas_estimation):
+    code = """
+enum Foobar:
+    FOO
+    BAR
+
+struct Foo:
+    a: uint256
+    b: Foobar
 
-@pytest.mark.parametrize("typ,lo,hi,bits", PARAMS)
-def test_uint_literal(get_contract, assert_compile_failed, typ, lo, hi, bits):
-    good_cases = [0, 1, 2, 3, hi // 2 - 1, hi // 2, hi // 2 + 1, hi - 1, hi]
-    bad_cases = [-1, -2, -3, -hi // 2, -hi + 1, -hi]
-    code_template = """
 @external
-def test() -> {typ}:
-    o: {typ} = {val}
-    return o
+def get_enum_from_struct() -> Foobar:
+    f: Foo = Foo({a: 1, b: Foobar.BAR})
+    return f.b
     """
+    c = get_contract_with_gas_estimation(code)
+    assert c.get_enum_from_struct() == 2
+
+
+def test_mapping_with_enum(get_contract_with_gas_estimation):
+    code = """
+enum Foobar:
+    FOO
+    BAR
 
-    for val in good_cases:
-        c = get_contract(code_template.format(typ=typ, val=val))
-        assert c.test() == val
+fb: HashMap[Foobar, uint256]
 
-    for val in bad_cases:
-        assert_compile_failed(lambda: get_contract(code_template.format(typ=typ, val=val)))
+@external
+def get_key(f: Foobar, i: uint256) -> uint256:
+    self.fb[f] = i
+    return self.fb[f]
+    """
+    c = get_contract_with_gas_estimation(code)
+    assert c.get_key(1, 777) == 777
```

### Comparing `vyper-0.3.7/tests/parser/types/test_bytes.py` & `vyper-0.3.8/tests/parser/types/test_bytes.py`

 * *Files 1% similar despite different names*

```diff
@@ -194,15 +194,15 @@
     """
 
     c = get_contract_with_gas_estimation(bytes_to_num_code)
 
     assert c.getsome() == b"\x0e"
     assert c.testsome(b"a")
     assert c.testsome(b"\x61")
-    assert c.testsome(0b1100001 .to_bytes(1, "big"))
+    assert c.testsome(0b1100001.to_bytes(1, "big"))
     assert not c.testsome(b"b")
     assert c.testsome_storage(b"a")
     assert not c.testsome_storage(b"x")
 
 
 def test_bytes_comparison(get_contract_with_gas_estimation):
     code = """
@@ -251,30 +251,29 @@
     return l == {vyper_literal}
     """
 
     c = get_contract(code)
 
     assert c.test() is True
     assert c.test2() is True
-    assert c.test2(val) is True
+    assert c.test2(vyper_literal) is True
 
 
 def test_zero_padding_with_private(get_contract):
     code = """
 counter: uint256
 
 @internal
 @view
 def to_little_endian_64(_value: uint256) -> Bytes[8]:
     y: uint256 = 0
     x: uint256 = _value
     for _ in range(8):
-        y = shift(y, 8)
-        y = y + (x & 255)
-        x = shift(x, -8)
+        y = (y << 8) | (x & 255)
+        x >>= 8
     return slice(convert(y, bytes32), 24, 8)
 
 @external
 def set_count(i: uint256):
     self.counter = i
 
 @external
```

### Comparing `vyper-0.3.7/tests/parser/types/test_bytes_literal.py` & `vyper-0.3.8/tests/parser/types/test_bytes_literal.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/parser/types/test_bytes_zero_padding.py` & `vyper-0.3.8/tests/parser/types/test_bytes_zero_padding.py`

 * *Files 5% similar despite different names*

```diff
@@ -7,28 +7,27 @@
     code = """
 @internal
 @view
 def to_little_endian_64(_value: uint256) -> Bytes[8]:
     y: uint256 = 0
     x: uint256 = _value
     for _ in range(8):
-        y = shift(y, 8)
-        y = y + (x & 255)
-        x = shift(x, -8)
+        y = (y << 8) | (x & 255)
+        x >>= 8
     return slice(convert(y, bytes32), 24, 8)
 
 @external
 @view
 def get_count(counter: uint256) -> Bytes[24]:
     return self.to_little_endian_64(counter)
     """
     c = get_contract_module(code)
     return c
 
 
 @pytest.mark.fuzzing
-@hypothesis.given(value=hypothesis.strategies.integers(min_value=0, max_value=2 ** 64))
+@hypothesis.given(value=hypothesis.strategies.integers(min_value=0, max_value=2**64))
 @hypothesis.settings(deadline=400)
 def test_zero_pad_range(little_endian_contract, value):
     actual_bytes = value.to_bytes(8, byteorder="little")
     contract_bytes = little_endian_contract.get_count(value)
     assert contract_bytes == actual_bytes
```

### Comparing `vyper-0.3.7/tests/parser/types/test_dynamic_array.py` & `vyper-0.3.8/tests/parser/types/test_dynamic_array.py`

 * *Files 7% similar despite different names*

```diff
@@ -98,14 +98,19 @@
     assert c.foo4([["hello", "world"]]) == "hello"
     assert c.foo5() == ["hello", "world"]
     assert c.foo6() == [["hello", "world"]]
 
 
 def test_list_output_tester_code(get_contract_with_gas_estimation):
     list_output_tester_code = """
+enum Foobar:
+    FOO
+    BAR
+
+y: DynArray[Foobar, 2]
 z: DynArray[int128, 2]
 
 @external
 def foo() -> DynArray[int128, 2]:
     return [3, 5]
 
 @external
@@ -176,14 +181,28 @@
 @external
 def qoo(inp: DynArray[int128, 2]) -> DynArray[DynArray[int128, 2], 2]:
     return [inp, [3,4]]
 
 @external
 def roo(inp: DynArray[decimal, 2]) -> DynArray[DynArray[decimal, 2], 2]:
     return [inp, [3.0, 4.0]]
+
+@external
+def soo() -> DynArray[Foobar, 2]:
+    x: DynArray[Foobar, 2] = [Foobar.FOO, Foobar.BAR]
+    return x
+
+@external
+def too() -> DynArray[Foobar, 2]:
+    self.y = [Foobar.BAR, Foobar.FOO]
+    return self.y
+
+@external
+def uoo(inp: DynArray[Foobar, 2]) -> DynArray[DynArray[Foobar, 2], 2]:
+    return [inp, [Foobar.BAR, Foobar.FOO]]
     """
 
     c = get_contract_with_gas_estimation(list_output_tester_code)
     assert c.foo() == [3, 5]
     assert c.goo() == [3, 5]
     assert c.hoo() == [3, 5]
     assert c.hoo1() == c.hoo2() == c.hoo3() == c.hoo4() == []
@@ -196,14 +215,17 @@
     assert c.noo([3, 5]) == [3, 5]
     assert c.ooo([]) == []
     assert c.ooo([3, 5]) == [3, 5]
     assert c.poo([]) == []
     assert c.poo([[1, 2], [3, 4]]) == [[1, 2], [3, 4]]
     assert c.qoo([1, 2]) == [[1, 2], [3, 4]]
     assert c.roo([1, 2]) == [[1.0, 2.0], [3.0, 4.0]]
+    assert c.soo() == [1, 2]
+    assert c.too() == [2, 1]
+    assert c.uoo([1, 2]) == [[1, 2], [2, 1]]
 
     print("Passed list output tests")
 
 
 def test_array_accessor(get_contract_with_gas_estimation):
     array_accessor = """
 @external
@@ -504,33 +526,14 @@
     assert c.check1("0x0000000000000000000000000000000000000036") is False
 
     assert c.check2("0x0000000000000000000000000000000000000036") is True
     assert c.check2("0x0000000000000000000000000000000000000048") is True
     assert c.check2("0x0000000000000000000000000000000000000024") is False
 
 
-(
-    "bytes32",
-    [
-        [
-            b"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\xac\\x58\\xca",  # noqa: E501
-            b"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\xac\\x58\\xcb",  # noqa: E501
-        ],
-        [
-            b"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\xac\\x58\\xcc",  # noqa: E501
-            b"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\xac\\x58\\xcd",  # noqa: E501
-        ],
-    ],
-    [
-        b"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\xac\\x58\\xcc",  # noqa: E501,
-        b"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\xac\\x58\\xce",  # noqa: E501
-    ],
-),
-
-
 def test_member_in_nested_bytes32_list(get_contract_with_gas_estimation):
     code = """
 @external
 def check1(a: bytes32) -> bool:
     x: DynArray[DynArray[bytes32, 2], 2] = [
         [
             0x0000000000000000000000000000000000000000000000000000000080ac58ca,
@@ -1086,15 +1089,15 @@
     x.append({data[2]})
     return x
     """
     c = get_contract(code)
     assert c.foo() == data
 
 
-@pytest.mark.parametrize("subtyp,lit", [("uint8", 256), ("uint256", -1), ("int128", 2 ** 127)])
+@pytest.mark.parametrize("subtyp,lit", [("uint8", 256), ("uint256", -1), ("int128", 2**127)])
 def test_append_invalid_literal(get_contract, assert_compile_failed, subtyp, lit):
     code = f"""
 @external
 def foo() -> DynArray[{subtyp}, 3]:
     x: DynArray[{subtyp}, 3] = []
     x.append({lit})
     return x
@@ -1223,29 +1226,39 @@
         lambda x: None,
     ),
 ]
 
 
 @pytest.mark.parametrize("code_template,check_result", append_pop_complex_tests)
 @pytest.mark.parametrize(
-    "subtype", ["uint256[3]", "DynArray[uint256,3]", "DynArray[uint8, 4]", "Foo"]
+    "subtype",
+    ["uint256[3]", "DynArray[uint256,3]", "DynArray[uint8, 4]", "Foo", "DynArray[Foobar, 3]"],
 )
 # TODO change this to fuzz random data
 def test_append_pop_complex(get_contract, assert_tx_failed, code_template, check_result, subtype):
     code = code_template.format(typ=subtype)
     test_data = [1, 2, 3]
     if subtype == "Foo":
         test_data = tuple(test_data)
         struct_def = """
 struct Foo:
     x: uint256
     y: uint256
     z: uint256
         """
         code = struct_def + "\n" + code
+    elif subtype == "DynArray[Foobar, 3]":
+        enum_def = """
+enum Foobar:
+    FOO
+    BAR
+    BAZ
+        """
+        code = enum_def + "\n" + code
+        test_data = [2 ** (i - 1) for i in test_data]
 
     c = get_contract(code)
     expected_result = check_result(test_data)
     if expected_result is None:
         # None is sentinel to indicate txn should revert
         assert_tx_failed(lambda: c.foo(test_data))
     else:
@@ -1275,28 +1288,35 @@
     """
     c = get_contract(code)
     assert c.foo() == [666, [1, 2, 3], [88, 12]]
 
 
 def test_list_of_structs_arg(get_contract):
     code = """
+enum Foobar:
+    FOO
+    BAR
+
 struct Foo:
     x: uint256
     y: uint256
+    z: Foobar
 
 @external
 def bar(_baz: DynArray[Foo, 3]) -> uint256:
     sum: uint256 = 0
     for i in range(3):
-        sum += _baz[i].x * _baz[i].y
+        e: Foobar = _baz[i].z
+        f: uint256 = convert(e, uint256)
+        sum += _baz[i].x * _baz[i].y + f
     return sum
     """
     c = get_contract(code)
-    c_input = [[x, y] for x, y in zip(range(3), range(3))]
-    assert c.bar(c_input) == 5  # 0 * 0 + 1 * 1 + 2 * 2
+    c_input = [[x, y, 1] for x, y in zip(range(3), range(3))]
+    assert c.bar(c_input) == 8  # (0 * 0 + 1) + (1 * 1 + 1) + (2 * 2 + 1)
 
 
 def test_list_of_structs_arg_with_dynamic_type(get_contract):
     code = """
 struct Foo:
     x: uint256
     _msg: String[32]
@@ -1541,18 +1561,19 @@
 @internal
 def _foo2() -> Foo:
     _nF1: nestedFoo = self._foo()
     return Foo({b1: [[[_nF1, _nF1], [_nF1, _nF1]], [[_nF1, _nF1], [_nF1, _nF1]]]})
 
 @internal
 def _foo3(f: Foo) -> Foo:
-    f.b1[0][1][0].a1[0][0] = [0, 0]
-    f.b1[1][0][0].a1[0][1] = [0, 0]
-    f.b1[1][1][0].a1[1][1] = [0, 0]
-    return f
+    new_f: Foo = f
+    new_f.b1[0][1][0].a1[0][0] = [0, 0]
+    new_f.b1[1][0][0].a1[0][1] = [0, 0]
+    new_f.b1[1][1][0].a1[1][1] = [0, 0]
+    return new_f
 
 @external
 def bar() -> DynArray[DynArray[DynArray[uint256, 2], 2], 2]:
     foo: Foo = self._foo2()
     return self._foo3(foo).b1[1][1][0].a1
 
 @external
@@ -1664,14 +1685,15 @@
     """
     c = get_contract(code)
     assert c.foo() == val
 
 
 # TODO test negative public(DynArray) cases?
 
+
 # CMC 2022-08-04 these are blocked due to typechecker bug; leaving as
 # negative tests so we know if/when the typechecker is fixed.
 # (don't consider it a high priority to fix since membership in
 # in empty list literal seems like something we should plausibly
 # reject at compile-time anyway)
 def test_empty_list_membership_fail(get_contract, assert_compile_failed):
     code = """
@@ -1722,7 +1744,99 @@
 MY_CONSTANT: constant(DynArray[{storage_type}, 3]) = [1, 2, 3]
 
 @external
 def foo(i: uint256) -> {return_type}:
     return MY_CONSTANT[i]
     """
     assert_compile_failed(lambda: get_contract(code), TypeMismatch)
+
+
+dynarray_length_no_clobber_cases = [
+    # GHSA-3p37-3636-q8wv cases
+    """
+a: DynArray[uint256,3]
+
+@external
+def should_revert() -> DynArray[uint256,3]:
+    self.a = [1,2,3]
+    self.a = empty(DynArray[uint256,3])
+    self.a = [self.a[0], self.a[1], self.a[2]]
+
+    return self.a  # if bug: returns [1,2,3]
+    """,
+    """
+@external
+def should_revert() -> DynArray[uint256,3]:
+    self.a()
+    return self.b() # if bug: returns [1,2,3]
+
+@internal
+def a():
+    a: uint256 = 0
+    b: uint256 = 1
+    c: uint256 = 2
+    d: uint256 = 3
+
+@internal
+def b() -> DynArray[uint256,3]:
+    a: DynArray[uint256,3] = empty(DynArray[uint256,3])
+    a = [a[0],a[1],a[2]]
+    return a
+    """,
+    """
+a: DynArray[uint256,4]
+
+@external
+def should_revert() -> DynArray[uint256,4]:
+    self.a = [1,2,3]
+    self.a = empty(DynArray[uint256,4])
+    self.a = [4, self.a[0]]
+
+    return self.a  # if bug: return [4, 4]
+    """,
+    """
+@external
+def should_revert() -> DynArray[uint256,4]:
+    a: DynArray[uint256, 4] = [1,2,3]
+    a = []
+
+    a = [a.pop()]  # if bug: return [1]
+
+    return a
+    """,
+    """
+@external
+def should_revert():
+    c: DynArray[uint256, 1] = []
+    c.append(c[0])
+    """,
+    """
+@external
+def should_revert():
+    c: DynArray[uint256, 1] = [1]
+    c[0] = c.pop()
+    """,
+    """
+@external
+def should_revert():
+    c: DynArray[DynArray[uint256, 1], 2] = [[]]
+    c[0] = c.pop()
+    """,
+    """
+a: DynArray[String[65],2]
+
+@external
+def should_revert() -> DynArray[String[65], 2]:
+    self.a = ["hello", "world"]
+    self.a = []
+    self.a = [self.a[0], self.a[1]]
+
+    return self.a  # if bug: return ["hello", "world"]
+    """,
+]
+
+
+@pytest.mark.parametrize("code", dynarray_length_no_clobber_cases)
+def test_dynarray_length_no_clobber(get_contract, assert_tx_failed, code):
+    # check that length is not clobbered before dynarray data copy happens
+    c = get_contract(code)
+    assert_tx_failed(lambda: c.should_revert())
```

### Comparing `vyper-0.3.7/tests/parser/types/test_identifier_naming.py` & `vyper-0.3.8/tests/parser/types/test_identifier_naming.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,21 +1,19 @@
 import pytest
 
 from vyper.ast.folding import BUILTIN_CONSTANTS
-from vyper.builtin_functions import BUILTIN_FUNCTIONS
+from vyper.builtins.functions import BUILTIN_FUNCTIONS
 from vyper.codegen.expr import ENVIRONMENT_VARIABLES
 from vyper.exceptions import NamespaceCollision, StructureException, SyntaxException
 from vyper.semantics.namespace import RESERVED_KEYWORDS
-from vyper.utils import FUNCTION_WHITELIST
+from vyper.semantics.types.primitives import AddressT
 
+BUILTIN_CONSTANTS = set(BUILTIN_CONSTANTS.keys())
 ALL_RESERVED_KEYWORDS = (
-    set(BUILTIN_CONSTANTS.keys())
-    .union(BUILTIN_FUNCTIONS)
-    .union(RESERVED_KEYWORDS)
-    .union(ENVIRONMENT_VARIABLES)
+    BUILTIN_CONSTANTS | BUILTIN_FUNCTIONS | RESERVED_KEYWORDS | ENVIRONMENT_VARIABLES
 )
 
 
 @pytest.mark.parametrize("constant", sorted(ALL_RESERVED_KEYWORDS))
 def test_reserved_keywords_memory(constant, get_contract, assert_compile_failed):
     code = f"""
 @external
@@ -43,19 +41,31 @@
     pass
     """
     assert_compile_failed(
         lambda: get_contract(code), (SyntaxException, StructureException, NamespaceCollision)
     )
 
 
-RESERVED_KEYWORDS_NOT_WHITELISTED = sorted(ALL_RESERVED_KEYWORDS.difference(FUNCTION_WHITELIST))
+SELF_NAMESPACE_MEMBERS = set(AddressT._type_members.keys())
+DISALLOWED_FN_NAMES = SELF_NAMESPACE_MEMBERS | RESERVED_KEYWORDS | BUILTIN_CONSTANTS
+ALLOWED_FN_NAMES = ALL_RESERVED_KEYWORDS - DISALLOWED_FN_NAMES
 
 
-@pytest.mark.parametrize("constant", sorted(RESERVED_KEYWORDS_NOT_WHITELISTED))
-def test_reserved_keywords_fns(constant, get_contract, assert_compile_failed):
+@pytest.mark.parametrize("constant", sorted(ALLOWED_FN_NAMES))
+def test_reserved_keywords_fns_pass(constant, get_contract, assert_compile_failed):
+    code = f"""
+@external
+def {constant}(var: int128):
+    pass
+    """
+    assert get_contract(code) is not None
+
+
+@pytest.mark.parametrize("constant", sorted(DISALLOWED_FN_NAMES))
+def test_reserved_keywords_fns_fail(constant, get_contract, assert_compile_failed):
     code = f"""
 @external
 def {constant}(var: int128):
     pass
     """
     assert_compile_failed(
         lambda: get_contract(code), (SyntaxException, StructureException, NamespaceCollision)
```

### Comparing `vyper-0.3.7/tests/parser/types/test_lists.py` & `vyper-0.3.8/tests/parser/types/test_lists.py`

 * *Files 4% similar despite different names*

```diff
@@ -648,20 +648,20 @@
 
 
 @pytest.mark.parametrize(
     "type,value",
     [
         ("decimal", [5.0, 11.0, 17.0, 29.0, 37.0, 41.0]),
         ("uint8", [0, 1, 17, 250, 255, 2]),
-        ("int128", [0, -1, 1, -(2 ** 127), 2 ** 127 - 1, -50]),
-        ("int256", [0, -1, 1, -(2 ** 255), 2 ** 255 - 1, -50]),
-        ("uint256", [0, 1, 2 ** 8, 2 ** 255 + 1, 2 ** 256 - 1, 100]),
+        ("int128", [0, -1, 1, -(2**127), 2**127 - 1, -50]),
+        ("int256", [0, -1, 1, -(2**255), 2**255 - 1, -50]),
+        ("uint256", [0, 1, 2**8, 2**255 + 1, 2**256 - 1, 100]),
         (
             "uint256",
-            [2 ** 255 + 1, 2 ** 255 + 2, 2 ** 255 + 3, 2 ** 255 + 4, 2 ** 255 + 5, 2 ** 255 + 6],
+            [2**255 + 1, 2**255 + 2, 2**255 + 3, 2**255 + 4, 2**255 + 5, 2**255 + 6],
         ),
         ("bool", [True, False, True, False, True, False]),
     ],
 )
 def test_constant_list(get_contract, assert_tx_failed, type, value):
     code = f"""
 MY_LIST: constant({type}[{len(value)}]) = {value}
@@ -672,14 +672,26 @@
     c = get_contract(code)
     for i, p in enumerate(value):
         assert c.ix(i) == p
     # assert oob
     assert_tx_failed(lambda: c.ix(len(value) + 1))
 
 
+def test_nested_constant_list_accessor(get_contract):
+    code = """
+@external
+def foo() -> bool:
+    f: uint256 = 1
+    a: bool = 1 == [1,2,4][f] + -1
+    return a
+    """
+    c = get_contract(code)
+    assert c.foo() is True
+
+
 # Would be nice to put this somewhere accessible, like in vyper.types or something
 integer_types = ["uint8", "int128", "int256", "uint256"]
 
 
 @pytest.mark.parametrize("storage_type,return_type", itertools.permutations(integer_types, 2))
 def test_constant_list_fail(get_contract, assert_compile_failed, storage_type, return_type):
     code = f"""
@@ -741,28 +753,45 @@
     c = get_contract(code)
     for i, p in enumerate(some_good_address):
         assert c.ix(i) == p
     # assert oob
     assert_tx_failed(lambda: c.ix(len(some_good_address) + 1))
 
 
+def test_list_index_complex_expr(get_contract, assert_tx_failed):
+    # test subscripts where the index is not a literal
+    code = """
+@external
+def foo(xs: uint256[257], i: uint8) -> uint256:
+    return xs[i + 1]
+    """
+    c = get_contract(code)
+    xs = [i + 1 for i in range(257)]
+
+    for ix in range(255):
+        assert c.foo(xs, ix) == xs[ix + 1]
+
+    # safemath should fail for uint8: 255 + 1.
+    assert_tx_failed(lambda: c.foo(xs, 255))
+
+
 @pytest.mark.parametrize(
     "type,value",
     [
         ("decimal", [[5.0, 11.0], [17.0, 29.0], [37.0, 41.0]]),
         ("uint8", [[0, 1], [17, 250], [255, 2]]),
-        ("int128", [[0, -1], [1, -(2 ** 127)], [2 ** 127 - 1, -50]]),
-        ("int256", [[0, -1], [1, -(2 ** 255)], [2 ** 255 - 1, -50]]),
-        ("uint256", [[0, 1], [2 ** 8, 2 ** 255 + 1], [2 ** 256 - 1, 100]]),
+        ("int128", [[0, -1], [1, -(2**127)], [2**127 - 1, -50]]),
+        ("int256", [[0, -1], [1, -(2**255)], [2**255 - 1, -50]]),
+        ("uint256", [[0, 1], [2**8, 2**255 + 1], [2**256 - 1, 100]]),
         (
             "uint256",
             [
-                [2 ** 255 + 1, 2 ** 255 + 2],
-                [2 ** 255 + 3, 2 ** 255 + 4],
-                [2 ** 255 + 5, 2 ** 255 + 6],
+                [2**255 + 1, 2**255 + 2],
+                [2**255 + 3, 2**255 + 4],
+                [2**255 + 5, 2**255 + 6],
             ],
         ),
         ("bool", [[True, False], [True, False], [True, False]]),
     ],
 )
 def test_constant_nested_list(get_contract, assert_tx_failed, type, value):
     code = f"""
```

### Comparing `vyper-0.3.7/tests/parser/types/test_string.py` & `vyper-0.3.8/tests/parser/types/test_string.py`

 * *Files 0% similar despite different names*

```diff
@@ -52,17 +52,17 @@
 @external
 def get(k: String[34]) -> int128:
     return self.mapped_string[k]
     """
 
     c = get_contract(code)
 
-    c.set(b"a" * 34, 6789, transact={"gas": 10 ** 6})
+    c.set("a" * 34, 6789, transact={"gas": 10**6})
 
-    assert c.get(b"a" * 34) == 6789
+    assert c.get("a" * 34) == 6789
 
 
 def test_string_slice(get_contract_with_gas_estimation, assert_tx_failed):
     test_slice4 = """
 @external
 def foo(inp: String[10], start: uint256, _len: uint256) -> String[10]:
     return slice(inp, start, _len)
@@ -148,15 +148,14 @@
     c2 = get_contract_with_gas_estimation(contract_2)
 
     assert c1.out_literals() == [1, "0x0000000000000000000000000000000000000123", "random"]
     assert c2.test(c1.address) == [1, "0x0000000000000000000000000000000000000123", "random"]
 
 
 def test_default_arg_string(get_contract_with_gas_estimation):
-
     code = """
 @external
 def test(a: uint256, b: String[50] = "foo") -> Bytes[100]:
     return concat(
         convert(a, bytes32),
         convert(b, Bytes[50])
     )
```

### Comparing `vyper-0.3.7/tests/parser/types/test_string_literal.py` & `vyper-0.3.8/tests/parser/types/test_string_literal.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/parser/types/value/test_as_wei_value.py` & `vyper-0.3.8/tests/parser/types/value/test_as_wei_value.py`

 * *Files 6% similar despite different names*

```diff
@@ -28,50 +28,50 @@
 @external
 def foo(a: uint256) -> uint256:
     return as_wei_value(a, "{denom}")
     """
 
     c = get_contract(code)
 
-    value = (2 ** 256 - 1) // (10 ** multiplier)
-    assert c.foo(value) == value * (10 ** multiplier)
+    value = (2**256 - 1) // (10**multiplier)
+    assert c.foo(value) == value * (10**multiplier)
 
-    value = (2 ** 256 - 1) // (10 ** (multiplier - 1))
+    value = (2**256 - 1) // (10 ** (multiplier - 1))
     assert_tx_failed(lambda: c.foo(value))
 
 
 @pytest.mark.parametrize("denom,multiplier", wei_denoms.items())
 def test_wei_int128(get_contract, assert_tx_failed, denom, multiplier):
     code = f"""
 @external
 def foo(a: int128) -> uint256:
     return as_wei_value(a, "{denom}")
     """
 
     c = get_contract(code)
-    value = (2 ** 127 - 1) // (10 ** multiplier)
+    value = (2**127 - 1) // (10**multiplier)
 
-    assert c.foo(value) == value * (10 ** multiplier)
+    assert c.foo(value) == value * (10**multiplier)
 
 
 @pytest.mark.parametrize("denom,multiplier", wei_denoms.items())
 def test_wei_decimal(get_contract, assert_tx_failed, denom, multiplier):
     code = f"""
 @external
 def foo(a: decimal) -> uint256:
     return as_wei_value(a, "{denom}")
     """
 
     c = get_contract(code)
-    value = Decimal((2 ** 127 - 1) / (10 ** multiplier))
+    value = Decimal((2**127 - 1) / (10**multiplier))
 
-    assert c.foo(value) == value * (10 ** multiplier)
+    assert c.foo(value) == value * (10**multiplier)
 
 
-@pytest.mark.parametrize("value", (-1, -(2 ** 127)))
+@pytest.mark.parametrize("value", (-1, -(2**127)))
 @pytest.mark.parametrize("data_type", ["decimal", "int128"])
 def test_negative_value_reverts(get_contract, assert_tx_failed, value, data_type):
     code = f"""
 @external
 def foo(a: {data_type}) -> uint256:
     return as_wei_value(a, "ether")
     """
```

### Comparing `vyper-0.3.7/tests/signatures/test_method_id_conflicts.py` & `vyper-0.3.8/tests/signatures/test_method_id_conflicts.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tests/test_utils.py` & `vyper-0.3.8/tests/test_utils.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/tox.ini` & `vyper-0.3.8/tox.ini`

 * *Files 6% similar despite different names*

```diff
@@ -1,58 +1,57 @@
 [tox]
 envlist =
-    py{38,39,310}-{core,no-opt}
+    py{310,311}-{core,no-opt}
     lint
     mypy
     docs
 
 [testenv]
 usedevelop = True
 commands =
     core: pytest -m "not fuzzing" --showlocals {posargs:tests/}
     no-opt: pytest -m "not fuzzing" --showlocals --no-optimize {posargs:tests/}
 basepython =
-    py38: python3.8
-    py39: python3.9
     py310: python3.10
+    py311: python3.11
 extras =
     test
 whitelist_externals = make
 
 [testenv:docs]
-basepython=python3.8
+basepython=python3
 deps =
     sphinx
     sphinx_rtd_theme
     recommonmark
 commands =
     sphinx-build {posargs:-E} -b html docs dist/docs -n -q --color
 
 [testenv:fuzzing]
-basepython = python3.8
+basepython = python3
 commands =
     pytest -m fuzzing {posargs:tests/}
 extras =
     test
 whitelist_externals = make
 
 [testenv:memory]
-basepython = python3.8
+basepython = python3
 commands =
     pytest --memorymock {posargs:tests/}
 extras =
     test
 whitelist_externals = make
 
 [testenv:lint]
-basepython = python3.8
+basepython = python3
 extras = lint
 commands =
-    black -C -t py38 {toxinidir}/vyper {toxinidir}/tests {toxinidir}/setup.py
+    black -C -t py311 {toxinidir}/vyper {toxinidir}/tests {toxinidir}/setup.py
     flake8 {toxinidir}/vyper {toxinidir}/tests
     isort {toxinidir}/vyper {toxinidir}/tests {toxinidir}/setup.py
 
 [testenv:mypy]
-basepython = python3.8
+basepython = python3
 extras = lint
 commands =
     mypy --install-types --non-interactive --follow-imports=silent --ignore-missing-imports --disallow-incomplete-defs -p vyper
```

### Comparing `vyper-0.3.7/vyper/__init__.py` & `vyper-0.3.8/vyper/__init__.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/vyper/__main__.py` & `vyper-0.3.8/vyper/__main__.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,15 +1,14 @@
 #!/usr/bin/env python3
 # -*- coding: UTF-8 -*-
 import sys
 
 from vyper.cli import vyper_compile, vyper_ir, vyper_serve
 
 if __name__ == "__main__":
-
     allowed_subcommands = ("--vyper-compile", "--vyper-ir", "--vyper-serve")
 
     if len(sys.argv) <= 1 or sys.argv[1] not in allowed_subcommands:
         # default (no args, no switch in first arg): run vyper_compile
         vyper_compile._parse_cli_args()
     else:
         # pop switch and forward args to subcommand
```

### Comparing `vyper-0.3.7/vyper/abi_types.py` & `vyper-0.3.8/vyper/abi_types.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/vyper/address_space.py` & `vyper-0.3.8/vyper/evm/address_space.py`

 * *Files 7% similar despite different names*

```diff
@@ -44,14 +44,15 @@
 #     return 32
 # # implement more properties...
 #
 # MEMORY = Memory()
 
 MEMORY = AddrSpace("memory", 32, "mload", "mstore")
 STORAGE = AddrSpace("storage", 1, "sload", "sstore")
+TRANSIENT = AddrSpace("transient", 1, "tload", "tstore")
 CALLDATA = AddrSpace("calldata", 32, "calldataload")
 # immutables address space: "immutables" section of memory
 # which is read-write in deploy code but then gets turned into
 # the "data" section of the runtime code
 IMMUTABLES = AddrSpace("immutables", 32, "iload", "istore")
 # data addrspace: "data" section of runtime code, read-only.
 DATA = AddrSpace("data", 32, "dload")
```

### Comparing `vyper-0.3.7/vyper/ast/README.md` & `vyper-0.3.8/vyper/ast/README.md`

 * *Files 1% similar despite different names*

```diff
@@ -95,15 +95,15 @@
 
 Node classes in make use of `__slots__` for additional type safety. Denying the
 creation of `__dict__` in node classes ensures that unwanted fields cannot be
 silently included in the nodes.
 
 To learn more about `__slots__`:
 
-* Python Documentation: [`__slots__`](https://docs.python.org/3.8/reference/datamodel.html#slots)
+* Python Documentation: [`__slots__`](https://docs.python.org/3.10/reference/datamodel.html#slots)
 * Stack Overflow: [Usage of `__slots__`?](https://stackoverflow.com/a/28059785/11451521)
 
 ### Interface Files (`.pyi`)
 
 This module makes use of Python interface files ("stubs") to aid in MyPy type
 annotation.
```

### Comparing `vyper-0.3.7/vyper/ast/annotation.py` & `vyper-0.3.8/vyper/ast/annotation.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 import ast as python_ast
 import tokenize
 from decimal import Decimal
-from typing import Optional
+from typing import Optional, cast
 
 import asttokens
 
 from vyper.exceptions import CompilerPanic, SyntaxException
 from vyper.typing import ModificationOffsets
 
 
@@ -175,15 +175,15 @@
 
     def visit_Num(self, node):
         """
         Adjust numeric node class based on the value type.
 
         Python uses `Num` to represent floats and integers. Integers may also
         be given in binary, octal, decimal, or hexadecimal format. This method
-        modifies `ast_type` to seperate `Num` into more granular Vyper node
+        modifies `ast_type` to separate `Num` into more granular Vyper node
         classes.
         """
         # modify vyper AST type according to the format of the literal value
         self.generic_visit(node)
         value = node.node_source_code
 
         # deduce non base-10 types based on prefix
@@ -226,19 +226,14 @@
         """
         Adjust operand value and discard unary operations, where possible.
 
         This is done so that negative decimal literals are accurately represented.
         """
         self.generic_visit(node)
 
-        # TODO once grammar is updated, remove this
-        # UAdd has no effect on the value of it's operand, so it is discarded
-        if isinstance(node.op, python_ast.UAdd):
-            return node.operand
-
         is_sub = isinstance(node.op, python_ast.USub)
         is_num = (
             hasattr(node.operand, "n")
             and not isinstance(node.operand.n, bool)
             and isinstance(node.operand.n, (int, Decimal))
         )
         if is_sub and is_num:
@@ -270,12 +265,12 @@
         A mapping of class names to their original class types.
 
     Returns
     -------
         The annotated and optimized AST.
     """
 
-    tokens = asttokens.ASTTokens(source_code, tree=parsed_ast)
+    tokens = asttokens.ASTTokens(source_code, tree=cast(Optional[python_ast.Module], parsed_ast))
     visitor = AnnotatingVisitor(source_code, modification_offsets, tokens, source_id, contract_name)
     visitor.visit(parsed_ast)
 
     return parsed_ast
```

### Comparing `vyper-0.3.7/vyper/ast/expansion.py` & `vyper-0.3.8/vyper/ast/expansion.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,11 +1,12 @@
 import copy
 
 from vyper import ast as vy_ast
 from vyper.exceptions import CompilerPanic
+from vyper.semantics.types.function import ContractFunctionT
 
 
 def expand_annotated_ast(vyper_module: vy_ast.Module) -> None:
     """
     Perform expansion / simplification operations on an annotated Vyper AST.
 
     This pass uses annotated type information to modify the AST, simplifying
@@ -28,15 +29,15 @@
     ---------
     vyper_module : Module
         Top-level Vyper AST node.
     """
 
     for node in vyper_module.get_children(vy_ast.VariableDecl, {"is_public": True}):
         func_type = node._metadata["func_type"]
-        input_types, return_type = func_type.get_signature()
+        input_types, return_type = node._metadata["type"].getter_signature
         input_nodes = []
 
         # use the annotation node to build the input args and return type
         annotation = copy.copy(node.annotation)
 
         return_stmt: vy_ast.VyperNode
         # constants just return a value
@@ -81,14 +82,18 @@
             node.annotation,
             name=func_type.name,
             args=vy_ast.arguments(args=input_nodes, defaults=[]),
             body=[vy_ast.Return(value=return_stmt)],
             decorator_list=[vy_ast.Name(id="external"), vy_ast.Name(id="view")],
             returns=return_node,
         )
+
+        with vyper_module.namespace():
+            func_type = ContractFunctionT.from_FunctionDef(expanded)
+
         expanded._metadata["type"] = func_type
         return_node.set_parent(expanded)
         vyper_module.add_to_body(expanded)
 
 
 def remove_unused_statements(vyper_module: vy_ast.Module) -> None:
     """
@@ -104,9 +109,9 @@
     """
 
     # constant declarations - values were substituted within the AST during folding
     for node in vyper_module.get_children(vy_ast.VariableDecl, {"is_constant": True}):
         vyper_module.remove_from_body(node)
 
     # `implements: interface` statements - validated during type checking
-    for node in vyper_module.get_children(vy_ast.AnnAssign, {"target.id": "implements"}):
+    for node in vyper_module.get_children(vy_ast.ImplementsDecl):
         vyper_module.remove_from_body(node)
```

### Comparing `vyper-0.3.7/vyper/ast/folding.py` & `vyper-0.3.8/vyper/ast/folding.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,29 +1,29 @@
 import warnings
-from typing import Union
+from typing import Optional, Union
 
 from vyper.ast import nodes as vy_ast
-from vyper.builtin_functions import DISPATCH_TABLE
+from vyper.builtins.functions import DISPATCH_TABLE
 from vyper.exceptions import UnfoldableNode, UnknownType
-from vyper.semantics.types.bases import BaseTypeDefinition, DataLocation
-from vyper.semantics.types.utils import get_type_from_annotation
+from vyper.semantics.types.base import VyperType
+from vyper.semantics.types.utils import type_from_annotation
 from vyper.utils import SizeLimits
 
 BUILTIN_CONSTANTS = {
     "EMPTY_BYTES32": (
         vy_ast.Hex,
         "0x0000000000000000000000000000000000000000000000000000000000000000",
         "empty(bytes32)",
     ),  # NOQA: E501
     "ZERO_ADDRESS": (vy_ast.Hex, "0x0000000000000000000000000000000000000000", "empty(address)"),
-    "MAX_INT128": (vy_ast.Int, 2 ** 127 - 1, "max_value(int128)"),
-    "MIN_INT128": (vy_ast.Int, -(2 ** 127), "min_value(int128)"),
+    "MAX_INT128": (vy_ast.Int, 2**127 - 1, "max_value(int128)"),
+    "MIN_INT128": (vy_ast.Int, -(2**127), "min_value(int128)"),
     "MAX_DECIMAL": (vy_ast.Decimal, SizeLimits.MAX_AST_DECIMAL, "max_value(decimal)"),
     "MIN_DECIMAL": (vy_ast.Decimal, SizeLimits.MIN_AST_DECIMAL, "min_value(decimal)"),
-    "MAX_UINT256": (vy_ast.Int, 2 ** 256 - 1, "max_value(uint256)"),
+    "MAX_UINT256": (vy_ast.Int, 2**256 - 1, "max_value(uint256)"),
 }
 
 
 def fold(vyper_module: vy_ast.Module) -> None:
     """
     Perform literal folding operations on a Vyper AST.
 
@@ -177,15 +177,15 @@
         if not node.is_constant:
             # annotation is not wrapped in `constant(...)`
             continue
 
         # Extract type definition from propagated annotation
         type_ = None
         try:
-            type_ = get_type_from_annotation(node.annotation, DataLocation.UNSET)
+            type_ = type_from_annotation(node.annotation)
         except UnknownType:
             # handle user-defined types e.g. structs - it's OK to not
             # propagate the type annotation here because user-defined
             # types can be unambiguously inferred at typechecking time
             pass
 
         changed_nodes += replace_constant(
@@ -227,15 +227,15 @@
 
 
 def replace_constant(
     vyper_module: vy_ast.Module,
     id_: str,
     replacement_node: Union[vy_ast.Constant, vy_ast.List, vy_ast.Call],
     raise_on_error: bool,
-    type_: BaseTypeDefinition = None,
+    type_: Optional[VyperType] = None,
 ) -> int:
     """
     Replace references to a variable name with a literal value.
 
     Arguments
     ---------
     vyper_module : Module
@@ -243,51 +243,49 @@
     id_ : str
         String representing the `.id` attribute of the node(s) to be replaced.
     replacement_node : Constant | List | Call
         Vyper ast node representing the literal value to be substituted in.
         `Call` nodes are for struct constants.
     raise_on_error: bool
         Boolean indicating if `UnfoldableNode` exception should be raised or ignored.
-    type_ : BaseTypeDefinition, optional
+    type_ : VyperType, optional
         Type definition to be propagated to type checker.
 
     Returns
     -------
     int
         Number of nodes that were replaced.
     """
-    is_struct = False
-
-    if isinstance(replacement_node, vy_ast.Call) and len(replacement_node.args) == 1:
-        if isinstance(replacement_node.args[0], vy_ast.Dict):
-            is_struct = True
-
     changed_nodes = 0
 
     for node in vyper_module.get_descendants(vy_ast.Name, {"id": id_}, reverse=True):
         parent = node.get_ancestor()
 
         if isinstance(parent, vy_ast.Call) and node == parent.func:
-            # do not replace calls that are not structs
-            if not is_struct:
-                continue
+            # do not replace calls because splicing a constant into a callable site is
+            # never valid and it worsens the error message
+            continue
 
         # do not replace dictionary keys
         if isinstance(parent, vy_ast.Dict) and node in parent.keys:
             continue
 
         if not node.get_ancestor(vy_ast.Index):
             # do not replace left-hand side of assignments
             assign = node.get_ancestor(
                 (vy_ast.Assign, vy_ast.AnnAssign, vy_ast.AugAssign, vy_ast.VariableDecl)
             )
 
             if assign and node in assign.target.get_descendants(include_self=True):
                 continue
 
+        # do not replace enum members
+        if node.get_ancestor(vy_ast.EnumDef):
+            continue
+
         try:
             # note: _replace creates a copy of the replacement_node
             new_node = _replace(node, replacement_node, type_=type_)
         except UnfoldableNode:
             if raise_on_error:
                 raise
             continue
```

### Comparing `vyper-0.3.7/vyper/ast/grammar.lark` & `vyper-0.3.8/vyper/ast/grammar.lark`

 * *Files 3% similar despite different names*

```diff
@@ -29,26 +29,29 @@
 import_alias: _AS NAME
 ?import_list: _import_name [import_alias] ("," _import_name [import_alias] )* [","]
 _import_from: _FROM (DOT* _import_path | DOT+)
 import: _IMPORT DOT* _import_path [import_alias]
       | _import_from _IMPORT ( WILDCARD | _import_name [import_alias] )
       | _import_from _IMPORT "(" import_list ")"
 
-
 // Constant definitions
 // NOTE: Temporary until decorators used
-constant_def: NAME ":" "constant" "(" type ")" "=" _expr
+constant: "constant" "(" type ")"
+constant_private: NAME ":" constant
+constant_with_getter: NAME ":" "public" "(" constant ")"
+constant_def: (constant_private | constant_with_getter) "=" _expr
 
 // immutable definitions
 // NOTE: Temporary until decorators used
-immutable_def: NAME ":" "immutable" "(" type ")"
+immutable: "immutable" "(" type ")"
+immutable_def: NAME ":" immutable
 
 variable: NAME ":" type
 // NOTE: Temporary until decorators used
-variable_with_getter: NAME ":" "public" "(" type ")"
+variable_with_getter: NAME ":" "public" "(" (type | immutable) ")"
 variable_def: variable | variable_with_getter
 
 // A decorator "wraps" a method, modifying it's context.
 // NOTE: One or more can be applied (some combos might conflict)
 decorator: "@" NAME [ "(" [arguments] ")" ] _NEWLINE
 decorators: decorator+
 
@@ -65,27 +68,27 @@
 function_sig: _FUNC_DECL NAME "(" [parameters] ")" [returns]
 function_def: [decorators] function_sig ":" body
 
 // Events can be composed of 0 or more members
 _EVENT_DECL: "event"
 event_member: NAME ":" type
 indexed_event_arg: NAME ":" "indexed" "(" type ")"
-event_body: _NEWLINE _INDENT ((variable | indexed_event_arg) _NEWLINE)+ _DEDENT
+event_body: _NEWLINE _INDENT ((event_member | indexed_event_arg) _NEWLINE)+ _DEDENT
 // Events which use no args use a pass statement instead
 event_def: _EVENT_DECL NAME ":" ( event_body | _PASS )
 
 // Enums
 _ENUM_DECL: "enum"
 enum_member: NAME
 enum_body: _NEWLINE _INDENT (enum_member _NEWLINE)+ _DEDENT
 enum_def: _ENUM_DECL NAME ":" enum_body
 
 // Types
-array_def: (NAME | array_def | dyn_array_def) "[" (DEC_NUMBER | NAME) "]"
-dyn_array_def: "DynArray" "[" (NAME | array_def | dyn_array_def) "," (DEC_NUMBER | NAME) "]"
+array_def: (NAME | array_def | dyn_array_def) "[" _expr "]"
+dyn_array_def: "DynArray" "[" (NAME | array_def | dyn_array_def) "," _expr "]"
 tuple_def: "(" ( NAME | array_def | dyn_array_def | tuple_def ) ( "," ( NAME | array_def | dyn_array_def | tuple_def ) )* [","] ")"
 // NOTE: Map takes a basic type and maps to another type (can be non-basic, including maps)
 _MAP: "HashMap"
 map_def: _MAP "[" ( NAME | array_def ) "," type "]"
 type: ( NAME | array_def | tuple_def | map_def | dyn_array_def )
 
 // Structs can be composed of 1+ basic types or other custom_types
@@ -94,14 +97,16 @@
 struct_def: _STRUCT_DECL NAME ":" _NEWLINE _INDENT (struct_member _NEWLINE)+ _DEDENT
 
 // Interfaces are composed of a series of method definitions, plus their mutability
 _INTERFACE_DECL: "interface"
 mutability: NAME
 interface_function: function_sig ":" mutability
 interface_def: _INTERFACE_DECL NAME ":" _NEWLINE _INDENT ( interface_function _NEWLINE)+ _DEDENT
+_IMPLEMENTS_DECL: "implements"
+implements_def: _IMPLEMENTS_DECL ":" NAME
 
 
 // Statements
 // If and For blocks create a new block, and thus are complete when de-indented
 // Conversely, the rest of the statements require a newline to be considered complete
 // (as they do not create a new block)
 _stmt: ( if_stmt | for_stmt ) [COMMENT]
@@ -165,20 +170,23 @@
 default_exec: body
 if_stmt: "if" cond_exec ("elif" cond_exec)* ["else" ":" default_exec]
 // TODO: make this into a variable definition e.g. `for i: uint256 in range(0, 5): ...`
 loop_variable: NAME [":" NAME]
 loop_iterator: _expr
 for_stmt: "for" loop_variable "in" loop_iterator ":" body
 
+// ternary operator
+ternary: _expr "if" _expr "else" _expr
 
 // Expressions
 _expr: operation
      | dict
+     | ternary
 
-get_item: variable_access "[" _expr "]"
+get_item: (variable_access | list) "[" _expr "]"
 get_attr: variable_access "." NAME
 call: variable_access "(" [arguments] ")"
 ?variable_access: NAME -> get_var
                 | get_item
                 | get_attr
                 | call
                 | "(" variable_access ")"
```

### Comparing `vyper-0.3.7/vyper/ast/grammar.py` & `vyper-0.3.8/vyper/ast/grammar.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/vyper/ast/natspec.py` & `vyper-0.3.8/vyper/ast/natspec.py`

 * *Files 2% similar despite different names*

```diff
@@ -69,15 +69,14 @@
 def _parse_docstring(
     source: str,
     docstring: str,
     invalid_fields: Tuple,
     params: Optional[Tuple] = None,
     return_length: int = 0,
 ) -> dict:
-
     natspec: dict = {}
     if params is None:
         params = tuple()
 
     line_no = LineNumbers(source)
     start = source.index(docstring)
 
@@ -85,15 +84,15 @@
 
     pattern = r"(?:^|\n)\s*@(\S+)\s*([\s\S]*?)(?=\n\s*@\S|\s*$)"
 
     for match in re.finditer(pattern, docstring):
         tag, value = match.groups()
         err_args = (source, *line_no.offset_to_line(start + match.start(1)))
 
-        if tag not in SINGLE_FIELDS + PARAM_FIELDS:
+        if tag not in SINGLE_FIELDS + PARAM_FIELDS and not tag.startswith("custom:"):
             raise NatSpecSyntaxException(f"Unknown NatSpec field '@{tag}'", *err_args)
         if tag in invalid_fields:
             raise NatSpecSyntaxException(
                 f"'@{tag}' is not a valid field for this docstring", *err_args
             )
 
         if not value or value.startswith("@"):
```

### Comparing `vyper-0.3.7/vyper/ast/nodes.py` & `vyper-0.3.8/vyper/ast/nodes.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,21 +1,24 @@
 import ast as python_ast
+import contextlib
 import copy
 import decimal
 import operator
 import sys
 from typing import Any, Optional, Union
 
+from vyper.ast.metadata import NodeMetadata
 from vyper.compiler.settings import VYPER_ERROR_CONTEXT_LINES, VYPER_ERROR_LINE_NUMBERS
 from vyper.exceptions import (
     ArgumentException,
     CompilerPanic,
     InvalidLiteral,
     InvalidOperation,
     OverflowException,
+    StructureException,
     SyntaxException,
     TypeMismatch,
     UnfoldableNode,
     ZeroDivisionException,
 )
 from vyper.utils import MAX_DECIMAL_PLACES, SizeLimits, annotate_source_code
 
@@ -60,22 +63,24 @@
         # workaround: some third party module (ex. ipython) might insert
         # a "parent" member into the node, creating a duplicate kwarg
         # error below when calling vy_class()
         if "parent" in ast_struct:
             ast_struct = copy.copy(ast_struct)
             del ast_struct["parent"]
 
-    # Replace state and local variable declarations `AnnAssign` with `VariableDecl`
-    # Parent node is required for context to determine whether replacement should happen.
-    if (
-        ast_struct["ast_type"] == "AnnAssign"
-        and isinstance(parent, Module)
-        and not getattr(ast_struct["target"], "id", None) in ("implements",)
-    ):
-        ast_struct["ast_type"] = "VariableDecl"
+    if ast_struct["ast_type"] == "AnnAssign" and isinstance(parent, Module):
+        # Replace `implements` interface declarations `AnnAssign` with `ImplementsDecl`
+        if getattr(ast_struct["target"], "id", None) == "implements":
+            if ast_struct["value"] is not None:
+                _raise_syntax_exc("`implements` cannot have a value assigned", ast_struct)
+            ast_struct["ast_type"] = "ImplementsDecl"
+        # Replace state and local variable declarations `AnnAssign` with `VariableDecl`
+        # Parent node is required for context to determine whether replacement should happen.
+        else:
+            ast_struct["ast_type"] = "VariableDecl"
 
     vy_class = getattr(sys.modules[__name__], ast_struct["ast_type"], None)
     if not vy_class:
         if ast_struct["ast_type"] == "Delete":
             _raise_syntax_exc("Deleting is not supported", ast_struct)
         elif ast_struct["ast_type"] in ("ExtSlice", "Slice"):
             _raise_syntax_exc("Vyper does not support slicing", ast_struct)
@@ -247,15 +252,15 @@
         parent: VyperNode, optional
             Node which contains this node.
         **kwargs : dict
             Dictionary of fields to be included within the node.
         """
         self.set_parent(parent)
         self._children: set = set()
-        self._metadata: dict = {}
+        self._metadata: NodeMetadata = NodeMetadata()
 
         for field_name in NODE_SRC_ATTRIBUTES:
             # when a source offset is not available, use the parent's source offset
             value = kwargs.get(field_name)
             if kwargs.get(field_name) is None:
                 value = getattr(parent, field_name, None)
             setattr(self, field_name, value)
@@ -656,14 +661,27 @@
         ---------
         node: VyperNode
             Vyper node to be appended to the body of the this node.
         """
         self.body.remove(node)
         self._children.remove(node)
 
+    @contextlib.contextmanager
+    def namespace(self):
+        from vyper.semantics.namespace import get_namespace, override_global_namespace
+
+        # kludge implementation for backwards compatibility.
+        # TODO: replace with type_from_ast
+        try:
+            ns = self._metadata["namespace"]
+        except AttributeError:
+            ns = get_namespace()
+        with override_global_namespace(ns):
+            yield
+
 
 class FunctionDef(TopLevel):
     __slots__ = ("args", "returns", "decorator_list", "pos")
 
 
 class DocStr(VyperNode):
     """
@@ -677,47 +695,63 @@
 
     __slots__ = ("value",)
     _translated_fields = {"s": "value"}
 
 
 class arguments(VyperNode):
     __slots__ = ("args", "defaults", "default")
-    _only_empty_fields = ("vararg", "kwonlyargs", "kwarg", "kw_defaults")
+    _only_empty_fields = ("posonlyargs", "vararg", "kwonlyargs", "kwarg", "kw_defaults")
 
 
 class arg(VyperNode):
     __slots__ = ("arg", "annotation")
 
 
-class Return(VyperNode):
+# base class for stmt nodes. doesn't do anything except classification
+class Stmt(VyperNode):
+    pass
+
+
+class Return(Stmt):
     __slots__ = ("value",)
     _is_terminus = True
 
 
-class Log(VyperNode):
+class Expr(Stmt):
+    __slots__ = ("value",)
+
+
+class Log(Stmt):
     __slots__ = ("value",)
 
 
-class EnumDef(VyperNode):
+class EnumDef(TopLevel):
     __slots__ = ("name", "body")
 
 
-class EventDef(VyperNode):
+class EventDef(TopLevel):
     __slots__ = ("name", "body")
 
 
-class InterfaceDef(VyperNode):
+class InterfaceDef(TopLevel):
     __slots__ = ("name", "body")
 
 
-class StructDef(VyperNode):
+class StructDef(TopLevel):
     __slots__ = ("name", "body")
 
 
-class Constant(VyperNode):
+# base class for expression nodes
+# note that it is named ExprNode to avoid a conflict with
+# the Expr type (which is a type of statement node, see python AST docs).
+class ExprNode(VyperNode):
+    __slots__ = ("_expr_info",)
+
+
+class Constant(ExprNode):
     # inherited class for all simple constant node types
     __slots__ = ("value",)
 
 
 class Num(Constant):
     # inherited class for all numeric constant node types
     __slots__ = ()
@@ -794,14 +828,28 @@
 
     def validate(self):
         if "_" in self.value:
             raise InvalidLiteral("Underscores not allowed in hex literals", self)
         if len(self.value) % 2:
             raise InvalidLiteral("Hex notation requires an even number of digits", self)
 
+    @property
+    def n_nibbles(self):
+        """
+        The number of nibbles this hex value represents
+        """
+        return len(self.value) - 2
+
+    @property
+    def n_bytes(self):
+        """
+        The number of bytes this hex value represents
+        """
+        return self.n_nibbles // 2
+
 
 class Str(Constant):
     __slots__ = ()
     _translated_fields = {"s": "value"}
 
     def validate(self):
         for c in self.value:
@@ -831,48 +879,44 @@
         return ast_dict
 
     @property
     def s(self):
         return self.value
 
 
-class List(VyperNode):
+class List(ExprNode):
     __slots__ = ("elements",)
     _translated_fields = {"elts": "elements"}
 
 
-class Tuple(VyperNode):
+class Tuple(ExprNode):
     __slots__ = ("elements",)
     _translated_fields = {"elts": "elements"}
 
     def validate(self):
         if not self.elements:
             raise InvalidLiteral("Cannot have an empty tuple", self)
 
 
-class Dict(VyperNode):
+class Dict(ExprNode):
     __slots__ = ("keys", "values")
 
 
 class NameConstant(Constant):
     __slots__ = ("value",)
 
 
-class Name(VyperNode):
+class Name(ExprNode):
     __slots__ = ("id",)
 
 
-class Expr(VyperNode):
-    __slots__ = ("value",)
-
-
-class UnaryOp(VyperNode):
+class UnaryOp(ExprNode):
     __slots__ = ("op", "operand")
 
-    def evaluate(self) -> VyperNode:
+    def evaluate(self) -> ExprNode:
         """
         Attempt to evaluate the unary operation.
 
         Returns
         -------
         Int | Decimal
             Node representing the result of the evaluation.
@@ -885,70 +929,82 @@
             raise UnfoldableNode("Node contains invalid field(s) for evaluation")
 
         value = self.op._op(self.operand.value)
         _validate_numeric_bounds(self, value)
         return type(self.operand).from_node(self, value=value)
 
 
-class USub(VyperNode):
+class Operator(VyperNode):
+    pass
+
+
+class USub(Operator):
     __slots__ = ()
     _description = "negation"
     _op = operator.neg
 
 
-class Not(VyperNode):
+class Not(Operator):
     __slots__ = ()
     _op = operator.not_
 
 
-class Invert(VyperNode):
+class Invert(Operator):
     __slots__ = ()
     _description = "bitwise not"
     _pretty = "~"
-    _op = operator.inv
+
+    def _op(self, value):
+        return (2**256 - 1) ^ value
 
 
-class BinOp(VyperNode):
+class BinOp(ExprNode):
     __slots__ = ("left", "op", "right")
 
-    def evaluate(self) -> VyperNode:
+    def evaluate(self) -> ExprNode:
         """
         Attempt to evaluate the arithmetic operation.
 
         Returns
         -------
         Int | Decimal
             Node representing the result of the evaluation.
         """
         left, right = self.left, self.right
         if type(left) is not type(right):
             raise UnfoldableNode("Node contains invalid field(s) for evaluation")
         if not isinstance(left, (Int, Decimal)):
             raise UnfoldableNode("Node contains invalid field(s) for evaluation")
 
+        # this validation is performed to prevent the compiler from hanging
+        # on very large shifts and improve the error message for negative
+        # values.
+        if isinstance(self.op, (LShift, RShift)) and not (0 <= right.value <= 256):
+            raise InvalidLiteral("Shift bits must be between 0 and 256", right)
+
         value = self.op._op(left.value, right.value)
         _validate_numeric_bounds(self, value)
         return type(left).from_node(self, value=value)
 
 
-class Add(VyperNode):
+class Add(Operator):
     __slots__ = ()
     _description = "addition"
     _pretty = "+"
     _op = operator.add
 
 
-class Sub(VyperNode):
+class Sub(Operator):
     __slots__ = ()
     _description = "subtraction"
     _pretty = "-"
     _op = operator.sub
 
 
-class Mult(VyperNode):
+class Mult(Operator):
     __slots__ = ()
     _description = "multiplication"
     _pretty = "*"
 
     def _op(self, left, right):
         assert type(left) is type(right)
         value = left * right
@@ -957,15 +1013,15 @@
             return value.quantize(
                 decimal.Decimal(f"{1:0.{MAX_DECIMAL_PLACES}f}"), decimal.ROUND_DOWN
             )
         else:
             return value
 
 
-class Div(VyperNode):
+class Div(Operator):
     __slots__ = ()
     _description = "division"
     _pretty = "/"
 
     def _op(self, left, right):
         # evaluate the operation using true division or floor division
         assert type(left) is type(right)
@@ -984,67 +1040,81 @@
         else:
             value = left // right
             if value < 0:
                 return -(-left // right)
             return value
 
 
-class Mod(VyperNode):
+class Mod(Operator):
     __slots__ = ()
     _description = "modulus"
     _pretty = "%"
 
     def _op(self, left, right):
         if not right:
             raise ZeroDivisionException("Modulo by zero")
 
         value = abs(left) % abs(right)
         if left < 0:
             value = -value
         return value
 
 
-class Pow(VyperNode):
+class Pow(Operator):
     __slots__ = ()
     _description = "exponentiation"
     _pretty = "**"
 
     def _op(self, left, right):
         if isinstance(left, decimal.Decimal):
             raise TypeMismatch("Cannot perform exponentiation on decimal values.", self._parent)
         if right < 0:
             raise InvalidOperation("Cannot calculate a negative power", self._parent)
-        return int(left ** right)
+        return int(left**right)
 
 
-class BitAnd(VyperNode):
+class BitAnd(Operator):
     __slots__ = ()
     _description = "bitwise and"
     _pretty = "&"
     _op = operator.and_
 
 
-class BitOr(VyperNode):
+class BitOr(Operator):
     __slots__ = ()
     _description = "bitwise or"
     _pretty = "|"
     _op = operator.or_
 
 
-class BitXor(VyperNode):
+class BitXor(Operator):
     __slots__ = ()
     _description = "bitwise xor"
     _pretty = "^"
     _op = operator.xor
 
 
-class BoolOp(VyperNode):
+class LShift(Operator):
+    __slots__ = ()
+    _description = "bitwise left shift"
+    _pretty = "<<"
+    _op = operator.lshift
+
+
+class RShift(Operator):
+    __slots__ = ()
+    _description = "bitwise right shift"
+    _pretty = ">>"
+    _op = operator.rshift
+
+
+class BoolOp(ExprNode):
     __slots__ = ("op", "values")
 
-    def evaluate(self) -> VyperNode:
+    def evaluate(self) -> ExprNode:
         """
         Attempt to evaluate the boolean operation.
 
         Returns
         -------
         NameConstant
             Node representing the result of the evaluation.
@@ -1056,51 +1126,51 @@
         if None in values:
             raise UnfoldableNode("Node contains invalid field(s) for evaluation")
 
         value = self.op._op(values)
         return NameConstant.from_node(self, value=value)
 
 
-class And(VyperNode):
+class And(Operator):
     __slots__ = ()
     _description = "logical and"
     _op = all
 
 
-class Or(VyperNode):
+class Or(Operator):
     __slots__ = ()
     _description = "logical or"
     _op = any
 
 
-class Compare(VyperNode):
+class Compare(ExprNode):
     """
     A comparison of two values.
 
     Attributes
     ----------
-    left : VyperNode
+    left : ExprNode
         The left-hand value in the comparison.
-    op : VyperNode
+    op : Operator
         The comparison operator.
-    right : VyperNode
+    right : ExprNode
         The right-hand value in the comparison.
     """
 
     __slots__ = ("left", "op", "right")
 
     def __init__(self, *args, **kwargs):
         if len(kwargs["ops"]) > 1 or len(kwargs["comparators"]) > 1:
             _raise_syntax_exc("Cannot have a comparison with more than two elements", kwargs)
 
         kwargs["op"] = kwargs.pop("ops")[0]
         kwargs["right"] = kwargs.pop("comparators")[0]
         super().__init__(*args, **kwargs)
 
-    def evaluate(self) -> VyperNode:
+    def evaluate(self) -> ExprNode:
         """
         Attempt to evaluate the comparison.
 
         Returns
         -------
         NameConstant
             Node representing the result of the evaluation.
@@ -1127,91 +1197,91 @@
         if not isinstance(self.op, (Eq, NotEq)) and not isinstance(left, (Int, Decimal)):
             raise TypeMismatch(f"Invalid literal types for {self.op.description} comparison", self)
 
         value = self.op._op(left.value, right.value)
         return NameConstant.from_node(self, value=value)
 
 
-class Eq(VyperNode):
+class Eq(Operator):
     __slots__ = ()
     _description = "equality"
     _op = operator.eq
 
 
-class NotEq(VyperNode):
+class NotEq(Operator):
     __slots__ = ()
     _description = "non-equality"
     _op = operator.ne
 
 
-class Lt(VyperNode):
+class Lt(Operator):
     __slots__ = ()
     _description = "less than"
     _op = operator.lt
 
 
-class LtE(VyperNode):
+class LtE(Operator):
     __slots__ = ()
     _description = "less-or-equal"
     _op = operator.le
 
 
-class Gt(VyperNode):
+class Gt(Operator):
     __slots__ = ()
     _description = "greater than"
     _op = operator.gt
 
 
-class GtE(VyperNode):
+class GtE(Operator):
     __slots__ = ()
     _description = "greater-or-equal"
     _op = operator.ge
 
 
-class In(VyperNode):
+class In(Operator):
     __slots__ = ()
     _description = "membership"
 
     def _op(self, left, right):
         return left in right
 
 
-class NotIn(VyperNode):
+class NotIn(Operator):
     __slots__ = ()
     _description = "exclusion"
 
     def _op(self, left, right):
         return left not in right
 
 
-class Call(VyperNode):
+class Call(ExprNode):
     __slots__ = ("func", "args", "keywords", "keyword")
 
 
 class keyword(VyperNode):
     __slots__ = ("arg", "value")
 
 
-class Attribute(VyperNode):
+class Attribute(ExprNode):
     __slots__ = ("attr", "value")
 
 
-class Subscript(VyperNode):
+class Subscript(ExprNode):
     __slots__ = ("slice", "value")
 
-    def evaluate(self) -> VyperNode:
+    def evaluate(self) -> ExprNode:
         """
         Attempt to evaluate the subscript.
 
         This method reduces an indexed reference to a literal array into the value
         within the array, e.g. `["foo", "bar"][1]` becomes `"bar"`
 
         Returns
         -------
-        VyperNode
+        ExprNode
             Node representing the result of the evaluation.
         """
         if not isinstance(self.value, List):
             raise UnfoldableNode("Subscript object is not a literal list")
         elements = self.value.elements
         if len(set([type(i) for i in elements])) > 1:
             raise UnfoldableNode("List contains multiple node types")
@@ -1222,23 +1292,23 @@
         return elements[idx]
 
 
 class Index(VyperNode):
     __slots__ = ("value",)
 
 
-class Assign(VyperNode):
+class Assign(Stmt):
     """
     An assignment.
 
     Attributes
     ----------
     target : VyperNode
         Left-hand side of the assignment.
-    value : VyperNode
+    value : ExprNode
         Right-hand side of the assignment.
     """
 
     __slots__ = ("target", "value")
 
     def __init__(self, *args, **kwargs):
         if len(kwargs["targets"]) > 1:
@@ -1270,22 +1340,31 @@
         If true, indicates that the variable is a constant variable.
     is_public : bool, optional
         If true, indicates that the variable is a public state variable.
     is_immutable : bool, optional
         If true, indicates that the variable is an immutable variable.
     """
 
-    __slots__ = ("target", "annotation", "value", "is_constant", "is_public", "is_immutable")
+    __slots__ = (
+        "target",
+        "annotation",
+        "value",
+        "is_constant",
+        "is_public",
+        "is_immutable",
+        "is_transient",
+    )
 
     def __init__(self, *args, **kwargs):
         super().__init__(*args, **kwargs)
 
         self.is_constant = False
         self.is_public = False
         self.is_immutable = False
+        self.is_transient = False
 
         def _check_args(annotation, call_name):
             # do the same thing as `validate_call_args`
             # (can't be imported due to cyclic dependency)
             if len(annotation.args) != 1:
                 raise ArgumentException("Invalid number of arguments to `{call_name}`:", self)
 
@@ -1295,43 +1374,44 @@
         # TYPE | PUBLIC "(" TYPE | ((IMMUTABLE | CONSTANT) "(" TYPE ")") ")"
         if self.annotation.get("func.id") == "public":
             _check_args(self.annotation, "public")
             self.is_public = True
             # unwrap one layer
             self.annotation = self.annotation.args[0]
 
-        if self.annotation.get("func.id") in ("immutable", "constant"):
-            _check_args(self.annotation, self.annotation.func.id)
-            setattr(self, f"is_{self.annotation.func.id}", True)
+        func_id = self.annotation.get("func.id")
+        if func_id in ("immutable", "constant", "transient"):
+            _check_args(self.annotation, func_id)
+            setattr(self, f"is_{func_id}", True)
             # unwrap one layer
             self.annotation = self.annotation.args[0]
 
         if isinstance(self.annotation, Call):
             _raise_syntax_exc("Invalid scope for variable declaration", self.annotation)
 
 
-class AugAssign(VyperNode):
+class AugAssign(Stmt):
     __slots__ = ("op", "target", "value")
 
 
-class Raise(VyperNode):
+class Raise(Stmt):
     __slots__ = ("exc",)
     _only_empty_fields = ("cause",)
     _is_terminus = True
 
 
-class Assert(VyperNode):
+class Assert(Stmt):
     __slots__ = ("test", "msg")
 
 
-class Pass(VyperNode):
+class Pass(Stmt):
     __slots__ = ()
 
 
-class _Import(VyperNode):
+class _Import(Stmt):
     __slots__ = ("name", "alias")
 
     def __init__(self, *args, **kwargs):
         if len(kwargs["names"]) > 1:
             _raise_syntax_exc("Assignment statement must have one target", kwargs)
         names = kwargs.pop("names")[0]
         kwargs["name"] = names.name
@@ -1343,22 +1423,49 @@
     __slots__ = ()
 
 
 class ImportFrom(_Import):
     __slots__ = ("level", "module")
 
 
-class If(VyperNode):
+class ImplementsDecl(Stmt):
+    """
+    An `implements` declaration.
+
+    Excludes `simple` and `value` attributes from Python `AnnAssign` node.
+
+    Attributes
+    ----------
+    target : Name
+        Name node for the `implements` keyword
+    annotation : Name
+        Name node for the interface to be implemented
+    """
+
+    __slots__ = ("target", "annotation")
+
+    def __init__(self, *args, **kwargs):
+        super().__init__(*args, **kwargs)
+
+        if not isinstance(self.annotation, Name):
+            raise StructureException("not an identifier", self.annotation)
+
+
+class If(Stmt):
+    __slots__ = ("test", "body", "orelse")
+
+
+class IfExp(ExprNode):
     __slots__ = ("test", "body", "orelse")
 
 
-class For(VyperNode):
+class For(Stmt):
     __slots__ = ("iter", "target", "body")
     _only_empty_fields = ("orelse",)
 
 
-class Break(VyperNode):
+class Break(Stmt):
     __slots__ = ()
 
 
-class Continue(VyperNode):
+class Continue(Stmt):
     __slots__ = ()
```

### Comparing `vyper-0.3.7/vyper/ast/nodes.pyi` & `vyper-0.3.8/vyper/ast/nodes.pyi`

 * *Files 2% similar despite different names*

```diff
@@ -57,14 +57,15 @@
     def __len__(self) -> int: ...
     def __contains__(self, obj: Any) -> bool: ...
 
 class Module(TopLevel):
     def replace_in_tree(self, old_node: VyperNode, new_node: VyperNode) -> None: ...
     def add_to_body(self, node: VyperNode) -> None: ...
     def remove_from_body(self, node: VyperNode) -> None: ...
+    def namespace(self) -> Any: ...  # context manager
 
 class FunctionDef(TopLevel):
     args: arguments = ...
     decorator_list: list = ...
     returns: VyperNode = ...
 
 class arguments(VyperNode):
@@ -89,26 +90,31 @@
     body: list = ...
     name: str = ...
 
 class StructDef(VyperNode):
     body: list = ...
     name: str = ...
 
+class ExprNode(VyperNode): ...
+
 class Constant(VyperNode):
     value: Any = ...
 
 class Num(Constant):
     @property
     def n(self): ...
 
 class Int(Num):
     value: int = ...
 
 class Decimal(Num): ...
-class Hex(Num): ...
+
+class Hex(Num):
+    @property
+    def n_bytes(self): ...
 
 class Str(Constant):
     @property
     def s(self): ...
 
 class Bytes(Constant):
     @property
@@ -129,47 +135,55 @@
 class Name(VyperNode):
     id: str = ...
     _type: str = ...
 
 class Expr(VyperNode):
     value: VyperNode = ...
 
-class UnaryOp(VyperNode):
+class UnaryOp(ExprNode):
     op: VyperNode = ...
 
 class USub(VyperNode): ...
 class Not(VyperNode): ...
 
-class BinOp(VyperNode):
+class BinOp(ExprNode):
     left: VyperNode = ...
     op: VyperNode = ...
     right: VyperNode = ...
 
 class Add(VyperNode): ...
 class Sub(VyperNode): ...
 class Mult(VyperNode): ...
 class Div(VyperNode): ...
 class Mod(VyperNode): ...
 class Pow(VyperNode): ...
-class BoolOp(VyperNode): ...
+class LShift(VyperNode): ...
+class RShift(VyperNode): ...
+class BitAnd(VyperNode): ...
+class BitOr(VyperNode): ...
+class BitXor(VyperNode): ...
+
+class BoolOp(ExprNode):
+    op: VyperNode = ...
+
 class And(VyperNode): ...
 class Or(VyperNode): ...
 
-class Compare(VyperNode):
+class Compare(ExprNode):
     op: VyperNode = ...
 
 class Eq(VyperNode): ...
 class NotEq(VyperNode): ...
 class Lt(VyperNode): ...
 class LtE(VyperNode): ...
 class Gt(VyperNode): ...
 class GtE(VyperNode): ...
 class In(VyperNode): ...
 
-class Call(VyperNode):
+class Call(ExprNode):
     args: list = ...
     keywords: list = ...
     func: Name = ...
 
 class keyword(VyperNode): ...
 
 class Attribute(VyperNode):
@@ -213,14 +227,23 @@
 
 class ImportFrom(VyperNode):
     alias: str = ...
     level: int = ...
     module: str = ...
     name: str = ...
 
+class ImplementsDecl(VyperNode):
+    target: Name = ...
+    annotation: Name = ...
+
 class If(VyperNode):
     body: list = ...
     orelse: list = ...
 
+class IfExp(ExprNode):
+    test: ExprNode = ...
+    body: ExprNode = ...
+    orelse: ExprNode = ...
+
 class For(VyperNode): ...
 class Break(VyperNode): ...
 class Continue(VyperNode): ...
```

### Comparing `vyper-0.3.7/vyper/ast/pre_parser.py` & `vyper-0.3.8/vyper/ast/pre_parser.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/vyper/ast/signatures/function_signature.py` & `vyper-0.3.8/vyper/codegen/module.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,239 +1,192 @@
-import math
-from dataclasses import dataclass
-from typing import Dict, Optional, Tuple
+# a contract.vy -- all functions and constructor
+
+from typing import Any, List, Optional
 
 from vyper import ast as vy_ast
-from vyper.address_space import MEMORY
-from vyper.codegen.ir_node import Encoding
-from vyper.codegen.types import NodeType
-from vyper.exceptions import StructureException
-from vyper.utils import MemoryPositions, cached_property, mkalphanum
-
-# dict from function names to signatures
-FunctionSignatures = Dict[str, "FunctionSignature"]
-
-
-# Function variable
-# TODO move to context.py
-# TODO use dataclass
-class VariableRecord:
-    def __init__(  # type: ignore
-        self,
-        name,
-        pos,
-        typ,
-        mutable,
-        encoding=Encoding.VYPER,
-        location=MEMORY,
-        blockscopes=None,
-        defined_at=None,  # note: dead variable
-        is_internal=False,
-        is_immutable=False,
-        data_offset: Optional[int] = None,
-    ):
-        self.name = name
-        self.pos = pos
-        self.typ = typ
-        self.mutable = mutable
-        self.location = location
-        self.encoding = encoding
-        self.blockscopes = [] if blockscopes is None else blockscopes
-        self.defined_at = defined_at  # source code location variable record was defined.
-        self.is_internal = is_internal
-        self.is_immutable = is_immutable
-        self.data_offset = data_offset  # location in data section
-
-    def __repr__(self):
-        ret = vars(self)
-        ret["allocated"] = self.size * 32
-        return f"VariableRecord(f{ret})"
-
-    @property
-    def size(self):
-        if hasattr(self.typ, "size_in_bytes"):
-            # temporary requirement to support both new and old type objects
-            # we divide by 32 here because the returned value is denominated
-            # in "slots" of 32 bytes each
-            # CMC 20211023 revisit this divide-by-32.
-            return math.ceil(self.typ.size_in_bytes / 32)
-        return math.ceil(self.typ.memory_bytes_required / 32)
-
-
-@dataclass
-class FunctionArg:
-    name: str
-    typ: NodeType
-    ast_source: vy_ast.VyperNode
-
-
-@dataclass
-class FrameInfo:
-    frame_start: int
-    frame_size: int
-    frame_vars: Dict[str, Tuple[int, NodeType]]
-
-    @property
-    def mem_used(self):
-        return self.frame_size + MemoryPositions.RESERVED_MEMORY
-
-
-# Function signature object
-class FunctionSignature:
-    def __init__(
-        self,
-        name,
-        args,
-        return_type,
-        mutability,
-        internal,
-        nonreentrant_key,
-        func_ast_code,
-        is_from_json,
-    ):
-        self.name = name
-        self.args = args
-        self.return_type = return_type
-        self.mutability = mutability
-        self.internal = internal
-        self.gas_estimate = None
-        self.nonreentrant_key = nonreentrant_key
-        self.func_ast_code = func_ast_code
-        self.is_from_json = is_from_json
-
-        self.set_default_args()
-
-        # frame info is metadata that will be generated during codegen.
-        self.frame_info: Optional[FrameInfo] = None
-
-    def __str__(self):
-        input_name = "def " + self.name + "(" + ",".join([str(arg.typ) for arg in self.args]) + ")"
-        if self.return_type:
-            return input_name + " -> " + str(self.return_type) + ":"
-        return input_name + ":"
-
-    def set_frame_info(self, frame_info):
-        self.frame_info = frame_info
-
-    @cached_property
-    def _ir_identifier(self) -> str:
-        # we could do a bit better than this but it just needs to be unique
-        visibility = "internal" if self.internal else "external"
-        argz = ",".join([str(arg.typ) for arg in self.args])
-        ret = f"{visibility} {self.name} ({argz})"
-        return mkalphanum(ret)
-
-    # calculate the abi signature for a given set of kwargs
-    def abi_signature_for_kwargs(self, kwargs):
-        args = self.base_args + kwargs
-        return self.name + "(" + ",".join([arg.typ.abi_type.selector_name() for arg in args]) + ")"
-
-    @cached_property
-    def base_signature(self):
-        return self.abi_signature_for_kwargs([])
-
-    @property
-    # common entry point for external function with kwargs
-    def external_function_base_entry_label(self):
-        assert not self.internal
-
-        return self._ir_identifier + "_common"
-
-    @property
-    def internal_function_label(self):
-        assert self.internal, "why are you doing this"
-
-        return self._ir_identifier
-
-    @property
-    def exit_sequence_label(self):
-        return self._ir_identifier + "_cleanup"
-
-    def set_default_args(self):
-        """Split base from kwargs and set member data structures"""
-
-        args = self.func_ast_code.args
-
-        defaults = getattr(args, "defaults", [])
-        num_base_args = len(args.args) - len(defaults)
-
-        self.base_args = self.args[:num_base_args]
-        self.default_args = self.args[num_base_args:]
-
-        # Keep all the value to assign to default parameters.
-        self.default_values = dict(zip([arg.name for arg in self.default_args], defaults))
-
-    # Get a signature from a function definition
-    @classmethod
-    def from_definition(
-        cls,
-        func_ast,  # vy_ast.FunctionDef
-        global_ctx,
-        interface_def=False,
-        constant_override=False,  # CMC 20210907 what does this do?
-        is_from_json=False,
-    ):
-        name = func_ast.name
-
-        args = []
-        for arg in func_ast.args.args:
-            argname = arg.arg
-            argtyp = global_ctx.parse_type(arg.annotation)
-
-            args.append(FunctionArg(argname, argtyp, arg))
-
-        mutability = "nonpayable"  # Assume nonpayable by default
-        nonreentrant_key = None
-        is_internal = None
-
-        # Update function properties from decorators
-        # NOTE: Can't import enums here because of circular import
-        for dec in func_ast.decorator_list:
-            if isinstance(dec, vy_ast.Name) and dec.id in ("payable", "view", "pure"):
-                mutability = dec.id
-            elif isinstance(dec, vy_ast.Name) and dec.id == "internal":
-                is_internal = True
-            elif isinstance(dec, vy_ast.Name) and dec.id == "external":
-                is_internal = False
-            elif isinstance(dec, vy_ast.Call) and dec.func.id == "nonreentrant":
-                nonreentrant_key = dec.args[0].s
-
-        if constant_override:
-            # In case this override is abused, match previous behavior
-            if mutability == "payable":
-                raise StructureException(f"Function {name} cannot be both constant and payable.")
-            mutability = "view"
-
-        # Determine the return type and whether or not it's constant. Expects something
-        # of the form:
-        # def foo(): ...
-        # def foo() -> int128: ...
-        # If there is no return type, ie. it's of the form def foo(): ...
-        # and NOT def foo() -> type: ..., then it's null
-        return_type = None
-        if func_ast.returns:
-            return_type = global_ctx.parse_type(func_ast.returns)
-            # sanity check: Output type must be canonicalizable
-            assert return_type.abi_type.selector_name()
-
-        return cls(
-            name,
-            args,
-            return_type,
-            mutability,
-            is_internal,
-            nonreentrant_key,
-            func_ast,
-            is_from_json,
+from vyper.codegen.core import shr
+from vyper.codegen.function_definitions import generate_ir_for_function
+from vyper.codegen.global_context import GlobalContext
+from vyper.codegen.ir_node import IRnode
+from vyper.exceptions import CompilerPanic
+
+
+def _topsort_helper(functions, lookup):
+    #  single pass to get a global topological sort of functions (so that each
+    # function comes after each of its callees). may have duplicates, which get
+    # filtered out in _topsort()
+
+    ret = []
+    for f in functions:
+        # called_functions is a list of ContractFunctions, need to map
+        # back to FunctionDefs.
+        callees = [lookup[t.name] for t in f._metadata["type"].called_functions]
+        ret.extend(_topsort_helper(callees, lookup))
+        ret.append(f)
+
+    return ret
+
+
+def _topsort(functions):
+    lookup = {f.name: f for f in functions}
+    # strip duplicates
+    return list(dict.fromkeys(_topsort_helper(functions, lookup)))
+
+
+def _is_constructor(func_ast):
+    return func_ast._metadata["type"].is_constructor
+
+
+def _is_fallback(func_ast):
+    return func_ast._metadata["type"].is_fallback
+
+
+def _is_internal(func_ast):
+    return func_ast._metadata["type"].is_internal
+
+
+def _is_payable(func_ast):
+    return func_ast._metadata["type"].is_payable
+
+
+# codegen for all runtime functions + callvalue/calldata checks + method selector routines
+def _runtime_ir(runtime_functions, global_ctx):
+    # categorize the runtime functions because we will organize the runtime
+    # code into the following sections:
+    # payable functions, nonpayable functions, fallback function, internal_functions
+    internal_functions = [f for f in runtime_functions if _is_internal(f)]
+
+    external_functions = [f for f in runtime_functions if not _is_internal(f)]
+    default_function = next((f for f in external_functions if _is_fallback(f)), None)
+
+    # functions that need to go exposed in the selector section
+    regular_functions = [f for f in external_functions if not _is_fallback(f)]
+    payables = [f for f in regular_functions if _is_payable(f)]
+    nonpayables = [f for f in regular_functions if not _is_payable(f)]
+
+    # create a map of the IR functions since they might live in both
+    # runtime and deploy code (if init function calls them)
+    internal_functions_ir: list[IRnode] = []
+
+    for func_ast in internal_functions:
+        func_ir = generate_ir_for_function(func_ast, global_ctx, False)
+        internal_functions_ir.append(func_ir)
+
+    # for some reason, somebody may want to deploy a contract with no
+    # external functions, or more likely, a "pure data" contract which
+    # contains immutables
+    if len(external_functions) == 0:
+        # TODO: prune internal functions in this case? dead code eliminator
+        # might not eliminate them, since internal function jumpdest is at the
+        # first instruction in the contract.
+        runtime = ["seq"] + internal_functions_ir
+        return runtime
+
+    # note: if the user does not provide one, the default fallback function
+    # reverts anyway. so it does not hurt to batch the payable check.
+    default_is_nonpayable = default_function is None or not _is_payable(default_function)
+
+    # when a contract has a nonpayable default function,
+    # we can do a single check for all nonpayable functions
+    batch_payable_check = len(nonpayables) > 0 and default_is_nonpayable
+    skip_nonpayable_check = batch_payable_check
+
+    selector_section = ["seq"]
+
+    for func_ast in payables:
+        func_ir = generate_ir_for_function(func_ast, global_ctx, False)
+        selector_section.append(func_ir)
+
+    if batch_payable_check:
+        selector_section.append(["assert", ["iszero", "callvalue"]])
+
+    for func_ast in nonpayables:
+        func_ir = generate_ir_for_function(func_ast, global_ctx, skip_nonpayable_check)
+        selector_section.append(func_ir)
+
+    if default_function:
+        fallback_ir = generate_ir_for_function(default_function, global_ctx, skip_nonpayable_check)
+    else:
+        fallback_ir = IRnode.from_list(
+            ["revert", 0, 0], annotation="Default function", error_msg="fallback function"
+        )
+
+    # ensure the external jumptable section gets closed out
+    # (for basic block hygiene and also for zksync interpreter)
+    # NOTE: this jump gets optimized out in assembly since the
+    # fallback label is the immediate next instruction,
+    close_selector_section = ["goto", "fallback"]
+
+    runtime = [
+        "seq",
+        ["with", "_calldata_method_id", shr(224, ["calldataload", 0]), selector_section],
+        close_selector_section,
+        ["label", "fallback", ["var_list"], fallback_ir],
+    ]
+
+    # note: dead code eliminator will clean dead functions
+    runtime.extend(internal_functions_ir)
+
+    return runtime
+
+
+# take a GlobalContext, and generate the runtime and deploy IR
+def generate_ir_for_module(global_ctx: GlobalContext) -> tuple[IRnode, IRnode]:
+    # order functions so that each function comes after all of its callees
+    function_defs = _topsort(global_ctx.functions)
+
+    init_function: Optional[vy_ast.FunctionDef] = None
+
+    runtime_functions = [f for f in function_defs if not _is_constructor(f)]
+    init_function = next((f for f in function_defs if _is_constructor(f)), None)
+
+    runtime = _runtime_ir(runtime_functions, global_ctx)
+
+    deploy_code: List[Any] = ["seq"]
+    immutables_len = global_ctx.immutable_section_bytes
+    if init_function:
+        # TODO might be cleaner to separate this into an _init_ir helper func
+        init_func_ir = generate_ir_for_function(
+            init_function, global_ctx, skip_nonpayable_check=False, is_ctor_context=True
         )
 
-    @property
-    def is_default_func(self):
-        return self.name == "__default__"
-
-    @property
-    def is_init_func(self):
-        return self.name == "__init__"
-
-    @property
-    def is_regular_function(self):
-        return not self.is_default_func and not self.is_init_func
+        # pass the amount of memory allocated for the init function
+        # so that deployment does not clobber while preparing immutables
+        # note: (deploy mem_ofst, code, extra_padding)
+        init_mem_used = init_function._metadata["type"]._ir_info.frame_info.mem_used
+
+        # force msize to be initialized past the end of immutables section
+        # so that builtins which use `msize` for "dynamic" memory
+        # allocation do not clobber uninitialized immutables.
+        # cf. GH issue 3101.
+        # note mload/iload X touches bytes from X to X+32, and msize rounds up
+        # to the nearest 32, so `iload`ing `immutables_len - 32` guarantees
+        # that `msize` will refer to a memory location of at least
+        # `<immutables_start> + immutables_len` (where <immutables_start> ==
+        # `_mem_deploy_end` as defined in the assembler).
+        # note:
+        #   mload 32 => msize == 64
+        #   mload 33 => msize == 96
+        # assumption in general: (mload X) => msize == ceil32(X + 32)
+        # see py-evm extend_memory: after_size = ceil32(start_position + size)
+        if immutables_len > 0:
+            deploy_code.append(["iload", max(0, immutables_len - 32)])
+
+        deploy_code.append(init_func_ir)
+
+        deploy_code.append(["deploy", init_mem_used, runtime, immutables_len])
+
+        # internal functions come after everything else
+        internal_functions = [f for f in runtime_functions if _is_internal(f)]
+        for f in internal_functions:
+            func_ir = generate_ir_for_function(
+                f, global_ctx, skip_nonpayable_check=False, is_ctor_context=True
+            )
+            # note: we depend on dead code eliminator to clean dead function defs
+            deploy_code.append(func_ir)
+
+    else:
+        if immutables_len != 0:
+            raise CompilerPanic("unreachable")
+        deploy_code.append(["deploy", 0, runtime, 0])
+
+    return IRnode.from_list(deploy_code), IRnode.from_list(runtime)
```

### Comparing `vyper-0.3.7/vyper/ast/utils.py` & `vyper-0.3.8/vyper/ast/utils.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/vyper/ast/validation.py` & `vyper-0.3.8/vyper/ast/validation.py`

 * *Files 5% similar despite different names*

```diff
@@ -41,23 +41,25 @@
         raise CompilerPanic(f"Invalid type for arg_count: {type(arg_count).__name__}")
 
     if isinstance(arg_count, tuple):
         if arg_count[1] == -1:
             # -1 is sentinel which means we have varargs.
             # set arg_count[1] to some large number that we
             # would never see in practice
-            arg_count = (arg_count[0], 2 ** 64)
+            arg_count = (arg_count[0], 2**64)
 
         if arg_count[0] == arg_count[1]:
             arg_count == arg_count[0]
 
     if isinstance(node.func, vy_ast.Attribute):
         msg = f" for call to '{node.func.attr}'"
     elif isinstance(node.func, vy_ast.Name):
         msg = f" for call to '{node.func.id}'"
+    else:
+        raise CompilerPanic("Unreachable")
 
     if isinstance(arg_count, int) and len(node.args) != arg_count:
         if not node.args:
             exc_node = node
         elif len(node.args) < arg_count:
             exc_node = node.args[-1]
         else:
```

### Comparing `vyper-0.3.7/vyper/builtin_functions/convert.py` & `vyper-0.3.8/vyper/builtins/_convert.py`

 * *Files 12% similar despite different names*

```diff
@@ -8,83 +8,66 @@
     IRnode,
     bytes_clamp,
     bytes_data_ptr,
     clamp,
     clamp_basetype,
     get_bytearray_length,
     int_clamp,
+    is_bytes_m_type,
+    is_decimal_type,
+    is_enum_type,
+    is_integer_type,
     sar,
     shl,
     shr,
     unwrap_location,
 )
 from vyper.codegen.expr import Expr
-from vyper.codegen.types import (
-    BaseType,
-    ByteArrayLike,
-    ByteArrayType,
-    EnumType,
-    StringType,
-    is_base_type,
-    is_bytes_m_type,
-    is_decimal_type,
-    is_enum_type,
-    is_integer_type,
-)
 from vyper.exceptions import (
     CompilerPanic,
     InvalidLiteral,
     InvalidType,
     StructureException,
     TypeMismatch,
 )
-from vyper.utils import DECIMAL_DIVISOR, SizeLimits, round_towards_zero, unsigned_to_signed
+from vyper.semantics.types import (
+    AddressT,
+    BoolT,
+    BytesM_T,
+    BytesT,
+    DecimalT,
+    EnumT,
+    IntegerT,
+    StringT,
+)
+from vyper.semantics.types.bytestrings import _BytestringT
+from vyper.semantics.types.shortcuts import INT256_T, UINT160_T, UINT256_T
+from vyper.utils import DECIMAL_DIVISOR, round_towards_zero, unsigned_to_signed
 
 
 def _FAIL(ityp, otyp, source_expr=None):
     # TODO consider changing this to InvalidType to be consistent
     # with the case when types are equal.
     raise TypeMismatch(f"Can't convert {ityp} to {otyp}", source_expr)
 
 
-# helper function for `_input_types`
-# generates a string representation of a type
-# (makes up for lack of proper hierarchy in IR type system)
-# (ideally would use type generated during annotation, but
-# not available for builtins)
-def _type_class_of(typ):
-    if is_integer_type(typ):
-        return "int"
-    if is_bytes_m_type(typ):
-        return "bytes_m"
-    if is_decimal_type(typ):
-        return "decimal"
-    if isinstance(typ, BaseType):
-        return typ.typ  # e.g., "bool"
-    if isinstance(typ, ByteArrayType):
-        return "bytes"
-    if isinstance(typ, StringType):
-        return "string"
-
-
 def _input_types(*allowed_types):
     def decorator(f):
         @functools.wraps(f)
         def check_input_type(expr, arg, out_typ):
             # convert arg to out_typ.
             # (expr is the AST corresponding to `arg`)
-            ityp = _type_class_of(arg.typ)
-            ok = ityp in allowed_types
+            ok = isinstance(arg.typ, allowed_types)
             if not ok:
                 _FAIL(arg.typ, out_typ, expr)
 
             # user safety: disallow convert from type to itself
             # note allowance of [u]int256; this is due to type inference
             # on literals not quite working yet.
-            if arg.typ == out_typ and not is_base_type(arg.typ, ("uint256", "int256")):
+            if arg.typ == out_typ and arg.typ not in (UINT256_T, INT256_T):
                 raise InvalidType(f"value and target are both {out_typ}", expr)
 
             return f(expr, arg, out_typ)
 
         return check_input_type
 
     return decorator
@@ -92,21 +75,20 @@
 
 def _bytes_to_num(arg, out_typ, signed):
     # converting a bytestring to a number:
     # bytestring and bytes_m are right-padded with zeroes, int is left-padded.
     # convert by shr or sar the number of zero bytes (converted to bits)
     # e.g. "abcd000000000000" -> bitcast(000000000000abcd, output_type)
 
-    if isinstance(arg.typ, ByteArrayLike):
+    if isinstance(arg.typ, _BytestringT):
         _len = get_bytearray_length(arg)
         arg = LOAD(bytes_data_ptr(arg))
         num_zero_bits = ["mul", 8, ["sub", 32, _len]]
     elif is_bytes_m_type(arg.typ):
-        info = arg.typ._bytes_info
-        num_zero_bits = 8 * (32 - info.m)
+        num_zero_bits = 8 * (32 - arg.typ.m)
     else:
         raise CompilerPanic("unreachable")  # pragma: notest
 
     if signed:
         ret = sar(num_zero_bits, arg)
     else:
         ret = shr(num_zero_bits, arg)
@@ -123,143 +105,135 @@
         # if not arg_is_signed, arg_lo is 0, so this branch cannot be hit
         assert arg_is_signed, "bad assumption in numeric convert"
         arg = clamp("sge", arg, out_lo)
 
     if arg_hi > out_hi:
         # out_hi must be smaller than MAX_UINT256, so clample makes sense.
         # add an assertion, just in case this assumption ever changes.
-        assert out_hi < 2 ** 256 - 1, "bad assumption in numeric convert"
+        assert out_hi < 2**256 - 1, "bad assumption in numeric convert"
         CLAMP_OP = "sle" if arg_is_signed else "le"
         arg = clamp(CLAMP_OP, arg, out_hi)
 
     return arg
 
 
 # truncate from fixed point decimal to int
 def _fixed_to_int(arg, out_typ):
-    arg_info = arg.typ._decimal_info
-    out_info = out_typ._int_info
-
-    DIVISOR = arg_info.divisor
+    DIVISOR = arg.typ.divisor
 
     # block inputs which are out of bounds before truncation.
     # e.g., convert(255.1, uint8) should revert or fail to compile.
-    out_lo, out_hi = out_info.bounds
-    out_lo = out_lo * DIVISOR
-    out_hi = out_hi * DIVISOR
+    out_lo, out_hi = out_typ.int_bounds
+    out_lo *= DIVISOR
+    out_hi *= DIVISOR
 
-    clamped_arg = _clamp_numeric_convert(arg, arg_info.bounds, (out_lo, out_hi), arg_info.is_signed)
+    arg_bounds = arg.typ.int_bounds
 
-    assert arg_info.is_signed, "should use unsigned div"  # stub in case we ever add ufixed
+    clamped_arg = _clamp_numeric_convert(arg, arg_bounds, (out_lo, out_hi), arg.typ.is_signed)
+
+    assert arg.typ.is_signed, "should use unsigned div"  # stub for when we ufixed
     return IRnode.from_list(["sdiv", clamped_arg, DIVISOR], typ=out_typ)
 
 
 # promote from int to fixed point decimal
 def _int_to_fixed(arg, out_typ):
-    arg_info = arg.typ._int_info
-    out_info = out_typ._decimal_info
-
-    DIVISOR = out_info.divisor
+    DIVISOR = out_typ.divisor
 
     # block inputs which are out of bounds before promotion
-    out_lo, out_hi = out_info.bounds
+    out_lo, out_hi = out_typ.int_bounds
     out_lo = round_towards_zero(out_lo / decimal.Decimal(DIVISOR))
     out_hi = round_towards_zero(out_hi / decimal.Decimal(DIVISOR))
 
-    clamped_arg = _clamp_numeric_convert(arg, arg_info.bounds, (out_lo, out_hi), arg_info.is_signed)
+    arg_bounds = arg.typ.int_bounds
+
+    clamped_arg = _clamp_numeric_convert(arg, arg_bounds, (out_lo, out_hi), arg.typ.is_signed)
 
     return IRnode.from_list(["mul", clamped_arg, DIVISOR], typ=out_typ)
 
 
 # clamp for dealing with conversions between int types (from arg to dst)
 def _int_to_int(arg, out_typ):
-    arg_info = arg.typ._int_info
-    out_info = out_typ._int_info
-
     # do the same thing as
-    # _clamp_numeric_convert(arg, arg_info.bounds, out_info.bounds, arg_info.is_signed)
+    # _clamp_numeric_convert(arg, arg.typ.int_bounds, out_typ.int_bounds, arg.typ.is_signed)
     # but with better code size and gas.
-    if arg_info.is_signed and not out_info.is_signed:
-
+    if arg.typ.is_signed and not out_typ.is_signed:
         # e.g. (clample (clampge arg 0) (2**128 - 1))
 
-        # note that when out_info.bits == 256,
+        # note that when out_typ.bits == 256,
         # (clample arg 2**256 - 1) does not make sense.
         # see similar assertion in _clamp_numeric_convert.
 
-        if out_info.bits < arg_info.bits:
-
-            assert out_info.bits < 256, "unreachable"
+        if out_typ.bits < arg.typ.bits:
+            assert out_typ.bits < 256, "unreachable"
             # note: because of the usage of signed=False, and the fact
             # that out_bits < 256 in this branch, below implies
             # not only (clample arg 2**128 - 1) but also (clampge arg 0).
-            arg = int_clamp(arg, out_info.bits, signed=False)
+            arg = int_clamp(arg, out_typ.bits, signed=False)
 
         else:
             # note: this also works for out_bits == 256.
             arg = clamp("sge", arg, 0)
 
-    elif not arg_info.is_signed and out_info.is_signed:
+    elif not arg.typ.is_signed and out_typ.is_signed:
         # e.g. (uclample (uclampge arg 0) (2**127 - 1))
         # (note that (uclampge arg 0) always evaluates to true.)
-        arg = int_clamp(arg, out_info.bits - 1, signed=False)
+        arg = int_clamp(arg, out_typ.bits - 1, signed=False)
 
-    elif out_info.bits < arg_info.bits:
-        assert out_info.bits < 256, "unreachable"
+    elif out_typ.bits < arg.typ.bits:
+        assert out_typ.bits < 256, "unreachable"
         # narrowing conversion, signs are the same.
         # we can just use regular int clampers.
-        arg = int_clamp(arg, out_info.bits, out_info.is_signed)
+        arg = int_clamp(arg, out_typ.bits, out_typ.is_signed)
 
     else:
         # widening conversion, signs are the same.
         # we do not have to do any clamps.
-        assert arg_info.is_signed == out_info.is_signed and out_info.bits >= arg_info.bits
+        assert arg.typ.is_signed == out_typ.is_signed and out_typ.bits >= arg.typ.bits
 
     return IRnode.from_list(arg, typ=out_typ)
 
 
 def _check_bytes(expr, arg, output_type, max_bytes_allowed):
-    if isinstance(arg.typ, ByteArrayLike):
+    if isinstance(arg.typ, _BytestringT):
         if arg.typ.maxlen > max_bytes_allowed:
             _FAIL(arg.typ, output_type, expr)
     else:
         # sanity check. should not have conversions to non-base types
         assert output_type.memory_bytes_required == 32
 
 
 # apply sign extension, if expected. note that the sign bit
 # is always taken to be the first bit of the bytestring.
 # (e.g. convert(0xff <bytes1>, int16) == -1)
 def _signextend(expr, val, arg_typ):
     if isinstance(expr, vy_ast.Hex):
-        assert len(expr.value[2:]) // 2 == arg_typ._bytes_info.m
-        n_bits = arg_typ._bytes_info.m_bits
+        assert len(expr.value[2:]) // 2 == arg_typ.m
+        n_bits = arg_typ.m_bits
     else:
         assert len(expr.value) == arg_typ.maxlen
         n_bits = arg_typ.maxlen * 8
 
     return unsigned_to_signed(val, n_bits)
 
 
 def _literal_int(expr, arg_typ, out_typ):
     # TODO: possible to reuse machinery from expr.py?
-    int_info = out_typ._int_info
     if isinstance(expr, vy_ast.Hex):
         val = int(expr.value, 16)
     elif isinstance(expr, vy_ast.Bytes):
         val = int.from_bytes(expr.value, "big")
     elif isinstance(expr, (vy_ast.Int, vy_ast.Decimal, vy_ast.NameConstant)):
         val = expr.value
     else:  # pragma: no cover
         raise CompilerPanic("unreachable")
 
-    if isinstance(expr, (vy_ast.Hex, vy_ast.Bytes)) and int_info.is_signed:
+    if isinstance(expr, (vy_ast.Hex, vy_ast.Bytes)) and out_typ.is_signed:
         val = _signextend(expr, val, arg_typ)
 
-    (lo, hi) = int_info.bounds
+    lo, hi = out_typ.int_bounds
     if not (lo <= val <= hi):
         raise InvalidLiteral("Number out of range", expr)
 
     # cast to int AFTER bounds check (ensures decimal is in bounds before truncation)
     val = int(val)
 
     return IRnode.from_list(val, typ=out_typ)
@@ -274,236 +248,241 @@
 
     # sanity check type checker did its job
     assert math.ceil(val) == math.floor(val)
 
     val = int(val)
 
     # apply sign extension, if expected
-    out_info = out_typ._decimal_info
-    if isinstance(expr, (vy_ast.Hex, vy_ast.Bytes)) and out_info.is_signed:
+    if isinstance(expr, (vy_ast.Hex, vy_ast.Bytes)) and out_typ.is_signed:
         val = _signextend(expr, val, arg_typ)
 
-    if not SizeLimits.in_bounds("decimal", val):
+    lo, hi = out_typ.int_bounds
+    if not lo <= val <= hi:
         raise InvalidLiteral("Number out of range", expr)
 
     return IRnode.from_list(val, typ=out_typ)
 
 
 # any base type or bytes/string
-@_input_types("int", "decimal", "bytes_m", "address", "bool", "bytes", "string")
+@_input_types(IntegerT, DecimalT, BytesM_T, AddressT, BoolT, BytesT, StringT)
 def to_bool(expr, arg, out_typ):
     _check_bytes(expr, arg, out_typ, 32)  # should we restrict to Bytes[1]?
 
-    if isinstance(arg.typ, ByteArrayType):
+    if isinstance(arg.typ, _BytestringT):
         # no clamp. checks for any nonzero bytes.
         arg = _bytes_to_num(arg, out_typ, signed=False)
 
     # NOTE: for decimal, the behavior is x != 0.0,
     # (we do not issue an `sdiv DECIMAL_DIVISOR`)
 
     return IRnode.from_list(["iszero", ["iszero", arg]], typ=out_typ)
 
 
-@_input_types("int", "bytes_m", "decimal", "bytes", "address", "bool")
+@_input_types(IntegerT, DecimalT, BytesM_T, AddressT, BoolT, EnumT, BytesT)
 def to_int(expr, arg, out_typ):
-    int_info = out_typ._int_info
+    return _to_int(expr, arg, out_typ)
+
 
-    assert int_info.bits % 8 == 0
+# an internal version of to_int without input validation
+def _to_int(expr, arg, out_typ):
+    assert out_typ.bits % 8 == 0
     _check_bytes(expr, arg, out_typ, 32)
 
     if isinstance(expr, vy_ast.Constant):
         return _literal_int(expr, arg.typ, out_typ)
 
-    elif isinstance(arg.typ, ByteArrayType):
+    elif isinstance(arg.typ, BytesT):
         arg_typ = arg.typ
-        arg = _bytes_to_num(arg, out_typ, signed=int_info.is_signed)
-        if arg_typ.maxlen * 8 > int_info.bits:
-            arg = int_clamp(arg, int_info.bits, signed=int_info.is_signed)
+        arg = _bytes_to_num(arg, out_typ, signed=out_typ.is_signed)
+        if arg_typ.maxlen * 8 > out_typ.bits:
+            arg = int_clamp(arg, out_typ.bits, signed=out_typ.is_signed)
 
     elif is_bytes_m_type(arg.typ):
-        arg_info = arg.typ._bytes_info
-        arg = _bytes_to_num(arg, out_typ, signed=int_info.is_signed)
-        if arg_info.m_bits > int_info.bits:
-            arg = int_clamp(arg, int_info.bits, signed=int_info.is_signed)
+        arg_typ = arg.typ
+        arg = _bytes_to_num(arg, out_typ, signed=out_typ.is_signed)
+        if arg_typ.m_bits > out_typ.bits:
+            arg = int_clamp(arg, out_typ.bits, signed=out_typ.is_signed)
 
     elif is_decimal_type(arg.typ):
         arg = _fixed_to_int(arg, out_typ)
 
     elif is_enum_type(arg.typ):
-        if not is_base_type(out_typ, "uint256"):
+        if out_typ != UINT256_T:
             _FAIL(arg.typ, out_typ, expr)
+        # pretend enum is uint256
+        arg = IRnode.from_list(arg, typ=UINT256_T)
+        # use int_to_int rules
         arg = _int_to_int(arg, out_typ)
 
     elif is_integer_type(arg.typ):
         arg = _int_to_int(arg, out_typ)
 
-    elif is_base_type(arg.typ, "address"):
-        if int_info.is_signed:
+    elif arg.typ == AddressT():
+        if out_typ.is_signed:
             # TODO if possible, refactor to move this validation close to the entry of the function
             _FAIL(arg.typ, out_typ, expr)
-        if int_info.bits < 160:
-            arg = int_clamp(arg, int_info.bits, signed=False)
+        if out_typ.bits < 160:
+            arg = int_clamp(arg, out_typ.bits, signed=False)
 
     return IRnode.from_list(arg, typ=out_typ)
 
 
-@_input_types("int", "bool", "bytes_m", "bytes")
+@_input_types(IntegerT, BoolT, BytesM_T, BytesT)
 def to_decimal(expr, arg, out_typ):
     _check_bytes(expr, arg, out_typ, 32)
 
-    out_info = out_typ._decimal_info
-
     if isinstance(expr, vy_ast.Constant):
         return _literal_decimal(expr, arg.typ, out_typ)
 
-    if isinstance(arg.typ, ByteArrayType):
+    if isinstance(arg.typ, BytesT):
         arg_typ = arg.typ
         arg = _bytes_to_num(arg, out_typ, signed=True)
         if arg_typ.maxlen * 8 > 168:
             arg = IRnode.from_list(arg, typ=out_typ)
             arg = clamp_basetype(arg)
 
         return IRnode.from_list(arg, typ=out_typ)
 
     elif is_bytes_m_type(arg.typ):
-        info = arg.typ._bytes_info
+        arg_typ = arg.typ
         arg = _bytes_to_num(arg, out_typ, signed=True)
-        if info.m_bits > 168:
+        if arg_typ.m_bits > 168:
             arg = IRnode.from_list(arg, typ=out_typ)
             arg = clamp_basetype(arg)
 
         return IRnode.from_list(arg, typ=out_typ)
 
     elif is_integer_type(arg.typ):
         arg = _int_to_fixed(arg, out_typ)
         return IRnode.from_list(arg, typ=out_typ)
 
-    elif is_base_type(arg.typ, "bool"):
-        # TODO: consider adding _int_info to bool so we can use _int_to_fixed
-        arg = ["mul", arg, 10 ** out_info.decimals]
+    elif arg.typ == BoolT():
+        # TODO: consider adding is_signed and bits to bool so we can use _int_to_fixed
+        arg = ["mul", arg, 10**out_typ.decimals]
         return IRnode.from_list(arg, typ=out_typ)
     else:
         raise CompilerPanic("unreachable")  # pragma: notest
 
 
-@_input_types("int", "decimal", "bytes_m", "address", "bytes", "bool")
+@_input_types(IntegerT, DecimalT, BytesM_T, AddressT, BytesT, BoolT)
 def to_bytes_m(expr, arg, out_typ):
-    out_info = out_typ._bytes_info
+    _check_bytes(expr, arg, out_typ, max_bytes_allowed=out_typ.m)
 
-    _check_bytes(expr, arg, out_typ, max_bytes_allowed=out_info.m)
-
-    if isinstance(arg.typ, ByteArrayType):
+    if isinstance(arg.typ, BytesT):
         bytes_val = LOAD(bytes_data_ptr(arg))
 
         # zero out any dirty bytes (which can happen in the last
         # word of a bytearray)
         len_ = get_bytearray_length(arg)
         num_zero_bits = IRnode.from_list(["mul", ["sub", 32, len_], 8])
         with num_zero_bits.cache_when_complex("bits") as (b, num_zero_bits):
             arg = shl(num_zero_bits, shr(num_zero_bits, bytes_val))
             arg = b.resolve(arg)
 
     elif is_bytes_m_type(arg.typ):
-        arg_info = arg.typ._bytes_info
         # clamp if it's a downcast
-        if arg_info.m > out_info.m:
-            arg = bytes_clamp(arg, out_info.m)
+        if arg.typ.m > out_typ.m:
+            arg = bytes_clamp(arg, out_typ.m)
 
-    elif is_integer_type(arg.typ) or is_base_type(arg.typ, "address"):
-        int_bits = arg.typ._int_info.bits
+    elif is_integer_type(arg.typ) or arg.typ == AddressT():
+        if arg.typ == AddressT():
+            int_bits = 160
+        else:
+            int_bits = arg.typ.bits
 
-        if out_info.m_bits < int_bits:
+        if out_typ.m_bits < int_bits:
             # question: allow with runtime clamp?
-            # arg = int_clamp(m_bits, signed=int_info.signed)
+            # arg = int_clamp(m_bits, signed=arg.typ.signed)
             _FAIL(arg.typ, out_typ, expr)
 
         # note: neg numbers not OOB. keep sign bit
-        arg = shl(256 - out_info.m_bits, arg)
+        arg = shl(256 - out_typ.m_bits, arg)
 
     elif is_decimal_type(arg.typ):
-        if out_info.m_bits < arg.typ._decimal_info.bits:
+        if out_typ.m_bits < arg.typ.bits:
             _FAIL(arg.typ, out_typ, expr)
 
         # note: neg numbers not OOB. keep sign bit
-        arg = shl(256 - out_info.m_bits, arg)
+        arg = shl(256 - out_typ.m_bits, arg)
 
     else:
         # bool
-        arg = shl(256 - out_info.m_bits, arg)
+        arg = shl(256 - out_typ.m_bits, arg)
 
     return IRnode.from_list(arg, typ=out_typ)
 
 
-@_input_types("bytes_m", "int", "bytes")
+@_input_types(BytesM_T, IntegerT, BytesT)
 def to_address(expr, arg, out_typ):
     # question: should this be allowed?
     if is_integer_type(arg.typ):
-        if arg.typ._int_info.is_signed:
+        if arg.typ.is_signed:
             _FAIL(arg.typ, out_typ, expr)
 
-    return to_int(expr, arg, out_typ)
+    ret = _to_int(expr, arg, UINT160_T)
+    return IRnode.from_list(ret, out_typ)
 
 
 # question: should we allow bytesM -> String?
-@_input_types("bytes")
+@_input_types(BytesT)
 def to_string(expr, arg, out_typ):
     _check_bytes(expr, arg, out_typ, out_typ.maxlen)
 
     # NOTE: this is a pointer cast
     return IRnode.from_list(arg, typ=out_typ)
 
 
-@_input_types("string")
+@_input_types(StringT)
 def to_bytes(expr, arg, out_typ):
     _check_bytes(expr, arg, out_typ, out_typ.maxlen)
 
     # TODO: more casts
 
     # NOTE: this is a pointer cast
     return IRnode.from_list(arg, typ=out_typ)
 
 
-@_input_types("int")
+@_input_types(IntegerT)
 def to_enum(expr, arg, out_typ):
-    if not is_base_type(arg.typ, "uint256"):
+    if arg.typ != UINT256_T:
         _FAIL(arg.typ, out_typ, expr)
 
-    if len(out_typ.members) < 256:
-        arg = int_clamp(arg, bits=len(out_typ.members), signed=False)
+    if len(out_typ._enum_members) < 256:
+        arg = int_clamp(arg, bits=len(out_typ._enum_members), signed=False)
 
     return IRnode.from_list(arg, typ=out_typ)
 
 
 def convert(expr, context):
-    if len(expr.args) != 2:
-        raise StructureException("The convert function expects two parameters.", expr)
+    assert len(expr.args) == 2, "bad typecheck: convert"
 
     arg_ast = expr.args[0]
     arg = Expr(arg_ast, context).ir_node
     original_arg = arg
-    out_typ = context.parse_type(expr.args[1])
 
-    if isinstance(arg.typ, BaseType):
+    out_typ = expr.args[1]._metadata["type"].typedef
+
+    if arg.typ._is_prim_word:
         arg = unwrap_location(arg)
     with arg.cache_when_complex("arg") as (b, arg):
-        if is_base_type(out_typ, "bool"):
+        if out_typ == BoolT():
             ret = to_bool(arg_ast, arg, out_typ)
-        elif is_base_type(out_typ, "address"):
+        elif out_typ == AddressT():
             ret = to_address(arg_ast, arg, out_typ)
-        elif isinstance(out_typ, EnumType):
+        elif is_enum_type(out_typ):
             ret = to_enum(arg_ast, arg, out_typ)
         elif is_integer_type(out_typ):
             ret = to_int(arg_ast, arg, out_typ)
         elif is_bytes_m_type(out_typ):
             ret = to_bytes_m(arg_ast, arg, out_typ)
         elif is_decimal_type(out_typ):
             ret = to_decimal(arg_ast, arg, out_typ)
-        elif isinstance(out_typ, ByteArrayType):
+        elif isinstance(out_typ, BytesT):
             ret = to_bytes(arg_ast, arg, out_typ)
-        elif isinstance(out_typ, StringType):
+        elif isinstance(out_typ, StringT):
             ret = to_string(arg_ast, arg, out_typ)
         else:
             raise StructureException(f"Conversion to {out_typ} is invalid.", arg_ast)
 
         # test if arg actually changed. if not, we do not need to use
         # unwrap_location (this can reduce memory traffic for downstream
         # operations which are in-place, like the returndata routine)
```

### Comparing `vyper-0.3.7/vyper/builtin_functions/functions.py` & `vyper-0.3.8/vyper/builtins/functions.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,20 +1,17 @@
 import hashlib
 import math
 import operator
 from decimal import Decimal
 
 from vyper import ast as vy_ast
 from vyper.abi_types import ABI_Tuple
-from vyper.address_space import MEMORY, STORAGE
-from vyper.ast.signatures.function_signature import VariableRecord
 from vyper.ast.validation import validate_call_args
-from vyper.builtin_functions.convert import convert
 from vyper.codegen.abi_encoder import abi_encode
-from vyper.codegen.context import Context
+from vyper.codegen.context import Context, VariableRecord
 from vyper.codegen.core import (
     STORE,
     IRnode,
     _freshname,
     add_ofst,
     bytes_data_ptr,
     calculate_type_for_external_return,
@@ -25,102 +22,87 @@
     clamp_nonzero,
     copy_bytes,
     ensure_in_memory,
     eval_once_check,
     eval_seq,
     get_bytearray_length,
     get_element_ptr,
+    get_type_for_exact_size,
     ir_tuple_from_args,
     needs_external_call_wrap,
     promote_signed_int,
     sar,
     shl,
     shr,
     unwrap_location,
 )
 from vyper.codegen.expr import Expr
 from vyper.codegen.ir_node import Encoding
 from vyper.codegen.keccak256_helper import keccak256_helper
-from vyper.codegen.types import (
-    BaseType,
-    ByteArrayLike,
-    ByteArrayType,
-    SArrayType,
-    StringType,
-    TupleType,
-    get_type_for_exact_size,
-    is_base_type,
-    parse_decimal_info,
-    parse_integer_typeinfo,
-)
-from vyper.codegen.types.convert import new_type_to_old_type
+from vyper.evm.address_space import MEMORY, STORAGE
 from vyper.exceptions import (
     ArgumentException,
     CompilerPanic,
     InvalidLiteral,
     InvalidType,
     OverflowException,
     StateAccessViolation,
     StructureException,
     TypeMismatch,
     UnfoldableNode,
     ZeroDivisionException,
 )
-from vyper.semantics.types import (
-    ArrayDefinition,
-    BoolDefinition,
-    DynamicArrayDefinition,
-    DynamicArrayPrimitive,
-    TupleDefinition,
-)
-from vyper.semantics.types.abstract import (
-    ArrayValueAbstractType,
-    BytesAbstractType,
-    FixedAbstractType,
-    IntegerAbstractType,
-    NumericAbstractType,
-    SignedIntegerAbstractType,
-    UnsignedIntegerAbstractType,
-)
-from vyper.semantics.types.bases import DataLocation
-from vyper.semantics.types.utils import KwargSettings, TypeTypeDefinition, get_type_from_annotation
-from vyper.semantics.types.value.address import AddressDefinition
-from vyper.semantics.types.value.array_value import (
-    BytesArrayDefinition,
-    BytesArrayPrimitive,
-    StringDefinition,
-    StringPrimitive,
-)
-from vyper.semantics.types.value.bytes_fixed import Bytes4Definition  # type: ignore
-from vyper.semantics.types.value.bytes_fixed import Bytes32Definition
-from vyper.semantics.types.value.numeric import Int256Definition  # type: ignore
-from vyper.semantics.types.value.numeric import Uint8Definition  # type: ignore
-from vyper.semantics.types.value.numeric import Uint256Definition  # type: ignore
-from vyper.semantics.types.value.numeric import DecimalDefinition
-from vyper.semantics.validation.utils import (
+from vyper.semantics.analysis.base import VarInfo
+from vyper.semantics.analysis.utils import (
     get_common_types,
     get_exact_type_from_node,
     get_possible_types_from_node,
     validate_expected_type,
 )
+from vyper.semantics.types import (
+    TYPE_T,
+    AddressT,
+    BoolT,
+    BytesM_T,
+    BytesT,
+    DArrayT,
+    DecimalT,
+    HashMapT,
+    IntegerT,
+    KwargSettings,
+    SArrayT,
+    StringT,
+    TupleT,
+)
+from vyper.semantics.types.bytestrings import _BytestringT
+from vyper.semantics.types.shortcuts import (
+    BYTES4_T,
+    BYTES32_T,
+    INT128_T,
+    INT256_T,
+    UINT8_T,
+    UINT256_T,
+)
+from vyper.semantics.types.utils import type_from_annotation
 from vyper.utils import (
     DECIMAL_DIVISOR,
     EIP_170_LIMIT,
     SHA3_PER_WORD,
     MemoryPositions,
     SizeLimits,
-    abi_method_id,
     bytes_to_int,
     ceil32,
     fourbytes_to_int,
     keccak256,
+    method_id_int,
     vyper_warn,
 )
 
-from .signatures import BuiltinFunction, process_inputs
+from ._convert import convert
+from ._signatures import BuiltinFunction, process_inputs
 
 SHA256_ADDRESS = 2
 SHA256_BASE_GAS = 60
 SHA256_PER_WORD_GAS = 12
 
 
 class FoldedFunction(BuiltinFunction):
@@ -142,126 +124,126 @@
 
     def fetch_call_return(self, node):
         type_ = self.infer_arg_types(node)[0].typedef
         return type_
 
     def infer_arg_types(self, node):
         validate_call_args(node, 1)
-        input_typedef = TypeTypeDefinition(
-            get_type_from_annotation(node.args[0], DataLocation.MEMORY)
-        )
+        input_typedef = TYPE_T(type_from_annotation(node.args[0]))
         return [input_typedef]
 
 
 class Floor(BuiltinFunction):
-
     _id = "floor"
-    _inputs = [("value", DecimalDefinition())]
+    _inputs = [("value", DecimalT())]
     # TODO: maybe use int136?
-    _return_type = Int256Definition()
+    _return_type = INT256_T
 
     def evaluate(self, node):
         validate_call_args(node, 1)
         if not isinstance(node.args[0], vy_ast.Decimal):
             raise UnfoldableNode
 
         value = math.floor(node.args[0].value)
         return vy_ast.Int.from_node(node, value=value)
 
     @process_inputs
     def build_IR(self, expr, args, kwargs, context):
-        return IRnode.from_list(
-            [
-                "if",
-                ["slt", args[0], 0],
-                ["sdiv", ["sub", args[0], DECIMAL_DIVISOR - 1], DECIMAL_DIVISOR],
-                ["sdiv", args[0], DECIMAL_DIVISOR],
-            ],
-            typ=BaseType("int256"),
-        )
+        arg = args[0]
+        with arg.cache_when_complex("arg") as (b1, arg):
+            ret = IRnode.from_list(
+                [
+                    "if",
+                    ["slt", arg, 0],
+                    ["sdiv", ["sub", arg, DECIMAL_DIVISOR - 1], DECIMAL_DIVISOR],
+                    ["sdiv", arg, DECIMAL_DIVISOR],
+                ],
+                typ=INT256_T,
+            )
+            return b1.resolve(ret)
 
 
 class Ceil(BuiltinFunction):
-
     _id = "ceil"
-    _inputs = [("value", DecimalDefinition())]
+    _inputs = [("value", DecimalT())]
     # TODO: maybe use int136?
-    _return_type = Int256Definition()
+    _return_type = INT256_T
 
     def evaluate(self, node):
         validate_call_args(node, 1)
         if not isinstance(node.args[0], vy_ast.Decimal):
             raise UnfoldableNode
 
         value = math.ceil(node.args[0].value)
         return vy_ast.Int.from_node(node, value=value)
 
     @process_inputs
     def build_IR(self, expr, args, kwargs, context):
-        return IRnode.from_list(
-            [
-                "if",
-                ["slt", args[0], 0],
-                ["sdiv", args[0], DECIMAL_DIVISOR],
-                ["sdiv", ["add", args[0], DECIMAL_DIVISOR - 1], DECIMAL_DIVISOR],
-            ],
-            typ=BaseType("int256"),
-        )
+        arg = args[0]
+        with arg.cache_when_complex("arg") as (b1, arg):
+            ret = IRnode.from_list(
+                [
+                    "if",
+                    ["slt", arg, 0],
+                    ["sdiv", arg, DECIMAL_DIVISOR],
+                    ["sdiv", ["add", arg, DECIMAL_DIVISOR - 1], DECIMAL_DIVISOR],
+                ],
+                typ=INT256_T,
+            )
+            return b1.resolve(ret)
 
 
 class Convert(BuiltinFunction):
-
     _id = "convert"
 
     def fetch_call_return(self, node):
         _, target_typedef = self.infer_arg_types(node)
 
         # note: more type conversion validation happens in convert.py
         return target_typedef.typedef
 
     # TODO: push this down into convert.py for more consistency
     def infer_arg_types(self, node):
         validate_call_args(node, 2)
 
-        target_type = get_type_from_annotation(node.args[1], DataLocation.UNSET)
+        target_type = type_from_annotation(node.args[1])
         value_types = get_possible_types_from_node(node.args[0])
 
         # For `convert` of integer literals, we need to match type inference rules in
         # convert.py codegen routines.
         # TODO: This can probably be removed once constant folding for `convert` is implemented
-        if len(value_types) > 1 and all(isinstance(v, IntegerAbstractType) for v in value_types):
+        if len(value_types) > 1 and all(isinstance(v, IntegerT) for v in value_types):
             # Get the smallest (and unsigned if available) type for non-integer target types
             # (note this is different from the ordering returned by `get_possible_types_from_node`)
-            if not isinstance(target_type, IntegerAbstractType):
-                value_types = sorted(
-                    value_types, key=lambda v: (v._is_signed, v._bits), reverse=True
-                )
+            if not isinstance(target_type, IntegerT):
+                value_types = sorted(value_types, key=lambda v: (v.is_signed, v.bits), reverse=True)
             else:
                 # filter out the target type from list of possible types
                 value_types = [i for i in value_types if not target_type.compare_type(i)]
 
         value_type = value_types.pop()
 
         # block conversions between same type
         if target_type.compare_type(value_type):
             raise InvalidType(f"Value and target type are both '{target_type}'", node)
 
-        return [value_type, TypeTypeDefinition(target_type)]
+        return [value_type, TYPE_T(target_type)]
 
     def build_IR(self, expr, context):
         return convert(expr, context)
 
 
 ADHOC_SLICE_NODE_MACROS = ["~calldata", "~selfcode", "~extcode"]
 
 
 def _build_adhoc_slice_node(sub: IRnode, start: IRnode, length: IRnode, context: Context) -> IRnode:
     assert length.is_literal, "typechecker failed"
+    assert isinstance(length.value, int)  # mypy hint
 
-    dst_typ = ByteArrayType(maxlen=length.value)
+    dst_typ = BytesT(length.value)
     # allocate a buffer for the return value
     np = context.new_internal_variable(dst_typ)
 
     # `msg.data` by `calldatacopy`
     if sub.value == "~calldata":
         node = [
             "seq",
@@ -294,42 +276,43 @@
                 ["assert", ["le", ["add", start, length], ["extcodesize", "_extcode_address"]]],
                 ["mstore", np, length],
                 ["extcodecopy", "_extcode_address", np + 32, start, length],
                 np,
             ],
         ]
 
-    return IRnode.from_list(node, typ=ByteArrayType(length.value), location=MEMORY)
+    assert isinstance(length.value, int)  # mypy hint
+    return IRnode.from_list(node, typ=BytesT(length.value), location=MEMORY)
 
 
+# note: this and a lot of other builtins could be refactored to accept any uint type
 class Slice(BuiltinFunction):
-
     _id = "slice"
     _inputs = [
-        ("b", (Bytes32Definition(), BytesArrayPrimitive(), StringPrimitive())),
-        ("start", Uint256Definition()),
-        ("length", Uint256Definition()),
+        ("b", (BYTES32_T, BytesT.any(), StringT.any())),
+        ("start", UINT256_T),
+        ("length", UINT256_T),
     ]
     _return_type = None
 
     def fetch_call_return(self, node):
         arg_type, _, _ = self.infer_arg_types(node)
 
-        if isinstance(arg_type, StringDefinition):
-            return_type = StringDefinition()
+        if isinstance(arg_type, StringT):
+            return_type = StringT()
         else:
-            return_type = BytesArrayDefinition()
+            return_type = BytesT()
 
         # validate start and length are in bounds
 
         arg = node.args[0]
         start_expr = node.args[1]
         length_expr = node.args[2]
 
-        # CMC 2022-03-22 NOTE slight code duplication with semantics/validation/local
+        # CMC 2022-03-22 NOTE slight code duplication with semantics/analysis/local
         is_adhoc_slice = arg.get("attr") == "code" or (
             arg.get("value.id") == "msg" and arg.get("attr") == "data"
         )
 
         start_literal = start_expr.value if isinstance(start_expr, vy_ast.Int) else None
         length_literal = length_expr.value if isinstance(length_expr, vy_ast.Int) else None
 
@@ -359,33 +342,31 @@
         self._validate_arg_types(node)
         # return a concrete type for `b`
         b_type = get_possible_types_from_node(node.args[0]).pop()
         return [b_type, self._inputs[1][1], self._inputs[2][1]]
 
     @process_inputs
     def build_IR(self, expr, args, kwargs, context):
-
         src, start, length = args
 
         # Handle `msg.data`, `self.code`, and `<address>.code`
         if src.value in ADHOC_SLICE_NODE_MACROS:
             return _build_adhoc_slice_node(src, start, length, context)
 
-        is_bytes32 = is_base_type(src.typ, "bytes32")
+        is_bytes32 = src.typ == BYTES32_T
         if src.location is None:
             # it's not a pointer; force it to be one since
             # copy_bytes works on pointers.
             assert is_bytes32, src
             src = ensure_in_memory(src, context)
 
         with src.cache_when_complex("src") as (b1, src), start.cache_when_complex("start") as (
             b2,
             start,
         ), length.cache_when_complex("length") as (b3, length):
-
             if is_bytes32:
                 src_maxlen = 32
             else:
                 src_maxlen = src.typ.maxlen
 
             dst_maxlen = length.value if length.is_literal else src_maxlen
 
@@ -393,22 +374,23 @@
 
             # add 32 bytes to the buffer size bc word access might
             # be unaligned (see below)
             if src.location == STORAGE:
                 buflen += 32
 
             # Get returntype string or bytes
-            assert isinstance(src.typ, ByteArrayLike) or is_bytes32
-            if isinstance(src.typ, StringType):
-                dst_typ = StringType(maxlen=dst_maxlen)
+            assert isinstance(src.typ, _BytestringT) or is_bytes32
+            # TODO: try to get dst_typ from semantic analysis
+            if isinstance(src.typ, StringT):
+                dst_typ = StringT(dst_maxlen)
             else:
-                dst_typ = ByteArrayType(maxlen=dst_maxlen)
+                dst_typ = BytesT(dst_maxlen)
 
             # allocate a buffer for the return value
-            buf = context.new_internal_variable(ByteArrayType(buflen))
+            buf = context.new_internal_variable(BytesT(buflen))
             # assign it the correct return type.
             # (note mismatch between dst_maxlen and buflen)
             dst = IRnode.from_list(buf, typ=dst_typ, location=MEMORY)
 
             dst_data = bytes_data_ptr(dst)
 
             if is_bytes32:
@@ -472,18 +454,17 @@
                 dst,  # return pointer to dst
             ]
             ret = IRnode.from_list(ret, typ=dst_typ, location=MEMORY)
             return b1.resolve(b2.resolve(b3.resolve(ret)))
 
 
 class Len(BuiltinFunction):
-
     _id = "len"
-    _inputs = [("b", (ArrayValueAbstractType(), DynamicArrayPrimitive()))]
-    _return_type = Uint256Definition()
+    _inputs = [("b", (StringT.any(), BytesT.any(), DArrayT.any()))]
+    _return_type = UINT256_T
 
     def evaluate(self, node):
         validate_call_args(node, 1)
         arg = node.args[0]
         if isinstance(arg, (vy_ast.Str, vy_ast.Bytes)):
             length = len(arg.value)
         elif isinstance(arg, vy_ast.Hex):
@@ -493,49 +474,48 @@
             raise UnfoldableNode
 
         return vy_ast.Int.from_node(node, value=length)
 
     def build_IR(self, node, context):
         arg = Expr(node.args[0], context).ir_node
         if arg.value == "~calldata":
-            return IRnode.from_list(["calldatasize"], typ="uint256")
+            return IRnode.from_list(["calldatasize"], typ=UINT256_T)
         return get_bytearray_length(arg)
 
 
 class Concat(BuiltinFunction):
-
     _id = "concat"
 
     def fetch_call_return(self, node):
         arg_types = self.infer_arg_types(node)
 
         length = 0
         for arg_t in arg_types:
             length += arg_t.length
 
-        if isinstance(arg_types[0], BytesAbstractType):
-            return_type = BytesArrayDefinition()
+        if isinstance(arg_types[0], (StringT)):
+            return_type = StringT()
         else:
-            return_type = StringDefinition()
+            return_type = BytesT()
         return_type.set_length(length)
         return return_type
 
     def infer_arg_types(self, node):
         if len(node.args) < 2:
             raise ArgumentException("Invalid argument count: expected at least 2", node)
 
         if node.keywords:
             raise ArgumentException("Keyword arguments are not accepted here", node.keywords[0])
 
         ret = []
         prev_typeclass = None
         for arg in node.args:
-            validate_expected_type(arg, (BytesAbstractType(), StringDefinition()))
+            validate_expected_type(arg, (BytesT.any(), StringT.any(), BytesM_T.any()))
             arg_t = get_possible_types_from_node(arg).pop()
-            current_typeclass = "Bytes" if isinstance(arg_t, BytesAbstractType) else "String"
+            current_typeclass = "String" if isinstance(arg_t, StringT) else "Bytes"
             if prev_typeclass and current_typeclass != prev_typeclass:
                 raise TypeMismatch(
                     (
                         "Concat expects consistent use of string or bytes types, "
                         "use either string or bytes."
                     ),
                     arg,
@@ -548,24 +528,22 @@
     def build_IR(self, expr, context):
         args = [Expr(arg, context).ir_node for arg in expr.args]
         if len(args) < 2:
             raise StructureException("Concat expects at least two arguments", expr)
 
         # Maximum length of the output
         dst_maxlen = sum(
-            [
-                arg.typ.maxlen if isinstance(arg.typ, ByteArrayLike) else arg.typ._bytes_info.m
-                for arg in args
-            ]
+            [arg.typ.maxlen if isinstance(arg.typ, _BytestringT) else arg.typ.m for arg in args]
         )
 
-        if isinstance(args[0].typ, StringType):
-            ret_typ = StringType(maxlen=dst_maxlen)
+        # TODO: try to grab these from semantic analysis
+        if isinstance(args[0].typ, StringT):
+            ret_typ = StringT(dst_maxlen)
         else:
-            ret_typ = ByteArrayType(maxlen=dst_maxlen)
+            ret_typ = BytesT(dst_maxlen)
 
         # Node representing the position of the output in memory
         dst = IRnode.from_list(
             context.new_internal_variable(ret_typ),
             typ=ret_typ,
             location=MEMORY,
             annotation="concat destination",
@@ -573,53 +551,51 @@
 
         ret = ["seq"]
         # stack item representing our current offset in the dst buffer
         ofst = "concat_ofst"
 
         # TODO: optimize for the case where all lengths are statically known.
         for arg in args:
-
             dst_data = add_ofst(bytes_data_ptr(dst), ofst)
 
-            if isinstance(arg.typ, ByteArrayLike):
+            if isinstance(arg.typ, _BytestringT):
                 # Ignore empty strings
                 if arg.typ.maxlen == 0:
                     continue
 
                 with arg.cache_when_complex("arg") as (b1, arg):
                     argdata = bytes_data_ptr(arg)
 
                     with get_bytearray_length(arg).cache_when_complex("len") as (b2, arglen):
-
                         do_copy = [
                             "seq",
                             copy_bytes(dst_data, argdata, arglen, arg.typ.maxlen),
                             ["set", ofst, ["add", ofst, arglen]],
                         ]
                         ret.append(b1.resolve(b2.resolve(do_copy)))
 
             else:
                 ret.append(STORE(dst_data, unwrap_location(arg)))
-                ret.append(["set", ofst, ["add", ofst, arg.typ._bytes_info.m]])
+                ret.append(["set", ofst, ["add", ofst, arg.typ.m]])
 
         ret.append(STORE(dst, ofst))
 
         # Memory location of the output
         ret.append(dst)
 
         return IRnode.from_list(
             ["with", ofst, 0, ret], typ=ret_typ, location=MEMORY, annotation="concat"
         )
 
 
 class Keccak256(BuiltinFunction):
-
     _id = "keccak256"
-    _inputs = [("value", (BytesAbstractType(), StringDefinition()))]
-    _return_type = Bytes32Definition()
+    # TODO allow any BytesM_T
+    _inputs = [("value", (BytesT.any(), BYTES32_T, StringT.any()))]
+    _return_type = BYTES32_T
 
     def evaluate(self, node):
         validate_call_args(node, 1)
         if isinstance(node.args[0], vy_ast.Bytes):
             value = node.args[0].value
         elif isinstance(node.args[0], vy_ast.Str):
             value = node.args[0].value.encode()
@@ -637,15 +613,15 @@
         # return a concrete type for `value`
         value_type = get_possible_types_from_node(node.args[0]).pop()
         return [value_type]
 
     @process_inputs
     def build_IR(self, expr, args, kwargs, context):
         assert len(args) == 1
-        return keccak256_helper(expr, args[0], context)
+        return keccak256_helper(args[0], context)
 
 
 def _make_sha256_call(inp_start, inp_len, out_start, out_len):
     return [
         "assert",
         [
             "staticcall",
@@ -656,18 +632,17 @@
             out_start,
             out_len,
         ],
     ]
 
 
 class Sha256(BuiltinFunction):
-
     _id = "sha256"
-    _inputs = [("value", (Bytes32Definition(), BytesArrayPrimitive(), StringPrimitive()))]
-    _return_type = Bytes32Definition()
+    _inputs = [("value", (BYTES32_T, BytesT.any(), StringT.any()))]
+    _return_type = BYTES32_T
 
     def evaluate(self, node):
         validate_call_args(node, 1)
         if isinstance(node.args[0], vy_ast.Bytes):
             value = node.args[0].value
         elif isinstance(node.args[0], vy_ast.Str):
             value = node.args[0].value.encode()
@@ -686,28 +661,28 @@
         value_type = get_possible_types_from_node(node.args[0]).pop()
         return [value_type]
 
     @process_inputs
     def build_IR(self, expr, args, kwargs, context):
         sub = args[0]
         # bytes32 input
-        if is_base_type(sub.typ, "bytes32"):
+        if sub.typ == BYTES32_T:
             return IRnode.from_list(
                 [
                     "seq",
                     ["mstore", MemoryPositions.FREE_VAR_SPACE, sub],
                     _make_sha256_call(
                         inp_start=MemoryPositions.FREE_VAR_SPACE,
                         inp_len=32,
                         out_start=MemoryPositions.FREE_VAR_SPACE,
                         out_len=32,
                     ),
                     ["mload", MemoryPositions.FREE_VAR_SPACE],  # push value onto stack
                 ],
-                typ=BaseType("bytes32"),
+                typ=BYTES32_T,
                 add_gas_estimate=SHA256_BASE_GAS + 1 * SHA256_PER_WORD_GAS,
             )
         # bytearay-like input
         # special case if it's already in memory
         sub = ensure_in_memory(sub, context)
 
         return IRnode.from_list(
@@ -723,82 +698,78 @@
                         inp_len=["mload", "_sub"],
                         out_start=MemoryPositions.FREE_VAR_SPACE,
                         out_len=32,
                     ),
                     ["mload", MemoryPositions.FREE_VAR_SPACE],
                 ],
             ],
-            typ=BaseType("bytes32"),
+            typ=BYTES32_T,
             add_gas_estimate=SHA256_BASE_GAS + sub.typ.maxlen * SHA256_PER_WORD_GAS,
         )
 
 
 class MethodID(FoldedFunction):
-
     _id = "method_id"
 
     def evaluate(self, node):
         validate_call_args(node, 1, ["output_type"])
 
         args = node.args
         if not isinstance(args[0], vy_ast.Str):
             raise InvalidType("method id must be given as a literal string", args[0])
         if " " in args[0].value:
             raise InvalidLiteral("Invalid function signature - no spaces allowed.")
 
         return_type = self.infer_kwarg_types(node)
-        value = abi_method_id(args[0].value)
+        value = method_id_int(args[0].value)
 
-        if isinstance(return_type, Bytes4Definition):
+        if return_type.compare_type(BYTES4_T):
             return vy_ast.Hex.from_node(node, value=hex(value))
         else:
             return vy_ast.Bytes.from_node(node, value=value.to_bytes(4, "big"))
 
     def fetch_call_return(self, node):
         validate_call_args(node, 1, ["output_type"])
 
         type_ = self.infer_kwarg_types(node)
         return type_
 
     def infer_kwarg_types(self, node):
         if node.keywords:
-            return_type = get_type_from_annotation(node.keywords[0].value, DataLocation.UNSET)
-            if isinstance(return_type, Bytes4Definition):
-                return Bytes4Definition()
-            elif isinstance(return_type, BytesArrayDefinition) and return_type.length == 4:
-                return BytesArrayDefinition(4)
+            return_type = type_from_annotation(node.keywords[0].value)
+            if return_type.compare_type(BYTES4_T):
+                return BYTES4_T
+            elif isinstance(return_type, BytesT) and return_type.length == 4:
+                return BytesT(4)
             else:
                 raise ArgumentException("output_type must be Bytes[4] or bytes4", node.keywords[0])
 
         # If `output_type` is not given, default to `Bytes[4]`
-        return BytesArrayDefinition(4)
+        return BytesT(4)
 
 
 class ECRecover(BuiltinFunction):
-
     _id = "ecrecover"
     _inputs = [
-        ("hash", Bytes32Definition()),
-        ("v", (Uint256Definition(), Uint8Definition())),
-        ("r", (Uint256Definition(), Bytes32Definition())),
-        ("s", (Uint256Definition(), Bytes32Definition())),
+        ("hash", BYTES32_T),
+        ("v", (UINT256_T, UINT8_T)),
+        ("r", (UINT256_T, BYTES32_T)),
+        ("s", (UINT256_T, BYTES32_T)),
     ]
-    _return_type = AddressDefinition()
+    _return_type = AddressT()
 
     def infer_arg_types(self, node):
         self._validate_arg_types(node)
         v_t, r_t, s_t = [get_possible_types_from_node(arg).pop() for arg in node.args[1:]]
-        return [Bytes32Definition(), v_t, r_t, s_t]
+        return [BYTES32_T, v_t, r_t, s_t]
 
     @process_inputs
     def build_IR(self, expr, args, kwargs, context):
         placeholder_node = IRnode.from_list(
-            context.new_internal_variable(ByteArrayType(128)),
-            typ=ByteArrayType(128),
-            location=MEMORY,
+            context.new_internal_variable(BytesT(128)), typ=BytesT(128), location=MEMORY
         )
         return IRnode.from_list(
             [
                 "seq",
                 ["mstore", placeholder_node, args[0]],
                 ["mstore", ["add", placeholder_node, 32], args[1]],
                 ["mstore", ["add", placeholder_node, 64], args[2]],
@@ -813,144 +784,142 @@
                         128,
                         MemoryPositions.FREE_VAR_SPACE,
                         32,
                     ],
                 ],
                 ["mload", MemoryPositions.FREE_VAR_SPACE],
             ],
-            typ=BaseType("address"),
+            typ=AddressT(),
         )
 
 
 def _getelem(arg, ind):
-    return unwrap_location(get_element_ptr(arg, IRnode.from_list(ind, "int128")))
+    return unwrap_location(get_element_ptr(arg, IRnode.from_list(ind, typ=INT128_T)))
 
 
 class ECAdd(BuiltinFunction):
-
     _id = "ecadd"
-    _inputs = [
-        ("a", ArrayDefinition(Uint256Definition(), 2)),
-        ("b", ArrayDefinition(Uint256Definition(), 2)),
-    ]
-    _return_type = ArrayDefinition(Uint256Definition(), 2)
+    _inputs = [("a", SArrayT(UINT256_T, 2)), ("b", SArrayT(UINT256_T, 2))]
+    _return_type = SArrayT(UINT256_T, 2)
 
     @process_inputs
     def build_IR(self, expr, args, kwargs, context):
         placeholder_node = IRnode.from_list(
-            context.new_internal_variable(ByteArrayType(128)),
-            typ=ByteArrayType(128),
-            location=MEMORY,
+            context.new_internal_variable(BytesT(128)), typ=BytesT(128), location=MEMORY
         )
-        o = IRnode.from_list(
-            [
-                "seq",
-                ["mstore", placeholder_node, _getelem(args[0], 0)],
-                ["mstore", ["add", placeholder_node, 32], _getelem(args[0], 1)],
-                ["mstore", ["add", placeholder_node, 64], _getelem(args[1], 0)],
-                ["mstore", ["add", placeholder_node, 96], _getelem(args[1], 1)],
-                ["assert", ["staticcall", ["gas"], 6, placeholder_node, 128, placeholder_node, 64]],
-                placeholder_node,
-            ],
-            typ=SArrayType(BaseType("uint256"), 2),
-            location=MEMORY,
-        )
-        return o
 
+        with args[0].cache_when_complex("a") as (b1, a), args[1].cache_when_complex("b") as (b2, b):
+            o = IRnode.from_list(
+                [
+                    "seq",
+                    ["mstore", placeholder_node, _getelem(a, 0)],
+                    ["mstore", ["add", placeholder_node, 32], _getelem(a, 1)],
+                    ["mstore", ["add", placeholder_node, 64], _getelem(b, 0)],
+                    ["mstore", ["add", placeholder_node, 96], _getelem(b, 1)],
+                    [
+                        "assert",
+                        ["staticcall", ["gas"], 6, placeholder_node, 128, placeholder_node, 64],
+                    ],
+                    placeholder_node,
+                ],
+                typ=SArrayT(UINT256_T, 2),
+                location=MEMORY,
+            )
+            return b2.resolve(b1.resolve(o))
 
-class ECMul(BuiltinFunction):
 
+class ECMul(BuiltinFunction):
     _id = "ecmul"
-    _inputs = [("point", ArrayDefinition(Uint256Definition(), 2)), ("scalar", Uint256Definition())]
-    _return_type = ArrayDefinition(Uint256Definition(), 2)
+    _inputs = [("point", SArrayT(UINT256_T, 2)), ("scalar", UINT256_T)]
+    _return_type = SArrayT(UINT256_T, 2)
 
     @process_inputs
     def build_IR(self, expr, args, kwargs, context):
         placeholder_node = IRnode.from_list(
-            context.new_internal_variable(ByteArrayType(128)),
-            typ=ByteArrayType(128),
-            location=MEMORY,
-        )
-        o = IRnode.from_list(
-            [
-                "seq",
-                ["mstore", placeholder_node, _getelem(args[0], 0)],
-                ["mstore", ["add", placeholder_node, 32], _getelem(args[0], 1)],
-                ["mstore", ["add", placeholder_node, 64], args[1]],
-                ["assert", ["staticcall", ["gas"], 7, placeholder_node, 96, placeholder_node, 64]],
-                placeholder_node,
-            ],
-            typ=SArrayType(BaseType("uint256"), 2),
-            location=MEMORY,
+            context.new_internal_variable(BytesT(128)), typ=BytesT(128), location=MEMORY
         )
-        return o
+
+        with args[0].cache_when_complex("a") as (b1, a), args[1].cache_when_complex("b") as (b2, b):
+            o = IRnode.from_list(
+                [
+                    "seq",
+                    ["mstore", placeholder_node, _getelem(a, 0)],
+                    ["mstore", ["add", placeholder_node, 32], _getelem(a, 1)],
+                    ["mstore", ["add", placeholder_node, 64], b],
+                    [
+                        "assert",
+                        ["staticcall", ["gas"], 7, placeholder_node, 96, placeholder_node, 64],
+                    ],
+                    placeholder_node,
+                ],
+                typ=SArrayT(UINT256_T, 2),
+                location=MEMORY,
+            )
+            return b2.resolve(b1.resolve(o))
 
 
 def _generic_element_getter(op):
     def f(index):
         return IRnode.from_list(
-            [op, ["add", "_sub", ["add", 32, ["mul", 32, index]]]], typ=BaseType("int128")
+            [op, ["add", "_sub", ["add", 32, ["mul", 32, index]]]], typ=INT128_T
         )
 
     return f
 
 
 def _storage_element_getter(index):
-    return IRnode.from_list(["sload", ["add", "_sub", ["add", 1, index]]], typ=BaseType("int128"))
+    return IRnode.from_list(["sload", ["add", "_sub", ["add", 1, index]]], typ=INT128_T)
 
 
 class Extract32(BuiltinFunction):
-
     _id = "extract32"
-    _inputs = [("b", BytesArrayPrimitive()), ("start", UnsignedIntegerAbstractType())]
+    _inputs = [("b", BytesT.any()), ("start", IntegerT.unsigneds())]
     # "TYPE_DEFINITION" is a placeholder value for a type definition string, and
-    # will be replaced by a `TypeTypeDefinition` object in `infer_kwarg_types`
-    # (note that it is ignored in `_validate_arg_types`)
-    _kwargs = {"output_type": KwargSettings("TYPE_DEFINITION", "bytes32")}
+    # will be replaced by a `TYPE_T` object in `infer_kwarg_types`
+    # (note that it is ignored in _validate_arg_types)
+    _kwargs = {"output_type": KwargSettings("TYPE_DEFINITION", BYTES32_T)}
     _return_type = None
 
     def fetch_call_return(self, node):
         self._validate_arg_types(node)
         return_type = self.infer_kwarg_types(node)["output_type"].typedef
         return return_type
 
     def infer_arg_types(self, node):
         self._validate_arg_types(node)
         input_type = get_possible_types_from_node(node.args[0]).pop()
-        return [input_type, Uint256Definition()]
+        return [input_type, UINT256_T]
 
     def infer_kwarg_types(self, node):
         if node.keywords:
-            output_type = get_type_from_annotation(node.keywords[0].value, DataLocation.MEMORY)
-            if not isinstance(
-                output_type, (AddressDefinition, Bytes32Definition, IntegerAbstractType)
-            ):
+            output_type = type_from_annotation(node.keywords[0].value)
+            if not isinstance(output_type, (AddressT, BytesM_T, IntegerT)):
                 raise InvalidType(
                     "Output type must be one of integer, bytes32 or address", node.keywords[0].value
                 )
-            output_typedef = TypeTypeDefinition(output_type)
+            output_typedef = TYPE_T(output_type)
             node.keywords[0].value._metadata["type"] = output_typedef
         else:
-            output_typedef = TypeTypeDefinition(Bytes32Definition())
+            output_typedef = TYPE_T(BYTES32_T)
 
         return {"output_type": output_typedef}
 
     @process_inputs
     def build_IR(self, expr, args, kwargs, context):
         sub, index = args
         ret_type = kwargs["output_type"]
 
         # Get length and specific element
         if sub.location == STORAGE:
-            lengetter = IRnode.from_list(["sload", "_sub"], typ=BaseType("int128"))
+            lengetter = IRnode.from_list(["sload", "_sub"], typ=INT128_T)
             elementgetter = _storage_element_getter
 
         else:
             op = sub.location.load_op
-            lengetter = IRnode.from_list([op, "_sub"], typ=BaseType("int128"))
+            lengetter = IRnode.from_list([op, "_sub"], typ=INT128_T)
             elementgetter = _generic_element_getter(op)
 
         # TODO rewrite all this with cache_when_complex and bitshifts
 
         # Special case: index known to be a multiple of 32
         if isinstance(index.value, int) and not index.value % 32:
             o = IRnode.from_list(
@@ -1010,28 +979,27 @@
                 typ=ret_type,
                 annotation="extract32",
             )
         return IRnode.from_list(clamp_basetype(o), typ=ret_type)
 
 
 class AsWeiValue(BuiltinFunction):
-
     _id = "as_wei_value"
-    _inputs = [("value", NumericAbstractType()), ("unit", StringDefinition())]
-    _return_type = Uint256Definition()
+    _inputs = [("value", (IntegerT.any(), DecimalT())), ("unit", StringT.any())]
+    _return_type = UINT256_T
 
     wei_denoms = {
         ("wei",): 1,
-        ("femtoether", "kwei", "babbage"): 10 ** 3,
-        ("picoether", "mwei", "lovelace"): 10 ** 6,
-        ("nanoether", "gwei", "shannon"): 10 ** 9,
-        ("microether", "szabo"): 10 ** 12,
-        ("milliether", "finney"): 10 ** 15,
-        ("ether",): 10 ** 18,
-        ("kether", "grand"): 10 ** 21,
+        ("femtoether", "kwei", "babbage"): 10**3,
+        ("picoether", "mwei", "lovelace"): 10**6,
+        ("nanoether", "gwei", "shannon"): 10**9,
+        ("microether", "szabo"): 10**12,
+        ("milliether", "finney"): 10**15,
+        ("ether",): 10**18,
+        ("kether", "grand"): 10**21,
     }
 
     def get_denomination(self, node):
         if not isinstance(node.args[1], vy_ast.Str):
             raise ArgumentException(
                 "Wei denomination must be given as a literal string", node.args[1]
             )
@@ -1051,81 +1019,82 @@
         if not isinstance(node.args[0], (vy_ast.Decimal, vy_ast.Int)):
             raise UnfoldableNode
         value = node.args[0].value
 
         if value < 0:
             raise InvalidLiteral("Negative wei value not allowed", node.args[0])
 
-        if isinstance(value, int) and value >= 2 ** 256:
+        if isinstance(value, int) and value >= 2**256:
             raise InvalidLiteral("Value out of range for uint256", node.args[0])
-        if isinstance(value, Decimal) and value >= 2 ** 127:
+        if isinstance(value, Decimal) and value > SizeLimits.MAX_AST_DECIMAL:
             raise InvalidLiteral("Value out of range for decimal", node.args[0])
 
         return vy_ast.Int.from_node(node, value=int(value * denom))
 
     def fetch_call_return(self, node):
         self.infer_arg_types(node)
         return self._return_type
 
     def infer_arg_types(self, node):
         self._validate_arg_types(node)
-        # return a concrete type instead of NumericAbstractType
+        # return a concrete type instead of abstract type
         value_type = get_possible_types_from_node(node.args[0]).pop()
-        return [value_type, self._inputs[1][1]]
+        unit_type = get_possible_types_from_node(node.args[1]).pop()
+        return [value_type, unit_type]
 
     @process_inputs
     def build_IR(self, expr, args, kwargs, context):
         value = args[0]
 
         denom_divisor = self.get_denomination(expr)
-        if value.typ.typ == "uint256" or value.typ.typ == "uint8":
-            sub = [
-                "with",
-                "ans",
-                ["mul", value, denom_divisor],
-                [
-                    "seq",
+        with value.cache_when_complex("value") as (b1, value):
+            if value.typ in (UINT256_T, UINT8_T):
+                sub = [
+                    "with",
+                    "ans",
+                    ["mul", value, denom_divisor],
                     [
-                        "assert",
-                        ["or", ["eq", ["div", "ans", value], denom_divisor], ["iszero", value]],
+                        "seq",
+                        [
+                            "assert",
+                            ["or", ["eq", ["div", "ans", value], denom_divisor], ["iszero", value]],
+                        ],
+                        "ans",
                     ],
-                    "ans",
-                ],
-            ]
-        elif value.typ.typ == "int128":
-            # signed types do not require bounds checks because the
-            # largest possible converted value will not overflow 2**256
-            sub = ["seq", ["assert", ["sgt", value, -1]], ["mul", value, denom_divisor]]
-        elif value.typ.typ == "decimal":
-            sub = [
-                "seq",
-                ["assert", ["sgt", value, -1]],
-                ["div", ["mul", value, denom_divisor], DECIMAL_DIVISOR],
-            ]
-        else:
-            raise CompilerPanic(f"Unexpected type: {value.typ.typ}")
+                ]
+            elif value.typ == INT128_T:
+                # signed types do not require bounds checks because the
+                # largest possible converted value will not overflow 2**256
+                sub = ["seq", ["assert", ["sgt", value, -1]], ["mul", value, denom_divisor]]
+            elif value.typ == DecimalT():
+                sub = [
+                    "seq",
+                    ["assert", ["sgt", value, -1]],
+                    ["div", ["mul", value, denom_divisor], DECIMAL_DIVISOR],
+                ]
+            else:
+                raise CompilerPanic(f"Unexpected type: {value.typ}")
 
-        return IRnode.from_list(sub, typ=BaseType("uint256"))
+            return IRnode.from_list(b1.resolve(sub), typ=UINT256_T)
 
 
-zero_value = IRnode.from_list(0, typ=BaseType("uint256"))
-empty_value = IRnode.from_list(0, typ=BaseType("bytes32"))
+zero_value = IRnode.from_list(0, typ=UINT256_T)
+empty_value = IRnode.from_list(0, typ=BYTES32_T)
 
 
 class RawCall(BuiltinFunction):
-
     _id = "raw_call"
-    _inputs = [("to", AddressDefinition()), ("data", BytesAbstractType())]
+    _inputs = [("to", AddressT()), ("data", BytesT.any())]
     _kwargs = {
-        "max_outsize": KwargSettings(Uint256Definition(), 0, require_literal=True),
-        "gas": KwargSettings(Uint256Definition(), "gas"),
-        "value": KwargSettings(Uint256Definition(), zero_value),
-        "is_delegate_call": KwargSettings(BoolDefinition(), False, require_literal=True),
-        "is_static_call": KwargSettings(BoolDefinition(), False, require_literal=True),
-        "revert_on_failure": KwargSettings(BoolDefinition(), True, require_literal=True),
+        "max_outsize": KwargSettings(UINT256_T, 0, require_literal=True),
+        "gas": KwargSettings(UINT256_T, "gas"),
+        "value": KwargSettings(UINT256_T, zero_value),
+        "is_delegate_call": KwargSettings(BoolT(), False, require_literal=True),
+        "is_static_call": KwargSettings(BoolT(), False, require_literal=True),
+        "revert_on_failure": KwargSettings(BoolT(), True, require_literal=True),
     }
     _return_type = None
 
     def fetch_call_return(self, node):
         self._validate_arg_types(node)
 
         kwargz = {i.arg: i.value for i in node.keywords}
@@ -1133,26 +1102,26 @@
         outsize = kwargz.get("max_outsize")
         revert_on_failure = kwargz.get("revert_on_failure")
         revert_on_failure = revert_on_failure.value if revert_on_failure is not None else True
 
         if outsize is None:
             if revert_on_failure:
                 return None
-            return BoolDefinition()
+            return BoolT()
 
         if not isinstance(outsize, vy_ast.Int) or outsize.value < 0:
             raise
 
         if outsize.value:
-            return_type = BytesArrayDefinition()
+            return_type = BytesT()
             return_type.set_min_length(outsize.value)
 
             if revert_on_failure:
                 return return_type
-            return TupleDefinition([BoolDefinition(), return_type])
+            return TupleT([BoolT(), return_type])
 
     def infer_arg_types(self, node):
         self._validate_arg_types(node)
         # return a concrete type for `data`
         data_type = get_possible_types_from_node(node.args[1]).pop()
         return [self._inputs[0][1], data_type]
 
@@ -1197,20 +1166,18 @@
             else:
                 call_ir = ["seq", eval_input_buf]
 
             args_ofst = add_ofst(input_buf, 32)
             args_len = ["mload", input_buf]
 
         output_node = IRnode.from_list(
-            context.new_internal_variable(ByteArrayType(outsize)),
-            typ=ByteArrayType(outsize),
-            location=MEMORY,
+            context.new_internal_variable(BytesT(outsize)), typ=BytesT(outsize), location=MEMORY
         )
 
-        bool_ty = BaseType("bool")
+        bool_ty = BoolT()
 
         # build IR for call or delegatecall
         common_call_args = [
             args_ofst,
             args_len,
             # if there is no return value, the return offset can be 0
             add_ofst(output_node, 32) if outsize else 0,
@@ -1230,89 +1197,120 @@
         if outsize:
             # return minimum of outsize and returndatasize
             size = ["select", ["lt", outsize, "returndatasize"], outsize, "returndatasize"]
 
             # store output size and return output location
             store_output_size = ["seq", ["mstore", output_node, size], output_node]
 
-            bytes_ty = ByteArrayType(outsize)
+            bytes_ty = BytesT(outsize)
 
             if revert_on_failure:
                 typ = bytes_ty
+                # check the call success flag, and store returndata in memory
                 ret_ir = ["seq", check_external_call(call_ir), store_output_size]
+                return IRnode.from_list(ret_ir, typ=typ, location=MEMORY)
             else:
-                typ = TupleType([bool_ty, bytes_ty])
+                typ = TupleT([bool_ty, bytes_ty])
                 ret_ir = [
                     "multi",
                     # use IRnode.from_list to make sure the types are
                     # set properly on the "multi" members
                     IRnode.from_list(call_ir, typ=bool_ty),
                     IRnode.from_list(store_output_size, typ=bytes_ty, location=MEMORY),
                 ]
+                # return an IR tuple of call success flag and returndata pointer
+                return IRnode.from_list(ret_ir, typ=typ)
+
+        # max_outsize is 0.
+
+        if not revert_on_failure:
+            # return call flag as stack item
+            typ = bool_ty
+            return IRnode.from_list(call_ir, typ=typ)
 
         else:
-            if revert_on_failure:
-                typ = None
-                ret_ir = check_external_call(call_ir)
-            else:
-                typ = bool_ty
-                ret_ir = call_ir
+            # check the call success flag and don't return anything
+            ret_ir = check_external_call(call_ir)
+            return IRnode.from_list(ret_ir, typ=None)
 
-        return IRnode.from_list(ret_ir, typ=typ, location=MEMORY)
+        raise CompilerPanic("unreachable!")
 
 
 class Send(BuiltinFunction):
-
     _id = "send"
-    _inputs = [("to", AddressDefinition()), ("value", Uint256Definition())]
+    _inputs = [("to", AddressT()), ("value", UINT256_T)]
+    # default gas stipend is 0
+    _kwargs = {"gas": KwargSettings(UINT256_T, 0)}
     _return_type = None
 
     @process_inputs
     def build_IR(self, expr, args, kwargs, context):
         to, value = args
+        gas = kwargs["gas"]
         context.check_is_not_constant("send ether", expr)
-        return IRnode.from_list(["assert", ["call", 0, to, value, 0, 0, 0, 0]])
+        return IRnode.from_list(["assert", ["call", gas, to, value, 0, 0, 0, 0]])
 
 
 class SelfDestruct(BuiltinFunction):
-
     _id = "selfdestruct"
-    _inputs = [("to", AddressDefinition())]
+    _inputs = [("to", AddressT())]
     _return_type = None
     _is_terminus = True
+    _warned = False
 
     @process_inputs
     def build_IR(self, expr, args, kwargs, context):
+        if not self._warned:
+            vyper_warn("`selfdestruct` is deprecated! The opcode is no longer recommended for use.")
+            self._warned = True
+
         context.check_is_not_constant("selfdestruct", expr)
         return IRnode.from_list(
             ["seq", eval_once_check(_freshname("selfdestruct")), ["selfdestruct", args[0]]]
         )
 
 
 class BlockHash(BuiltinFunction):
-
     _id = "blockhash"
-    _inputs = [("block_num", Uint256Definition())]
-    _return_type = Bytes32Definition()
+    _inputs = [("block_num", UINT256_T)]
+    _return_type = BYTES32_T
 
     @process_inputs
     def build_IR(self, expr, args, kwargs, contact):
         return IRnode.from_list(
             ["blockhash", clamp("lt", clamp("sge", args[0], ["sub", ["number"], 256]), "number")],
-            typ=BaseType("bytes32"),
+            typ=BYTES32_T,
         )
 
 
-class RawLog(BuiltinFunction):
+class RawRevert(BuiltinFunction):
+    _id = "raw_revert"
+    _inputs = [("data", BytesT.any())]
+    _return_type = None
+    _is_terminus = True
+
+    def fetch_call_return(self, node):
+        return None
 
+    def infer_arg_types(self, node):
+        self._validate_arg_types(node)
+        data_type = get_possible_types_from_node(node.args[0]).pop()
+        return [data_type]
+
+    @process_inputs
+    def build_IR(self, expr, args, kwargs, context):
+        with ensure_in_memory(args[0], context).cache_when_complex("err_buf") as (b, buf):
+            data = bytes_data_ptr(buf)
+            len_ = get_bytearray_length(buf)
+            return b.resolve(IRnode.from_list(["revert", data, len_]))
+
+
+class RawLog(BuiltinFunction):
     _id = "raw_log"
-    _inputs = [
-        ("topics", DynamicArrayDefinition(Bytes32Definition(), 4)),
-        ("data", (Bytes32Definition(), BytesArrayPrimitive())),
-    ]
+    _inputs = [("topics", DArrayT(BYTES32_T, 4)), ("data", (BYTES32_T, BytesT.any()))]
 
     def fetch_call_return(self, node):
         self.infer_arg_types(node)
 
     def infer_arg_types(self, node):
         self._validate_arg_types(node)
 
@@ -1330,16 +1328,16 @@
         topics = args[0].args
 
         # sanity check topics is a literal list
         assert args[0].value in ("~empty", "multi")
 
         data = args[1]
 
-        if data.typ == BaseType("bytes32"):
-            placeholder = context.new_internal_variable(BaseType("bytes32"))
+        if data.typ == BYTES32_T:
+            placeholder = context.new_internal_variable(BYTES32_T)
             return IRnode.from_list(
                 [
                     "seq",
                     # TODO use make_setter
                     ["mstore", placeholder, unwrap_location(data)],
                     ["log" + str(topics_length), placeholder, 32] + topics,
                 ]
@@ -1354,144 +1352,145 @@
                 input_buf,
                 ["log" + str(topics_length), ["add", "_sub", 32], ["mload", "_sub"], *topics],
             ]
         )
 
 
 class BitwiseAnd(BuiltinFunction):
-
     _id = "bitwise_and"
-    _inputs = [("x", Uint256Definition()), ("y", Uint256Definition())]
-    _return_type = Uint256Definition()
+    _inputs = [("x", UINT256_T), ("y", UINT256_T)]
+    _return_type = UINT256_T
     _warned = False
 
     def evaluate(self, node):
         if not self.__class__._warned:
             vyper_warn("`bitwise_and()` is deprecated! Please use the & operator instead.")
             self.__class__._warned = True
 
         validate_call_args(node, 2)
         for arg in node.args:
             if not isinstance(arg, vy_ast.Num):
                 raise UnfoldableNode
-            if arg.value < 0 or arg.value >= 2 ** 256:
+            if arg.value < 0 or arg.value >= 2**256:
                 raise InvalidLiteral("Value out of range for uint256", arg)
 
         value = node.args[0].value & node.args[1].value
         return vy_ast.Int.from_node(node, value=value)
 
     @process_inputs
     def build_IR(self, expr, args, kwargs, context):
-        return IRnode.from_list(["and", args[0], args[1]], typ=BaseType("uint256"))
+        return IRnode.from_list(["and", args[0], args[1]], typ=UINT256_T)
 
 
 class BitwiseOr(BuiltinFunction):
-
     _id = "bitwise_or"
-    _inputs = [("x", Uint256Definition()), ("y", Uint256Definition())]
-    _return_type = Uint256Definition()
+    _inputs = [("x", UINT256_T), ("y", UINT256_T)]
+    _return_type = UINT256_T
     _warned = False
 
     def evaluate(self, node):
         if not self.__class__._warned:
             vyper_warn("`bitwise_or()` is deprecated! Please use the | operator instead.")
             self.__class__._warned = True
 
         validate_call_args(node, 2)
         for arg in node.args:
             if not isinstance(arg, vy_ast.Num):
                 raise UnfoldableNode
-            if arg.value < 0 or arg.value >= 2 ** 256:
+            if arg.value < 0 or arg.value >= 2**256:
                 raise InvalidLiteral("Value out of range for uint256", arg)
 
         value = node.args[0].value | node.args[1].value
         return vy_ast.Int.from_node(node, value=value)
 
     @process_inputs
     def build_IR(self, expr, args, kwargs, context):
-        return IRnode.from_list(["or", args[0], args[1]], typ=BaseType("uint256"))
+        return IRnode.from_list(["or", args[0], args[1]], typ=UINT256_T)
 
 
 class BitwiseXor(BuiltinFunction):
-
     _id = "bitwise_xor"
-    _inputs = [("x", Uint256Definition()), ("y", Uint256Definition())]
-    _return_type = Uint256Definition()
+    _inputs = [("x", UINT256_T), ("y", UINT256_T)]
+    _return_type = UINT256_T
     _warned = False
 
     def evaluate(self, node):
         if not self.__class__._warned:
             vyper_warn("`bitwise_xor()` is deprecated! Please use the ^ operator instead.")
             self.__class__._warned = True
 
         validate_call_args(node, 2)
         for arg in node.args:
             if not isinstance(arg, vy_ast.Num):
                 raise UnfoldableNode
-            if arg.value < 0 or arg.value >= 2 ** 256:
+            if arg.value < 0 or arg.value >= 2**256:
                 raise InvalidLiteral("Value out of range for uint256", arg)
 
         value = node.args[0].value ^ node.args[1].value
         return vy_ast.Int.from_node(node, value=value)
 
     @process_inputs
     def build_IR(self, expr, args, kwargs, context):
-        return IRnode.from_list(["xor", args[0], args[1]], typ=BaseType("uint256"))
+        return IRnode.from_list(["xor", args[0], args[1]], typ=UINT256_T)
 
 
 class BitwiseNot(BuiltinFunction):
-
     _id = "bitwise_not"
-    _inputs = [("x", Uint256Definition())]
-    _return_type = Uint256Definition()
+    _inputs = [("x", UINT256_T)]
+    _return_type = UINT256_T
     _warned = False
 
     def evaluate(self, node):
         if not self.__class__._warned:
             vyper_warn("`bitwise_not()` is deprecated! Please use the ^ operator instead.")
             self.__class__._warned = True
 
         validate_call_args(node, 1)
         if not isinstance(node.args[0], vy_ast.Num):
             raise UnfoldableNode
 
         value = node.args[0].value
-        if value < 0 or value >= 2 ** 256:
+        if value < 0 or value >= 2**256:
             raise InvalidLiteral("Value out of range for uint256", node.args[0])
 
-        value = (2 ** 256 - 1) - value
+        value = (2**256 - 1) - value
         return vy_ast.Int.from_node(node, value=value)
 
     @process_inputs
     def build_IR(self, expr, args, kwargs, context):
-        return IRnode.from_list(["not", args[0]], typ=BaseType("uint256"))
+        return IRnode.from_list(["not", args[0]], typ=UINT256_T)
 
 
 class Shift(BuiltinFunction):
-
     _id = "shift"
-    _inputs = [
-        ("x", (Uint256Definition(), Int256Definition())),
-        ("shift_bits", SignedIntegerAbstractType()),
-    ]
+    _inputs = [("x", (UINT256_T, INT256_T)), ("_shift_bits", IntegerT.any())]
+    _return_type = UINT256_T
+    _warned = False
 
     def evaluate(self, node):
+        if not self.__class__._warned:
+            vyper_warn("`shift()` is deprecated! Please use the << or >> operator instead.")
+            self.__class__._warned = True
+
         validate_call_args(node, 2)
         if [i for i in node.args if not isinstance(i, vy_ast.Num)]:
             raise UnfoldableNode
         value, shift = [i.value for i in node.args]
-        if value < 0 or value >= 2 ** 256:
+        if value < 0 or value >= 2**256:
             raise InvalidLiteral("Value out of range for uint256", node.args[0])
-        if shift < -(2 ** 127) or shift >= 2 ** 127:
-            raise InvalidLiteral("Value out of range for int128", node.args[1])
+        if shift < -256 or shift > 256:
+            # this validation is performed to prevent the compiler from hanging
+            # rather than for correctness because the post-folded constant would
+            # have been validated anyway
+            raise InvalidLiteral("Shift must be between -256 and 256", node.args[1])
 
         if shift < 0:
             value = value >> -shift
         else:
-            value = (value << shift) % (2 ** 256)
+            value = (value << shift) % (2**256)
         return vy_ast.Int.from_node(node, value=value)
 
     def fetch_call_return(self, node):
         # return type is the type of the first argument
         return self.infer_arg_types(node)[0]
 
     def infer_arg_types(self, node):
@@ -1501,48 +1500,50 @@
         shift_ty = get_possible_types_from_node(node.args[1])[0]
         return [arg_ty, shift_ty]
 
     @process_inputs
     def build_IR(self, expr, args, kwargs, context):
         # "gshr" -- generalized right shift
         argty = args[0].typ
-        GSHR = sar if argty._int_info.is_signed else shr
+        GSHR = sar if argty.is_signed else shr
 
         with args[0].cache_when_complex("to_shift") as (b1, arg), args[1].cache_when_complex(
             "bits"
         ) as (b2, bits):
             neg_bits = ["sub", 0, bits]
             ret = ["if", ["slt", bits, 0], GSHR(neg_bits, arg), shl(bits, arg)]
             return b1.resolve(b2.resolve(IRnode.from_list(ret, typ=argty)))
 
 
 class _AddMulMod(BuiltinFunction):
-
-    _inputs = [("a", Uint256Definition()), ("b", Uint256Definition()), ("c", Uint256Definition())]
-    _return_type = Uint256Definition()
+    _inputs = [("a", UINT256_T), ("b", UINT256_T), ("c", UINT256_T)]
+    _return_type = UINT256_T
 
     def evaluate(self, node):
         validate_call_args(node, 3)
         if isinstance(node.args[2], vy_ast.Num) and node.args[2].value == 0:
             raise ZeroDivisionException("Modulo by 0", node.args[2])
         for arg in node.args:
             if not isinstance(arg, vy_ast.Num):
                 raise UnfoldableNode
-            if arg.value < 0 or arg.value >= 2 ** 256:
+            if arg.value < 0 or arg.value >= 2**256:
                 raise InvalidLiteral("Value out of range for uint256", arg)
 
         value = self._eval_fn(node.args[0].value, node.args[1].value) % node.args[2].value
         return vy_ast.Int.from_node(node, value=value)
 
     @process_inputs
     def build_IR(self, expr, args, kwargs, context):
-        return IRnode.from_list(
-            ["seq", ["assert", args[2]], [self._opcode, args[0], args[1], args[2]]],
-            typ=BaseType("uint256"),
-        )
+        c = args[2]
+
+        with c.cache_when_complex("c") as (b1, c):
+            ret = IRnode.from_list(
+                ["seq", ["assert", c], [self._opcode, args[0], args[1], c]], typ=UINT256_T
+            )
+            return b1.resolve(ret)
 
 
 class AddMod(_AddMulMod):
     _id = "uint256_addmod"
     _eval_fn = operator.add
     _opcode = "addmod"
 
@@ -1551,39 +1552,39 @@
     _id = "uint256_mulmod"
     _eval_fn = operator.mul
     _opcode = "mulmod"
 
 
 class PowMod256(BuiltinFunction):
     _id = "pow_mod256"
-    _inputs = [("a", Uint256Definition()), ("b", Uint256Definition())]
-    _return_type = Uint256Definition()
+    _inputs = [("a", UINT256_T), ("b", UINT256_T)]
+    _return_type = UINT256_T
 
     def evaluate(self, node):
         validate_call_args(node, 2)
         if next((i for i in node.args if not isinstance(i, vy_ast.Int)), None):
             raise UnfoldableNode
 
         left, right = node.args
         if left.value < 0 or right.value < 0:
             raise UnfoldableNode
 
-        value = (left.value ** right.value) % (2 ** 256)
+        value = pow(left.value, right.value, 2**256)
         return vy_ast.Int.from_node(node, value=value)
 
     def build_IR(self, expr, context):
         left = Expr.parse_value_expr(expr.args[0], context)
         right = Expr.parse_value_expr(expr.args[1], context)
         return IRnode.from_list(["exp", left, right], typ=left.typ)
 
 
 class Abs(BuiltinFunction):
     _id = "abs"
-    _inputs = [("value", Int256Definition())]
-    _return_type = Int256Definition()
+    _inputs = [("value", INT256_T)]
+    _return_type = INT256_T
 
     def evaluate(self, node):
         validate_call_args(node, 1)
         if not isinstance(node.args[0], vy_ast.Int):
             raise UnfoldableNode
 
         value = node.args[0].value
@@ -1605,19 +1606,20 @@
                 "if",
                 ["slt", "orig", 0],
                 # clamp orig != -2**255 (because it maps to itself under negation)
                 ["seq", ["assert", ["ne", "orig", ["sub", 0, "orig"]]], ["sub", 0, "orig"]],
                 "orig",
             ],
         ]
-        return IRnode.from_list(sub, typ=BaseType("int256"))
+        return IRnode.from_list(sub, typ=INT256_T)
 
 
 # CREATE* functions
 
+
 # create helper functions
 # generates CREATE op sequence + zero check for result
 def _create_ir(value, buf, length, salt=None, checked=True):
     args = [value, buf, length]
     create_op = "create"
     if salt is not None:
         create_op = "create2"
@@ -1692,15 +1694,14 @@
     )
 
 
 # "standard" initcode for code which can be larger than 256 bytes.
 # returns the code starting from 0x0b with len `codesize`.
 # NOTE: it assumes codesize <= 2**24.
 def _create_preamble(codesize):
-
     from vyper.ir.compile_ir import assembly_to_evm
 
     evm_len = 0x0B  # 11 bytes
     asm = [
         # use PUSH3 to be able to deal with larger contracts
         "PUSH3",
         # blank space for codesize
@@ -1721,18 +1722,18 @@
     shl_bits = (evm_len - 4) * 8  # codesize needs to go right after the PUSH3
     # mask codesize into the aforementioned "blank space"
     return ["or", bytes_to_int(evm), shl(shl_bits, codesize)], evm_len
 
 
 class _CreateBase(BuiltinFunction):
     _kwargs = {
-        "value": KwargSettings(Uint256Definition(), zero_value),
-        "salt": KwargSettings(Bytes32Definition(), empty_value),
+        "value": KwargSettings(UINT256_T, zero_value),
+        "salt": KwargSettings(BYTES32_T, empty_value),
     }
-    _return_type = AddressDefinition()
+    _return_type = AddressT()
 
     @process_inputs
     def build_IR(self, expr, args, kwargs, context):
         # errmsg something like "Cannot use {self._id} in pure fn"
         context.check_is_not_constant("use {self._id}", expr)
 
         should_use_create2 = "salt" in [kwarg.arg for kwarg in expr.keywords]
@@ -1740,48 +1741,44 @@
             kwargs["salt"] = None
 
         ir_builder = self._build_create_IR(expr, args, context, **kwargs)
 
         add_gas_estimate = self._add_gas_estimate(args, should_use_create2)
 
         return IRnode.from_list(
-            ir_builder,
-            typ=BaseType("address"),
-            annotation=self._id,
-            add_gas_estimate=add_gas_estimate,
+            ir_builder, typ=AddressT(), annotation=self._id, add_gas_estimate=add_gas_estimate
         )
 
 
 class CreateMinimalProxyTo(_CreateBase):
     # create an EIP1167 "minimal proxy" to the target contract
 
     _id = "create_minimal_proxy_to"
-    _inputs = [("target", AddressDefinition())]
+    _inputs = [("target", AddressT())]
 
     def _add_gas_estimate(self, args, should_use_create2):
         a, b, c = eip1167_bytecode()
         bytecode_len = 20 + len(b) + len(c)
         return _create_addl_gas_estimate(bytecode_len, should_use_create2)
 
     def _build_create_IR(self, expr, args, context, value, salt):
-
         target_address = args[0]
 
-        buf = context.new_internal_variable(ByteArrayType(96))
+        buf = context.new_internal_variable(BytesT(96))
 
         loader_evm, forwarder_pre_evm, forwarder_post_evm = eip1167_bytecode()
         # Adjust to 32-byte boundaries
         preamble_length = len(loader_evm) + len(forwarder_pre_evm)
         forwarder_preamble = bytes_to_int(
             loader_evm + forwarder_pre_evm + b"\x00" * (32 - preamble_length)
         )
         forwarder_post = bytes_to_int(forwarder_post_evm + b"\x00" * (32 - len(forwarder_post_evm)))
 
         # left-align the target
-        if target_address.typ.is_literal:
+        if target_address.is_literal:
             # note: should move to optimizer once we have
             # codesize optimization pipeline
             aligned_target = args[0].value << 96
         else:
             aligned_target = shl(96, target_address)
 
         buf_len = preamble_length + 20 + len(forwarder_post_evm)
@@ -1803,17 +1800,16 @@
             vyper_warn("`create_forwarder_to` is a deprecated alias of `create_minimal_proxy_to`!")
             self._warned = True
 
         return super().build_IR(expr, context)
 
 
 class CreateCopyOf(_CreateBase):
-
     _id = "create_copy_of"
-    _inputs = [("target", AddressDefinition())]
+    _inputs = [("target", AddressT())]
 
     @property
     def _preamble_len(self):
         return 11
 
     def _add_gas_estimate(self, args, should_use_create2):
         # max possible runtime length + preamble length
@@ -1849,22 +1845,21 @@
 
                 ir.append(_create_ir(value, buf, buf_len, salt))
 
                 return b1.resolve(b2.resolve(b3.resolve(ir)))
 
 
 class CreateFromBlueprint(_CreateBase):
-
     _id = "create_from_blueprint"
-    _inputs = [("target", AddressDefinition())]
+    _inputs = [("target", AddressT())]
     _kwargs = {
-        "value": KwargSettings(Uint256Definition(), zero_value),
-        "salt": KwargSettings(Bytes32Definition(), empty_value),
-        "raw_args": KwargSettings(BoolDefinition(), False, require_literal=True),
-        "code_offset": KwargSettings(Uint256Definition(), zero_value),
+        "value": KwargSettings(UINT256_T, zero_value),
+        "salt": KwargSettings(BYTES32_T, empty_value),
+        "raw_args": KwargSettings(BoolT(), False, require_literal=True),
+        "code_offset": KwargSettings(UINT256_T, zero_value),
     }
     _has_varargs = True
 
     def _add_gas_estimate(self, args, should_use_create2):
         ctor_args = ir_tuple_from_args(args[1:])
         # max possible size of init code
         maxlen = EIP_170_LIMIT + ctor_args.typ.abi_type.size_bound()
@@ -1873,15 +1868,15 @@
     def _build_create_IR(self, expr, args, context, value, salt, code_offset, raw_args):
         target = args[0]
         ctor_args = args[1:]
 
         ctor_args = [ensure_in_memory(arg, context) for arg in ctor_args]
 
         if raw_args:
-            if len(ctor_args) != 1 or not isinstance(ctor_args[0].typ, ByteArrayType):
+            if len(ctor_args) != 1 or not isinstance(ctor_args[0].typ, BytesT):
                 raise StructureException("raw_args must be used with exactly 1 bytes argument")
 
             argbuf = bytes_data_ptr(ctor_args[0])
             argslen = get_bytearray_length(ctor_args[0])
             bufsz = ctor_args[0].typ.maxlen
         else:
             # encode the varargs
@@ -1943,31 +1938,28 @@
 
                 ir.append(_create_ir(value, mem_ofst, length, salt))
 
                 return b1.resolve(b2.resolve(b3.resolve(b4.resolve(b5.resolve(ir)))))
 
 
 class _UnsafeMath(BuiltinFunction):
-
     # TODO add unsafe math for `decimal`s
-    _inputs = [("a", IntegerAbstractType()), ("b", IntegerAbstractType())]
+    _inputs = [("a", IntegerT.any()), ("b", IntegerT.any())]
 
     def __repr__(self):
         return f"builtin function unsafe_{self.op}"
 
     def fetch_call_return(self, node):
         return_type = self.infer_arg_types(node).pop()
         return return_type
 
     def infer_arg_types(self, node):
         self._validate_arg_types(node)
 
-        types_list = get_common_types(
-            *node.args, filter_fn=lambda x: isinstance(x, IntegerAbstractType)
-        )
+        types_list = get_common_types(*node.args, filter_fn=lambda x: isinstance(x, IntegerT))
         if not types_list:
             raise TypeMismatch(f"unsafe_{self.op} called on dislike types", node)
 
         type_ = types_list.pop()
         return [type_, type_]
 
     @process_inputs
@@ -1975,29 +1967,28 @@
         (a, b) = args
         op = self.op
 
         assert a.typ == b.typ, "unreachable"
 
         otyp = a.typ
 
-        int_info = parse_integer_typeinfo(a.typ.typ)
-        if op == "div" and int_info.is_signed:
+        if op == "div" and a.typ.is_signed:
             op = "sdiv"
 
         ret = [op, a, b]
 
-        if int_info.bits < 256:
+        if a.typ.bits < 256:
             # wrap for ops which could under/overflow
-            if int_info.is_signed:
+            if a.typ.is_signed:
                 # e.g. int128 -> (signextend 15 (add x y))
-                ret = promote_signed_int(ret, int_info.bits)
+                ret = promote_signed_int(ret, a.typ.bits)
             else:
                 # e.g. uint8 -> (mod (add x y) 256)
                 # TODO mod_bound could be a really large literal
-                ret = ["mod", ret, 2 ** int_info.bits]
+                ret = ["mod", ret, 2**a.typ.bits]
 
         return IRnode.from_list(ret, typ=otyp)
 
         # TODO handle decimal case
 
 
 class UnsafeAdd(_UnsafeMath):
@@ -2013,44 +2004,48 @@
 
 
 class UnsafeDiv(_UnsafeMath):
     op = "div"
 
 
 class _MinMax(BuiltinFunction):
-
-    _inputs = [("a", NumericAbstractType()), ("b", NumericAbstractType())]
+    _inputs = [("a", (DecimalT(), IntegerT.any())), ("b", (DecimalT(), IntegerT.any()))]
 
     def evaluate(self, node):
         validate_call_args(node, 2)
         if not isinstance(node.args[0], type(node.args[1])):
             raise UnfoldableNode
         if not isinstance(node.args[0], (vy_ast.Decimal, vy_ast.Int)):
             raise UnfoldableNode
 
         left, right = (i.value for i in node.args)
         if isinstance(left, Decimal) and (
-            min(left, right) < -(2 ** 127) or max(left, right) >= 2 ** 127
+            min(left, right) < SizeLimits.MIN_AST_DECIMAL
+            or max(left, right) > SizeLimits.MAX_AST_DECIMAL
         ):
             raise InvalidType("Decimal value is outside of allowable range", node)
-        if isinstance(left, int) and (min(left, right) < 0 and max(left, right) >= 2 ** 127):
+
+        types_list = get_common_types(
+            *node.args, filter_fn=lambda x: isinstance(x, (IntegerT, DecimalT))
+        )
+        if not types_list:
             raise TypeMismatch("Cannot perform action between dislike numeric types", node)
 
         value = self._eval_fn(left, right)
         return type(node.args[0]).from_node(node, value=value)
 
     def fetch_call_return(self, node):
         return_type = self.infer_arg_types(node).pop()
         return return_type
 
     def infer_arg_types(self, node):
         self._validate_arg_types(node)
 
         types_list = get_common_types(
-            *node.args, filter_fn=lambda x: isinstance(x, NumericAbstractType)
+            *node.args, filter_fn=lambda x: isinstance(x, (IntegerT, DecimalT))
         )
         if not types_list:
             raise TypeMismatch("Cannot perform action between dislike numeric types", node)
 
         type_ = types_list.pop()
         return [type_, type_]
 
@@ -2058,22 +2053,20 @@
     def build_IR(self, expr, args, kwargs, context):
         op = self._opcode
 
         with args[0].cache_when_complex("_l") as (b1, left), args[1].cache_when_complex("_r") as (
             b2,
             right,
         ):
-
-            if left.typ.typ == right.typ.typ:
-                if left.typ.typ != "uint256":
+            if left.typ == right.typ:
+                if left.typ != UINT256_T:
                     # if comparing like types that are not uint256, use SLT or SGT
                     op = f"s{op}"
                 o = ["select", [op, left, right], left, right]
                 otyp = left.typ
-                otyp.is_literal = False
 
             else:
                 raise TypeMismatch(f"Minmax types incompatible: {left.typ.typ} {right.typ.typ}")
             return IRnode.from_list(b1.resolve(b2.resolve(o)), typ=otyp)
 
 
 class Min(_MinMax):
@@ -2086,21 +2079,21 @@
     _id = "max"
     _eval_fn = max
     _opcode = "gt"
 
 
 class Uint2Str(BuiltinFunction):
     _id = "uint2str"
-    _inputs = [("x", UnsignedIntegerAbstractType())]  # should allow any uint?
+    _inputs = [("x", IntegerT.unsigneds())]
 
     def fetch_call_return(self, node):
         arg_t = self.infer_arg_types(node)[0]
-        bits = arg_t._bits
+        bits = arg_t.bits
         len_needed = math.ceil(bits * math.log(2) / math.log(10))
-        return StringDefinition(len_needed)
+        return StringT(len_needed)
 
     def evaluate(self, node):
         validate_call_args(node, 1)
         if not isinstance(node.args[0], vy_ast.Int):
             raise UnfoldableNode
 
         value = str(node.args[0].value)
@@ -2109,22 +2102,21 @@
     def infer_arg_types(self, node):
         self._validate_arg_types(node)
         input_type = get_possible_types_from_node(node.args[0]).pop()
         return [input_type]
 
     @process_inputs
     def build_IR(self, expr, args, kwargs, context):
-        return_t = new_type_to_old_type(self.fetch_call_return(expr))
+        return_t = self.fetch_call_return(expr)
         n_digits = return_t.maxlen
 
         with args[0].cache_when_complex("val") as (b1, val):
-
             buf = context.new_internal_variable(return_t)
 
-            i = IRnode.from_list(context.fresh_varname("uint2str_i"), typ="uint256")
+            i = IRnode.from_list(context.fresh_varname("uint2str_i"), typ=UINT256_T)
 
             ret = ["repeat", i, 0, n_digits + 1, n_digits + 1]
 
             body = [
                 "seq",
                 [
                     "if",
@@ -2158,23 +2150,22 @@
                 ["seq", ret, val],
             ]
 
             return b1.resolve(IRnode.from_list(ret, location=MEMORY, typ=return_t))
 
 
 class Sqrt(BuiltinFunction):
-
     _id = "sqrt"
-    _inputs = [("d", DecimalDefinition())]
-    _return_type = DecimalDefinition()
+    _inputs = [("d", DecimalT())]
+    _return_type = DecimalT()
 
     @process_inputs
     def build_IR(self, expr, args, kwargs, context):
-        # TODO check out this import
-        from vyper.builtin_functions.utils import generate_inline_function
+        # TODO fix cyclic dependency with codegen/stmt.py
+        from ._utils import generate_inline_function
 
         arg = args[0]
         # TODO: reify decimal and integer sqrt paths (see isqrt)
         sqrt_code = """
 assert x >= 0.0
 z: decimal = 0.0
 
@@ -2187,46 +2178,45 @@
     for i in range(256):
         if z == y:
             break
         y = z
         z = (x / z + z) / 2.0
         """
 
-        x_type = BaseType("decimal")
+        x_type = DecimalT()
         placeholder_copy = ["pass"]
         # Steal current position if variable is already allocated.
         if arg.value == "mload":
             new_var_pos = arg.args[0]
         # Other locations need to be copied.
         else:
             new_var_pos = context.new_internal_variable(x_type)
             placeholder_copy = ["mstore", new_var_pos, arg]
         # Create input variables.
         variables = {"x": VariableRecord(name="x", pos=new_var_pos, typ=x_type, mutable=False)}
         # Dictionary to update new (i.e. typecheck) namespace
-        variables_2 = {"x": DecimalDefinition()}
+        variables_2 = {"x": VarInfo(DecimalT())}
         # Generate inline IR.
         new_ctx, sqrt_ir = generate_inline_function(
             code=sqrt_code,
             variables=variables,
             variables_2=variables_2,
             memory_allocator=context.memory_allocator,
         )
         return IRnode.from_list(
             ["seq", placeholder_copy, sqrt_ir, new_ctx.vars["z"].pos],  # load x variable
-            typ=BaseType("decimal"),
+            typ=DecimalT(),
             location=MEMORY,
         )
 
 
 class ISqrt(BuiltinFunction):
-
     _id = "isqrt"
-    _inputs = [("d", Uint256Definition())]
-    _return_type = Uint256Definition()
+    _inputs = [("d", UINT256_T)]
+    _return_type = UINT256_T
 
     @process_inputs
     def build_IR(self, expr, args, kwargs, context):
         # calculate isqrt using the babylonian method
 
         y, z = "y", "z"
         arg = args[0]
@@ -2250,33 +2240,38 @@
                 ],
                 [
                     "if",
                     ["ge", y, 2 ** (16 + 8)],
                     ["seq", ["set", y, shr(16, y)], ["set", z, shl(8, z)]],
                 ],
             ]
-            ret.append(["set", z, ["div", ["mul", z, ["add", y, 2 ** 16]], 2 ** 18]])
+            ret.append(["set", z, ["div", ["mul", z, ["add", y, 2**16]], 2**18]])
 
             for _ in range(7):
                 ret.append(["set", z, ["div", ["add", ["div", x, z], z], 2]])
 
             # note: If ``x+1`` is a perfect square, then the Babylonian
             # algorithm oscillates between floor(sqrt(x)) and ceil(sqrt(x)) in
             # consecutive iterations. return the floor value always.
 
             ret.append(["with", "t", ["div", x, z], ["select", ["lt", z, "t"], z, "t"]])
 
             ret = ["with", y, x, ["with", z, 181, ret]]
-            return b1.resolve(IRnode.from_list(ret, typ=BaseType("uint256")))
+            return b1.resolve(IRnode.from_list(ret, typ=UINT256_T))
 
 
 class Empty(TypenameFoldedFunction):
-
     _id = "empty"
 
+    def fetch_call_return(self, node):
+        type_ = self.infer_arg_types(node)[0].typedef
+        if isinstance(type_, HashMapT):
+            raise TypeMismatch("Cannot use empty on HashMap", node)
+        return type_
+
     @process_inputs
     def build_IR(self, expr, args, kwargs, context):
         output_type = args[0]
         return IRnode("~empty", typ=output_type)
 
 
 class Breakpoint(BuiltinFunction):
@@ -2297,15 +2292,15 @@
         return IRnode.from_list("breakpoint", annotation="breakpoint()")
 
 
 class Print(BuiltinFunction):
     _id = "print"
     _inputs: list = []
     _has_varargs = True
-    _kwargs = {"hardhat_compat": KwargSettings(BoolDefinition(), False, require_literal=True)}
+    _kwargs = {"hardhat_compat": KwargSettings(BoolT(), False, require_literal=True)}
 
     _warned = False
 
     def fetch_call_return(self, node):
         if not self._warned:
             vyper_warn("`print` should only be used for debugging!\n" + node._annotated_source)
             self._warned = True
@@ -2317,40 +2312,40 @@
         args_as_tuple = ir_tuple_from_args(args)
         args_abi_t = args_as_tuple.typ.abi_type
 
         # create a signature like "log(uint256)"
         sig = "log" + "(" + ",".join([arg.typ.abi_type.selector_name() for arg in args]) + ")"
 
         if kwargs["hardhat_compat"] is True:
-            method_id = abi_method_id(sig)
+            method_id = method_id_int(sig)
             buflen = 32 + args_abi_t.size_bound()
 
             # 32 bytes extra space for the method id
             buf = context.new_internal_variable(get_type_for_exact_size(buflen))
 
             ret = ["seq"]
             ret.append(["mstore", buf, method_id])
             encode = abi_encode(buf + 32, args_as_tuple, context, buflen, returns_len=True)
 
         else:
-            method_id = abi_method_id("log(string,bytes)")
+            method_id = method_id_int("log(string,bytes)")
             schema = args_abi_t.selector_name().encode("utf-8")
             if len(schema) > 32:
                 raise CompilerPanic("print signature too long: {schema}")
 
-            schema_t = StringType(len(schema))
+            schema_t = StringT(len(schema))
             schema_buf = context.new_internal_variable(schema_t)
             ret = ["seq"]
             ret.append(["mstore", schema_buf, len(schema)])
 
             # TODO use Expr.make_bytelike, or better have a `bytestring` IRnode type
             ret.append(["mstore", schema_buf + 32, bytes_to_int(schema.ljust(32, b"\x00"))])
 
             payload_buflen = args_abi_t.size_bound()
-            payload_t = ByteArrayType(payload_buflen)
+            payload_t = BytesT(payload_buflen)
 
             # 32 bytes extra space for the method id
             payload_buf = context.new_internal_variable(payload_t)
             encode_payload = abi_encode(
                 payload_buf + 32, args_as_tuple, context, payload_buflen, returns_len=True
             )
 
@@ -2388,18 +2383,16 @@
     # ://docs.soliditylang.org/en/v0.8.6/abi-spec.html#function-selector-and-argument-encoding
     # if this is turned off, then bytes will be encoded as bytes.
 
     _inputs: list = []
     _has_varargs = True
 
     _kwargs = {
-        "ensure_tuple": KwargSettings(BoolDefinition(), True, require_literal=True),
-        "method_id": KwargSettings(
-            (Bytes4Definition(), BytesArrayDefinition(4)), None, require_literal=True
-        ),
+        "ensure_tuple": KwargSettings(BoolT(), True, require_literal=True),
+        "method_id": KwargSettings((BYTES4_T, BytesT(4)), None, require_literal=True),
     }
 
     def infer_kwarg_types(self, node):
         ret = {}
         for kwarg in node.keywords:
             kwarg_name = kwarg.arg
             validate_expected_type(kwarg.value, self._kwargs[kwarg_name].typ)
@@ -2429,15 +2422,15 @@
 
         maxlen = arg_abi_t.size_bound()
 
         if has_method_id:
             # the output includes 4 bytes for the method_id.
             maxlen += 4
 
-        ret = BytesArrayDefinition()
+        ret = BytesT()
         ret.set_length(maxlen)
         return ret
 
     @staticmethod
     def _parse_method_id(method_id_literal):
         if method_id_literal is None:
             return None
@@ -2464,15 +2457,15 @@
             encode_input = ir_tuple_from_args(args)
 
         input_abi_t = encode_input.typ.abi_type
         maxlen = input_abi_t.size_bound()
         if method_id is not None:
             maxlen += 4
 
-        buf_t = ByteArrayType(maxlen=maxlen)
+        buf_t = BytesT(maxlen)
         assert self.fetch_call_return(expr).length == maxlen
         buf = context.new_internal_variable(buf_t)
 
         ret = ["seq"]
         if method_id is not None:
             # <32 bytes length> | <4 bytes method_id> | <everything else>
             # write the unaligned method_id first, then we will
@@ -2494,28 +2487,26 @@
         ret += [buf]
 
         return IRnode.from_list(ret, location=MEMORY, typ=buf_t)
 
 
 class ABIDecode(BuiltinFunction):
     _id = "_abi_decode"
-    _inputs = [("data", BytesArrayPrimitive()), ("output_type", "TYPE_DEFINITION")]
-    _kwargs = {"unwrap_tuple": KwargSettings(BoolDefinition(), True, require_literal=True)}
+    _inputs = [("data", BytesT.any()), ("output_type", "TYPE_DEFINITION")]
+    _kwargs = {"unwrap_tuple": KwargSettings(BoolT(), True, require_literal=True)}
 
     def fetch_call_return(self, node):
         _, output_type = self.infer_arg_types(node)
         return output_type.typedef
 
     def infer_arg_types(self, node):
         validate_call_args(node, 2, ["unwrap_tuple"])
 
         data_type = get_exact_type_from_node(node.args[0])
-        output_typedef = TypeTypeDefinition(
-            get_type_from_annotation(node.args[1], DataLocation.MEMORY)
-        )
+        output_typedef = TYPE_T(type_from_annotation(node.args[1]))
 
         return [data_type, output_typedef]
 
     @process_inputs
     def build_IR(self, expr, args, kwargs, context):
         unwrap_tuple = kwargs["unwrap_tuple"]
 
@@ -2541,15 +2532,14 @@
                     f"than {abi_size_bound}"
                 ),
                 expr.args[0],
             )
 
         data = ensure_in_memory(data, context)
         with data.cache_when_complex("to_decode") as (b1, data):
-
             data_ptr = bytes_data_ptr(data)
             data_len = get_bytearray_length(data)
 
             # Normally, ABI-encoded data assumes the argument is a tuple
             # (See comments for `wrap_value_for_external_return`)
             # However, we do not want to use `wrap_value_for_external_return`
             # technique as used in external call codegen because in order to be
@@ -2584,69 +2574,57 @@
                 )
             )
 
 
 class _MinMaxValue(TypenameFoldedFunction):
     def evaluate(self, node):
         self._validate_arg_types(node)
-        input_type = get_type_from_annotation(node.args[0], DataLocation.UNSET)
+        input_type = type_from_annotation(node.args[0])
 
-        if not isinstance(input_type, NumericAbstractType):
+        if not isinstance(input_type, (IntegerT, DecimalT)):
             raise InvalidType(f"Expected numeric type but got {input_type} instead", node)
 
-        if isinstance(input_type, DecimalDefinition):
-            val = self._eval_decimal(input_type)
-            return vy_ast.Decimal.from_node(node, value=val)
-
-        if isinstance(input_type, IntegerAbstractType):
-            val = self._eval_int(input_type)
-            return vy_ast.Int.from_node(node, value=val)
+        val = self._eval(input_type)
+
+        if isinstance(input_type, DecimalT):
+            ret = vy_ast.Decimal.from_node(node, value=val)
+
+        if isinstance(input_type, IntegerT):
+            ret = vy_ast.Int.from_node(node, value=val)
+
+        # TODO: to change to known_type once #3213 is merged
+        ret._metadata["type"] = input_type
+        return ret
 
 
 class MinValue(_MinMaxValue):
     _id = "min_value"
 
-    def _eval_int(self, type_):
-        typinfo = parse_integer_typeinfo(str(type_))
-        return typinfo.bounds[0]
-
-    def _eval_decimal(self, type_):
-        typinfo = parse_decimal_info(str(type_))
-        return typinfo.decimal_bounds[0]
+    def _eval(self, type_):
+        return type_.ast_bounds[0]
 
 
 class MaxValue(_MinMaxValue):
     _id = "max_value"
 
-    def _eval_int(self, type_):
-        typinfo = parse_integer_typeinfo(str(type_))
-        return typinfo.bounds[1]
-
-    def _eval_decimal(self, type_):
-        typinfo = parse_decimal_info(str(type_))
-        return typinfo.decimal_bounds[1]
+    def _eval(self, type_):
+        return type_.ast_bounds[1]
 
 
 class Epsilon(TypenameFoldedFunction):
     _id = "epsilon"
 
     def evaluate(self, node):
         self._validate_arg_types(node)
-        input_type = get_type_from_annotation(node.args[0], DataLocation.UNSET)
+        input_type = type_from_annotation(node.args[0])
 
-        if not isinstance(input_type, FixedAbstractType):
+        if not input_type.compare_type(DecimalT()):
             raise InvalidType(f"Expected decimal type but got {input_type} instead", node)
 
-        # this check seems redundant, but sets a pattern to be followed
-        # when new decimal types are created
-        if isinstance(input_type, DecimalDefinition):
-            typinfo = parse_decimal_info(str(input_type))
-            return vy_ast.Decimal.from_node(node, value=typinfo.epsilon)
-
-        raise CompilerPanic("unreachable")  # pragma: notest
+        return vy_ast.Decimal.from_node(node, value=input_type.epsilon)
 
 
 DISPATCH_TABLE = {
     "_abi_encode": ABIEncode(),
     "_abi_decode": ABIDecode(),
     "floor": Floor(),
     "ceil": Ceil(),
@@ -2695,14 +2673,15 @@
 STMT_DISPATCH_TABLE = {
     "send": Send(),
     "print": Print(),
     "breakpoint": Breakpoint(),
     "selfdestruct": SelfDestruct(),
     "raw_call": RawCall(),
     "raw_log": RawLog(),
+    "raw_revert": RawRevert(),
     "create_minimal_proxy_to": CreateMinimalProxyTo(),
     "create_forwarder_to": CreateForwarderTo(),
     "create_copy_of": CreateCopyOf(),
     "create_from_blueprint": CreateFromBlueprint(),
 }
 
 BUILTIN_FUNCTIONS = {**STMT_DISPATCH_TABLE, **DISPATCH_TABLE}.keys()
```

### Comparing `vyper-0.3.7/vyper/builtin_functions/signatures.py` & `vyper-0.3.8/vyper/builtins/_signatures.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,40 +1,31 @@
 import functools
 from typing import Dict
 
 from vyper.ast import nodes as vy_ast
 from vyper.ast.validation import validate_call_args
 from vyper.codegen.expr import Expr
 from vyper.codegen.ir_node import IRnode
-from vyper.codegen.types.convert import new_type_to_old_type
 from vyper.exceptions import CompilerPanic, TypeMismatch
-from vyper.semantics.types import (
-    ArrayValueAbstractType,
-    BaseTypeDefinition,
-    DataLocation,
-    StructDefinition,
-    ValueTypeDefinition,
-)
-from vyper.semantics.types.utils import KwargSettings, TypeTypeDefinition, get_type_from_annotation
-from vyper.semantics.validation.utils import get_exact_type_from_node, validate_expected_type
+from vyper.semantics.analysis.utils import get_exact_type_from_node, validate_expected_type
+from vyper.semantics.types import TYPE_T, KwargSettings, VyperType
+from vyper.semantics.types.utils import type_from_annotation
 
 
 def process_arg(arg, expected_arg_type, context):
     # If the input value is a typestring, return the equivalent codegen type for IR generation
-    if isinstance(expected_arg_type, TypeTypeDefinition):
-        return new_type_to_old_type(expected_arg_type.typedef)
+    if isinstance(expected_arg_type, TYPE_T):
+        return expected_arg_type.typedef
 
     # if it is a word type, return a stack item.
-    # TODO: Builtins should not require value expressions
-    if isinstance(expected_arg_type, ValueTypeDefinition) and not isinstance(
-        expected_arg_type, (StructDefinition, ArrayValueAbstractType)
-    ):
+    # TODO: remove this case, builtins should not require value expressions
+    if expected_arg_type._is_prim_word:
         return Expr.parse_value_expr(arg, context)
 
-    if isinstance(expected_arg_type, BaseTypeDefinition):
+    if isinstance(expected_arg_type, VyperType):
         return Expr(arg, context).ir_node
 
     raise CompilerPanic(f"Unexpected type: {expected_arg_type}")  # pragma: notest
 
 
 def process_kwarg(kwarg_node, kwarg_settings, expected_kwarg_type, context):
     if kwarg_settings.require_literal:
@@ -80,26 +71,25 @@
 
         return wrapped_fn(self, node, subs, kwsubs, context)
 
     return decorator_fn
 
 
 class BuiltinFunction:
-
     _has_varargs = False
     _kwargs: Dict[str, KwargSettings] = {}
 
     # helper function to deal with TYPE_DEFINITIONs
     def _validate_single(self, arg, expected_type):
         # TODO using "TYPE_DEFINITION" is a kludge in derived classes,
         # refactor me.
         if expected_type == "TYPE_DEFINITION":
-            # try to parse the type - call get_type_from_annotation
+            # try to parse the type - call type_from_annotation
             # for its side effects (will throw if is not a type)
-            get_type_from_annotation(arg, DataLocation.UNSET)
+            type_from_annotation(arg)
         else:
             validate_expected_type(arg, expected_type)
 
     def _validate_arg_types(self, node):
         num_args = len(self._inputs)  # the number of args the signature indicates
 
         expect_num_args = num_args
```

### Comparing `vyper-0.3.7/vyper/builtin_functions/utils.py` & `vyper-0.3.8/vyper/builtins/_utils.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 from vyper.ast import parse_to_ast
 from vyper.codegen.context import Context
 from vyper.codegen.global_context import GlobalContext
 from vyper.codegen.stmt import parse_body
+from vyper.semantics.analysis.local import FunctionNodeVisitor
 from vyper.semantics.namespace import Namespace, override_global_namespace
-from vyper.semantics.types.function import ContractFunction, FunctionVisibility, StateMutability
-from vyper.semantics.validation.local import FunctionNodeVisitor
+from vyper.semantics.types.function import ContractFunctionT, FunctionVisibility, StateMutability
 
 
 def _strip_source_pos(ir_node):
     ir_node.source_pos = None
     for x in ir_node.args:
         _strip_source_pos(x)
 
@@ -16,22 +16,22 @@
 def generate_inline_function(code, variables, variables_2, memory_allocator):
     ast_code = parse_to_ast(code, add_fn_node="dummy_fn")
     # Annotate the AST with a temporary old (i.e. typecheck) namespace
     namespace = Namespace()
     namespace.update(variables_2)
     with override_global_namespace(namespace):
         # Initialise a placeholder `FunctionDef` AST node and corresponding
-        # `ContractFunction` type to rely on the annotation visitors in semantics
+        # `ContractFunctionT` type to rely on the annotation visitors in semantics
         # module.
-        ast_code.body[0]._metadata["type"] = ContractFunction(
-            "sqrt_builtin", {}, 0, 0, None, FunctionVisibility.INTERNAL, StateMutability.NONPAYABLE
+        ast_code.body[0]._metadata["type"] = ContractFunctionT(
+            "sqrt_builtin", [], [], None, FunctionVisibility.INTERNAL, StateMutability.NONPAYABLE
         )
-        sv = FunctionNodeVisitor(ast_code, ast_code.body[0], namespace)
-        for n in ast_code.body[0].body:
-            sv.visit(n)
+        # The FunctionNodeVisitor's constructor performs semantic checks
+        # annotate the AST as side effects.
+        FunctionNodeVisitor(ast_code, ast_code.body[0], namespace)
 
     new_context = Context(
         vars_=variables, global_ctx=GlobalContext(), memory_allocator=memory_allocator
     )
     generated_ir = parse_body(ast_code.body[0].body, new_context)
     # strip source position info from the generated_ir since
     # it doesn't make any sense (e.g. the line numbers will start from 0
```

### Comparing `vyper-0.3.7/vyper/builtin_interfaces/ERC20.py` & `vyper-0.3.8/vyper/builtins/interfaces/ERC20.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/vyper/builtin_interfaces/ERC4626.py` & `vyper-0.3.8/vyper/builtins/interfaces/ERC4626.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,40 +1,45 @@
 interface_code = """
 # Events
 event Deposit:
-    depositor: indexed(address)
-    receiver: indexed(address)
+    sender: indexed(address)
+    owner: indexed(address)
     assets: uint256
     shares: uint256
 
 event Withdraw:
-    withdrawer: indexed(address)
+    sender: indexed(address)
     receiver: indexed(address)
     owner: indexed(address)
     assets: uint256
     shares: uint256
 
 # Functions
 @view
 @external
-def totalAssets() -> uint256:
+def asset() -> address:
     pass
 
 @view
 @external
-def convertToAssets(shareAmount: uint256) -> uint256:
+def totalAssets() -> uint256:
     pass
 
 @view
 @external
 def convertToShares(assetAmount: uint256) -> uint256:
     pass
 
 @view
 @external
+def convertToAssets(shareAmount: uint256) -> uint256:
+    pass
+
+@view
+@external
 def maxDeposit(owner: address) -> uint256:
     pass
 
 @view
 @external
 def previewDeposit(assets: uint256) -> uint256:
     pass
```

### Comparing `vyper-0.3.7/vyper/builtin_interfaces/ERC721.py` & `vyper-0.3.8/vyper/builtins/interfaces/ERC721.py`

 * *Files 7% similar despite different names*

```diff
@@ -16,14 +16,19 @@
     _operator: address
     _approved: bool
 
 # Functions
 
 @view
 @external
+def supportsInterface(interface_id: bytes4) -> bool:
+    pass
+
+@view
+@external
 def balanceOf(_owner: address) -> uint256:
     pass
 
 @view
 @external
 def ownerOf(_tokenId: uint256) -> address:
     pass
```

### Comparing `vyper-0.3.7/vyper/cli/utils.py` & `vyper-0.3.8/vyper/cli/utils.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/vyper/cli/vyper_compile.py` & `vyper-0.3.8/vyper/cli/vyper_compile.py`

 * *Files 2% similar despite different names*

```diff
@@ -16,14 +16,15 @@
 from vyper.typing import ContractCodes, ContractPath, OutputFormats
 
 T = TypeVar("T")
 
 format_options_help = """Format to print, one or more of:
 bytecode (default) - Deployable bytecode
 bytecode_runtime   - Bytecode at runtime
+blueprint_bytecode - Deployment bytecode for an ERC-5202 compatible blueprint
 abi                - ABI in JSON format
 abi_python         - ABI in python format
 source_map         - Vyper source map
 method_identifiers - Dictionary of method signature to method identifier
 userdoc            - Natspec user documentation
 devdoc             - Natspec developer documentation
 combined_json      - All of the above format options combined as single JSON output
@@ -96,15 +97,16 @@
         "--storage-layout-file",
         help="Override storage slots provided by compiler",
         dest="storage_layout",
         nargs="+",
     )
     parser.add_argument(
         "--evm-version",
-        help=f"Select desired EVM version (default {DEFAULT_EVM_VERSION})",
+        help=f"Select desired EVM version (default {DEFAULT_EVM_VERSION}). "
+        " note: cancun support is EXPERIMENTAL",
         choices=list(EVM_VERSIONS),
         default=DEFAULT_EVM_VERSION,
         dest="evm_version",
     )
     parser.add_argument("--no-optimize", help="Do not optimize", action="store_true")
     parser.add_argument(
         "--no-bytecode-metadata", help="Do not add metadata to bytecode", action="store_true"
@@ -195,15 +197,14 @@
 
     for file_path, code in contract_sources.items():
         interfaces[file_path] = {}
         parent_path = root_path.joinpath(file_path).parent
 
         interface_codes = extract_file_interface_imports(code)
         for interface_name, interface_path in interface_codes.items():
-
             base_paths = [parent_path]
             if not interface_path.startswith(".") and root_path.joinpath(file_path).exists():
                 base_paths.append(root_path)
             elif interface_path.startswith("../") and len(Path(file_path).parent.parts) < Path(
                 interface_path
             ).parts.count(".."):
                 raise FileNotFoundError(
@@ -253,15 +254,14 @@
     root_folder: str = ".",
     show_gas_estimates: bool = False,
     evm_version: str = DEFAULT_EVM_VERSION,
     no_optimize: bool = False,
     storage_layout: Iterable[str] = None,
     no_bytecode_metadata: bool = False,
 ) -> OrderedDict:
-
     root_path = Path(root_folder).resolve()
     if not root_path.exists():
         raise FileNotFoundError(f"Invalid root path - '{root_path.as_posix()}' does not exist")
 
     contract_sources: ContractCodes = OrderedDict()
     for file_name in input_files:
         file_path = Path(file_name)
```

### Comparing `vyper-0.3.7/vyper/cli/vyper_ir.py` & `vyper-0.3.8/vyper/cli/vyper_ir.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/vyper/cli/vyper_json.py` & `vyper-0.3.8/vyper/cli/vyper_json.py`

 * *Files 5% similar despite different names*

```diff
@@ -20,14 +20,15 @@
     "devdoc": "devdoc",
     "evm.methodIdentifiers": "method_identifiers",
     "evm.bytecode.object": "bytecode",
     "evm.bytecode.opcodes": "opcodes",
     "evm.deployedBytecode.object": "bytecode_runtime",
     "evm.deployedBytecode.opcodes": "opcodes_runtime",
     "evm.deployedBytecode.sourceMap": "source_map",
+    "evm.deployedBytecode.sourceMapFull": "source_map_full",
     "interface": "interface",
     "ir": "ir_dict",
     "ir_runtime": "ir_runtime_dict",
     # "metadata": "metadata",  # don't include  in "*" output for now
     "layout": "layout",
     "userdoc": "userdoc",
 }
@@ -350,14 +351,15 @@
             raise FileNotFoundError(f"Invalid root path - '{root_path.as_posix()}' does not exist")
 
     if input_dict["language"] != "Vyper":
         raise JSONError(f"Invalid language '{input_dict['language']}' - Only Vyper is supported.")
 
     evm_version = get_evm_version(input_dict)
     no_optimize = not input_dict["settings"].get("optimize", True)
+    no_bytecode_metadata = not input_dict["settings"].get("bytecodeMetadata", True)
 
     contract_sources: ContractCodes = get_input_dict_contracts(input_dict)
     interface_sources = get_input_dict_interfaces(input_dict)
     output_formats = get_input_dict_output_formats(input_dict, contract_sources)
 
     compiler_data, warning_data = {}, {}
     warnings.simplefilter("always")
@@ -373,28 +375,28 @@
                 data = vyper.compile_codes(
                     {contract_path: contract_sources[contract_path]},
                     output_formats[contract_path],
                     interface_codes=interface_codes,
                     initial_id=id_,
                     no_optimize=no_optimize,
                     evm_version=evm_version,
+                    no_bytecode_metadata=no_bytecode_metadata,
                 )
             except Exception as exc:
                 return exc_handler(contract_path, exc, "compiler"), {}
             compiler_data[contract_path] = data[contract_path]
             if caught_warnings:
                 warning_data[contract_path] = caught_warnings
 
     return compiler_data, warning_data
 
 
 def format_to_output_dict(compiler_data: Dict) -> Dict:
     output_dict: Dict = {"compiler": f"vyper-{vyper.__version__}", "contracts": {}, "sources": {}}
     for id_, (path, data) in enumerate(compiler_data.items()):
-
         output_dict["sources"][path] = {"id": id_}
         if "ast_dict" in data:
             output_dict["sources"][path]["ast"] = data["ast_dict"]["ast"]
 
         name = Path(path).stem
         output_dict["contracts"][path] = {name: {}}
         output_contracts = output_dict["contracts"][path][name]
@@ -413,22 +415,25 @@
         if any(i in data for i in evm_keys):
             evm = output_contracts.setdefault("evm", {}).setdefault("bytecode", {})
             if "bytecode" in data:
                 evm["object"] = data["bytecode"]
             if "opcodes" in data:
                 evm["opcodes"] = data["opcodes"]
 
-        if any(i + "_runtime" in data for i in evm_keys) or "source_map" in data:
+        pc_maps_keys = ("source_map", "source_map_full")
+        if any(i + "_runtime" in data for i in evm_keys) or any(i in data for i in pc_maps_keys):
             evm = output_contracts.setdefault("evm", {}).setdefault("deployedBytecode", {})
             if "bytecode_runtime" in data:
                 evm["object"] = data["bytecode_runtime"]
             if "opcodes_runtime" in data:
                 evm["opcodes"] = data["opcodes_runtime"]
             if "source_map" in data:
                 evm["sourceMap"] = data["source_map"]["pc_pos_map_compressed"]
+            if "source_map_full" in data:
+                evm["sourceMapFull"] = data["source_map"]
 
     return output_dict
 
 
 # https://stackoverflow.com/a/49518779
 def _raise_on_duplicate_keys(ordered_pairs: List[Tuple[Hashable, Any]]) -> Dict:
     """
```

### Comparing `vyper-0.3.7/vyper/cli/vyper_serve.py` & `vyper-0.3.8/vyper/cli/vyper_serve.py`

 * *Files 5% similar despite different names*

```diff
@@ -60,15 +60,14 @@
             self.wfile.write(f"Vyper Compiler. Version: {vyper.__version__}\n".encode())
         else:
             self.send_404()
 
         return
 
     def do_POST(self):
-
         if self.path == "/compile":
             content_len = int(self.headers.get("content-length"))
             post_body = self.rfile.read(content_len)
             data = json.loads(post_body)
 
             response, status_code = self._compile(data)
 
@@ -94,14 +93,15 @@
             code = data["code"]
             out_dict = vyper.compile_codes(
                 {"": code},
                 list(vyper.compiler.OUTPUT_FORMATS.keys()),
                 evm_version=data.get("evm_version", DEFAULT_EVM_VERSION),
             )[""]
             out_dict["ir"] = str(out_dict["ir"])
+            out_dict["ir_runtime"] = str(out_dict["ir_runtime"])
         except VyperException as e:
             return (
                 {"status": "failed", "message": str(e), "column": e.col_offset, "line": e.lineno},
                 400,
             )
         except SyntaxError as e:
             return (
```

### Comparing `vyper-0.3.7/vyper/codegen/abi_encoder.py` & `vyper-0.3.8/vyper/codegen/abi_encoder.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,30 +1,37 @@
-from vyper.address_space import MEMORY
 from vyper.codegen.core import (
     STORE,
     add_ofst,
     get_dyn_array_count,
     get_element_ptr,
+    is_tuple_like,
     make_setter,
     zero_pad,
 )
 from vyper.codegen.ir_node import IRnode
-from vyper.codegen.types import BaseType, ByteArrayLike, DArrayType, SArrayType, TupleLike
+from vyper.evm.address_space import MEMORY
 from vyper.exceptions import CompilerPanic
+from vyper.semantics.types import DArrayT, SArrayT, _BytestringT
+from vyper.semantics.types.shortcuts import UINT256_T
+
+
+def _is_complex_type(typ):
+    # Tuples, Structs, and SArrays follow the same code path
+    return is_tuple_like(typ) or isinstance(typ, (SArrayT))
 
 
 # turn an ir node into a list, based on its type.
 def _deconstruct_complex_type(ir_node):
     ir_t = ir_node.typ
-    assert isinstance(ir_t, (TupleLike, SArrayType))
+    assert _is_complex_type(ir_t)
 
-    if isinstance(ir_t, TupleLike):
+    if is_tuple_like(ir_t):
         ks = ir_t.tuple_keys()
     else:
-        ks = [IRnode.from_list(i, "uint256") for i in range(ir_t.count)]
+        ks = [IRnode.from_list(i, UINT256_T) for i in range(ir_t.count)]
 
     ret = []
     for k in ks:
         ret.append(get_element_ptr(ir_node, k, array_bounds_check=False))
     return ret
 
 
@@ -70,26 +77,26 @@
         _bufsz = dst.typ.abi_type.size_bound()
         return [
             "seq",
             make_setter(buf, ir_node),
             ["set", "dyn_ofst", abi_encode(dst, buf, context, _bufsz, returns_len=True)],
         ]
 
-    subtyp = ir_node.typ.subtype
+    subtyp = ir_node.typ.value_type
     child_abi_t = subtyp.abi_type
 
     ret = ["seq"]
 
     len_ = get_dyn_array_count(ir_node)
     with len_.cache_when_complex("len") as (b, len_):
         # set the length word
         ret.append(STORE(dst, len_))
 
         # prepare the loop
-        t = BaseType("uint256")
+        t = UINT256_T
         i = IRnode.from_list(context.fresh_varname("ix"), typ=t)
 
         # offset of the i'th element in ir_node
         child_location = get_element_ptr(ir_node, i, array_bounds_check=False)
 
         # offset of the i'th element in dst
         dst = add_ofst(dst, 32)  # jump past length word
@@ -179,42 +186,40 @@
             ir_ret.append(abi_t.embedded_static_size())
         return IRnode.from_list(ir_ret, annotation=annotation)
 
     # contains some computation, we need to only do it once.
     with ir_node.cache_when_complex("to_encode") as (b1, ir_node), dst.cache_when_complex(
         "dst"
     ) as (b2, dst):
-
         dyn_ofst = "dyn_ofst"  # current offset in the dynamic section
 
-        if isinstance(ir_node.typ, BaseType):
+        if ir_node.typ._is_prim_word:
             ir_ret.append(make_setter(dst, ir_node))
-        elif isinstance(ir_node.typ, ByteArrayLike):
+        elif isinstance(ir_node.typ, _BytestringT):
             # TODO optimize out repeated ceil32 calculation
             ir_ret.append(make_setter(dst, ir_node))
             ir_ret.append(zero_pad(dst))
-        elif isinstance(ir_node.typ, DArrayType):
+        elif isinstance(ir_node.typ, DArrayT):
             ir_ret.append(_encode_dyn_array_helper(dst, ir_node, context))
-
-        elif isinstance(ir_node.typ, (TupleLike, SArrayType)):
+        elif _is_complex_type(ir_node.typ):
             static_ofst = 0
             elems = _deconstruct_complex_type(ir_node)
             for e in elems:
                 encode_ir = _encode_child_helper(dst, e, static_ofst, dyn_ofst, context)
                 ir_ret.extend(encode_ir)
                 static_ofst += e.typ.abi_type.embedded_static_size()
 
         else:
             raise CompilerPanic(f"unencodable type: {ir_node.typ}")
 
         # declare IR variables.
         if returns_len:
             if not abi_t.is_dynamic():
                 ir_ret.append(abi_t.embedded_static_size())
-            elif isinstance(ir_node.typ, ByteArrayLike):
+            elif isinstance(ir_node.typ, _BytestringT):
                 # for abi purposes, return zero-padded length
                 calc_len = ["ceil32", ["add", 32, ["mload", dst]]]
                 ir_ret.append(calc_len)
             elif abi_t.is_complex_type():
                 ir_ret.append("dyn_ofst")
             else:
                 raise CompilerPanic(f"unknown type {ir_node.typ}")
```

### Comparing `vyper-0.3.7/vyper/codegen/arithmetic.py` & `vyper-0.3.8/vyper/codegen/arithmetic.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,14 +1,19 @@
 import decimal
 import math
 from typing import Tuple
 
-from vyper.codegen.core import clamp, clamp_basetype
+from vyper.codegen.core import (
+    clamp,
+    clamp_basetype,
+    is_decimal_type,
+    is_integer_type,
+    is_numeric_type,
+)
 from vyper.codegen.ir_node import IRnode
-from vyper.codegen.types import BaseType, is_decimal_type, is_integer_type
 from vyper.evm.opcodes import version_check
 from vyper.exceptions import CompilerPanic, TypeCheckFailure, UnimplementedException
 
 
 def calculate_largest_power(a: int, num_bits: int, is_signed: bool) -> int:
     """
     For a given base `a`, compute the maximum power `b` that will not
@@ -32,17 +37,17 @@
     if num_bits % 8:  # pragma: no cover
         raise CompilerPanic("Type is not a modulo of 8")
 
     if a in (-1, 0, 1):  # pragma: no cover
         raise CompilerPanic("Exponential operation is useless!")
 
     value_bits = num_bits - (1 if is_signed else 0)
-    if a >= 2 ** value_bits:  # pragma: no cover
+    if a >= 2**value_bits:  # pragma: no cover
         raise TypeCheckFailure("Value is too large and will always throw")
-    if a < -(2 ** value_bits):  # pragma: no cover
+    if a < -(2**value_bits):  # pragma: no cover
         raise TypeCheckFailure("Value is too small and will always throw")
 
     a_is_negative = a < 0
 
     a = abs(a)  # No longer need to know if it's signed or not
 
     # NOTE: There is an edge case if `a` were left signed where the following
@@ -56,28 +61,28 @@
     # CMC 2022-05-06 (TODO we should be able to this with algebra
     # instead of looping):
     # a ** x == 2**value_bits
     # x ln(a) = ln(2**value_bits)
     # x = ln(2**value_bits) / ln(a)
 
     num_iterations = 0
-    while a ** (b + 1) < 2 ** value_bits:
+    while a ** (b + 1) < 2**value_bits:
         b += 1
         num_iterations += 1
         assert num_iterations < 10000
-    while a ** b >= 2 ** value_bits:
+    while a**b >= 2**value_bits:
         b -= 1
         num_iterations += 1
         assert num_iterations < 10000
 
     # Edge case: If a is negative and the values of a and b are such that:
     #   (-a) ** (b + 1) == -(2 ** value_bits)
     # we can squeak one more out of it because lower bound of signed ints
     # is slightly wider than upper bound
-    if a_is_negative and (-a) ** (b + 1) == -(2 ** value_bits):  # NOTE: a = abs(a)
+    if a_is_negative and (-a) ** (b + 1) == -(2**value_bits):  # NOTE: a = abs(a)
         return b + 1
     else:
         return b  # Exact
 
 
 def calculate_largest_base(b: int, num_bits: int, is_signed: bool) -> Tuple[int, int]:
     """
@@ -123,46 +128,46 @@
     # ln(x) == ln(2**value_bits) / b
     # x == exp( ln(2**value_bits) / b)
 
     # Estimate (up to ~39 digits precision required)
     a = math.ceil(2 ** (decimal.Decimal(value_bits) / decimal.Decimal(b)))
     # Do a bit of iteration to ensure we have the exact number
     num_iterations = 0
-    while (a + 1) ** b < 2 ** value_bits:
+    while (a + 1) ** b < 2**value_bits:
         a += 1
         num_iterations += 1
         assert num_iterations < 10000
-    while a ** b >= 2 ** value_bits:
+    while a**b >= 2**value_bits:
         a -= 1
         num_iterations += 1
         assert num_iterations < 10000
 
     if not is_signed:
         return 0, a
 
-    if (a + 1) ** b == (2 ** value_bits):
+    if (a + 1) ** b == (2**value_bits):
         # edge case: lower bound is slightly wider than upper bound
         return -(a + 1), a
     else:
         return -a, a
 
 
 # def safe_add(x: IRnode, y: IRnode) -> IRnode:
 def safe_add(x, y):
-    assert x.typ is not None and x.typ == y.typ and isinstance(x.typ, BaseType)
-    num_info = x.typ._num_info
+    assert x.typ is not None and x.typ == y.typ and is_numeric_type(x.typ)
+    typ = x.typ
 
-    res = IRnode.from_list(["add", x, y], typ=x.typ.typ)
+    res = IRnode.from_list(["add", x, y], typ=typ)
 
-    if num_info.bits < 256:
+    if typ.bits < 256:
         return clamp_basetype(res)
 
     # bits == 256
     with res.cache_when_complex("ans") as (b1, res):
-        if num_info.is_signed:
+        if typ.is_signed:
             # if r < 0:
             #   ans < l
             # else:
             #   ans >= l  # aka (iszero (ans < l))
             # aka: (r < 0) == (ans < l)
             ok = ["eq", ["slt", y, 0], ["slt", res, x]]
         else:
@@ -175,24 +180,25 @@
         check = IRnode.from_list(["assert", ok], error_msg="safeadd")
         ret = IRnode.from_list(["seq", check, res])
         return b1.resolve(ret)
 
 
 # def safe_sub(x: IRnode, y: IRnode) -> IRnode:
 def safe_sub(x, y):
-    num_info = x.typ._num_info
+    assert x.typ == y.typ
+    typ = x.typ
 
-    res = IRnode.from_list(["sub", x, y], typ=x.typ.typ)
+    res = IRnode.from_list(["sub", x, y], typ=typ)
 
-    if num_info.bits < 256:
+    if typ.bits < 256:
         return clamp_basetype(res)
 
     # bits == 256
     with res.cache_when_complex("ans") as (b1, res):
-        if num_info.is_signed:
+        if typ.is_signed:
             # if r < 0:
             #   ans > l
             # else:
             #   ans <= l  # aka (iszero (ans > l))
             # aka: (r < 0) == (ans > l)
             ok = ["eq", ["slt", y, 0], ["sgt", res, x]]
         else:
@@ -205,173 +211,170 @@
         check = IRnode.from_list(["assert", ok], error_msg="safesub")
         ret = IRnode.from_list(["seq", check, res])
         return b1.resolve(ret)
 
 
 # def safe_mul(x: IRnode, y: IRnode) -> IRnode:
 def safe_mul(x, y):
-    # precondition: x.typ.typ == y.typ.typ
-    num_info = x.typ._num_info
+    # precondition: x.typ == y.typ
+    assert x.typ == y.typ
+    typ = x.typ
 
     # optimizer rules work better for the safemul checks below
     # if second operand is literal
     if x.is_literal:
         tmp = x
         x = y
         y = tmp
 
-    res = IRnode.from_list(["mul", x, y], typ=x.typ.typ)
+    res = IRnode.from_list(["mul", x, y], typ=x.typ)
 
-    DIV = "sdiv" if num_info.is_signed else "div"
+    DIV = "sdiv" if typ.is_signed else "div"
 
     with res.cache_when_complex("ans") as (b1, res):
-
         ok = [1]  # True
 
-        if num_info.bits > 128:  # check overflow mod 256
+        if typ.bits > 128:  # check overflow mod 256
             # assert (res/y == x | y == 0)
             ok = ["or", ["eq", [DIV, res, y], x], ["iszero", y]]
 
         # int256
-        if num_info.is_signed and num_info.bits == 256:
+        if typ.is_signed and typ.bits == 256:
             # special case:
             # in the above sdiv check, if (r==-1 and l==-2**255),
             # -2**255<res> / -1<r> will return -2**255<l>.
             # need to check: not (r == -1 and l == -2**255)
             if version_check(begin="constantinople"):
                 upper_bound = ["shl", 255, 1]
             else:
-                upper_bound = -(2 ** 255)
+                upper_bound = -(2**255)
 
             check_x = ["ne", x, upper_bound]
             check_y = ["ne", ["not", y], 0]
 
             if not x.is_literal and not y.is_literal:
                 # TODO can simplify this condition?
                 ok = ["and", ok, ["or", check_x, check_y]]
 
             # TODO push some of this constant folding into optimizer
-            elif x.is_literal and x.value == -(2 ** 255):
+            elif x.is_literal and x.value == -(2**255):
                 ok = ["and", ok, check_y]
             elif y.is_literal and y.value == -1:
                 ok = ["and", ok, check_x]
             else:
                 # x or y is a literal, and we have determined it is
                 # not an evil value
                 pass
 
         if is_decimal_type(res.typ):
-            res = IRnode.from_list([DIV, res, num_info.divisor], typ=res.typ)
+            res = IRnode.from_list([DIV, res, typ.divisor], typ=res.typ)
 
         # check overflow mod <bits>
         # NOTE: if 128 < bits < 256, `x * y` could be between
         # MAX_<bits> and 2**256 OR it could overflow past 2**256.
         # so, we check for overflow in mod 256 AS WELL AS mod <bits>
         # (if bits == 256, clamp_basetype is a no-op)
         res = clamp_basetype(res)
 
-        check = IRnode.from_list(["assert", ok], error_msg="safediv")
+        check = IRnode.from_list(["assert", ok], error_msg="safemul")
         res = IRnode.from_list(["seq", check, res], typ=res.typ)
 
         return b1.resolve(res)
 
 
 # def safe_div(x: IRnode, y: IRnode) -> IRnode:
 def safe_div(x, y):
-    num_info = x.typ._num_info
+    assert x.typ == y.typ
     typ = x.typ
 
     ok = [1]  # true
 
     if is_decimal_type(x.typ):
-        lo, hi = num_info.bounds
-        if max(abs(lo), abs(hi)) * num_info.divisor > 2 ** 256 - 1:
+        lo, hi = typ.int_bounds
+        if max(abs(lo), abs(hi)) * typ.divisor > 2**256 - 1:
             # stub to prevent us from adding fixed point numbers we don't know
             # how to deal with
-            raise UnimplementedException("safe_mul for decimal{num_info.bits}x{num_info.decimals}")
-        x = ["mul", x, num_info.divisor]
+            raise UnimplementedException("safe_mul for decimal{typ.bits}x{typ.decimals}")
+        x = ["mul", x, typ.divisor]
 
-    DIV = "sdiv" if num_info.is_signed else "div"
+    DIV = "sdiv" if typ.is_signed else "div"
     res = IRnode.from_list([DIV, x, clamp("gt", y, 0)], typ=typ)
     with res.cache_when_complex("res") as (b1, res):
-
         # TODO: refactor this condition / push some things into the optimizer
-        if num_info.is_signed and num_info.bits == 256:
+        if typ.is_signed and typ.bits == 256:
             if version_check(begin="constantinople"):
                 upper_bound = ["shl", 255, 1]
             else:
-                upper_bound = -(2 ** 255)
+                upper_bound = -(2**255)
 
-            if not x.is_literal and not y.typ.is_literal:
+            if not x.is_literal and not y.is_literal:
                 ok = ["or", ["ne", y, ["not", 0]], ["ne", x, upper_bound]]
             # TODO push these rules into the optimizer
-            elif x.is_literal and x.value == -(2 ** 255):
+            elif x.is_literal and x.value == -(2**255):
                 ok = ["ne", y, ["not", 0]]
             elif y.is_literal and y.value == -1:
                 ok = ["ne", x, upper_bound]
             else:
                 # x or y is a literal, and not an evil value.
                 pass
 
-        elif num_info.is_signed and is_integer_type(typ):
-            lo, hi = num_info.bounds
+        elif typ.is_signed and is_integer_type(typ):
+            lo, hi = typ.int_bounds
             # we need to throw on min_value(typ) / -1,
             # but we can skip if one of the operands is a literal and not
             # the evil value
             can_skip_clamp = (x.is_literal and x.value != lo) or (y.is_literal and y.value != -1)
             if not can_skip_clamp:
                 # clamp_basetype has fewer ops than the int256 rule.
                 res = clamp_basetype(res)
 
         elif is_decimal_type(typ):
             # always clamp decimals, since decimal division can actually
             # result in something larger than either operand (e.g. 1.0 / 0.1)
             # TODO maybe use safe_mul
             res = clamp_basetype(res)
 
-        check = IRnode.from_list(["assert", ok], error_msg="safemul")
+        check = IRnode.from_list(["assert", ok], error_msg="safediv")
         return IRnode.from_list(b1.resolve(["seq", check, res]))
 
 
 # def safe_mod(x: IRnode, y: IRnode) -> IRnode:
 def safe_mod(x, y):
-    num_info = x.typ._num_info
-    MOD = "smod" if num_info.is_signed else "mod"
-    return IRnode.from_list([MOD, x, clamp("gt", y, 0)])
+    typ = x.typ
+    MOD = "smod" if typ.is_signed else "mod"
+    return IRnode.from_list([MOD, x, clamp("gt", y, 0)], error_msg="safemod")
 
 
 # def safe_pow(x: IRnode, y: IRnode) -> IRnode:
 def safe_pow(x, y):
-    num_info = x.typ._num_info
+    typ = x.typ
     if not is_integer_type(x.typ):
         # type checker should have caught this
         raise TypeCheckFailure("non-integer pow")
 
-    GE = "sge" if num_info.is_signed else "ge"
+    GE = "sge" if typ.is_signed else "ge"
 
     if x.is_literal:
         # cannot pass -1, 0 or 1 to `calculate_largest_power`
         if x.value in (-1, 0, 1):
             # not strictly needed, but consistent with other bases
             # (note: unsigned (ge y 0) will get optimized out)
             ok = [GE, y, 0]
         else:
-            upper_bound = calculate_largest_power(x.value, num_info.bits, num_info.is_signed)
+            upper_bound = calculate_largest_power(x.value, typ.bits, typ.is_signed)
             # for signed integers, this also prevents negative values
             ok = ["le", y, upper_bound]
 
     elif y.is_literal:
         # cannot pass 0 or 1 to `calculate_largest_base`
         if y.value in (0, 1):
             ok = [1]
         else:
-            lower_bound, upper_bound = calculate_largest_base(
-                y.value, num_info.bits, num_info.is_signed
-            )
-            if num_info.is_signed:
+            lower_bound, upper_bound = calculate_largest_base(y.value, typ.bits, typ.is_signed)
+            if typ.is_signed:
                 ok = ["and", ["sge", x, lower_bound], ["sle", x, upper_bound]]
             else:
                 ok = ["le", x, upper_bound]
     else:
         # `a ** b` where neither `a` or `b` are known
         # TODO this is currently unreachable, once we implement a way to do it safely
         # remove the check in `vyper/context/types/value/numeric.py`
```

### Comparing `vyper-0.3.7/vyper/codegen/context.py` & `vyper-0.3.8/vyper/codegen/context.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,93 +1,121 @@
 import contextlib
 import enum
-from typing import Optional
+from dataclasses import dataclass
+from typing import Any, Optional
 
-from vyper.ast import VyperNode
-from vyper.ast.signatures.function_signature import VariableRecord
-from vyper.codegen.types import NodeType
+from vyper.codegen.ir_node import Encoding
+from vyper.evm.address_space import MEMORY, AddrSpace
 from vyper.exceptions import CompilerPanic, StateAccessViolation
+from vyper.semantics.types import VyperType
 
 
 class Constancy(enum.Enum):
     Mutable = 0
     Constant = 1
 
 
+# Function variable
+@dataclass
+class VariableRecord:
+    name: str
+    pos: int
+    typ: VyperType
+    mutable: bool
+    encoding: Encoding = Encoding.VYPER
+    location: AddrSpace = MEMORY
+    size: Optional[int] = None  # allocated size
+    blockscopes: Optional[list] = None
+    defined_at: Any = None
+    is_internal: bool = False
+    is_immutable: bool = False
+    is_transient: bool = False
+    data_offset: Optional[int] = None
+
+    def __hash__(self):
+        return hash(id(self))
+
+    def __post_init__(self):
+        if self.blockscopes is None:
+            self.blockscopes = []
+
+    def __repr__(self):
+        ret = vars(self)
+        ret["allocated"] = self.typ.memory_bytes_required
+        return f"VariableRecord({ret})"
+
+
 # Contains arguments, variables, etc
 class Context:
     def __init__(
         self,
         global_ctx,
         memory_allocator,
         vars_=None,
-        sigs=None,
         forvars=None,
         constancy=Constancy.Mutable,
-        sig=None,
+        func_t=None,
+        is_ctor_context=False,
     ):
         # In-memory variables, in the form (name, memory location, type)
         self.vars = vars_ or {}
 
         # Global variables, in the form (name, storage location, type)
-        self.globals = global_ctx._globals
-
-        # ABI objects, in the form {classname: ABI JSON}
-        self.sigs = sigs or {"self": {}}
+        self.globals = global_ctx.variables
 
         # Variables defined in for loops, e.g. for i in range(6): ...
         self.forvars = forvars or {}
 
         # Is the function constant?
         self.constancy = constancy
 
         # Whether body is currently in an assert statement
         self.in_assertion = False
 
         # Whether we are currently parsing a range expression
         self.in_range_expr = False
 
-        # List of custom structs that have been defined.
-        self.structs = global_ctx._structs
-
         # store global context
         self.global_ctx = global_ctx
 
-        # full function signature
-        self.sig = sig
+        # full function type
+        self.func_t = func_t
         # Active scopes
         self._scopes = set()
 
         # Memory alloctor, keeps track of currently allocated memory.
         # Not intended to be accessed directly
         self.memory_allocator = memory_allocator
 
         # Incremented values, used for internal IDs
         self._internal_var_iter = 0
         self._scope_id_iter = 0
 
+        # either the constructor, or called from the constructor
+        self.is_ctor_context = is_ctor_context
+
     def is_constant(self):
         return self.constancy is Constancy.Constant or self.in_assertion or self.in_range_expr
 
     def check_is_not_constant(self, err, expr):
         if self.is_constant():
             raise StateAccessViolation(f"Cannot {err} from {self.pp_constancy()}", expr)
 
     # convenience propreties
     @property
     def is_payable(self):
-        return self.sig.mutability == "payable"
+        return self.func_t.is_payable
 
     @property
     def is_internal(self):
-        return self.sig.internal
+        return self.func_t.is_internal
 
     @property
     def return_type(self):
-        return self.sig.return_type
+        return self.func_t.return_type
 
     #
     # Context Managers
     # - Context managers are used to ensure proper wrapping of scopes and context states.
 
     @contextlib.contextmanager
     def range_scope(self):
@@ -110,15 +138,17 @@
         yield
 
         # Remove all variables that have specific scope_id attached
         released = [
             (k, v) for k, v in self.vars.items() if v.is_internal and scope_id in v.blockscopes
         ]
         for name, var in released:
-            self.memory_allocator.deallocate_memory(var.pos, var.size * 32)
+            n = var.typ.memory_bytes_required
+            assert n == var.size
+            self.memory_allocator.deallocate_memory(var.pos, n)
             del self.vars[name]
 
         # Remove block scopes
         self._scopes.remove(scope_id)
 
     @contextlib.contextmanager
     def block_scope(self):
@@ -132,141 +162,95 @@
         self._scope_id_iter += 1
         self._scopes.add(scope_id)
         yield
 
         # Remove all variables that have specific scope_id attached
         released = [(k, v) for k, v in self.vars.items() if scope_id in v.blockscopes]
         for name, var in released:
-            self.memory_allocator.deallocate_memory(var.pos, var.size * 32)
+            n = var.typ.memory_bytes_required
+            # sanity check the type's size hasn't changed since allocation.
+            assert n == var.size
+            self.memory_allocator.deallocate_memory(var.pos, n)
             del self.vars[name]
 
         # Remove block scopes
         self._scopes.remove(scope_id)
 
     def _new_variable(
-        self, name: str, typ: NodeType, var_size: int, is_internal: bool, is_mutable: bool = True
+        self, name: str, typ: VyperType, var_size: int, is_internal: bool, is_mutable: bool = True
     ) -> int:
-        if is_internal:
-            # TODO CMC 2022-03-02 change this to `.allocate_memory()`
-            # and make `expand_memory()` private.
-            var_pos = self.memory_allocator.expand_memory(var_size)
-        else:
-            var_pos = self.memory_allocator.allocate_memory(var_size)
+        var_pos = self.memory_allocator.allocate_memory(var_size)
 
         assert var_pos + var_size <= self.memory_allocator.size_of_mem, "function frame overrun"
 
         self.vars[name] = VariableRecord(
             name=name,
             pos=var_pos,
             typ=typ,
+            size=var_size,
             mutable=is_mutable,
             blockscopes=self._scopes.copy(),
             is_internal=is_internal,
         )
         return var_pos
 
-    def new_variable(
-        self, name: str, typ: NodeType, pos: VyperNode = None, is_mutable: bool = True
-    ) -> int:
-        # TODO remove dead arg: pos
+    def new_variable(self, name: str, typ: VyperType, is_mutable: bool = True) -> int:
         """
         Allocate memory for a user-defined variable.
 
         Arguments
         ---------
         name : str
             Name of the variable
-        typ : NodeType
+        typ : VyperType
             Variable type, used to determine the size of memory allocation
-        pos : VyperNode
-            AST node corresponding to the location where the variable was created,
-            used for annotating exceptions
 
         Returns
         -------
         int
             Memory offset for the variable
         """
 
-        if hasattr(typ, "size_in_bytes"):
-            # temporary requirement to support both new and old type objects
-            var_size = typ.size_in_bytes  # type: ignore
-        else:
-            var_size = typ.memory_bytes_required
+        var_size = typ.memory_bytes_required
         return self._new_variable(name, typ, var_size, False, is_mutable=is_mutable)
 
     def fresh_varname(self, name: Optional[str] = None) -> str:
         """
         return a unique
         """
         if name is None:
             name = "var"
         t = self._internal_var_iter
         self._internal_var_iter += 1
         return f"{name}{t}"
 
     # do we ever allocate immutable internal variables?
-    def new_internal_variable(self, typ: NodeType) -> int:
+    def new_internal_variable(self, typ: VyperType) -> int:
         """
         Allocate memory for an internal variable.
 
         Arguments
         ---------
-        typ : NodeType
+        typ : VyperType
             Variable type, used to determine the size of memory allocation
 
         Returns
         -------
         int
             Memory offset for the variable
         """
         # internal variable names begin with a number sign so there is no chance for collision
         name = self.fresh_varname("#internal")
 
-        if hasattr(typ, "size_in_bytes"):
-            # temporary requirement to support both new and old type objects
-            var_size = typ.size_in_bytes  # type: ignore
-        else:
-            var_size = typ.memory_bytes_required
+        var_size = typ.memory_bytes_required
         return self._new_variable(name, typ, var_size, True)
 
-    def parse_type(self, ast_node):
-        return self.global_ctx.parse_type(ast_node)
-
     def lookup_var(self, varname):
         return self.vars[varname]
 
-    def lookup_internal_function(self, method_name, args_ir, ast_source):
-        # TODO is this the right module for me?
-        """
-        Using a list of args, find the internal method to use, and
-        the kwargs which need to be filled in by the compiler
-        """
-
-        sig = self.sigs["self"].get(method_name, None)
-
-        def _check(cond, s="Unreachable"):
-            if not cond:
-                raise CompilerPanic(s)
-
-        # these should have been caught during type checking; sanity check
-        _check(sig is not None)
-        _check(sig.internal)
-        _check(len(sig.base_args) <= len(args_ir) <= len(sig.args))
-        # more sanity check, that the types match
-        # _check(all(l.typ == r.typ for (l, r) in zip(args_ir, sig.args))
-
-        num_provided_kwargs = len(args_ir) - len(sig.base_args)
-        num_kwargs = len(sig.default_args)
-        kwargs_needed = num_kwargs - num_provided_kwargs
-
-        kw_vals = list(sig.default_values.values())[:kwargs_needed]
-
-        return sig, kw_vals
-
     # Pretty print constancy for error messages
     def pp_constancy(self):
         if self.in_assertion:
             return "an assertion"
         elif self.in_range_expr:
             return "a range expression"
         elif self.constancy == Constancy.Constant:
```

### Comparing `vyper-0.3.7/vyper/codegen/core.py` & `vyper-0.3.8/vyper/codegen/core.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,30 +1,84 @@
 from vyper import ast as vy_ast
-from vyper.address_space import CALLDATA, DATA, IMMUTABLES, MEMORY, STORAGE
 from vyper.codegen.ir_node import Encoding, IRnode
-from vyper.codegen.types import (
-    DYNAMIC_ARRAY_OVERHEAD,
-    ArrayLike,
-    BaseType,
-    ByteArrayLike,
-    DArrayType,
-    EnumType,
-    MappingType,
-    SArrayType,
-    StructType,
-    TupleLike,
-    TupleType,
-    ceil32,
-    is_bytes_m_type,
-    is_decimal_type,
-    is_integer_type,
-)
+from vyper.evm.address_space import CALLDATA, DATA, IMMUTABLES, MEMORY, STORAGE, TRANSIENT
 from vyper.evm.opcodes import version_check
 from vyper.exceptions import CompilerPanic, StructureException, TypeCheckFailure, TypeMismatch
-from vyper.utils import GAS_CALLDATACOPY_WORD, GAS_CODECOPY_WORD, GAS_IDENTITY, GAS_IDENTITYWORD
+from vyper.semantics.types import (
+    AddressT,
+    BoolT,
+    BytesM_T,
+    BytesT,
+    DArrayT,
+    DecimalT,
+    HashMapT,
+    IntegerT,
+    InterfaceT,
+    StructT,
+    TupleT,
+    _BytestringT,
+)
+from vyper.semantics.types.shortcuts import BYTES32_T, INT256_T, UINT256_T
+from vyper.semantics.types.subscriptable import SArrayT
+from vyper.semantics.types.user import EnumT
+from vyper.utils import (
+    GAS_CALLDATACOPY_WORD,
+    GAS_CODECOPY_WORD,
+    GAS_IDENTITY,
+    GAS_IDENTITYWORD,
+    ceil32,
+)
+
+DYNAMIC_ARRAY_OVERHEAD = 1
+
+
+def is_bytes_m_type(typ):
+    return isinstance(typ, BytesM_T)
+
+
+def is_numeric_type(typ):
+    return isinstance(typ, (IntegerT, DecimalT))
+
+
+def is_integer_type(typ):
+    return isinstance(typ, IntegerT)
+
+
+def is_decimal_type(typ):
+    return isinstance(typ, DecimalT)
+
+
+def is_enum_type(typ):
+    return isinstance(typ, EnumT)
+
+
+def is_tuple_like(typ):
+    # A lot of code paths treat tuples and structs similarly
+    # so we have a convenience function to detect it
+    ret = isinstance(typ, (TupleT, StructT))
+    assert ret == hasattr(typ, "tuple_items")
+    return ret
+
+
+def is_array_like(typ):
+    # For convenience static and dynamic arrays share some code paths
+    ret = isinstance(typ, (DArrayT, SArrayT))
+    assert ret == typ._is_array_type
+    return ret
+
+
+def get_type_for_exact_size(n_bytes):
+    """Create a type which will take up exactly n_bytes. Used for allocating internal buffers.
+
+    Parameters:
+      n_bytes: the number of bytes to allocate
+    Returns:
+      type: A type which can be passed to context.new_variable
+    """
+    return BytesT(n_bytes - 32 * DYNAMIC_ARRAY_OVERHEAD)
 
 
 # propagate revert message when calls to external contracts fail
 def check_external_call(call_ir):
     copy_revertdata = ["returndatacopy", 0, 0, "returndatasize"]
     revert = IRnode.from_list(["revert", 0, "returndatasize"], error_msg="external call failed")
 
@@ -44,127 +98,137 @@
 def _codecopy_gas_bound(num_bytes):
     return GAS_CODECOPY_WORD * ceil32(num_bytes) // 32
 
 
 # Copy byte array word-for-word (including layout)
 # TODO make this a private function
 def make_byte_array_copier(dst, src):
-    assert isinstance(src.typ, ByteArrayLike)
-    assert isinstance(dst.typ, ByteArrayLike)
+    assert isinstance(src.typ, _BytestringT)
+    assert isinstance(dst.typ, _BytestringT)
 
     _check_assign_bytes(dst, src)
 
     # TODO: remove this branch, copy_bytes and get_bytearray_length should handle
     if src.value == "~empty":
         # set length word to 0.
         return STORE(dst, 0)
 
     with src.cache_when_complex("src") as (b1, src):
         with get_bytearray_length(src).cache_when_complex("len") as (b2, len_):
-
             max_bytes = src.typ.maxlen
 
             ret = ["seq"]
+
+            dst_ = bytes_data_ptr(dst)
+            src_ = bytes_data_ptr(src)
+
+            ret.append(copy_bytes(dst_, src_, len_, max_bytes))
+
             # store length
             ret.append(STORE(dst, len_))
 
-            dst = bytes_data_ptr(dst)
-            src = bytes_data_ptr(src)
-
-            ret.append(copy_bytes(dst, src, len_, max_bytes))
             return b1.resolve(b2.resolve(ret))
 
 
 def bytes_data_ptr(ptr):
     if ptr.location is None:
         raise CompilerPanic("tried to modify non-pointer type")
-    assert isinstance(ptr.typ, ByteArrayLike)
+    assert isinstance(ptr.typ, _BytestringT)
     return add_ofst(ptr, ptr.location.word_scale)
 
 
 def dynarray_data_ptr(ptr):
     if ptr.location is None:
         raise CompilerPanic("tried to modify non-pointer type")
-    assert isinstance(ptr.typ, DArrayType)
+    assert isinstance(ptr.typ, DArrayT)
     return add_ofst(ptr, ptr.location.word_scale)
 
 
 def _dynarray_make_setter(dst, src):
-    assert isinstance(src.typ, DArrayType)
-    assert isinstance(dst.typ, DArrayType)
+    assert isinstance(src.typ, DArrayT)
+    assert isinstance(dst.typ, DArrayT)
 
     if src.value == "~empty":
         return IRnode.from_list(STORE(dst, 0))
 
+    # copy contents of src dynarray to dst.
+    # note that in case src and dst refer to the same dynarray,
+    # in order for get_element_ptr oob checks on the src dynarray
+    # to work, we need to wait until after the data is copied
+    # before we clobber the length word.
+
     if src.value == "multi":
         ret = ["seq"]
         # handle literals
 
-        # write the length word
-        store_length = STORE(dst, len(src.args))
-        ann = None
-        if src.annotation is not None:
-            ann = f"len({src.annotation})"
-        store_length = IRnode.from_list(store_length, annotation=ann)
-        ret.append(store_length)
-
+        # copy each item
         n_items = len(src.args)
+
         for i in range(n_items):
-            k = IRnode.from_list(i, typ="uint256")
+            k = IRnode.from_list(i, typ=UINT256_T)
             dst_i = get_element_ptr(dst, k, array_bounds_check=False)
             src_i = get_element_ptr(src, k, array_bounds_check=False)
             ret.append(make_setter(dst_i, src_i))
 
+        # write the length word after data is copied
+        store_length = STORE(dst, n_items)
+        ann = None
+        if src.annotation is not None:
+            ann = f"len({src.annotation})"
+        store_length = IRnode.from_list(store_length, annotation=ann)
+
+        ret.append(store_length)
+
         return ret
 
     with src.cache_when_complex("darray_src") as (b1, src):
-
         # for ABI-encoded dynamic data, we must loop to unpack, since
         # the layout does not match our memory layout
-        should_loop = src.encoding == Encoding.ABI and src.typ.subtype.abi_type.is_dynamic()
+        should_loop = src.encoding == Encoding.ABI and src.typ.value_type.abi_type.is_dynamic()
 
         # if the data is not validated, we must loop to unpack
-        should_loop |= needs_clamp(src.typ.subtype, src.encoding)
+        should_loop |= needs_clamp(src.typ.value_type, src.encoding)
 
         # performance: if the subtype is dynamic, there might be a lot
         # of unused space inside of each element. for instance
         # DynArray[DynArray[uint256, 100], 5] where all the child
         # arrays are empty - for this case, we recursively call
         # into make_setter instead of straight bytes copy
         # TODO we can make this heuristic more precise, e.g.
         # loop when subtype.is_dynamic AND location == storage
         # OR array_size <= /bound where loop is cheaper than memcpy/
-        should_loop |= src.typ.subtype.abi_type.is_dynamic()
+        should_loop |= src.typ.value_type.abi_type.is_dynamic()
 
         with get_dyn_array_count(src).cache_when_complex("darray_count") as (b2, count):
             ret = ["seq"]
 
-            ret.append(STORE(dst, count))
-
             if should_loop:
-                i = IRnode.from_list(_freshname("copy_darray_ix"), typ="uint256")
+                i = IRnode.from_list(_freshname("copy_darray_ix"), typ=UINT256_T)
 
                 loop_body = make_setter(
                     get_element_ptr(dst, i, array_bounds_check=False),
                     get_element_ptr(src, i, array_bounds_check=False),
                 )
                 loop_body.annotation = f"{dst}[i] = {src}[i]"
 
                 ret.append(["repeat", i, 0, count, src.typ.count, loop_body])
 
             else:
-                element_size = src.typ.subtype.memory_bytes_required
+                element_size = src.typ.value_type.memory_bytes_required
                 # number of elements * size of element in bytes
                 n_bytes = _mul(count, element_size)
                 max_bytes = src.typ.count * element_size
 
                 src_ = dynarray_data_ptr(src)
                 dst_ = dynarray_data_ptr(dst)
                 ret.append(copy_bytes(dst_, src_, n_bytes, max_bytes))
 
+            # write the length word after data is copied
+            ret.append(STORE(dst, count))
+
             return b1.resolve(b2.resolve(ret))
 
 
 # Copy bytes
 # Accepts 4 arguments:
 # (i) an IR node for the start position of the source
 # (ii) an IR node for the start position of the destination
@@ -179,15 +243,14 @@
     src = IRnode.from_list(src)
     dst = IRnode.from_list(dst)
     length = IRnode.from_list(length)
 
     with src.cache_when_complex("src") as (b1, src), length.cache_when_complex(
         "copy_bytes_count"
     ) as (b2, length), dst.cache_when_complex("dst") as (b3, dst):
-
         assert isinstance(length_bound, int) and length_bound >= 0
 
         # correctness: do not clobber dst
         if length_bound == 0:
             return IRnode.from_list(["seq"], annotation=annotation)
         # performance: if we know that length is 0, do not copy anything
         if length.value == 0:
@@ -224,15 +287,15 @@
             # compile to identity, CODECOPY respectively.
             pass
 
         # general case, copy word-for-word
         # pseudocode for our approach (memory-storage as example):
         # for i in range(len, bound=MAX_LEN):
         #   sstore(_dst + i, mload(src + i * 32))
-        i = IRnode.from_list(_freshname("copy_bytes_ix"), typ="uint256")
+        i = IRnode.from_list(_freshname("copy_bytes_ix"), typ=UINT256_T)
 
         # optimized form of (div (ceil32 len) 32)
         n = ["div", ["add", 31, length], 32]
         n_bound = ceil32(length_bound) // 32
 
         dst_i = add_ofst(dst, _mul(i, dst.location.word_scale))
         src_i = add_ofst(src, _mul(i, src.location.word_scale))
@@ -244,76 +307,83 @@
         return b1.resolve(
             b2.resolve(b3.resolve(IRnode.from_list(main_loop, annotation=annotation)))
         )
 
 
 # get the number of bytes at runtime
 def get_bytearray_length(arg):
-    typ = BaseType("uint256")
+    typ = UINT256_T
 
-    # TODO add "~empty" case to mirror get_dyn_array_count
+    # TODO: it would be nice to merge the implementations of get_bytearray_length and
+    # get_dynarray_count
+    if arg.value == "~empty":
+        return IRnode.from_list(0, typ=typ)
 
     return IRnode.from_list(LOAD(arg), typ=typ)
 
 
 # get the number of elements at runtime
 def get_dyn_array_count(arg):
-    assert isinstance(arg.typ, DArrayType)
+    assert isinstance(arg.typ, DArrayT)
 
-    typ = BaseType("uint256")
+    typ = UINT256_T
 
     if arg.value == "multi":
         return IRnode.from_list(len(arg.args), typ=typ)
 
     if arg.value == "~empty":
         # empty(DynArray[...])
         return IRnode.from_list(0, typ=typ)
 
     return IRnode.from_list(LOAD(arg), typ=typ)
 
 
 def append_dyn_array(darray_node, elem_node):
-    assert isinstance(darray_node.typ, DArrayType)
+    assert isinstance(darray_node.typ, DArrayT)
 
     assert darray_node.typ.count > 0, "jerk boy u r out"
 
     ret = ["seq"]
     with darray_node.cache_when_complex("darray") as (b1, darray_node):
         len_ = get_dyn_array_count(darray_node)
         with len_.cache_when_complex("old_darray_len") as (b2, len_):
             assertion = ["assert", ["lt", len_, darray_node.typ.count]]
             ret.append(IRnode.from_list(assertion, error_msg=f"{darray_node.typ} bounds check"))
-            ret.append(STORE(darray_node, ["add", len_, 1]))
             # NOTE: typechecks elem_node
             # NOTE skip array bounds check bc we already asserted len two lines up
             ret.append(
                 make_setter(get_element_ptr(darray_node, len_, array_bounds_check=False), elem_node)
             )
+
+            # store new length
+            ret.append(STORE(darray_node, ["add", len_, 1]))
             return IRnode.from_list(b1.resolve(b2.resolve(ret)))
 
 
 def pop_dyn_array(darray_node, return_popped_item):
-    assert isinstance(darray_node.typ, DArrayType)
+    assert isinstance(darray_node.typ, DArrayT)
     assert darray_node.encoding == Encoding.VYPER
     ret = ["seq"]
     with darray_node.cache_when_complex("darray") as (b1, darray_node):
         old_len = clamp("gt", get_dyn_array_count(darray_node), 0)
-        new_len = IRnode.from_list(["sub", old_len, 1], typ="uint256")
+        new_len = IRnode.from_list(["sub", old_len, 1], typ=UINT256_T)
 
         with new_len.cache_when_complex("new_len") as (b2, new_len):
+            # store new length
             ret.append(STORE(darray_node, new_len))
 
             # NOTE skip array bounds check bc we already asserted len two lines up
             if return_popped_item:
                 popped_item = get_element_ptr(darray_node, new_len, array_bounds_check=False)
                 ret.append(popped_item)
                 typ = popped_item.typ
                 location = popped_item.location
             else:
                 typ, location = None, None
+
             return IRnode.from_list(b1.resolve(b2.resolve(ret)), typ=typ, location=location)
 
 
 def getpos(node):
     return (
         node.lineno,
         node.col_offset,
@@ -360,26 +430,27 @@
         annotation=f"{parent}{ofst}",
     )
 
 
 # TODO simplify this code, especially the ABI decoding
 def _get_element_ptr_tuplelike(parent, key):
     typ = parent.typ
-    assert isinstance(typ, TupleLike)
+    assert is_tuple_like(typ)
 
-    if isinstance(typ, StructType):
+    if isinstance(typ, StructT):
         assert isinstance(key, str)
-        subtype = typ.members[key]
+        subtype = typ.member_types[key]
         attrs = list(typ.tuple_keys())
         index = attrs.index(key)
         annotation = key
     else:
+        # TupleT
         assert isinstance(key, int)
-        subtype = typ.members[key]
-        attrs = list(range(len(typ.members)))
+        subtype = typ.member_types[key]
+        attrs = list(typ.tuple_keys())
         index = key
         annotation = None
 
     # generated by empty() + make_setter
     if parent.value == "~empty":
         return IRnode.from_list("~empty", typ=subtype)
 
@@ -389,53 +460,53 @@
 
     ofst = 0  # offset from parent start
 
     if parent.encoding == Encoding.ABI:
         if parent.location == STORAGE:
             raise CompilerPanic("storage variables should not be abi encoded")  # pragma: notest
 
-        member_t = typ.members[attrs[index]]
+        member_t = typ.member_types[attrs[index]]
 
         for i in range(index):
-            member_abi_t = typ.members[attrs[i]].abi_type
+            member_abi_t = typ.member_types[attrs[i]].abi_type
             ofst += member_abi_t.embedded_static_size()
 
         return _getelemptr_abi_helper(parent, member_t, ofst)
 
     if parent.location.word_addressable:
         for i in range(index):
-            ofst += typ.members[attrs[i]].storage_size_in_words
+            ofst += typ.member_types[attrs[i]].storage_size_in_words
     elif parent.location.byte_addressable:
         for i in range(index):
-            ofst += typ.members[attrs[i]].memory_bytes_required
+            ofst += typ.member_types[attrs[i]].memory_bytes_required
     else:
         raise CompilerPanic(f"bad location {parent.location}")  # pragma: notest
 
     return IRnode.from_list(
         add_ofst(parent, ofst),
         typ=subtype,
         location=parent.location,
         encoding=parent.encoding,
         annotation=annotation,
     )
 
 
 def has_length_word(typ):
-    return isinstance(typ, (DArrayType, ByteArrayLike))
+    # Consider moving this to an attribute on typ
+    return isinstance(typ, (DArrayT, _BytestringT))
 
 
 # TODO simplify this code, especially the ABI decoding
 def _get_element_ptr_array(parent, key, array_bounds_check):
-
-    assert isinstance(parent.typ, ArrayLike)
+    assert is_array_like(parent.typ)
 
     if not is_integer_type(key.typ):
         raise TypeCheckFailure(f"{key.typ} used as array index")
 
-    subtype = parent.typ.subtype
+    subtype = parent.typ.value_type
 
     if parent.value == "~empty":
         if array_bounds_check:
             # this case was previously missing a bounds check. codegen
             # is a bit complicated when bounds check is required, so
             # block it. there is no reason to index into a literal empty
             # array anyways!
@@ -445,15 +516,15 @@
     if parent.value == "multi":
         assert isinstance(key.value, int)
         return parent.args[key.value]
 
     ix = unwrap_location(key)
 
     if array_bounds_check:
-        is_darray = isinstance(parent.typ, DArrayType)
+        is_darray = isinstance(parent.typ, DArrayT)
         bound = get_dyn_array_count(parent) if is_darray else parent.typ.count
         # uclamplt works, even for signed ints. since two's-complement
         # is used, if the index is negative, (unsigned) LT will interpret
         # it as a very large number, larger than any practical value for
         # an array index, and the clamp will throw an error.
         # NOTE: there are optimization rules for this when ix or bound is literal
         ix = clamp("lt", ix, bound)
@@ -482,39 +553,39 @@
     else:
         data_ptr = parent
 
     return IRnode.from_list(add_ofst(data_ptr, ofst), typ=subtype, location=parent.location)
 
 
 def _get_element_ptr_mapping(parent, key):
-    assert isinstance(parent.typ, MappingType)
-    subtype = parent.typ.valuetype
+    assert isinstance(parent.typ, HashMapT)
+    subtype = parent.typ.value_type
     key = unwrap_location(key)
 
     # TODO when is key None?
-    if key is None or parent.location != STORAGE:
-        raise TypeCheckFailure(f"bad dereference on mapping {parent}[{key}]")
+    if key is None or parent.location not in (STORAGE, TRANSIENT):
+        raise TypeCheckFailure("bad dereference on mapping {parent}[{key}]")
 
-    return IRnode.from_list(["sha3_64", parent, key], typ=subtype, location=STORAGE)
+    return IRnode.from_list(["sha3_64", parent, key], typ=subtype, location=parent.location)
 
 
 # Take a value representing a memory or storage location, and descend down to
 # an element or member variable
 # This is analogous (but not necessarily equivalent to) getelementptr in LLVM.
 def get_element_ptr(parent, key, array_bounds_check=True):
     with parent.cache_when_complex("val") as (b, parent):
         typ = parent.typ
 
-        if isinstance(typ, TupleLike):
+        if is_tuple_like(typ):
             ret = _get_element_ptr_tuplelike(parent, key)
 
-        elif isinstance(typ, MappingType):
+        elif isinstance(typ, HashMapT):
             ret = _get_element_ptr_mapping(parent, key)
 
-        elif isinstance(typ, ArrayLike):
+        elif is_array_like(typ):
             ret = _get_element_ptr_array(parent, key, array_bounds_check)
 
         else:
             raise CompilerPanic(f"get_element_ptr cannot be called on {typ}")  # pragma: notest
 
         return b.resolve(ret)
 
@@ -565,19 +636,19 @@
             # must be word type
             return IRnode.from_list(0, typ=orig.typ)
         return orig
 
 
 # utility function, constructs an IR tuple out of a list of IR nodes
 def ir_tuple_from_args(args):
-    typ = TupleType([x.typ for x in args])
+    typ = TupleT([x.typ for x in args])
     return IRnode.from_list(["multi"] + [x for x in args], typ=typ)
 
 
-def needs_external_call_wrap(ir_typ):
+def needs_external_call_wrap(typ):
     # for calls to ABI conforming contracts.
     # according to the ABI spec, return types are ALWAYS tuples even
     # if only one element is being returned.
     # https://solidity.readthedocs.io/en/latest/abi-spec.html#function-selector-and-argument-encoding
     # "and the return values v_1, ..., v_k of f are encoded as
     #
     #    enc((v_1, ..., v_k))
@@ -586,21 +657,21 @@
     # therefore, wrap it in a tuple if it's not already a tuple.
     # for example, `bytes` is returned as abi-encoded (bytes,)
     # and `(bytes,)` is returned as abi-encoded ((bytes,),)
     # In general `-> X` gets returned as (X,)
     # including structs. MyStruct is returned as abi-encoded (MyStruct,).
     # (Sorry this is so confusing. I didn't make these rules.)
 
-    return not (isinstance(ir_typ, TupleType) and len(ir_typ.members) > 1)
+    return not (isinstance(typ, TupleT) and typ.length > 1)
 
 
-def calculate_type_for_external_return(ir_typ):
-    if needs_external_call_wrap(ir_typ):
-        return TupleType([ir_typ])
-    return ir_typ
+def calculate_type_for_external_return(typ):
+    if needs_external_call_wrap(typ):
+        return TupleT([typ])
+    return typ
 
 
 def wrap_value_for_external_return(ir_val):
     # used for LHS promotion
     if needs_external_call_wrap(ir_val.typ):
         return ir_tuple_from_args([ir_val])
     else:
@@ -630,87 +701,93 @@
     def FAIL():  # pragma: no cover
         raise TypeCheckFailure(f"assigning {right.typ} to {left.typ}")
 
     if left.value == "multi":
         # Cannot do something like [a, b, c] = [1, 2, 3]
         FAIL()  # pragma: notest
 
-    if isinstance(left, SArrayType):
-        if not isinstance(right, SArrayType):
+    if isinstance(left.typ, SArrayT):
+        if not is_array_like(right.typ):
             FAIL()  # pragma: notest
         if left.typ.count != right.typ.count:
             FAIL()  # pragma: notest
 
         # TODO recurse into left, right if literals?
-        check_assign(dummy_node_for_type(left.typ.subtyp), dummy_node_for_type(right.typ.subtyp))
+        check_assign(
+            dummy_node_for_type(left.typ.value_type), dummy_node_for_type(right.typ.value_type)
+        )
 
-    if isinstance(left, DArrayType):
-        if not isinstance(right, DArrayType):
+    if isinstance(left.typ, DArrayT):
+        if not isinstance(right.typ, DArrayT):
             FAIL()  # pragma: notest
 
         if left.typ.count < right.typ.count:
             FAIL()  # pragma: notest
 
         # stricter check for zeroing
         if right.value == "~empty" and right.typ.count != left.typ.count:
             raise TypeCheckFailure(
                 f"Bad type for clearing bytes: expected {left.typ} but got {right.typ}"
             )  # pragma: notest
 
         # TODO recurse into left, right if literals?
-        check_assign(dummy_node_for_type(left.typ.subtyp), dummy_node_for_type(right.typ.subtyp))
+        check_assign(
+            dummy_node_for_type(left.typ.value_type), dummy_node_for_type(right.typ.value_type)
+        )
 
 
 def _check_assign_tuple(left, right):
     def FAIL():  # pragma: no cover
         raise TypeCheckFailure(f"assigning {right.typ} to {left.typ}")
 
     if not isinstance(right.typ, left.typ.__class__):
         FAIL()  # pragma: notest
 
-    if isinstance(left.typ, StructType):
-        for k in left.typ.members:
-            if k not in right.typ.members:
+    if isinstance(left.typ, StructT):
+        for k in left.typ.member_types:
+            if k not in right.typ.member_types:
                 FAIL()  # pragma: notest
             # TODO recurse into left, right if literals?
             check_assign(
-                dummy_node_for_type(left.typ.members[k]), dummy_node_for_type(right.typ.members[k])
+                dummy_node_for_type(left.typ.member_types[k]),
+                dummy_node_for_type(right.typ.member_types[k]),
             )
 
-        for k in right.typ.members:
-            if k not in left.typ.members:
+        for k in right.typ.member_types:
+            if k not in left.typ.member_types:
                 FAIL()  # pragma: notest
 
         if left.typ.name != right.typ.name:
             FAIL()  # pragma: notest
 
     else:
-        if len(left.typ.members) != len(right.typ.members):
+        if len(left.typ.member_types) != len(right.typ.member_types):
             FAIL()  # pragma: notest
-        for (l, r) in zip(left.typ.members, right.typ.members):
+        for left_, right_ in zip(left.typ.member_types, right.typ.member_types):
             # TODO recurse into left, right if literals?
-            check_assign(dummy_node_for_type(l), dummy_node_for_type(r))
+            check_assign(dummy_node_for_type(left_), dummy_node_for_type(right_))
 
 
 # sanity check an assignment
 # typechecking source code is done at an earlier phase
 # this function is more of a sanity check for typechecking internally
 # generated assignments
+# TODO: do we still need this?
 def check_assign(left, right):
     def FAIL():  # pragma: no cover
         raise TypeCheckFailure(f"assigning {right.typ} to {left.typ} {left} {right}")
 
-    if isinstance(left.typ, ByteArrayLike):
+    if isinstance(left.typ, _BytestringT):
         _check_assign_bytes(left, right)
-    elif isinstance(left.typ, ArrayLike):
+    elif is_array_like(left.typ):
         _check_assign_list(left, right)
-    elif isinstance(left.typ, TupleLike):
+    elif is_tuple_like(left.typ):
         _check_assign_tuple(left, right)
 
-    elif isinstance(left.typ, BaseType):
+    elif left.typ._is_prim_word:
         # TODO once we propagate types from typechecker, introduce this check:
         # if left.typ != right.typ:
         #    FAIL()  # pragma: notest
         pass
 
     else:  # pragma: no cover
         FAIL()
@@ -734,55 +811,55 @@
 # returns True if t is ABI encoded and is a type that needs any kind of
 # validation
 def needs_clamp(t, encoding):
     if encoding == Encoding.VYPER:
         return False
     if encoding != Encoding.ABI:
         raise CompilerPanic("unreachable")  # pragma: notest
-    if isinstance(t, (ByteArrayLike, DArrayType)):
+    if isinstance(t, (_BytestringT, DArrayT)):
         return True
-    if isinstance(t, EnumType):
-        return len(t.members) < 256
-    if isinstance(t, BaseType):
-        return t.typ not in ("int256", "uint256", "bytes32")
-    if isinstance(t, SArrayType):
-        return needs_clamp(t.subtype, encoding)
-    if isinstance(t, TupleLike):
+    if isinstance(t, EnumT):
+        return len(t._enum_members) < 256
+    if isinstance(t, SArrayT):
+        return needs_clamp(t.value_type, encoding)
+    if is_tuple_like(t):
         return any(needs_clamp(m, encoding) for m in t.tuple_members())
+    if t._is_prim_word:
+        return t not in (INT256_T, UINT256_T, BYTES32_T)
 
     raise CompilerPanic("unreachable")  # pragma: notest
 
 
 # Create an x=y statement, where the types may be compound
 def make_setter(left, right):
     check_assign(left, right)
 
-    # Basic types
-    if isinstance(left.typ, BaseType):
+    # For types which occupy just one word we can use single load/store
+    if left.typ._is_prim_word:
         enc = right.encoding  # unwrap_location butchers encoding
         right = unwrap_location(right)
         # TODO rethink/streamline the clamp_basetype logic
         if needs_clamp(right.typ, enc):
             right = clamp_basetype(right)
 
         return STORE(left, right)
 
     # Byte arrays
-    elif isinstance(left.typ, ByteArrayLike):
+    elif isinstance(left.typ, _BytestringT):
         # TODO rethink/streamline the clamp_basetype logic
         if needs_clamp(right.typ, right.encoding):
             with right.cache_when_complex("bs_ptr") as (b, right):
                 copier = make_byte_array_copier(left, right)
                 ret = b.resolve(["seq", clamp_bytestring(right), copier])
         else:
             ret = make_byte_array_copier(left, right)
 
         return IRnode.from_list(ret)
 
-    elif isinstance(left.typ, DArrayType):
+    elif isinstance(left.typ, DArrayT):
         # TODO should we enable this?
         # implicit conversion from sarray to darray
         # if isinstance(right.typ, SArrayType):
         #    return _complex_make_setter(left, right)
 
         # TODO rethink/streamline the clamp_basetype logic
         if needs_clamp(right.typ, right.encoding):
@@ -790,40 +867,41 @@
                 copier = _dynarray_make_setter(left, right)
                 ret = b.resolve(["seq", clamp_dyn_array(right), copier])
         else:
             ret = _dynarray_make_setter(left, right)
 
         return IRnode.from_list(ret)
 
-    # Arrays
-    elif isinstance(left.typ, (SArrayType, TupleLike)):
-        return _complex_make_setter(left, right)
+    # Complex Types
+    assert isinstance(left.typ, (SArrayT, TupleT, StructT))
+
+    return _complex_make_setter(left, right)
 
 
 def _complex_make_setter(left, right):
     if right.value == "~empty" and left.location == MEMORY:
         # optimized memzero
         return mzero(left, left.typ.memory_bytes_required)
 
     ret = ["seq"]
 
-    if isinstance(left.typ, SArrayType):
+    if isinstance(left.typ, SArrayT):
         n_items = right.typ.count
-        keys = [IRnode.from_list(i, typ="uint256") for i in range(n_items)]
+        keys = [IRnode.from_list(i, typ=UINT256_T) for i in range(n_items)]
 
-    if isinstance(left.typ, TupleLike):
+    else:
+        assert is_tuple_like(left.typ)
         keys = left.typ.tuple_keys()
 
     # if len(keyz) == 0:
     #    return IRnode.from_list(["pass"])
 
     # general case
     # TODO use copy_bytes when the generated code is above a certain size
     with left.cache_when_complex("_L") as (b1, left), right.cache_when_complex("_R") as (b2, right):
-
         for k in keys:
             l_i = get_element_ptr(left, k, array_bounds_check=False)
             r_i = get_element_ptr(right, k, array_bounds_check=False)
             ret.append(make_setter(l_i, r_i))
 
         return b1.resolve(b2.resolve(IRnode.from_list(ret)))
 
@@ -851,15 +929,18 @@
     if isinstance(ir_node.value, int):
         return IRnode.from_list(ir_node)
     return None
 
 
 # TODO move return checks to vyper/semantics/validation
 def is_return_from_function(node):
-    if isinstance(node, vy_ast.Expr) and node.get("value.func.id") == "selfdestruct":
+    if isinstance(node, vy_ast.Expr) and node.get("value.func.id") in (
+        "raw_revert",
+        "selfdestruct",
+    ):
         return True
     if isinstance(node, (vy_ast.Return, vy_ast.Raise)):
         return True
     return False
 
 
 def check_single_exit(fn_node):
@@ -933,56 +1014,56 @@
         return ["sar", bits, x]
 
     raise NotImplementedError("no SAR emulation for pre-constantinople EVM")
 
 
 def clamp_bytestring(ir_node):
     t = ir_node.typ
-    if not isinstance(t, ByteArrayLike):
+    if not isinstance(t, _BytestringT):
         raise CompilerPanic(f"{t} passed to clamp_bytestring")  # pragma: notest
     ret = ["assert", ["le", get_bytearray_length(ir_node), t.maxlen]]
     return IRnode.from_list(ret, error_msg=f"{ir_node.typ} bounds check")
 
 
 def clamp_dyn_array(ir_node):
     t = ir_node.typ
-    assert isinstance(t, DArrayType)
+    assert isinstance(t, DArrayT)
     ret = ["assert", ["le", get_dyn_array_count(ir_node), t.count]]
     return IRnode.from_list(ret, error_msg=f"{ir_node.typ} bounds check")
 
 
 # clampers for basetype
 def clamp_basetype(ir_node):
     t = ir_node.typ
-    if not isinstance(t, BaseType):
+    if not t._is_prim_word:
         raise CompilerPanic(f"{t} passed to clamp_basetype")  # pragma: notest
 
     # copy of the input
     ir_node = unwrap_location(ir_node)
 
-    if isinstance(t, EnumType):
-        bits = len(t.members)
+    if isinstance(t, EnumT):
+        bits = len(t._enum_members)
         # assert x >> bits == 0
         ret = int_clamp(ir_node, bits, signed=False)
 
-    elif is_integer_type(t) or is_decimal_type(t):
-        if t._num_info.bits == 256:
+    elif isinstance(t, (IntegerT, DecimalT)):
+        if t.bits == 256:
             ret = ir_node
         else:
-            ret = int_clamp(ir_node, t._num_info.bits, signed=t._num_info.is_signed)
+            ret = int_clamp(ir_node, t.bits, signed=t.is_signed)
 
-    elif is_bytes_m_type(t):
-        if t._bytes_info.m == 32:
+    elif isinstance(t, BytesM_T):
+        if t.m == 32:
             ret = ir_node  # special case, no clamp.
         else:
-            ret = bytes_clamp(ir_node, t._bytes_info.m)
+            ret = bytes_clamp(ir_node, t.m)
 
-    elif t.typ in ("address",):
+    elif isinstance(t, (AddressT, InterfaceT)):
         ret = int_clamp(ir_node, 160)
-    elif t.typ in ("bool",):
+    elif t in (BoolT(),):
         ret = int_clamp(ir_node, 1)
     else:  # pragma: no cover
         raise CompilerPanic(f"{t} passed to clamp_basetype")
 
     return IRnode.from_list(ret, typ=ir_node.typ, error_msg=f"validate {t}")
```

### Comparing `vyper-0.3.7/vyper/codegen/events.py` & `vyper-0.3.8/vyper/codegen/events.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,25 +1,25 @@
 from vyper.codegen.abi_encoder import abi_encode
-from vyper.codegen.core import ir_tuple_from_args, unwrap_location
+from vyper.codegen.core import get_type_for_exact_size, ir_tuple_from_args, unwrap_location
 from vyper.codegen.ir_node import IRnode
 from vyper.codegen.keccak256_helper import keccak256_helper
-from vyper.codegen.types.types import BaseType, ByteArrayLike, get_type_for_exact_size
 from vyper.exceptions import TypeMismatch
+from vyper.semantics.types.bytestrings import _BytestringT
 
 
 # docs.soliditylang.org/en/v0.8.6/abi-spec.html#indexed-event-encoding
 def _encode_log_topics(expr, event_id, arg_nodes, context):
     topics = [event_id]
 
     for arg in arg_nodes:
-        if isinstance(arg.typ, BaseType):
+        if arg.typ._is_prim_word:
             value = unwrap_location(arg)
 
-        elif isinstance(arg.typ, ByteArrayLike):
-            value = keccak256_helper(expr, arg, context=context)
+        elif isinstance(arg.typ, _BytestringT):
+            value = keccak256_helper(arg, context=context)
         else:
             # TODO block at higher level
             raise TypeMismatch("Event indexes may only be value types", expr)
 
         topics.append(value)
 
     return topics
```

### Comparing `vyper-0.3.7/vyper/codegen/expr.py` & `vyper-0.3.8/vyper/codegen/expr.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,56 +1,61 @@
 import decimal
 import math
 
 import vyper.codegen.arithmetic as arithmetic
 from vyper import ast as vy_ast
-from vyper.address_space import DATA, IMMUTABLES, MEMORY, STORAGE
 from vyper.codegen import external_call, self_call
 from vyper.codegen.core import (
     clamp,
     ensure_in_memory,
     get_dyn_array_count,
     get_element_ptr,
     getpos,
+    is_array_like,
+    is_bytes_m_type,
+    is_enum_type,
+    is_numeric_type,
+    is_tuple_like,
     pop_dyn_array,
+    sar,
+    shl,
+    shr,
     unwrap_location,
 )
 from vyper.codegen.ir_node import IRnode
 from vyper.codegen.keccak256_helper import keccak256_helper
-from vyper.codegen.types import (
-    ArrayLike,
-    BaseType,
-    ByteArrayLike,
-    ByteArrayType,
-    DArrayType,
-    EnumType,
-    InterfaceType,
-    MappingType,
-    SArrayType,
-    StringType,
-    StructType,
-    TupleType,
-    is_base_type,
-    is_bytes_m_type,
-    is_numeric_type,
-)
-from vyper.codegen.types.convert import new_type_to_old_type
+from vyper.evm.address_space import DATA, IMMUTABLES, MEMORY, STORAGE, TRANSIENT
 from vyper.evm.opcodes import version_check
 from vyper.exceptions import (
     CompilerPanic,
     EvmVersionException,
     StructureException,
     TypeCheckFailure,
     TypeMismatch,
     UnimplementedException,
     VyperException,
 )
+from vyper.semantics.types import (
+    AddressT,
+    BoolT,
+    BytesT,
+    DArrayT,
+    DecimalT,
+    EnumT,
+    HashMapT,
+    InterfaceT,
+    SArrayT,
+    StringT,
+    StructT,
+    TupleT,
+)
+from vyper.semantics.types.bytestrings import _BytestringT
+from vyper.semantics.types.shortcuts import BYTES32_T, UINT256_T
 from vyper.utils import (
     DECIMAL_DIVISOR,
-    SizeLimits,
     bytes_to_int,
     is_checksum_encoded,
     string_to_bytes,
     vyper_warn,
 )
 
 ENVIRONMENT_VARIABLES = {"block", "msg", "tx", "chain"}
@@ -66,85 +71,72 @@
         if isinstance(node, IRnode):
             # TODO this seems bad
             self.ir_node = node
             return
 
         fn = getattr(self, f"parse_{type(node).__name__}", None)
         if fn is None:
-            raise TypeCheckFailure(f"Invalid statement node: {type(node).__name__}")
+            raise TypeCheckFailure(f"Invalid statement node: {type(node).__name__}", node)
 
         self.ir_node = fn()
         if self.ir_node is None:
-            raise TypeCheckFailure(f"{type(node).__name__} node did not produce IR. {self.expr}")
+            raise TypeCheckFailure(f"{type(node).__name__} node did not produce IR.", node)
 
         self.ir_node.annotation = self.expr.get("node_source_code")
         self.ir_node.source_pos = getpos(self.expr)
 
     def parse_Int(self):
-        typ_ = self.expr._metadata.get("type")
-        if typ_ is None:
-            raise CompilerPanic("Type of integer literal is unknown")
-        new_typ = new_type_to_old_type(typ_)
-        new_typ.is_literal = True
-        return IRnode.from_list(self.expr.n, typ=new_typ)
+        typ = self.expr._metadata["type"]
+        return IRnode.from_list(self.expr.n, typ=typ)
 
     def parse_Decimal(self):
         val = self.expr.value * DECIMAL_DIVISOR
 
         # sanity check that type checker did its job
         assert isinstance(val, decimal.Decimal)
-        assert SizeLimits.in_bounds("decimal", val)
         assert math.ceil(val) == math.floor(val)
 
         val = int(val)
+        lo, hi = DecimalT().int_bounds
+        # sanity check
+        assert lo <= val <= hi
 
-        return IRnode.from_list(val, typ=BaseType("decimal", is_literal=True))
+        return IRnode.from_list(val, typ=DecimalT())
 
     def parse_Hex(self):
         hexstr = self.expr.value
 
-        t = self.expr._metadata.get("type")
+        t = self.expr._metadata["type"]
 
         n_bytes = (len(hexstr) - 2) // 2  # e.g. "0x1234" is 2 bytes
 
-        if t is not None:
-            inferred_type = new_type_to_old_type(self.expr._metadata["type"])
-        # This branch is a band-aid to deal with bytes20 vs address literals
-        # TODO handle this properly in the type checker
-        elif len(hexstr) == 42:
-            inferred_type = BaseType("address", is_literal=True)
-        else:
-            inferred_type = BaseType(f"bytes{n_bytes}", is_literal=True)
-
-        if is_base_type(inferred_type, "address"):
+        if t == AddressT():
             # sanity check typechecker did its job
             assert len(hexstr) == 42 and is_checksum_encoded(hexstr)
-            typ = BaseType("address")
-            return IRnode.from_list(int(self.expr.value, 16), typ=typ)
+            return IRnode.from_list(int(self.expr.value, 16), typ=t)
 
-        elif is_bytes_m_type(inferred_type):
-            assert n_bytes == inferred_type._bytes_info.m
+        elif is_bytes_m_type(t):
+            assert n_bytes == t.m
 
             # bytes_m types are left padded with zeros
             val = int(hexstr, 16) << 8 * (32 - n_bytes)
 
-            typ = BaseType(f"bytes{n_bytes}", is_literal=True)
-            return IRnode.from_list(val, typ=typ)
+            return IRnode.from_list(val, typ=t)
 
     # String literals
     def parse_Str(self):
         bytez, bytez_length = string_to_bytes(self.expr.value)
-        typ = StringType(bytez_length, is_literal=True)
+        typ = StringT(bytez_length)
         return self._make_bytelike(typ, bytez, bytez_length)
 
     # Byte literals
     def parse_Bytes(self):
         bytez = self.expr.s
         bytez_length = len(self.expr.s)
-        typ = ByteArrayType(bytez_length, is_literal=True)
+        typ = BytesT(bytez_length)
         return self._make_bytelike(typ, bytez, bytez_length)
 
     def _make_bytelike(self, btype, bytez, bytez_length):
         placeholder = self.context.new_internal_variable(btype)
         seq = []
         seq.append(["mstore", placeholder, bytez_length])
         for i in range(0, len(bytez), 32):
@@ -160,236 +152,264 @@
             typ=btype,
             location=MEMORY,
             annotation=f"Create {btype}: {bytez}",
         )
 
     # True, False, None constants
     def parse_NameConstant(self):
-        if self.expr.value is True:
-            return IRnode.from_list(1, typ=BaseType("bool", is_literal=True))
-        elif self.expr.value is False:
-            return IRnode.from_list(0, typ=BaseType("bool", is_literal=True))
+        assert isinstance(self.expr.value, bool)
+        val = int(self.expr.value)
+        return IRnode.from_list(val, typ=BoolT())
 
     # Variable names
     def parse_Name(self):
-
         if self.expr.id == "self":
-            return IRnode.from_list(["address"], typ="address")
+            return IRnode.from_list(["address"], typ=AddressT())
         elif self.expr.id in self.context.vars:
             var = self.context.vars[self.expr.id]
-            return IRnode.from_list(
+            ret = IRnode.from_list(
                 var.pos,
                 typ=var.typ,
                 location=var.location,  # either 'memory' or 'calldata' storage is handled above.
                 encoding=var.encoding,
                 annotation=self.expr.id,
                 mutable=var.mutable,
             )
+            ret._referenced_variables = {var}
+            return ret
+
+        # TODO: use self.expr._expr_info
+        elif self.expr.id in self.context.globals:
+            varinfo = self.context.globals[self.expr.id]
+            assert varinfo.is_immutable, "not an immutable!"
 
-        elif self.expr._metadata["type"].is_immutable:
-            var = self.context.globals[self.expr.id]
-            ofst = self.expr._metadata["type"].position.offset
+            ofst = varinfo.position.offset
 
-            if self.context.sig.is_init_func:
+            if self.context.is_ctor_context:
                 mutable = True
                 location = IMMUTABLES
             else:
                 mutable = False
                 location = DATA
 
-            return IRnode.from_list(
-                ofst, typ=var.typ, location=location, annotation=self.expr.id, mutable=mutable
+            ret = IRnode.from_list(
+                ofst, typ=varinfo.typ, location=location, annotation=self.expr.id, mutable=mutable
             )
+            ret._referenced_variables = {varinfo}
+            return ret
 
     # x.y or x[5]
     def parse_Attribute(self):
-        typ = self.expr._metadata.get("type")
-        if typ is not None:
-            typ = new_type_to_old_type(typ)
+        typ = self.expr._metadata["type"]
 
         # MyEnum.foo
-        if isinstance(typ, EnumType) and typ.name == self.expr.value.id:
+        if (
+            isinstance(typ, EnumT)
+            and isinstance(self.expr.value, vy_ast.Name)
+            and typ.name == self.expr.value.id
+        ):
             # 0, 1, 2, .. 255
-            enum_id = typ.members[self.expr.attr]
-            value = 2 ** enum_id  # 0 => 0001, 1 => 0010, 2 => 0100, etc.
+            enum_id = typ._enum_members[self.expr.attr]
+            value = 2**enum_id  # 0 => 0001, 1 => 0010, 2 => 0100, etc.
             return IRnode.from_list(value, typ=typ)
 
         # x.balance: balance of address x
         if self.expr.attr == "balance":
             addr = Expr.parse_value_expr(self.expr.value, self.context)
-            if is_base_type(addr.typ, "address"):
+            if addr.typ == AddressT():
                 if (
                     isinstance(self.expr.value, vy_ast.Name)
                     and self.expr.value.id == "self"
                     and version_check(begin="istanbul")
                 ):
                     seq = ["selfbalance"]
                 else:
                     seq = ["balance", addr]
-                return IRnode.from_list(seq, typ=BaseType("uint256"))
+                return IRnode.from_list(seq, typ=UINT256_T)
         # x.codesize: codesize of address x
         elif self.expr.attr == "codesize" or self.expr.attr == "is_contract":
             addr = Expr.parse_value_expr(self.expr.value, self.context)
-            if is_base_type(addr.typ, "address"):
+            if addr.typ == AddressT():
                 if self.expr.attr == "codesize":
                     if self.expr.get("value.id") == "self":
                         eval_code = ["codesize"]
                     else:
                         eval_code = ["extcodesize", addr]
-                    output_type = "uint256"
+                    output_type = UINT256_T
                 else:
                     eval_code = ["gt", ["extcodesize", addr], 0]
-                    output_type = "bool"
-                return IRnode.from_list(eval_code, typ=BaseType(output_type))
+                    output_type = BoolT()
+                return IRnode.from_list(eval_code, typ=output_type)
         # x.codehash: keccak of address x
         elif self.expr.attr == "codehash":
             addr = Expr.parse_value_expr(self.expr.value, self.context)
             if not version_check(begin="constantinople"):
                 raise EvmVersionException(
                     "address.codehash is unavailable prior to constantinople ruleset", self.expr
                 )
-            if is_base_type(addr.typ, "address"):
-                return IRnode.from_list(["extcodehash", addr], typ=BaseType("bytes32"))
+            if addr.typ == AddressT():
+                return IRnode.from_list(["extcodehash", addr], typ=BYTES32_T)
         # x.code: codecopy/extcodecopy of address x
         elif self.expr.attr == "code":
             addr = Expr.parse_value_expr(self.expr.value, self.context)
-            if is_base_type(addr.typ, "address"):
+            if addr.typ == AddressT():
                 # These adhoc nodes will be replaced with a valid node in `Slice.build_IR`
                 if addr.value == "address":  # for `self.code`
-                    return IRnode.from_list(["~selfcode"], typ=ByteArrayType(0))
-                return IRnode.from_list(["~extcode", addr], typ=ByteArrayType(0))
+                    return IRnode.from_list(["~selfcode"], typ=BytesT(0))
+                return IRnode.from_list(["~extcode", addr], typ=BytesT(0))
         # self.x: global attribute
         elif isinstance(self.expr.value, vy_ast.Name) and self.expr.value.id == "self":
-            type_ = self.expr._metadata["type"]
-            var = self.context.globals[self.expr.attr]
-            return IRnode.from_list(
-                type_.position.position,
-                typ=var.typ,
-                location=STORAGE,
+            varinfo = self.context.globals[self.expr.attr]
+            location = TRANSIENT if varinfo.is_transient else STORAGE
+
+            ret = IRnode.from_list(
+                varinfo.position.position,
+                typ=varinfo.typ,
+                location=location,
                 annotation="self." + self.expr.attr,
             )
+            ret._referenced_variables = {varinfo}
+
+            return ret
+
         # Reserved keywords
         elif (
             isinstance(self.expr.value, vy_ast.Name) and self.expr.value.id in ENVIRONMENT_VARIABLES
         ):
             key = f"{self.expr.value.id}.{self.expr.attr}"
             if key == "msg.sender":
-                return IRnode.from_list(["caller"], typ="address")
+                return IRnode.from_list(["caller"], typ=AddressT())
             elif key == "msg.data":
                 # This adhoc node will be replaced with a valid node in `Slice/Len.build_IR`
-                return IRnode.from_list(["~calldata"], typ=ByteArrayType(0))
+                return IRnode.from_list(["~calldata"], typ=BytesT(0))
             elif key == "msg.value" and self.context.is_payable:
-                return IRnode.from_list(["callvalue"], typ=BaseType("uint256"))
+                return IRnode.from_list(["callvalue"], typ=UINT256_T)
             elif key == "msg.gas":
-                return IRnode.from_list(["gas"], typ="uint256")
+                return IRnode.from_list(["gas"], typ=UINT256_T)
             elif key == "block.prevrandao":
                 if not version_check(begin="paris"):
                     warning = VyperException(
                         "tried to use block.prevrandao in pre-Paris "
                         "environment! Suggest using block.difficulty instead.",
                         self.expr,
                     )
                     vyper_warn(str(warning))
-                return IRnode.from_list(["prevrandao"], typ="uint256")
+                return IRnode.from_list(["prevrandao"], typ=UINT256_T)
             elif key == "block.difficulty":
                 if version_check(begin="paris"):
                     warning = VyperException(
                         "tried to use block.difficulty in post-Paris "
                         "environment! Suggest using block.prevrandao instead.",
                         self.expr,
                     )
                     vyper_warn(str(warning))
-                return IRnode.from_list(["difficulty"], typ="uint256")
+                return IRnode.from_list(["difficulty"], typ=UINT256_T)
             elif key == "block.timestamp":
-                return IRnode.from_list(["timestamp"], typ=BaseType("uint256"))
+                return IRnode.from_list(["timestamp"], typ=UINT256_T)
             elif key == "block.coinbase":
-                return IRnode.from_list(["coinbase"], typ="address")
+                return IRnode.from_list(["coinbase"], typ=AddressT())
             elif key == "block.number":
-                return IRnode.from_list(["number"], typ="uint256")
+                return IRnode.from_list(["number"], typ=UINT256_T)
             elif key == "block.gaslimit":
-                return IRnode.from_list(["gaslimit"], typ="uint256")
+                return IRnode.from_list(["gaslimit"], typ=UINT256_T)
             elif key == "block.basefee":
-                return IRnode.from_list(["basefee"], typ="uint256")
+                return IRnode.from_list(["basefee"], typ=UINT256_T)
             elif key == "block.prevhash":
-                return IRnode.from_list(["blockhash", ["sub", "number", 1]], typ="bytes32")
+                return IRnode.from_list(["blockhash", ["sub", "number", 1]], typ=BYTES32_T)
             elif key == "tx.origin":
-                return IRnode.from_list(["origin"], typ="address")
+                return IRnode.from_list(["origin"], typ=AddressT())
             elif key == "tx.gasprice":
-                return IRnode.from_list(["gasprice"], typ="uint256")
+                return IRnode.from_list(["gasprice"], typ=UINT256_T)
             elif key == "chain.id":
                 if not version_check(begin="istanbul"):
                     raise EvmVersionException(
                         "chain.id is unavailable prior to istanbul ruleset", self.expr
                     )
-                return IRnode.from_list(["chainid"], typ="uint256")
+                return IRnode.from_list(["chainid"], typ=UINT256_T)
         # Other variables
         else:
             sub = Expr(self.expr.value, self.context).ir_node
             # contract type
-            if isinstance(sub.typ, InterfaceType):
+            if isinstance(sub.typ, InterfaceT):
+                # MyInterface.address
+                assert self.expr.attr == "address"
+                sub.typ = typ
                 return sub
-            if isinstance(sub.typ, StructType) and self.expr.attr in sub.typ.members:
+            if isinstance(sub.typ, StructT) and self.expr.attr in sub.typ.member_types:
                 return get_element_ptr(sub, self.expr.attr)
 
     def parse_Subscript(self):
         sub = Expr(self.expr.value, self.context).ir_node
         if sub.value == "multi":
             # force literal to memory, e.g.
             # MY_LIST: constant(decimal[6])
             # ...
             # return MY_LIST[ix]
             sub = ensure_in_memory(sub, self.context)
 
-        if isinstance(sub.typ, MappingType):
+        if isinstance(sub.typ, HashMapT):
             # TODO sanity check we are in a self.my_map[i] situation
-            index = Expr.parse_value_expr(self.expr.slice.value, self.context)
-            if isinstance(index.typ, ByteArrayLike):
+            index = Expr(self.expr.slice.value, self.context).ir_node
+            if isinstance(index.typ, _BytestringT):
                 # we have to hash the key to get a storage location
-                assert len(index.args) == 1
-                index = keccak256_helper(self.expr.slice.value, index.args[0], self.context)
+                index = keccak256_helper(index, self.context)
 
-        elif isinstance(sub.typ, ArrayLike):
+        elif is_array_like(sub.typ):
             index = Expr.parse_value_expr(self.expr.slice.value, self.context)
 
-        elif isinstance(sub.typ, TupleType):
+        elif is_tuple_like(sub.typ):
             index = self.expr.slice.value.n
             # note: this check should also happen in get_element_ptr
-            if not 0 <= index < len(sub.typ.members):
+            if not 0 <= index < len(sub.typ.member_types):
                 return
         else:
             return
 
         ir_node = get_element_ptr(sub, index)
         ir_node.mutable = sub.mutable
         return ir_node
 
     def parse_BinOp(self):
         left = Expr.parse_value_expr(self.expr.left, self.context)
         right = Expr.parse_value_expr(self.expr.right, self.context)
 
-        if not is_numeric_type(left.typ) or not is_numeric_type(right.typ):
-            return
+        if not isinstance(self.expr.op, (vy_ast.LShift, vy_ast.RShift)):
+            # Sanity check - ensure that we aren't dealing with different types
+            # This should be unreachable due to the type check pass
+            if left.typ != right.typ:
+                raise TypeCheckFailure(f"unreachable, {left.typ} != {right.typ}", self.expr)
 
-        ltyp, rtyp = left.typ.typ, right.typ.typ
+        assert is_numeric_type(left.typ) or is_enum_type(left.typ)
 
-        # Sanity check - ensure that we aren't dealing with different types
-        # This should be unreachable due to the type check pass
-        assert ltyp == rtyp, f"unreachable, {ltyp}!={rtyp}, {self.expr}"
+        out_typ = left.typ
 
         if isinstance(self.expr.op, vy_ast.BitAnd):
-            new_typ = left.typ
-            return IRnode.from_list(["and", left, right], typ=new_typ)
+            return IRnode.from_list(["and", left, right], typ=out_typ)
         if isinstance(self.expr.op, vy_ast.BitOr):
-            new_typ = left.typ
-            return IRnode.from_list(["or", left, right], typ=new_typ)
+            return IRnode.from_list(["or", left, right], typ=out_typ)
         if isinstance(self.expr.op, vy_ast.BitXor):
+            return IRnode.from_list(["xor", left, right], typ=out_typ)
+
+        if isinstance(self.expr.op, vy_ast.LShift):
             new_typ = left.typ
-            return IRnode.from_list(["xor", left, right], typ=new_typ)
+            if new_typ.bits != 256:
+                # TODO implement me. ["and", 2**bits - 1, shl(right, left)]
+                return
+            return IRnode.from_list(shl(right, left), typ=new_typ)
+        if isinstance(self.expr.op, vy_ast.RShift):
+            new_typ = left.typ
+            if new_typ.bits != 256:
+                # TODO implement me. promote_signed_int(op(right, left), bits)
+                return
+            op = shr if not left.typ.is_signed else sar
+            # note: sar NotImplementedError for pre-constantinople
+            return IRnode.from_list(op(right, left), typ=new_typ)
 
-        out_typ = BaseType(ltyp)
+        # enums can only do bit ops, not arithmetic.
+        assert is_numeric_type(left.typ)
 
         with left.cache_when_complex("x") as (b1, x), right.cache_when_complex("y") as (b2, y):
             if isinstance(self.expr.op, vy_ast.Add):
                 ret = arithmetic.safe_add(x, y)
             elif isinstance(self.expr.op, vy_ast.Sub):
                 ret = arithmetic.safe_sub(x, y)
             elif isinstance(self.expr.op, vy_ast.Mult):
@@ -397,41 +417,41 @@
             elif isinstance(self.expr.op, vy_ast.Div):
                 ret = arithmetic.safe_div(x, y)
             elif isinstance(self.expr.op, vy_ast.Mod):
                 ret = arithmetic.safe_mod(x, y)
             elif isinstance(self.expr.op, vy_ast.Pow):
                 ret = arithmetic.safe_pow(x, y)
             else:
-                return  # raises
+                raise CompilerPanic("Unreachable")
 
             return IRnode.from_list(b1.resolve(b2.resolve(ret)), typ=out_typ)
 
     def build_in_comparator(self):
         left = Expr(self.expr.left, self.context).ir_node
         right = Expr(self.expr.right, self.context).ir_node
 
         # temporary kludge to block #2637 bug
         # TODO actually fix the bug
-        if not isinstance(left.typ, BaseType):
+        if not left.typ._is_prim_word:
             raise TypeMismatch(
                 "`in` not allowed for arrays of non-base types, tracked in issue #2637", self.expr
             )
 
         left = unwrap_location(left)
 
         if isinstance(self.expr.op, vy_ast.In):
             found, not_found = 1, 0
         elif isinstance(self.expr.op, vy_ast.NotIn):
             found, not_found = 0, 1
         else:  # pragma: no cover
             return
 
-        i = IRnode.from_list(self.context.fresh_varname("in_ix"), typ="uint256")
+        i = IRnode.from_list(self.context.fresh_varname("in_ix"), typ=UINT256_T)
 
-        found_ptr = self.context.new_internal_variable(BaseType("bool"))
+        found_ptr = self.context.new_internal_variable(BoolT())
 
         ret = ["seq"]
 
         with left.cache_when_complex("needle") as (b1, left), right.cache_when_complex(
             "haystack"
         ) as (b2, right):
             # unroll the loop for compile-time list literals
@@ -450,15 +470,15 @@
             # general case: loop over the list and check each element
             # for equality
 
             # location of i'th item from list
             ith_element_ptr = get_element_ptr(right, i, array_bounds_check=False)
             ith_element = unwrap_location(ith_element_ptr)
 
-            if isinstance(right.typ, SArrayType):
+            if isinstance(right.typ, SArrayT):
                 len_ = right.typ.count
             else:
                 len_ = get_dyn_array_count(right)
 
             # Condition repeat loop has to break on.
             # TODO maybe put result on the stack
             loop_body = [
@@ -466,15 +486,15 @@
                 ["eq", left, ith_element],
                 ["seq", ["mstore", found_ptr, found], "break"],  # store true.
             ]
             loop = ["repeat", i, 0, len_, right.typ.count, loop_body]
 
             ret.append(["seq", ["mstore", found_ptr, not_found], loop, ["mload", found_ptr]])
 
-            return IRnode.from_list(b1.resolve(b2.resolve(ret)), typ="bool")
+            return IRnode.from_list(b1.resolve(b2.resolve(ret)), typ=BoolT())
 
     @staticmethod
     def _signed_to_unsigned_comparision_op(op):
         translation_map = {"sgt": "gt", "sge": "ge", "sle": "le", "slt": "lt"}
         if op in translation_map:
             return translation_map[op]
         else:
@@ -484,23 +504,23 @@
         left = Expr.parse_value_expr(self.expr.left, self.context)
         right = Expr.parse_value_expr(self.expr.right, self.context)
 
         if right.value is None:
             return
 
         if isinstance(self.expr.op, (vy_ast.In, vy_ast.NotIn)):
-            if isinstance(right.typ, ArrayLike):
+            if is_array_like(right.typ):
                 return self.build_in_comparator()
             else:
-                assert isinstance(right.typ, EnumType), right.typ
+                assert isinstance(right.typ, EnumT), right.typ
                 intersection = ["and", left, right]
                 if isinstance(self.expr.op, vy_ast.In):
-                    return IRnode.from_list(["iszero", ["iszero", intersection]], typ="bool")
+                    return IRnode.from_list(["iszero", ["iszero", intersection]], typ=BoolT())
                 elif isinstance(self.expr.op, vy_ast.NotIn):
-                    return IRnode.from_list(["iszero", intersection], typ="bool")
+                    return IRnode.from_list(["iszero", intersection], typ=BoolT())
 
         if isinstance(self.expr.op, vy_ast.Gt):
             op = "sgt"
         elif isinstance(self.expr.op, vy_ast.GtE):
             op = "sge"
         elif isinstance(self.expr.op, vy_ast.LtE):
             op = "sle"
@@ -510,54 +530,54 @@
             op = "eq"
         elif isinstance(self.expr.op, vy_ast.NotEq):
             op = "ne"
         else:
             return  # pragma: notest
 
         # Compare (limited to 32) byte arrays.
-        if isinstance(left.typ, ByteArrayLike) and isinstance(right.typ, ByteArrayLike):
+        if isinstance(left.typ, _BytestringT) and isinstance(right.typ, _BytestringT):
             left = Expr(self.expr.left, self.context).ir_node
             right = Expr(self.expr.right, self.context).ir_node
 
-            left_keccak = keccak256_helper(self.expr, left, self.context)
-            right_keccak = keccak256_helper(self.expr, right, self.context)
+            left_keccak = keccak256_helper(left, self.context)
+            right_keccak = keccak256_helper(right, self.context)
 
             if op not in ("eq", "ne"):
                 return  # raises
             else:
                 # use hash even for Bytes[N<=32], because there could be dirty
                 # bytes past the bytes data.
-                return IRnode.from_list([op, left_keccak, right_keccak], typ="bool")
+                return IRnode.from_list([op, left_keccak, right_keccak], typ=BoolT())
 
         # Compare other types.
         elif is_numeric_type(left.typ) and is_numeric_type(right.typ):
-            if left.typ.typ == right.typ.typ == "uint256":
+            if left.typ == right.typ and right.typ == UINT256_T:
                 # signed comparison ops work for any integer
                 # type BESIDES uint256
                 op = self._signed_to_unsigned_comparision_op(op)
 
-        elif isinstance(left.typ, BaseType) and isinstance(right.typ, BaseType):
+        elif left.typ._is_prim_word and right.typ._is_prim_word:
             if op not in ("eq", "ne"):
                 return
         else:
             # kludge to block behavior in #2638
             # TODO actually implement equality for complex types
             raise TypeMismatch(
                 f"operation not yet supported for {left.typ}, {right.typ}, see issue #2638",
                 self.expr.op,
             )
 
-        return IRnode.from_list([op, left, right], typ="bool")
+        return IRnode.from_list([op, left, right], typ=BoolT())
 
     def parse_BoolOp(self):
         values = []
         for value in self.expr.values:
             # Check for boolean operations with non-boolean inputs
             ir_val = Expr.parse_value_expr(value, self.context)
-            assert is_base_type(ir_val.typ, "bool")
+            assert ir_val.typ == BoolT()
             values.append(ir_val)
 
         assert len(values) >= 2, "bad BoolOp"
 
         if isinstance(self.expr.op, vy_ast.And):
             return Expr._logical_and(values)
 
@@ -577,15 +597,15 @@
 
         # iterate backward through the remaining values,
         # nesting further at each step
         for val in values[-2::-1]:
             # `x and y` => `if x { then y } { else 0 }`
             ir_node = ["if", val, ir_node, 0]
 
-        return IRnode.from_list(ir_node, typ="bool")
+        return IRnode.from_list(ir_node, typ=BoolT())
 
     @staticmethod
     def _logical_or(values):
         # return the logical or of a list of IRnodes
 
         # create a nested if statement starting from the
         # innermost node. note this also serves as the base case
@@ -594,129 +614,147 @@
 
         # iterate backward through the remaining values,
         # nesting further at each step
         for val in values[-2::-1]:
             # `x or y` => `if x { then 1 } { else y }`
             ir_node = ["if", val, 1, ir_node]
 
-        return IRnode.from_list(ir_node, typ="bool")
+        return IRnode.from_list(ir_node, typ=BoolT())
 
     # Unary operations (only "not" supported)
     def parse_UnaryOp(self):
         operand = Expr.parse_value_expr(self.expr.operand, self.context)
         if isinstance(self.expr.op, vy_ast.Not):
-            if isinstance(operand.typ, BaseType) and operand.typ.typ == "bool":
-                return IRnode.from_list(["iszero", operand], typ="bool")
+            if operand.typ._is_prim_word and operand.typ == BoolT():
+                return IRnode.from_list(["iszero", operand], typ=BoolT())
 
         if isinstance(self.expr.op, vy_ast.Invert):
-            if isinstance(operand.typ, EnumType):
-                n_members = len(operand.typ.members)
+            if isinstance(operand.typ, EnumT):
+                n_members = len(operand.typ._enum_members)
                 # use (xor 0b11..1 operand) to flip all the bits in
                 # `operand`. `mask` could be a very large constant and
                 # hurt codesize, but most user enums will likely have few
                 # enough members that the mask will not be large.
-                mask = (2 ** n_members) - 1
+                mask = (2**n_members) - 1
                 return IRnode.from_list(["xor", mask, operand], typ=operand.typ)
 
-            if is_base_type(operand.typ, "uint256"):
+            if operand.typ == UINT256_T:
                 return IRnode.from_list(["not", operand], typ=operand.typ)
 
             # block `~` for all other integer types, since reasoning
             # about dirty bits is not entirely trivial. maybe revisit
             # this at a later date.
             raise UnimplementedException(f"~ is not supported for {operand.typ}", self.expr)
 
         if isinstance(self.expr.op, vy_ast.USub) and is_numeric_type(operand.typ):
-            assert operand.typ._num_info.is_signed
+            assert operand.typ.is_signed
             # Clamp on minimum signed integer value as we cannot negate that
             # value (all other integer values are fine)
-            min_int_val, _ = operand.typ._num_info.bounds
+            min_int_val, _ = operand.typ.int_bounds
             return IRnode.from_list(["sub", 0, clamp("sgt", operand, min_int_val)], typ=operand.typ)
 
-    def _is_valid_interface_assign(self):
-        if self.expr.args and len(self.expr.args) == 1:
-            arg_ir = Expr(self.expr.args[0], self.context).ir_node
-            if arg_ir.typ == BaseType("address"):
-                return True, arg_ir
-        return False, None
-
     # Function calls
     def parse_Call(self):
-        # TODO check out this inline import
-        from vyper.builtin_functions import DISPATCH_TABLE
+        # TODO fix cyclic import
+        from vyper.builtins.functions import DISPATCH_TABLE
 
         if isinstance(self.expr.func, vy_ast.Name):
             function_name = self.expr.func.id
 
             if function_name in DISPATCH_TABLE:
                 return DISPATCH_TABLE[function_name].build_IR(self.expr, self.context)
 
             # Struct constructors do not need `self` prefix.
-            elif function_name in self.context.structs:
+            elif isinstance(self.expr._metadata["type"], StructT):
                 args = self.expr.args
                 if len(args) == 1 and isinstance(args[0], vy_ast.Dict):
-                    return Expr.struct_literals(args[0], function_name, self.context)
+                    return Expr.struct_literals(
+                        args[0], function_name, self.context, self.expr._metadata["type"]
+                    )
 
             # Interface assignment. Bar(<address>).
-            elif function_name in self.context.sigs:
-                ret, arg_ir = self._is_valid_interface_assign()
-                if ret is True:
-                    arg_ir.typ = InterfaceType(function_name)  # Cast to Correct interface type.
-                    return arg_ir
+            elif isinstance(self.expr._metadata["type"], InterfaceT):
+                (arg0,) = self.expr.args
+                arg_ir = Expr(arg0, self.context).ir_node
+
+                assert arg_ir.typ == AddressT()
+                arg_ir.typ = self.expr._metadata["type"]
+
+                return arg_ir
 
         elif isinstance(self.expr.func, vy_ast.Attribute) and self.expr.func.attr == "pop":
             # TODO consider moving this to builtins
             darray = Expr(self.expr.func.value, self.context).ir_node
             assert len(self.expr.args) == 0
-            assert isinstance(darray.typ, DArrayType)
+            assert isinstance(darray.typ, DArrayT)
             return pop_dyn_array(darray, return_popped_item=True)
 
         elif (
             # TODO use expr.func.type.is_internal once
             # type annotations are consistently available
             isinstance(self.expr.func, vy_ast.Attribute)
             and isinstance(self.expr.func.value, vy_ast.Name)
             and self.expr.func.value.id == "self"
         ):
             return self_call.ir_for_self_call(self.expr, self.context)
         else:
             return external_call.ir_for_external_call(self.expr, self.context)
 
     def parse_List(self):
-        typ = new_type_to_old_type(self.expr._metadata["type"])
+        typ = self.expr._metadata["type"]
         if len(self.expr.elements) == 0:
             return IRnode.from_list("~empty", typ=typ)
 
         multi_ir = [Expr(x, self.context).ir_node for x in self.expr.elements]
 
         return IRnode.from_list(["multi"] + multi_ir, typ=typ)
 
     def parse_Tuple(self):
         tuple_elements = [Expr(x, self.context).ir_node for x in self.expr.elements]
-        typ = TupleType([x.typ for x in tuple_elements], is_literal=True)
+        typ = TupleT([x.typ for x in tuple_elements])
         multi_ir = IRnode.from_list(["multi"] + tuple_elements, typ=typ)
         return multi_ir
 
+    def parse_IfExp(self):
+        test = Expr.parse_value_expr(self.expr.test, self.context)
+        assert test.typ == BoolT()  # sanity check
+
+        body = Expr(self.expr.body, self.context).ir_node
+        orelse = Expr(self.expr.orelse, self.context).ir_node
+
+        # if they are in the same location, we can skip copying
+        # into memory. also for the case where either body or orelse are
+        # literal `multi` values (ex. for tuple or arrays), copy to
+        # memory (to avoid crashing in make_setter, XXX fixme).
+        if body.location != orelse.location or body.value == "multi":
+            body = ensure_in_memory(body, self.context)
+            orelse = ensure_in_memory(orelse, self.context)
+
+        assert body.location == orelse.location
+        # check this once compare_type has no side effects:
+        # assert body.typ.compare_type(orelse.typ)
+
+        typ = self.expr._metadata["type"]
+        location = body.location
+        return IRnode.from_list(["if", test, body, orelse], typ=typ, location=location)
+
     @staticmethod
-    def struct_literals(expr, name, context):
+    def struct_literals(expr, name, context, typ):
         member_subs = {}
         member_typs = {}
         for key, value in zip(expr.keys, expr.values):
-            if not isinstance(key, vy_ast.Name):
-                return
-            if key.id in member_subs:
-                return
+            assert isinstance(key, vy_ast.Name)
+            assert key.id not in member_subs
+
             sub = Expr(value, context).ir_node
             member_subs[key.id] = sub
             member_typs[key.id] = sub.typ
 
-        # TODO: get struct type from context.global_ctx.parse_type(name)
         return IRnode.from_list(
-            ["multi"] + [member_subs[key] for key in member_subs.keys()],
-            typ=StructType(member_typs, name, is_literal=True),
+            ["multi"] + [member_subs[key] for key in member_subs.keys()], typ=typ
         )
 
     # Parse an expression that results in a value
     @classmethod
     def parse_value_expr(cls, expr, context):
         return unwrap_location(cls(expr, context).ir_node)
```

### Comparing `vyper-0.3.7/vyper/codegen/external_call.py` & `vyper-0.3.8/vyper/codegen/external_call.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,49 +1,47 @@
 from dataclasses import dataclass
 
 import vyper.utils as util
-from vyper.address_space import MEMORY
 from vyper.codegen.abi_encoder import abi_encode
 from vyper.codegen.core import (
     _freshname,
     calculate_type_for_external_return,
     check_assign,
     check_external_call,
     dummy_node_for_type,
     eval_once_check,
+    get_type_for_exact_size,
     make_setter,
     needs_clamp,
     unwrap_location,
     wrap_value_for_external_return,
 )
 from vyper.codegen.ir_node import Encoding, IRnode
-from vyper.codegen.types import InterfaceType, TupleType, get_type_for_exact_size
-from vyper.codegen.types.convert import new_type_to_old_type
+from vyper.evm.address_space import MEMORY
 from vyper.exceptions import TypeCheckFailure
+from vyper.semantics.types import InterfaceT, TupleT
 from vyper.semantics.types.function import StateMutability
 
 
 @dataclass
 class _CallKwargs:
     value: IRnode
     gas: IRnode
     skip_contract_check: bool
     default_return_value: IRnode
 
 
 def _pack_arguments(fn_type, args, context):
     # abi encoding just treats all args as a big tuple
-    args_tuple_t = TupleType([x.typ for x in args])
+    args_tuple_t = TupleT([x.typ for x in args])
     args_as_tuple = IRnode.from_list(["multi"] + [x for x in args], typ=args_tuple_t)
     args_abi_t = args_tuple_t.abi_type
 
     # sanity typecheck - make sure the arguments can be assigned
-    dst_tuple_t = TupleType(
-        [new_type_to_old_type(typ) for typ in fn_type.arguments.values()][: len(args)]
-    )
+    dst_tuple_t = TupleT(fn_type.argument_types[: len(args)])
     check_assign(dummy_node_for_type(dst_tuple_t), args_as_tuple)
 
     if fn_type.return_type is not None:
         return_abi_t = calculate_type_for_external_return(fn_type.return_type).abi_type
 
         # we use the same buffer for args and returndata,
         # so allocate enough space here for the returndata too.
@@ -65,30 +63,28 @@
     # 32 bytes                 | args
     # 0x..00<method_id_4bytes> | args
     # the reason for the left padding is just so the alignment is easier.
     # if we were only targeting constantinople, we could align
     # to buf (and also keep code size small) by using
     # (mstore buf (shl signature.method_id 224))
     pack_args = ["seq"]
-    pack_args.append(["mstore", buf, util.abi_method_id(abi_signature)])
+    pack_args.append(["mstore", buf, util.method_id_int(abi_signature)])
 
     if len(args) != 0:
         pack_args.append(abi_encode(buf + 32, args_as_tuple, context, bufsz=buflen))
 
     return buf, pack_args, args_ofst, args_len
 
 
 def _unpack_returndata(buf, fn_type, call_kwargs, contract_address, context, expr):
-    ast_return_t = fn_type.return_type
+    return_t = fn_type.return_type
 
-    if ast_return_t is None:
+    if return_t is None:
         return ["pass"], 0, 0
 
-    return_t = new_type_to_old_type(ast_return_t)
-
     wrapped_return_t = calculate_type_for_external_return(return_t)
 
     abi_return_t = wrapped_return_t.abi_type
 
     min_return_size = abi_return_t.min_size()
     max_return_size = abi_return_t.size_bound()
     assert 0 < min_return_size <= max_return_size
@@ -113,15 +109,15 @@
     if not call_kwargs.skip_contract_check:
         assertion = IRnode.from_list(
             ["assert", ["ge", "returndatasize", min_return_size]],
             error_msg="returndatasize too small",
         )
         unpacker.append(assertion)
 
-    assert isinstance(wrapped_return_t, TupleType)
+    assert isinstance(wrapped_return_t, TupleT)
 
     # unpack strictly
     if needs_clamp(wrapped_return_t, encoding):
         return_buf = context.new_internal_variable(wrapped_return_t)
         return_buf = IRnode.from_list(return_buf, typ=wrapped_return_t, location=MEMORY)
 
         # note: make_setter does ABI decoding and clamps
@@ -171,20 +167,18 @@
 
 
 def _extcodesize_check(address):
     return IRnode.from_list(["assert", ["extcodesize", address]], error_msg="extcodesize is zero")
 
 
 def _external_call_helper(contract_address, args_ir, call_kwargs, call_expr, context):
-    # expr.func._metadata["type"].return_type is more accurate
-    # than fn_sig.return_type in the case of JSON interfaces.
     fn_type = call_expr.func._metadata["type"]
 
     # sanity check
-    assert fn_type.min_arg_count <= len(args_ir) <= fn_type.max_arg_count
+    assert fn_type.n_positional_args <= len(args_ir) <= fn_type.n_total_args
 
     ret = ["seq"]
 
     # this is a sanity check to prevent double evaluation of the external call
     # in the codegen pipeline. if the external call gets doubly evaluated,
     # a duplicate label exception will get thrown during assembly.
     ret.append(eval_once_check(_freshname(call_expr.node_source_code)))
@@ -216,27 +210,26 @@
     if use_staticcall:
         call_op = ["staticcall", gas, contract_address, args_ofst, args_len, buf, ret_len]
     else:
         call_op = ["call", gas, contract_address, value, args_ofst, args_len, buf, ret_len]
 
     ret.append(check_external_call(call_op))
 
-    return_t = None
-    if fn_type.return_type is not None:
-        return_t = new_type_to_old_type(fn_type.return_type)
+    return_t = fn_type.return_type
+    if return_t is not None:
         ret.append(ret_unpacker)
 
     return IRnode.from_list(ret, typ=return_t, location=MEMORY)
 
 
 def ir_for_external_call(call_expr, context):
     from vyper.codegen.expr import Expr  # TODO rethink this circular import
 
     contract_address = Expr.parse_value_expr(call_expr.func.value, context)
-    assert isinstance(contract_address.typ, InterfaceType)
+    assert isinstance(contract_address.typ, InterfaceT)
     args_ir = [Expr(x, context).ir_node for x in call_expr.args]
     call_kwargs = _parse_kwargs(call_expr, context)
 
     with contract_address.cache_when_complex("external_contract") as (b1, contract_address):
         return b1.resolve(
             _external_call_helper(contract_address, args_ir, call_kwargs, call_expr, context)
         )
```

### Comparing `vyper-0.3.7/vyper/codegen/function_definitions/external_function.py` & `vyper-0.3.8/vyper/codegen/function_definitions/external_function.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,38 +1,36 @@
 from typing import Any, List
 
 import vyper.utils as util
-from vyper.address_space import CALLDATA, DATA, MEMORY
-from vyper.ast.signatures.function_signature import FunctionSignature, VariableRecord
 from vyper.codegen.abi_encoder import abi_encoding_matches_vyper
-from vyper.codegen.context import Context
+from vyper.codegen.context import Context, VariableRecord
 from vyper.codegen.core import get_element_ptr, getpos, make_setter, needs_clamp
 from vyper.codegen.expr import Expr
 from vyper.codegen.function_definitions.utils import get_nonreentrant_lock
 from vyper.codegen.ir_node import Encoding, IRnode
 from vyper.codegen.stmt import parse_body
-from vyper.codegen.types.types import TupleType
+from vyper.evm.address_space import CALLDATA, DATA, MEMORY
+from vyper.semantics.types import TupleT
+from vyper.semantics.types.function import ContractFunctionT
 
 
 # register function args with the local calling context.
 # also allocate the ones that live in memory (i.e. kwargs)
-def _register_function_args(context: Context, sig: FunctionSignature) -> List[IRnode]:
+def _register_function_args(func_t: ContractFunctionT, context: Context) -> List[IRnode]:
     ret = []
-
     # the type of the calldata
-    base_args_t = TupleType([arg.typ for arg in sig.base_args])
+    base_args_t = TupleT(tuple(arg.typ for arg in func_t.positional_args))
 
     # tuple with the abi_encoded args
-    if sig.is_init_func:
+    if func_t.is_constructor:
         base_args_ofst = IRnode(0, location=DATA, typ=base_args_t, encoding=Encoding.ABI)
     else:
         base_args_ofst = IRnode(4, location=CALLDATA, typ=base_args_t, encoding=Encoding.ABI)
 
-    for i, arg in enumerate(sig.base_args):
-
+    for i, arg in enumerate(func_t.positional_args):
         arg_ir = get_element_ptr(base_args_ofst, i)
 
         if needs_clamp(arg.typ, Encoding.ABI):
             # allocate a memory slot for it and copy
             p = context.new_variable(arg.name, arg.typ, is_mutable=False)
             dst = IRnode(p, typ=arg.typ, location=MEMORY)
 
@@ -51,58 +49,61 @@
                 encoding=Encoding.ABI,
             )
 
     return ret
 
 
 def _annotated_method_id(abi_sig):
-    method_id = util.abi_method_id(abi_sig)
+    method_id = util.method_id_int(abi_sig)
     annotation = f"{hex(method_id)}: {abi_sig}"
     return IRnode(method_id, annotation=annotation)
 
 
-def _generate_kwarg_handlers(context: Context, sig: FunctionSignature) -> List[Any]:
+def _generate_kwarg_handlers(func_t: ContractFunctionT, context: Context) -> List[Any]:
     # generate kwarg handlers.
     # since they might come in thru calldata or be default,
     # allocate them in memory and then fill it in based on calldata or default,
-    # depending on the signature
+    # depending on the ContractFunctionT
     # a kwarg handler looks like
     # (if (eq _method_id <method_id>)
     #    copy calldata args to memory
     #    write default args to memory
     #    goto external_function_common_ir
 
     def handler_for(calldata_kwargs, default_kwargs):
-        calldata_args = sig.base_args + calldata_kwargs
+        calldata_args = func_t.positional_args + calldata_kwargs
         # create a fake type so that get_element_ptr works
-        calldata_args_t = TupleType(list(arg.typ for arg in calldata_args))
+        calldata_args_t = TupleT(list(arg.typ for arg in calldata_args))
 
-        abi_sig = sig.abi_signature_for_kwargs(calldata_kwargs)
+        abi_sig = func_t.abi_signature_for_kwargs(calldata_kwargs)
         method_id = _annotated_method_id(abi_sig)
 
         calldata_kwargs_ofst = IRnode(
             4, location=CALLDATA, typ=calldata_args_t, encoding=Encoding.ABI
         )
 
         # a sequence of statements to strictify kwargs into memory
         ret = ["seq"]
 
         # ensure calldata is at least of minimum length
         args_abi_t = calldata_args_t.abi_type
         calldata_min_size = args_abi_t.min_size() + 4
-        ret.append(["assert", ["ge", "calldatasize", calldata_min_size]])
+
+        # note we don't need the check if calldata_min_size == 4,
+        # because the selector checks later in this routine ensure
+        # that calldatasize >= 4.
+        if calldata_min_size > 4:
+            ret.append(["assert", ["ge", "calldatasize", calldata_min_size]])
 
         # TODO optimize make_setter by using
-        # TupleType(list(arg.typ for arg in calldata_kwargs + default_kwargs))
+        # TupleT(list(arg.typ for arg in calldata_kwargs + default_kwargs))
         # (must ensure memory area is contiguous)
 
-        n_base_args = len(sig.base_args)
-
         for i, arg_meta in enumerate(calldata_kwargs):
-            k = n_base_args + i
+            k = func_t.n_positional_args + i
 
             dst = context.lookup_var(arg_meta.name).pos
 
             lhs = IRnode(dst, location=MEMORY, typ=arg_meta.typ)
 
             rhs = get_element_ptr(calldata_kwargs_ofst, k, array_bounds_check=False)
 
@@ -110,29 +111,52 @@
             copy_arg.source_pos = getpos(arg_meta.ast_source)
             ret.append(copy_arg)
 
         for x in default_kwargs:
             dst = context.lookup_var(x.name).pos
             lhs = IRnode(dst, location=MEMORY, typ=x.typ)
             lhs.source_pos = getpos(x.ast_source)
-            kw_ast_val = sig.default_values[x.name]  # e.g. `3` in x: int = 3
+            kw_ast_val = func_t.default_values[x.name]  # e.g. `3` in x: int = 3
             rhs = Expr(kw_ast_val, context).ir_node
 
             copy_arg = make_setter(lhs, rhs)
             copy_arg.source_pos = getpos(x.ast_source)
             ret.append(copy_arg)
 
-        ret.append(["goto", sig.external_function_base_entry_label])
+        ret.append(["goto", func_t._ir_info.external_function_base_entry_label])
 
-        ret = ["if", ["eq", "_calldata_method_id", method_id], ret]
+        method_id_check = ["eq", "_calldata_method_id", method_id]
+
+        # if there is a function whose selector is 0 or has trailing 0s, it
+        # might not be distinguished from the case where insufficient calldata
+        # is supplied, b/c calldataload loads 0s past the end of physical
+        # calldata (cf. yellow paper).
+        # since the expected behavior of supplying insufficient calldata
+        # is to trigger the fallback fn, we add to the selector check that
+        # calldatasize >= 4, which distinguishes any selector with trailing
+        # 0 bytes from the fallback function "selector" (equiv. to "all
+        # selectors not in the selector table").
+        #
+        # note that the inclusion of this check means that, we are always
+        # guaranteed that the calldata is at least 4 bytes - either we have
+        # the explicit `calldatasize >= 4` condition in the selector check,
+        # or there are no trailing zeroes in the selector, (so the selector
+        # is impossible to match without calldatasize being at least 4).
+        method_id_bytes = util.method_id(abi_sig)
+        assert len(method_id_bytes) == 4
+        has_trailing_zeroes = method_id_bytes.endswith(b"\x00")
+        if has_trailing_zeroes:
+            method_id_check = ["and", ["ge", "calldatasize", 4], method_id_check]
+
+        ret = ["if", method_id_check, ret]
         return ret
 
     ret = ["seq"]
 
-    keyword_args = sig.default_args
+    keyword_args = func_t.keyword_args
 
     # allocate variable slots in memory
     for arg in keyword_args:
         context.new_variable(arg.name, arg.typ, is_mutable=False)
 
     for i, _ in enumerate(keyword_args):
         calldata_kwargs = keyword_args[:i]
@@ -144,74 +168,75 @@
 
     return ret
 
 
 # TODO it would be nice if this returned a data structure which were
 # amenable to generating a jump table instead of the linear search for
 # method_id we have now.
-def generate_ir_for_external_function(code, sig, context, skip_nonpayable_check):
+def generate_ir_for_external_function(code, func_t, context, skip_nonpayable_check):
     # TODO type hints:
     # def generate_ir_for_external_function(
-    #    code: vy_ast.FunctionDef, sig: FunctionSignature, context: Context, check_nonpayable: bool,
+    #    code: vy_ast.FunctionDef,
+    #    func_t: ContractFunctionT,
+    #    context: Context,
+    #    check_nonpayable: bool,
     # ) -> IRnode:
     """Return the IR for an external function. Includes code to inspect the method_id,
     enter the function (nonpayable and reentrancy checks), handle kwargs and exit
     the function (clean up reentrancy storage variables)
     """
-    func_type = code._metadata["type"]
-
-    nonreentrant_pre, nonreentrant_post = get_nonreentrant_lock(func_type)
+    nonreentrant_pre, nonreentrant_post = get_nonreentrant_lock(func_t)
 
     # generate handlers for base args and register the variable records
-    handle_base_args = _register_function_args(context, sig)
+    handle_base_args = _register_function_args(func_t, context)
 
     # generate handlers for kwargs and register the variable records
-    kwarg_handlers = _generate_kwarg_handlers(context, sig)
+    kwarg_handlers = _generate_kwarg_handlers(func_t, context)
 
     body = ["seq"]
     # once optional args have been handled,
     # generate the main body of the function
     body += handle_base_args
 
-    if sig.mutability != "payable" and not skip_nonpayable_check:
+    if not func_t.is_payable and not skip_nonpayable_check:
         # if the contract contains payable functions, but this is not one of them
         # add an assertion that the value of the call is zero
         body += [["assert", ["iszero", "callvalue"]]]
 
     body += nonreentrant_pre
 
     body += [parse_body(code.body, context, ensure_terminated=True)]
 
     # wrap the body in labeled block
-    body = ["label", sig.external_function_base_entry_label, ["var_list"], body]
+    body = ["label", func_t._ir_info.external_function_base_entry_label, ["var_list"], body]
 
     exit_sequence = ["seq"] + nonreentrant_post
-    if sig.is_init_func:
+    if func_t.is_constructor:
         pass  # init func has special exit sequence generated by module.py
     elif context.return_type is None:
         exit_sequence += [["stop"]]
     else:
         exit_sequence += [["return", "ret_ofst", "ret_len"]]
 
     exit_sequence_args = ["var_list"]
     if context.return_type is not None:
         exit_sequence_args += ["ret_ofst", "ret_len"]
     # wrap the exit in a labeled block
-    exit = ["label", sig.exit_sequence_label, exit_sequence_args, exit_sequence]
+    exit = ["label", func_t._ir_info.exit_sequence_label, exit_sequence_args, exit_sequence]
 
     # the ir which comprises the main body of the function,
     # besides any kwarg handling
     func_common_ir = ["seq", body, exit]
 
-    if sig.is_default_func or sig.is_init_func:
+    if func_t.is_fallback or func_t.is_constructor:
         ret = ["seq"]
         # add a goto to make the function entry look like other functions
         # (for zksync interpreter)
-        ret.append(["goto", sig.external_function_base_entry_label])
+        ret.append(["goto", func_t._ir_info.external_function_base_entry_label])
         ret.append(func_common_ir)
     else:
         ret = kwarg_handlers
         # sneak the base code into the kwarg handler
         # TODO rethink this / make it clearer
         ret[-1][-1].append(func_common_ir)
 
-    return IRnode.from_list(ret)
+    return IRnode.from_list(ret, source_pos=getpos(code))
```

### Comparing `vyper-0.3.7/vyper/codegen/function_definitions/internal_function.py` & `vyper-0.3.8/vyper/codegen/function_definitions/internal_function.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,22 +1,22 @@
 from vyper import ast as vy_ast
-from vyper.ast.signatures import FunctionSignature
 from vyper.codegen.context import Context
 from vyper.codegen.function_definitions.utils import get_nonreentrant_lock
 from vyper.codegen.ir_node import IRnode
 from vyper.codegen.stmt import parse_body
+from vyper.semantics.types.function import ContractFunctionT
 
 
 def generate_ir_for_internal_function(
-    code: vy_ast.FunctionDef, sig: FunctionSignature, context: Context
+    code: vy_ast.FunctionDef, func_t: ContractFunctionT, context: Context
 ) -> IRnode:
     """
     Parse a internal function (FuncDef), and produce full function body.
 
-    :param sig: the FuntionSignature
+    :param func_t: the ContractFunctionT
     :param code: ast of function
     :param context: current calling context
     :return: function body in IR
     """
 
     # The calling convention is:
     #   Caller fills in argument buffer
@@ -33,30 +33,28 @@
     # operation. Second, it allows the caller to allocate the return
     # buffer in a way which reduces the number of copies. Third, it
     # reduces the potential for bugs since it forces the caller to have
     # the return data copied into a preallocated location. Otherwise, a
     # situation like the following is easy to bork:
     #   x: T[2] = [self.generate_T(), self.generate_T()]
 
-    func_type = code._metadata["type"]
-
     # Get nonreentrant lock
 
-    for arg in sig.args:
+    for arg in func_t.arguments:
         # allocate a variable for every arg, setting mutability
         # to False to comply with vyper semantics, function arguments are immutable
         context.new_variable(arg.name, arg.typ, is_mutable=False)
 
-    nonreentrant_pre, nonreentrant_post = get_nonreentrant_lock(func_type)
+    nonreentrant_pre, nonreentrant_post = get_nonreentrant_lock(func_t)
 
-    function_entry_label = sig.internal_function_label
-    cleanup_label = sig.exit_sequence_label
+    function_entry_label = func_t._ir_info.internal_function_label(context.is_ctor_context)
+    cleanup_label = func_t._ir_info.exit_sequence_label
 
     stack_args = ["var_list"]
-    if func_type.return_type:
+    if func_t.return_type:
         stack_args += ["return_buffer"]
     stack_args += ["return_pc"]
 
     body = [
         "label",
         function_entry_label,
         stack_args,
```

### Comparing `vyper-0.3.7/vyper/codegen/function_definitions/utils.py` & `vyper-0.3.8/vyper/codegen/function_definitions/utils.py`

 * *Files 13% similar despite different names*

```diff
@@ -4,24 +4,28 @@
 
 def get_nonreentrant_lock(func_type):
     if not func_type.nonreentrant:
         return ["pass"], ["pass"]
 
     nkey = func_type.reentrancy_key_position.position
 
+    LOAD, STORE = "sload", "sstore"
+    if version_check(begin="cancun"):
+        LOAD, STORE = "tload", "tstore"
+
     if version_check(begin="berlin"):
         # any nonzero values would work here (see pricing as of net gas
         # metering); these values are chosen so that downgrading to the
         # 0,1 scheme (if it is somehow necessary) is safe.
         final_value, temp_value = 3, 2
     else:
         final_value, temp_value = 0, 1
 
-    check_notset = ["assert", ["ne", temp_value, ["sload", nkey]]]
+    check_notset = ["assert", ["ne", temp_value, [LOAD, nkey]]]
 
     if func_type.mutability == StateMutability.VIEW:
         return [check_notset], [["seq"]]
 
     else:
-        pre = ["seq", check_notset, ["sstore", nkey, temp_value]]
-        post = ["sstore", nkey, final_value]
+        pre = ["seq", check_notset, [STORE, nkey, temp_value]]
+        post = [STORE, nkey, final_value]
         return [pre], [post]
```

### Comparing `vyper-0.3.7/vyper/codegen/ir_node.py` & `vyper-0.3.8/vyper/codegen/ir_node.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,17 +1,18 @@
 import re
 from enum import Enum, auto
+from functools import cached_property
 from typing import Any, List, Optional, Tuple, Union
 
-from vyper.address_space import AddrSpace
-from vyper.codegen.types import BaseType, NodeType, ceil32
 from vyper.compiler.settings import VYPER_COLOR_OUTPUT
+from vyper.evm.address_space import AddrSpace
 from vyper.evm.opcodes import get_ir_opcodes
 from vyper.exceptions import CodegenPanic, CompilerPanic
-from vyper.utils import VALID_IR_MACROS, cached_property
+from vyper.semantics.types import VyperType
+from vyper.utils import VALID_IR_MACROS, ceil32
 
 # Set default string representation for ints in IR output.
 AS_HEX_DEFAULT = False
 
 if VYPER_COLOR_OUTPUT:
     OKBLUE = "\033[94m"
     OKMAGENTA = "\033[35m"
@@ -107,30 +108,30 @@
     args: List["IRnode"]
     value: Union[str, int]
 
     def __init__(
         self,
         value: Union[str, int],
         args: List["IRnode"] = None,
-        typ: NodeType = None,
+        typ: VyperType = None,
         location: Optional[AddrSpace] = None,
         source_pos: Optional[Tuple[int, int]] = None,
         annotation: Optional[str] = None,
         error_msg: Optional[str] = None,
         mutable: bool = True,
         add_gas_estimate: int = 0,
         encoding: Encoding = Encoding.VYPER,
     ):
         if args is None:
             args = []
 
         self.value = value
         self.args = args
         # TODO remove this sanity check once mypy is more thorough
-        assert isinstance(typ, NodeType) or typ is None, repr(typ)
+        assert isinstance(typ, VyperType) or typ is None, repr(typ)
         self.typ = typ
         self.location = location
         self.source_pos = source_pos
         self.error_msg = error_msg
         self.annotation = annotation
         self.mutable = mutable
         self.add_gas_estimate = add_gas_estimate
@@ -147,15 +148,15 @@
         # 0 otherwise) and checks to make sure the number and valencies of
         # children are correct. Also, find an upper bound on gas consumption
         # Numbers
         if isinstance(self.value, int):
             _check(len(self.args) == 0, "int can't have arguments")
 
             # integers must be in the range (MIN_INT256, MAX_UINT256)
-            _check(-(2 ** 255) <= self.value < 2 ** 256, "out of range")
+            _check(-(2**255) <= self.value < 2**256, "out of range")
 
             self.valency = 1
             self._gas = 5
         elif isinstance(self.value, str):
             # Opcodes and pseudo-opcodes (e.g. clamp)
             if self.value.upper() in get_ir_opcodes():
                 _, ins, outs, gas = get_ir_opcodes()[self.value.upper()]
@@ -393,14 +394,24 @@
         # (e.g. `(add 1 2)`)
         # TODO this could really be moved into optimizer.py
         should_inline = not optimize(self).is_complex_ir
 
         return _WithBuilder(self, name, should_inline)
 
     @cached_property
+    def referenced_variables(self):
+        ret = set()
+        for arg in self.args:
+            ret |= arg.referenced_variables
+
+        ret |= getattr(self, "_referenced_variables", set())
+
+        return ret
+
+    @cached_property
     def contains_self_call(self):
         return getattr(self, "is_self_call", False) or any(x.contains_self_call for x in self.args)
 
     def __getitem__(self, i):
         return self.to_list()[i]
 
     def __len__(self):
@@ -437,17 +448,15 @@
         if val.lower() in VALID_IR_MACROS:  # highlight macro
             return OKLIGHTMAGENTA + val + ENDC
         elif val.upper() in get_ir_opcodes().keys():
             return OKMAGENTA + val + ENDC
         return val
 
     def repr(self) -> str:
-
         if not len(self.args):
-
             if self.annotation:
                 return f"{self.repr_value} " + OKLIGHTBLUE + f"<{self.annotation}>" + ENDC
             else:
                 return str(self.repr_value)
         # x = repr(self.to_list())
         # if len(x) < 80:
         #     return x
@@ -488,25 +497,25 @@
     def __repr__(self):
         return self.repr()
 
     @classmethod
     def from_list(
         cls,
         obj: Any,
-        typ: NodeType = None,
+        typ: VyperType = None,
         location: Optional[AddrSpace] = None,
         source_pos: Optional[Tuple[int, int]] = None,
         annotation: Optional[str] = None,
         error_msg: Optional[str] = None,
         mutable: bool = True,
         add_gas_estimate: int = 0,
         encoding: Encoding = Encoding.VYPER,
     ) -> "IRnode":
         if isinstance(typ, str):
-            typ = BaseType(typ)
+            raise CompilerPanic(f"Expected type, not string: {typ}")
 
         if isinstance(obj, IRnode):
             # note: this modify-and-returnclause is a little weird since
             # the input gets modified. CC 20191121.
             if typ is not None:
                 obj.typ = typ
             if obj.source_pos is None:
```

### Comparing `vyper-0.3.7/vyper/codegen/keccak256_helper.py` & `vyper-0.3.8/vyper/codegen/keccak256_helper.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,52 +1,54 @@
 from math import ceil
 
 from vyper.codegen.core import bytes_data_ptr, ensure_in_memory, get_bytearray_length
 from vyper.codegen.ir_node import IRnode
-from vyper.codegen.types import BaseType, ByteArrayLike, is_base_type
 from vyper.exceptions import CompilerPanic
+from vyper.semantics.types.bytestrings import _BytestringT
+from vyper.semantics.types.shortcuts import BYTES32_T
 from vyper.utils import SHA3_BASE, SHA3_PER_WORD, MemoryPositions, bytes_to_int, keccak256
 
 
-def _check_byteslike(typ, _expr):
-    if not isinstance(typ, ByteArrayLike) and not is_base_type(typ, "bytes32"):
+def _check_byteslike(typ):
+    if not isinstance(typ, _BytestringT) and typ != BYTES32_T:
         # NOTE this may be checked at a higher level, but just be safe
         raise CompilerPanic("keccak256 only accepts bytes-like objects")
 
 
 def _gas_bound(num_words):
     return SHA3_BASE + num_words * SHA3_PER_WORD
 
 
-def keccak256_helper(expr, to_hash, context):
-    _check_byteslike(to_hash.typ, expr)
+def keccak256_helper(to_hash, context):
+    _check_byteslike(to_hash.typ)
 
     # Can hash literals
     # TODO this is dead code.
     if isinstance(to_hash, bytes):
-        return IRnode.from_list(bytes_to_int(keccak256(to_hash)), typ=BaseType("bytes32"))
+        return IRnode.from_list(bytes_to_int(keccak256(to_hash)), typ=BYTES32_T)
 
     # Can hash bytes32 objects
-    if is_base_type(to_hash.typ, "bytes32"):
+    # TODO: Want to generalize to all bytes_M
+    if to_hash.typ == BYTES32_T:
         return IRnode.from_list(
             [
                 "seq",
                 ["mstore", MemoryPositions.FREE_VAR_SPACE, to_hash],
                 ["sha3", MemoryPositions.FREE_VAR_SPACE, 32],
             ],
-            typ=BaseType("bytes32"),
+            typ=BYTES32_T,
             add_gas_estimate=_gas_bound(1),
         )
 
     to_hash = ensure_in_memory(to_hash, context)
 
     with to_hash.cache_when_complex("buf") as (b1, to_hash):
         data = bytes_data_ptr(to_hash)
         len_ = get_bytearray_length(to_hash)
         return b1.resolve(
             IRnode.from_list(
                 ["sha3", data, len_],
-                typ="bytes32",
+                typ=BYTES32_T,
                 annotation="keccak256",
                 add_gas_estimate=_gas_bound(ceil(to_hash.typ.maxlen / 32)),
             )
         )
```

### Comparing `vyper-0.3.7/vyper/codegen/memory_allocator.py` & `vyper-0.3.8/vyper/codegen/memory_allocator.py`

 * *Files 2% similar despite different names*

```diff
@@ -94,18 +94,17 @@
             if free_memory.size == size:
                 del self.deallocated_mem[i]
                 return free_memory.position
             if free_memory.size > size:
                 return free_memory.partially_allocate(size)
 
         # if no deallocated slots are available, expand memory
-        return self.expand_memory(size)
+        return self._expand_memory(size)
 
-    # TODO this should be an internal function
-    def expand_memory(self, size: int) -> int:
+    def _expand_memory(self, size: int) -> int:
         """
         Allocate `size` bytes in memory, starting from the free memory pointer.
         """
         if size % 32 != 0:
             raise CompilerPanic("Memory misaligment, only multiples of 32 supported.")
 
         before_value = self.next_mem
```

### Comparing `vyper-0.3.7/vyper/codegen/return_.py` & `vyper-0.3.8/vyper/codegen/return_.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,46 +1,45 @@
 from typing import Any, Optional
 
-from vyper.address_space import MEMORY
 from vyper.codegen.abi_encoder import abi_encode, abi_encoding_matches_vyper
 from vyper.codegen.context import Context
 from vyper.codegen.core import (
     calculate_type_for_external_return,
     check_assign,
     dummy_node_for_type,
+    get_type_for_exact_size,
     make_setter,
     needs_clamp,
     wrap_value_for_external_return,
 )
 from vyper.codegen.ir_node import IRnode
-from vyper.codegen.types import get_type_for_exact_size
+from vyper.evm.address_space import MEMORY
 
 Stmt = Any  # mypy kludge
 
 
 # Generate code for return stmt
 def make_return_stmt(ir_val: IRnode, stmt: Any, context: Context) -> Optional[IRnode]:
+    func_t = context.func_t
 
-    sig = context.sig
-
-    jump_to_exit = ["exit_to", f"_sym_{sig.exit_sequence_label}"]
+    jump_to_exit = ["exit_to", f"_sym_{func_t._ir_info.exit_sequence_label}"]
 
     if context.return_type is None:
         if stmt.value is not None:
             return None  # triggers an exception
 
     else:
         # sanity typecheck
         check_assign(dummy_node_for_type(context.return_type), ir_val)
 
     # helper function
     # do NOT bypass this. jump_to_exit may do important function cleanup.
     def finalize(fill_return_buffer):
         fill_return_buffer = IRnode.from_list(
-            fill_return_buffer, annotation=f"fill return buffer {sig._ir_identifier}"
+            fill_return_buffer, annotation=f"fill return buffer {func_t._ir_info.ir_identifier}"
         )
         cleanup_loops = "cleanup_repeat" if context.forvars else "seq"
         # NOTE: because stack analysis is incomplete, cleanup_repeat must
         # come after fill_return_buffer otherwise the stack will break
         return IRnode.from_list(["seq", fill_return_buffer, cleanup_loops, jump_to_exit])
 
     if context.return_type is None:
@@ -51,15 +50,14 @@
         dst = IRnode.from_list(["return_buffer"], typ=context.return_type, location=MEMORY)
         fill_return_buffer = make_setter(dst, ir_val)
         jump_to_exit += ["return_pc"]
 
         return finalize(fill_return_buffer)
 
     else:  # return from external function
-
         external_return_type = calculate_type_for_external_return(context.return_type)
         maxlen = external_return_type.abi_type.size_bound()
 
         # optimize: if the value already happens to be ABI encoded in
         # memory, don't bother running abi_encode, just return the
         # buffer it is in.
         can_skip_encode = (
```

### Comparing `vyper-0.3.7/vyper/codegen/stmt.py` & `vyper-0.3.8/vyper/codegen/stmt.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,35 +1,36 @@
 import vyper.codegen.events as events
 import vyper.utils as util
 from vyper import ast as vy_ast
-from vyper.address_space import MEMORY, STORAGE
-from vyper.builtin_functions import STMT_DISPATCH_TABLE
+from vyper.builtins.functions import STMT_DISPATCH_TABLE
 from vyper.codegen import external_call, self_call
 from vyper.codegen.context import Constancy, Context
 from vyper.codegen.core import (
     LOAD,
     STORE,
     IRnode,
     append_dyn_array,
     check_assign,
+    clamp,
     dummy_node_for_type,
     get_dyn_array_count,
     get_element_ptr,
     getpos,
     is_return_from_function,
     make_byte_array_copier,
     make_setter,
     pop_dyn_array,
     zero_pad,
 )
 from vyper.codegen.expr import Expr
 from vyper.codegen.return_ import make_return_stmt
-from vyper.codegen.types import BaseType, ByteArrayType, DArrayType
-from vyper.codegen.types.convert import new_type_to_old_type
+from vyper.evm.address_space import MEMORY, STORAGE
 from vyper.exceptions import CompilerPanic, StructureException, TypeCheckFailure
+from vyper.semantics.types import DArrayT, MemberFunctionT
+from vyper.semantics.types.shortcuts import INT256_T, UINT256_T
 
 
 class Stmt:
     def __init__(self, node: vy_ast.VyperNode, context: Context) -> None:
         self.stmt = node
         self.context = context
         fn = getattr(self, f"parse_{type(node).__name__}", None)
@@ -55,47 +56,43 @@
     def parse_Name(self):
         if self.stmt.id == "vdb":
             return IRnode("debugger")
         else:
             raise StructureException(f"Unsupported statement type: {type(self.stmt)}", self.stmt)
 
     def parse_AnnAssign(self):
-        typ = self.context.parse_type(self.stmt.annotation)
+        ltyp = self.stmt.target._metadata["type"]
         varname = self.stmt.target.id
-        pos = self.context.new_variable(varname, typ)
-        if self.stmt.value is None:
-            return
-
-        sub = Expr(self.stmt.value, self.context).ir_node
-
-        is_literal_bytes32_assign = (
-            isinstance(sub.typ, ByteArrayType)
-            and sub.typ.maxlen == 32
-            and isinstance(typ, BaseType)
-            and typ.typ == "bytes32"
-            and sub.typ.is_literal
-        )
-
-        # If bytes[32] to bytes32 assignment rewrite sub as bytes32.
-        if is_literal_bytes32_assign:
-            sub = IRnode(util.bytes_to_int(self.stmt.value.s), typ=BaseType("bytes32"))
+        alloced = self.context.new_variable(varname, ltyp)
 
-        variable_loc = IRnode.from_list(pos, typ=typ, location=MEMORY)
+        assert self.stmt.value is not None
+        rhs = Expr(self.stmt.value, self.context).ir_node
 
-        ir_node = make_setter(variable_loc, sub)
+        lhs = IRnode.from_list(alloced, typ=ltyp, location=MEMORY)
 
-        return ir_node
+        return make_setter(lhs, rhs)
 
     def parse_Assign(self):
         # Assignment (e.g. x[4] = y)
-        sub = Expr(self.stmt.value, self.context).ir_node
-        target = self._get_target(self.stmt.target)
+        src = Expr(self.stmt.value, self.context).ir_node
+        dst = self._get_target(self.stmt.target)
 
-        ir_node = make_setter(target, sub)
-        return ir_node
+        ret = ["seq"]
+        overlap = len(dst.referenced_variables & src.referenced_variables) > 0
+        if overlap and not dst.typ._is_prim_word:
+            # there is overlap between the lhs and rhs, and the type is
+            # complex - i.e., it spans multiple words. for safety, we
+            # copy to a temporary buffer before copying to the destination.
+            tmp = self.context.new_internal_variable(src.typ)
+            tmp = IRnode.from_list(tmp, typ=src.typ, location=MEMORY)
+            ret.append(make_setter(tmp, src))
+            src = tmp
+
+        ret.append(make_setter(dst, src))
+        return IRnode.from_list(ret)
 
     def parse_If(self):
         if self.stmt.orelse:
             with self.context.block_scope():
                 add_on = [parse_body(self.stmt.orelse, self.context)]
         else:
             add_on = []
@@ -134,39 +131,48 @@
             funcname = self.stmt.func.id
             return STMT_DISPATCH_TABLE[funcname].build_IR(self.stmt, self.context)
 
         elif isinstance(self.stmt.func, vy_ast.Attribute) and self.stmt.func.attr in (
             "append",
             "pop",
         ):
-            # TODO: consider moving this to builtins
-            darray = Expr(self.stmt.func.value, self.context).ir_node
-            args = [Expr(x, self.context).ir_node for x in self.stmt.args]
-            if self.stmt.func.attr == "append":
-                # sanity checks
-                assert len(args) == 1
-                arg = args[0]
-                assert isinstance(darray.typ, DArrayType)
-                check_assign(dummy_node_for_type(darray.typ.subtype), dummy_node_for_type(arg.typ))
-
-                return append_dyn_array(darray, arg)
-            else:
-                assert len(args) == 0
-                return pop_dyn_array(darray, return_popped_item=False)
+            func_type = self.stmt.func._metadata["type"]
+            if isinstance(func_type, MemberFunctionT):
+                darray = Expr(self.stmt.func.value, self.context).ir_node
+                args = [Expr(x, self.context).ir_node for x in self.stmt.args]
+                if self.stmt.func.attr == "append":
+                    # sanity checks
+                    assert len(args) == 1
+                    arg = args[0]
+                    assert isinstance(darray.typ, DArrayT)
+                    check_assign(
+                        dummy_node_for_type(darray.typ.value_type), dummy_node_for_type(arg.typ)
+                    )
+
+                    return append_dyn_array(darray, arg)
+                else:
+                    assert len(args) == 0
+                    return pop_dyn_array(darray, return_popped_item=False)
 
-        elif is_self_function:
+        if is_self_function:
             return self_call.ir_for_self_call(self.stmt, self.context)
         else:
             return external_call.ir_for_external_call(self.stmt, self.context)
 
     def _assert_reason(self, test_expr, msg):
+        # from parse_Raise: None passed as the assert condition
+        is_raise = test_expr is None
+
         if isinstance(msg, vy_ast.Name) and msg.id == "UNREACHABLE":
-            return IRnode.from_list(
-                ["assert_unreachable", test_expr], error_msg="assert unreachable"
-            )
+            if is_raise:
+                return IRnode.from_list(["invalid"], error_msg="raise unreachable")
+            else:
+                return IRnode.from_list(
+                    ["assert_unreachable", test_expr], error_msg="assert unreachable"
+                )
 
         # set constant so that revert reason str is well behaved
         try:
             tmp = self.context.constancy
             self.context.constancy = Constancy.Constant
             msg_ir = Expr(msg, self.context).ir_node
         finally:
@@ -186,35 +192,33 @@
         else:
             buf = _get_last(msg_ir)
             if not isinstance(buf, int):
                 raise CompilerPanic(f"invalid bytestring {buf}\n{self}")
             instantiate_msg = msg_ir
 
         # offset of bytes in (bytes,)
-        method_id = util.abi_method_id("Error(string)")
+        method_id = util.method_id_int("Error(string)")
 
         # abi encode method_id + bytestring
         assert buf >= 36, "invalid buffer"
         # we don't mind overwriting other memory because we are
         # getting out of here anyway.
         _runtime_length = ["mload", buf]
         revert_seq = [
             "seq",
             instantiate_msg,
             zero_pad(buf),
             ["mstore", buf - 64, method_id],
             ["mstore", buf - 32, 0x20],
             ["revert", buf - 36, ["add", 4 + 32 + 32, ["ceil32", _runtime_length]]],
         ]
-
-        if test_expr is not None:
-            ir_node = ["if", ["iszero", test_expr], revert_seq]
-        else:
+        if is_raise:
             ir_node = revert_seq
-
+        else:
+            ir_node = ["if", ["iszero", test_expr], revert_seq]
         return IRnode.from_list(ir_node, error_msg="user revert with reason")
 
     def parse_Assert(self):
         test_expr = Expr.parse_value_expr(self.stmt.test, self.context)
 
         if self.stmt.msg:
             return self._assert_reason(test_expr, self.stmt.msg)
@@ -240,51 +244,52 @@
         with self.context.block_scope():
             if self.stmt.get("iter.func.id") == "range":
                 return self._parse_For_range()
             else:
                 return self._parse_For_list()
 
     def _parse_For_range(self):
-        # attempt to use the type specified by type checking, fall back to `int256`
-        # this is a stopgap solution to allow uint256 - it will be properly solved
-        # once we refactor type system
-        iter_typ = "int256"
+        # TODO make sure type always gets annotated
         if "type" in self.stmt.target._metadata:
-            iter_typ = self.stmt.target._metadata["type"]._id
+            iter_typ = self.stmt.target._metadata["type"]
+        else:
+            iter_typ = INT256_T
 
         # Get arg0
         arg0 = self.stmt.iter.args[0]
         num_of_args = len(self.stmt.iter.args)
 
         # Type 1 for, e.g. for i in range(10): ...
         if num_of_args == 1:
             arg0_val = self._get_range_const_value(arg0)
             start = IRnode.from_list(0, typ=iter_typ)
             rounds = arg0_val
 
         # Type 2 for, e.g. for i in range(100, 110): ...
-        elif self._check_valid_range_constant(self.stmt.iter.args[1]).typ.is_literal:
+        elif self._check_valid_range_constant(self.stmt.iter.args[1]).is_literal:
             arg0_val = self._get_range_const_value(arg0)
             arg1_val = self._get_range_const_value(self.stmt.iter.args[1])
             start = IRnode.from_list(arg0_val, typ=iter_typ)
             rounds = IRnode.from_list(arg1_val - arg0_val, typ=iter_typ)
 
         # Type 3 for, e.g. for i in range(x, x + 10): ...
         else:
             arg1 = self.stmt.iter.args[1]
             rounds = self._get_range_const_value(arg1.right)
             start = Expr.parse_value_expr(arg0, self.context)
+            _, hi = start.typ.int_bounds
+            start = clamp("le", start, hi + 1 - rounds)
 
         r = rounds if isinstance(rounds, int) else rounds.value
         if r < 1:
             return
 
         varname = self.stmt.target.id
-        i = IRnode.from_list(self.context.fresh_varname("range_ix"), typ="uint256")
-        iptr = self.context.new_variable(varname, BaseType(iter_typ))
+        i = IRnode.from_list(self.context.fresh_varname("range_ix"), typ=UINT256_T)
+        iptr = self.context.new_variable(varname, iter_typ)
 
         self.context.forvars[varname] = True
 
         loop_body = ["seq"]
         # store the current value of i so it is accessible to userland
         loop_body.append(["mstore", iptr, i])
         loop_body.append(parse_body(self.stmt.body, self.context))
@@ -295,25 +300,25 @@
         return ir_node
 
     def _parse_For_list(self):
         with self.context.range_scope():
             iter_list = Expr(self.stmt.iter, self.context).ir_node
 
         # override with type inferred at typechecking time
-        # TODO investigate why stmt.target.type != stmt.iter.type.subtype
-        target_type = new_type_to_old_type(self.stmt.target._metadata["type"])
-        iter_list.typ.subtype = target_type
+        # TODO investigate why stmt.target.type != stmt.iter.type.value_type
+        target_type = self.stmt.target._metadata["type"]
+        iter_list.typ.value_type = target_type
 
         # user-supplied name for loop variable
         varname = self.stmt.target.id
         loop_var = IRnode.from_list(
             self.context.new_variable(varname, target_type), typ=target_type, location=MEMORY
         )
 
-        i = IRnode.from_list(self.context.fresh_varname("for_list_ix"), typ="uint256")
+        i = IRnode.from_list(self.context.fresh_varname("for_list_ix"), typ=UINT256_T)
 
         self.context.forvars[varname] = True
 
         ret = ["seq"]
 
         # list literal, force it to memory first
         if isinstance(self.stmt.iter, vy_ast.List):
@@ -326,28 +331,32 @@
             iter_list = tmp_list
 
         # set up the loop variable
         e = get_element_ptr(iter_list, i, array_bounds_check=False)
         body = ["seq", make_setter(loop_var, e), parse_body(self.stmt.body, self.context)]
 
         repeat_bound = iter_list.typ.count
-        if isinstance(iter_list.typ, DArrayType):
+        if isinstance(iter_list.typ, DArrayT):
             array_len = get_dyn_array_count(iter_list)
         else:
             array_len = repeat_bound
 
         ret.append(["repeat", i, 0, array_len, repeat_bound, body])
 
         del self.context.forvars[varname]
         return IRnode.from_list(ret)
 
     def parse_AugAssign(self):
         target = self._get_target(self.stmt.target)
+
         sub = Expr.parse_value_expr(self.stmt.value, self.context)
-        if not isinstance(target.typ, BaseType):
+        if not target.typ._is_prim_word:
+            # because of this check, we do not need to check for
+            # make_setter references lhs<->rhs as in parse_Assign -
+            # single word load/stores are atomic.
             return
 
         with target.cache_when_complex("_loc") as (b, target):
             rhs = Expr.parse_value_expr(
                 vy_ast.BinOp(
                     left=IRnode.from_list(LOAD(target), typ=target.typ),
                     right=sub,
```

### Comparing `vyper-0.3.7/vyper/compiler/README.md` & `vyper-0.3.8/vyper/compiler/README.md`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/vyper/compiler/__init__.py` & `vyper-0.3.8/vyper/compiler/__init__.py`

 * *Files 1% similar despite different names*

```diff
@@ -32,14 +32,15 @@
     "ir_runtime_dict": output.build_ir_runtime_dict_output,
     "method_identifiers": output.build_method_identifiers_output,
     "metadata": output.build_metadata_output,
     # requires assembly
     "abi": output.build_abi_output,
     "asm": output.build_asm_output,
     "source_map": output.build_source_map_output,
+    "source_map_full": output.build_source_map_output,
     # requires bytecode
     "bytecode": output.build_bytecode_output,
     "bytecode_runtime": output.build_bytecode_runtime_output,
     "blueprint_bytecode": output.build_blueprint_bytecode_output,
     "opcodes": output.build_opcodes_output,
     "opcodes_runtime": output.build_opcodes_runtime_output,
 }
```

### Comparing `vyper-0.3.7/vyper/compiler/output.py` & `vyper-0.3.8/vyper/compiler/output.py`

 * *Files 8% similar despite different names*

```diff
@@ -31,21 +31,24 @@
 def build_userdoc(compiler_data: CompilerData) -> dict:
     userdoc, devdoc = parse_natspec(compiler_data.vyper_module_folded)
     return userdoc
 
 
 def build_external_interface_output(compiler_data: CompilerData) -> str:
     interface = compiler_data.vyper_module_folded._metadata["type"]
-    name = Path(compiler_data.contract_name).stem.capitalize()
+    stem = Path(compiler_data.contract_name).stem
+    # capitalize words separated by '_'
+    # ex: test_interface.vy -> TestInterface
+    name = "".join([x.capitalize() for x in stem.split("_")])
     out = f"\n# External Interfaces\ninterface {name}:\n"
 
-    for func in interface.members.values():
+    for func in interface.functions.values():
         if func.visibility == FunctionVisibility.INTERNAL or func.name == "__init__":
             continue
-        args = ", ".join([f"{name}: {typ}" for name, typ in func.arguments.items()])
+        args = ", ".join([f"{arg.name}: {arg.typ}" for arg in func.arguments])
         return_value = f" -> {func.return_type}" if func.return_type is not None else ""
         mutability = func.mutability.value
         out = f"{out}    def {func.name}({args}){return_value}: {mutability}\n"
 
     return out
 
 
@@ -55,22 +58,22 @@
 
     if interface.events:
         out = "# Events\n\n"
         for event in interface.events.values():
             encoded_args = "\n    ".join(f"{name}: {typ}" for name, typ in event.arguments.items())
             out = f"{out}event {event.name}:\n    {encoded_args if event.arguments else 'pass'}\n"
 
-    if interface.members:
+    if interface.functions:
         out = f"{out}\n# Functions\n\n"
-        for func in interface.members.values():
+        for func in interface.functions.values():
             if func.visibility == FunctionVisibility.INTERNAL or func.name == "__init__":
                 continue
             if func.mutability != StateMutability.NONPAYABLE:
                 out = f"{out}@{func.mutability.value}\n"
-            args = ", ".join([f"{name}: {typ}" for name, typ in func.arguments.items()])
+            args = ", ".join([f"{arg.name}: {arg.typ}" for arg in func.arguments])
             return_value = f" -> {func.return_type}" if func.return_type is not None else ""
             out = f"{out}@external\ndef {func.name}({args}){return_value}:\n    pass\n\n"
 
     return out
 
 
 def build_ir_output(compiler_data: CompilerData) -> IRnode:
@@ -110,43 +113,61 @@
         if ret["data_offset"] is None:
             del ret["data_offset"]
         for k in ("blockscopes", "defined_at", "encoding"):
             del ret[k]
         ret["location"] = ret["location"].name
         return ret
 
-    def _to_dict(sig):
-        ret = vars(sig)
+    def _to_dict(func_t):
+        ret = vars(func_t)
         ret["return_type"] = str(ret["return_type"])
-        ret["_ir_identifier"] = sig._ir_identifier
-        for attr in ("gas_estimate", "func_ast_code"):
-            del ret[attr]
-        for attr in ("args", "base_args", "default_args"):
-            if attr in ret:
-                ret[attr] = {arg.name: str(arg.typ) for arg in ret[attr]}
-        for k in ret["default_values"]:
-            # e.g. {"x": vy_ast.Int(..)} -> {"x": 1}
-            ret["default_values"][k] = ret["default_values"][k].node_source_code
-        ret["frame_info"] = vars(ret["frame_info"])
-        for k in ret["frame_info"]["frame_vars"].keys():
-            ret["frame_info"]["frame_vars"][k] = _var_rec_dict(ret["frame_info"]["frame_vars"][k])
+        ret["_ir_identifier"] = func_t._ir_info.ir_identifier
+
+        for attr in ("mutability", "visibility"):
+            ret[attr] = ret[attr].name.lower()
+
+        # e.g. {"x": vy_ast.Int(..)} -> {"x": 1}
+        ret["default_values"] = {
+            k: val.node_source_code for k, val in func_t.default_values.items()
+        }
+
+        for attr in ("positional_args", "keyword_args"):
+            args = ret[attr]
+            ret[attr] = {arg.name: str(arg.typ) for arg in args}
+
+        ret["frame_info"] = vars(func_t._ir_info.frame_info)
+        del ret["frame_info"]["frame_vars"]  # frame_var.pos might be IR, cannot serialize
+
+        keep_keys = {
+            "name",
+            "return_type",
+            "positional_args",
+            "keyword_args",
+            "default_values",
+            "frame_info",
+            "mutability",
+            "visibility",
+            "_ir_identifier",
+            "nonreentrant_key",
+        }
+        ret = {k: v for k, v in ret.items() if k in keep_keys}
         return ret
 
     return {"function_info": {name: _to_dict(sig) for (name, sig) in sigs.items()}}
 
 
 def build_method_identifiers_output(compiler_data: CompilerData) -> dict:
     interface = compiler_data.vyper_module_folded._metadata["type"]
-    functions = interface.members.values()
+    functions = interface.functions.values()
 
     return {k: hex(v) for func in functions for k, v in func.method_ids.items()}
 
 
 def build_abi_output(compiler_data: CompilerData) -> list:
-    abi = compiler_data.vyper_module_folded._metadata["type"].to_abi_dict()
+    abi = compiler_data.vyper_module_folded._metadata["type"].to_toplevel_abi_dict()
     if compiler_data.show_gas_estimates:
         # Add gas estimates for each function to ABI
         gas_estimates = build_gas_estimates(compiler_data.function_signatures)
         for func in abi:
             try:
                 func_signature = func["name"]
             except KeyError:
@@ -170,29 +191,28 @@
     return compiler_data.storage_layout
 
 
 def _build_asm(asm_list):
     output_string = ""
     in_push = 0
     for node in asm_list:
-
         if isinstance(node, list):
             output_string += "{ " + _build_asm(node) + "} "
             continue
 
         if in_push > 0:
             assert isinstance(node, int), node
             output_string += hex(node)[2:].rjust(2, "0")
             if in_push == 1:
                 output_string += " "
             in_push -= 1
         else:
             output_string += str(node) + " "
 
-            if isinstance(node, str) and node.startswith("PUSH"):
+            if isinstance(node, str) and node.startswith("PUSH") and node != "PUSH0":
                 assert in_push == 0
                 in_push = int(node[4:])
                 output_string += "0x"
 
     return output_string
 
 
@@ -246,15 +266,15 @@
 
 
 def build_blueprint_bytecode_output(compiler_data: CompilerData) -> str:
     return f"0x{compiler_data.blueprint_bytecode.hex()}"
 
 
 # EIP-170. Ref: https://eips.ethereum.org/EIPS/eip-170
-EIP170_CONTRACT_SIZE_LIMIT: int = 2 ** 14 + 2 ** 13
+EIP170_CONTRACT_SIZE_LIMIT: int = 2**14 + 2**13
 
 
 def build_bytecode_runtime_output(compiler_data: CompilerData) -> str:
     compiled_bytecode_runtime_length = len(compiler_data.bytecode_runtime)
     if compiled_bytecode_runtime_length > EIP170_CONTRACT_SIZE_LIMIT:
         warnings.warn(
             f"Length of compiled bytecode is bigger than Ethereum contract size limit "
@@ -279,13 +299,13 @@
 
     opcode_map = dict((v[0], k) for k, v in opcodes.get_opcodes().items())
     opcode_output = []
 
     while bytecode_sequence:
         op = bytecode_sequence.popleft()
         opcode_output.append(opcode_map[op])
-        if "PUSH" in opcode_output[-1]:
+        if "PUSH" in opcode_output[-1] and opcode_output[-1] != "PUSH0":
             push_len = int(opcode_map[op][4:])
             push_values = [hex(bytecode_sequence.popleft())[2:] for i in range(push_len)]
             opcode_output.append(f"0x{''.join(push_values).upper()}")
 
     return " ".join(opcode_output)
```

### Comparing `vyper-0.3.7/vyper/compiler/phases.py` & `vyper-0.3.8/vyper/compiler/phases.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,20 +1,20 @@
 import copy
 import warnings
+from functools import cached_property
 from typing import Optional, Tuple
 
 from vyper import ast as vy_ast
-from vyper.ast.signatures.function_signature import FunctionSignatures
 from vyper.codegen import module
 from vyper.codegen.global_context import GlobalContext
 from vyper.codegen.ir_node import IRnode
 from vyper.ir import compile_ir, optimizer
 from vyper.semantics import set_data_positions, validate_semantics
+from vyper.semantics.types.function import ContractFunctionT
 from vyper.typing import InterfaceImports, StorageLayout
-from vyper.utils import cached_property
 
 
 class CompilerData:
     """
     Object for fetching and storing compiler data for a Vyper contract.
 
     This object acts as a wrapper over the pure compiler functions, triggering
@@ -110,35 +110,39 @@
     @property
     def storage_layout(self) -> StorageLayout:
         module, storage_layout = self._folded_module
         return storage_layout
 
     @property
     def global_ctx(self) -> GlobalContext:
-        return generate_global_context(self.vyper_module_folded, self.interface_codes)
+        return GlobalContext(self.vyper_module_folded)
 
     @cached_property
     def _ir_output(self):
         # fetch both deployment and runtime IR
         return generate_ir_nodes(self.global_ctx, self.no_optimize)
 
     @property
     def ir_nodes(self) -> IRnode:
-        ir, ir_runtime, sigs = self._ir_output
+        ir, ir_runtime = self._ir_output
         return ir
 
     @property
     def ir_runtime(self) -> IRnode:
-        ir, ir_runtime, sigs = self._ir_output
+        ir, ir_runtime = self._ir_output
         return ir_runtime
 
     @property
-    def function_signatures(self) -> FunctionSignatures:
-        ir, ir_runtime, sigs = self._ir_output
-        return sigs
+    def function_signatures(self) -> dict[str, ContractFunctionT]:
+        # some metadata gets calculated during codegen, so
+        # ensure codegen is run:
+        _ = self._ir_output
+
+        fs = self.vyper_module_folded.get_children(vy_ast.FunctionDef)
+        return {f.name: f._metadata["type"] for f in fs}
 
     @cached_property
     def assembly(self) -> list:
         return generate_assembly(self.ir_nodes, self.no_optimize)
 
     @cached_property
     def assembly_runtime(self) -> list:
@@ -188,15 +192,14 @@
     """
     return vy_ast.parse_to_ast(source_code, source_id, contract_name)
 
 
 def generate_unfolded_ast(
     vyper_module: vy_ast.Module, interface_codes: Optional[InterfaceImports]
 ) -> vy_ast.Module:
-
     vy_ast.validation.validate_literal_nodes(vyper_module)
     vy_ast.folding.replace_builtin_constants(vyper_module)
     vy_ast.folding.replace_builtin_functions(vyper_module)
     # note: validate_semantics does type inference on the AST
     validate_semantics(vyper_module, interface_codes)
 
     return vyper_module
@@ -229,38 +232,15 @@
     validate_semantics(vyper_module_folded, interface_codes)
     vy_ast.expansion.expand_annotated_ast(vyper_module_folded)
     symbol_tables = set_data_positions(vyper_module_folded, storage_layout_overrides)
 
     return vyper_module_folded, symbol_tables
 
 
-def generate_global_context(
-    vyper_module: vy_ast.Module, interface_codes: Optional[InterfaceImports]
-) -> GlobalContext:
-    """
-    Generate a contextualized AST from the Vyper AST.
-
-    Arguments
-    ---------
-    vyper_module : vy_ast.Module
-        Top-level Vyper AST node
-    interface_codes: Dict, optional
-        Interfaces that may be imported by the contracts.
-
-    Returns
-    -------
-    GlobalContext
-        Sorted, contextualized representation of the Vyper AST
-    """
-    return GlobalContext.get_global_context(vyper_module, interface_codes=interface_codes)
-
-
-def generate_ir_nodes(
-    global_ctx: GlobalContext, no_optimize: bool
-) -> Tuple[IRnode, IRnode, FunctionSignatures]:
+def generate_ir_nodes(global_ctx: GlobalContext, no_optimize: bool) -> tuple[IRnode, IRnode]:
     """
     Generate the intermediate representation (IR) from the contextualized AST.
 
     This phase also includes IR-level optimizations.
 
     This function returns three values: deployment bytecode, runtime bytecode
     and the function signatures of the contract
@@ -272,19 +252,19 @@
 
     Returns
     -------
     (IRnode, IRnode)
         IR to generate deployment bytecode
         IR to generate runtime bytecode
     """
-    ir_nodes, ir_runtime, function_sigs = module.generate_ir_for_module(global_ctx)
+    ir_nodes, ir_runtime = module.generate_ir_for_module(global_ctx)
     if not no_optimize:
         ir_nodes = optimizer.optimize(ir_nodes)
         ir_runtime = optimizer.optimize(ir_runtime)
-    return ir_nodes, ir_runtime, function_sigs
+    return ir_nodes, ir_runtime
 
 
 def generate_assembly(ir_nodes: IRnode, no_optimize: bool = False) -> list:
     """
     Generate assembly instructions from IR.
 
     Arguments
```

### Comparing `vyper-0.3.7/vyper/evm/opcodes.py` & `vyper-0.3.8/vyper/evm/opcodes.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,39 +1,40 @@
 from typing import Dict, Optional
 
 from vyper.exceptions import CompilerPanic
 from vyper.typing import OpcodeGasCost, OpcodeMap, OpcodeRulesetMap, OpcodeRulesetValue, OpcodeValue
 
-active_evm_version: int = 4
-
 # EVM version rules work as follows:
 # 1. Fork rules go from oldest (lowest value) to newest (highest value).
 # 2. Fork versions aren't actually tied to anything. They are not a part of our
 #    official API. *DO NOT USE THE VALUES FOR ANYTHING IMPORTANT* besides versioning.
 # 3. When support for an older version is dropped, the numbers should *not* change to
 #    reflect it (i.e. dropping support for version 0 removes version 0 entirely).
 # 4. There can be multiple aliases to the same version number (but not the reverse).
 # 5. When supporting multiple chains, if a chain gets a fix first, it increments the
 #    number first.
 # 6. Yes, this will probably have to be rethought if there's ever conflicting support
 #    between multiple chains for a specific feature. Let's hope not.
 # 7. We support at a maximum 3 hard forks (for any given chain).
-EVM_VERSIONS: Dict[str, int] = {
+EVM_VERSIONS: dict[str, int] = {
     # ETH Forks
     "byzantium": 0,
     "constantinople": 1,
     "petersburg": 1,
     "istanbul": 2,
     "berlin": 3,
     "paris": 4,
+    "shanghai": 5,
+    "cancun": 6,
     # ETC Forks
     "atlantis": 0,
     "agharta": 1,
 }
-DEFAULT_EVM_VERSION: str = "paris"
+DEFAULT_EVM_VERSION: str = "shanghai"
+active_evm_version: int = EVM_VERSIONS[DEFAULT_EVM_VERSION]
 
 
 # opcode as hex value
 # number of values removed from stack
 # number of values added to stack
 # gas cost (byzantium, constantinople, istanbul, berlin)
 OPCODES: OpcodeMap = {
@@ -98,14 +99,15 @@
     "SSTORE": (0x55, 2, 0, 20000),
     "JUMP": (0x56, 1, 0, 8),
     "JUMPI": (0x57, 2, 0, 10),
     "PC": (0x58, 0, 1, 2),
     "MSIZE": (0x59, 0, 1, 2),
     "GAS": (0x5A, 0, 1, 2),
     "JUMPDEST": (0x5B, 0, 0, 1),
+    "PUSH0": (0x5F, 0, 1, 2),
     "PUSH1": (0x60, 0, 1, 3),
     "PUSH2": (0x61, 0, 1, 3),
     "PUSH3": (0x62, 0, 1, 3),
     "PUSH4": (0x63, 0, 1, 3),
     "PUSH5": (0x64, 0, 1, 3),
     "PUSH6": (0x65, 0, 1, 3),
     "PUSH7": (0x66, 0, 1, 3),
@@ -179,14 +181,16 @@
     "CREATE2": (0xF5, 4, 1, (None, 32000)),
     "SELFDESTRUCT": (0xFF, 1, 0, 25000),
     "STATICCALL": (0xFA, 6, 1, (700, 700, 700, 2100)),
     "REVERT": (0xFD, 2, 0, 0),
     "INVALID": (0xFE, 0, 0, 0),
     "DEBUG": (0xA5, 1, 0, 0),
     "BREAKPOINT": (0xA6, 0, 0, 0),
+    "TLOAD": (0xB3, 1, 1, 100),
+    "TSTORE": (0xB4, 2, 0, 100),
 }
 
 PSEUDO_OPCODES: OpcodeMap = {
     "CLAMP": (None, 3, 1, 70),
     "UCLAMPLT": (None, 2, 1, 25),
     "UCLAMPLE": (None, 2, 1, 30),
     "CLAMP_NONZERO": (None, 1, 1, 19),
```

### Comparing `vyper-0.3.7/vyper/exceptions.py` & `vyper-0.3.8/vyper/exceptions.py`

 * *Files 2% similar despite different names*

```diff
@@ -18,15 +18,15 @@
             raise self[0]
         elif len(self) > 1:
             err_msg = ["Compilation failed with the following errors:"]
             err_msg += [f"{type(i).__name__}: {i}" for i in reversed(self)]
             raise VyperException("\n\n".join(err_msg))
 
 
-class VyperException(Exception):
+class _BaseVyperException(Exception):
     """
     Base Vyper exception class.
 
     This exception is not raised directly. Other exceptions inherit it in
     order to display source annotations in the error string.
     """
 
@@ -121,14 +121,18 @@
             node_msg = textwrap.indent(node_msg, "  ")
             annotation_list.append(node_msg)
 
         annotation_msg = "\n".join(annotation_list)
         return f"{self.message}\n{annotation_msg}"
 
 
+class VyperException(_BaseVyperException):
+    pass
+
+
 class SyntaxException(VyperException):
 
     """Invalid syntax."""
 
     def __init__(self, message, source_code, lineno, col_offset):
         item = types.SimpleNamespace()  # TODO: Create an actual object for this
         item.lineno = lineno
@@ -147,14 +151,18 @@
     """Invalid syntax within NatSpec docstring."""
 
 
 class StructureException(VyperException):
     """Invalid structure for parsable syntax."""
 
 
+class InstantiationException(StructureException):
+    """Variable or expression cannot be instantiated"""
+
+
 class VersionException(VyperException):
     """Version string is malformed or incompatible with this compiler version."""
 
 
 class VariableDeclarationException(VyperException):
     """Invalid variable declaration."""
 
@@ -277,28 +285,25 @@
     """Some feature is known to be not implemented"""
 
 
 class StaticAssertionException(VyperException):
     """An assertion is proven to fail at compile-time."""
 
 
-class VyperInternalException(Exception):
+class VyperInternalException(_BaseVyperException):
     """
     Base Vyper internal exception class.
 
     This exception is not raised directly, it is subclassed by other internal
     exceptions.
 
     Internal exceptions are raised as a means of telling the user that the
     compiler has panicked, and that filing a bug report would be appropriate.
     """
 
-    def __init__(self, message=""):
-        self.message = message
-
     def __str__(self):
         return (
             f"{self.message}\n\nThis is an unhandled internal compiler error. "
             "Please create an issue on Github to notify the developers.\n"
             "https://github.com/vyperlang/vyper/issues/new?template=bug.md"
         )
```

### Comparing `vyper-0.3.7/vyper/ir/README.md` & `vyper-0.3.8/vyper/ir/README.md`

 * *Files 3% similar despite different names*

```diff
@@ -190,14 +190,18 @@
 ```
 
 Could compile to:
 ```
 _sym_foo JUMPDEST
 ```
 
+### UNIQUE\_SYMBOL
+
+`(unique_symbol l)` defines a "unique symbol". These are generated to help catch front-end bugs involving multiple execution of side-effects (which should be only executed once). They can be ignored, or to be strict, any backend should enforce that each `unique_symbol` only appears one time in the code.
+
 ### IF\_STMT
 
 Branching statements. There are two forms, if with a single branch, and if with two branches.
 
 Example:
 ```
 (if 1 stop)
```

### Comparing `vyper-0.3.7/vyper/ir/compile_ir.py` & `vyper-0.3.8/vyper/ir/compile_ir.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 import copy
 import functools
 import math
 
 from vyper.codegen.ir_node import IRnode
-from vyper.evm.opcodes import get_opcodes
+from vyper.evm.opcodes import get_opcodes, version_check
 from vyper.exceptions import CodegenPanic, CompilerPanic
 from vyper.utils import MemoryPositions
 from vyper.version import version_tuple
 
 PUSH_OFFSET = 0x5F
 DUP_OFFSET = 0x7F
 SWAP_OFFSET = 0x8F
@@ -19,15 +19,16 @@
         o.insert(0, x % 256)
         x //= 256
     return o
 
 
 def PUSH(x):
     bs = num_to_bytearray(x)
-    if len(bs) == 0:
+    # starting in shanghai, can do push0 directly with no immediates
+    if len(bs) == 0 and not version_check(begin="shanghai"):
         bs = [0]
     return [f"PUSH{len(bs)}"] + bs
 
 
 # push an exact number of bytes
 def PUSH_N(x, n):
     o = []
@@ -145,15 +146,15 @@
 
 
 def _add_postambles(asm_ops):
     to_append = []
 
     global _revert_label
 
-    _revert_string = [_revert_label, "JUMPDEST", "PUSH1", 0, "DUP1", "REVERT"]
+    _revert_string = [_revert_label, "JUMPDEST", *PUSH(0), "DUP1", "REVERT"]
 
     if _revert_label in asm_ops:
         # shared failure block
         to_append.extend(_revert_string)
 
     if len(to_append) > 0:
         # for some reason there might not be a STOP at the end of asm_ops.
@@ -252,19 +253,19 @@
         for i, c in enumerate(code.args[::-1]):
             o.extend(_compile_to_assembly(c, withargs, existing_labels, break_dest, height + i))
         o.append(code.value.upper())
         return o
 
     # Numbers
     elif isinstance(code.value, int):
-        if code.value < -(2 ** 255):
+        if code.value < -(2**255):
             raise Exception(f"Value too low: {code.value}")
-        elif code.value >= 2 ** 256:
+        elif code.value >= 2**256:
             raise Exception(f"Value too high: {code.value}")
-        return PUSH(code.value % 2 ** 256)
+        return PUSH(code.value % 2**256)
 
     # Variables connected to with statements
     elif isinstance(code.value, str) and code.value in withargs:
         return ["DUP" + str(_height_of(code.value))]
 
     # Setting variables connected to with statements
     elif code.value == "set":
@@ -533,15 +534,15 @@
         o = []
         for arg in code.args:
             o.extend(_compile_to_assembly(arg, withargs, existing_labels, break_dest, height))
             if arg.valency == 1 and arg != code.args[-1]:
                 o.append("POP")
         return o
     # Seq without popping.
-    # Assure (if false, invalid opcode)
+    # unreachable keyword produces INVALID opcode
     elif code.value == "assert_unreachable":
         o = _compile_to_assembly(code.args[0], withargs, existing_labels, break_dest, height)
         end_symbol = mksymbol("reachable")
         o.extend([end_symbol, "JUMPI", "INVALID", end_symbol, "JUMPDEST"])
         return o
     # Assert (if false, exit)
     elif code.value == "assert":
@@ -551,41 +552,34 @@
         return o
 
     # SHA3 a single value
     elif code.value == "sha3_32":
         o = _compile_to_assembly(code.args[0], withargs, existing_labels, break_dest, height)
         o.extend(
             [
-                "PUSH1",
-                MemoryPositions.FREE_VAR_SPACE,
+                *PUSH(MemoryPositions.FREE_VAR_SPACE),
                 "MSTORE",
-                "PUSH1",
-                32,
-                "PUSH1",
-                MemoryPositions.FREE_VAR_SPACE,
+                *PUSH(32),
+                *PUSH(MemoryPositions.FREE_VAR_SPACE),
                 "SHA3",
             ]
         )
         return o
     # SHA3 a 64 byte value
     elif code.value == "sha3_64":
         o = _compile_to_assembly(code.args[0], withargs, existing_labels, break_dest, height)
         o.extend(_compile_to_assembly(code.args[1], withargs, existing_labels, break_dest, height))
         o.extend(
             [
-                "PUSH1",
-                MemoryPositions.FREE_VAR_SPACE2,
+                *PUSH(MemoryPositions.FREE_VAR_SPACE2),
                 "MSTORE",
-                "PUSH1",
-                MemoryPositions.FREE_VAR_SPACE,
+                *PUSH(MemoryPositions.FREE_VAR_SPACE),
                 "MSTORE",
-                "PUSH1",
-                64,
-                "PUSH1",
-                MemoryPositions.FREE_VAR_SPACE,
+                *PUSH(64),
+                *PUSH(MemoryPositions.FREE_VAR_SPACE),
                 "SHA3",
             ]
         )
         return o
     elif code.value == "select":
         # b ^ ((a ^ b) * cond) where cond is 1 or 0
         # let t = a ^ b
```

### Comparing `vyper-0.3.7/vyper/ir/optimizer.py` & `vyper-0.3.8/vyper/ir/optimizer.py`

 * *Files 2% similar despite different names*

```diff
@@ -27,15 +27,15 @@
     if isinstance(node.value, int):
         ret = node.value
     else:
         return None
 
     if unsigned and ret < 0:
         return signed_to_unsigned(ret, 256, strict=True)
-    elif not unsigned and ret > 2 ** 255 - 1:
+    elif not unsigned and ret > 2**255 - 1:
         return unsigned_to_signed(ret, 256, strict=True)
 
     return ret
 
 
 def _is_int(node: IRnode) -> bool:
     return isinstance(node.value, int)
@@ -74,14 +74,19 @@
 # quick typedefs, maybe move these to IRnode
 IRVal = Union[str, int]
 IRArgs = List[IRnode]
 
 
 COMMUTATIVE_OPS = {"add", "mul", "eq", "ne", "and", "or", "xor"}
 COMPARISON_OPS = {"gt", "sgt", "ge", "sge", "lt", "slt", "le", "sle"}
+STRICT_COMPARISON_OPS = {t for t in COMPARISON_OPS if t.endswith("t")}
+UNSTRICT_COMPARISON_OPS = {t for t in COMPARISON_OPS if t.endswith("e")}
+
+assert not (STRICT_COMPARISON_OPS & UNSTRICT_COMPARISON_OPS)
+assert STRICT_COMPARISON_OPS | UNSTRICT_COMPARISON_OPS == COMPARISON_OPS
 
 
 def _flip_comparison_op(opname):
     assert opname in COMPARISON_OPS
     if "g" in opname:
         return opname.replace("g", "l")
     if "l" in opname:
@@ -93,15 +98,15 @@
 def _shorten_annotation(annotation):
     if len(annotation) > 16:
         return annotation[:16] + "..."
     return annotation
 
 
 def _wrap256(x, unsigned=UNSIGNED):
-    x %= 2 ** 256
+    x %= 2**256
     # wrap in a signed way.
     if not unsigned:
         x = unsigned_to_signed(x, 256, strict=True)
     return x
 
 
 def _comparison_helper(binop, args, prefer_strict=False):
@@ -252,19 +257,23 @@
         args = [args[1], args[0]]
 
     if binop in {"add", "sub", "xor", "or"} and _int(args[1]) == 0:
         # x + 0 == x - 0 == x | 0 == x ^ 0 == x
         return finalize("seq", [args[0]])
 
     if binop in {"sub", "xor", "ne"} and _conservative_eq(args[0], args[1]):
-        # x - x == x ^ x == x != x == 0
+        # (x - x) == (x ^ x) == (x != x) == 0
+        return finalize(0, [])
+
+    if binop in STRICT_COMPARISON_OPS and _conservative_eq(args[0], args[1]):
+        # (x < x) == (x > x) == 0
         return finalize(0, [])
 
-    if binop == "eq" and _conservative_eq(args[0], args[1]):
-        # (x == x) == 1
+    if binop in {"eq"} | UNSTRICT_COMPARISON_OPS and _conservative_eq(args[0], args[1]):
+        # (x == x) == (x >= x) == (x <= x) == 1
         return finalize(1, [])
 
     # TODO associativity rules
 
     # x * 0 == x / 0 == x % 0 == x & 0 == 0
     if binop in {"mul", "div", "sdiv", "mod", "smod", "and"} and _int(args[1]) == 0:
         return finalize(0, [])
```

### Comparing `vyper-0.3.7/vyper/ir/s_expressions.py` & `vyper-0.3.8/vyper/ir/s_expressions.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/vyper/semantics/README.md` & `vyper-0.3.8/vyper/semantics/README.md`

 * *Files 18% similar despite different names*

```diff
@@ -6,74 +6,70 @@
 Vyper abstract syntax tree (AST).
 
 ## Organization
 
 `vyper.semantics` has the following structure:
 
 * [`types/`](types): Subpackage of classes and methods used to represent types
-  * [`types/indexable/`](types/indexable)
-    * [`mapping.py`](types/indexable/mapping.py): Mapping type
-    * [`sequence.py`](types/indexable/sequence.py): Array and Tuple types
-  * [`types/user/`](types/user)
-    * [`interface.py`](types/user/interface.py): Contract interface types and getter functions
-    * [`struct.py`](types/user/struct.py): Struct types and getter functions
-  * [`types/value/`](types/value)
-    * [`address.py`](types/value/address.py): Address type
-    * [`array_value.py`](types/value/array_value.py): Single-value subscript types (bytes, string)
-    * [`boolean.py`](types/value/boolean.py): Boolean type
-    * [`bytes_fixed.py`](types/value/bytes_fixed.py): Fixed length byte types
-    * [`numeric.py`](types/value/numeric.py): Integer and decimal types
-  * [`abstract.py`](types/abstract.py): Abstract data type classes
   * [`bases.py`](types/bases.py): Common base classes for all type objects
-  * [`event.py`](types/user/event.py): `Event` type class
-  * [`function.py`](types/function.py): `ContractFunction` type class
+  * [`bytestrings.py`](types/bytestrings.py): Single-value subscript types (bytes, string)
+  * [`function.py`](types/function.py): Contract function and member function types
+  * [`primitives.py`](types/primitives.py): Address, boolean, fixed length byte, integer and decimal types
+  * [`shortcuts.py`](types/shortcuts.py): Helper constants for commonly used types
+  * [`subscriptable.py`](types/subscriptable.py): Mapping, array and tuple types
+  * [`user.py`](types/user.py): Enum, event, interface and struct types
   * [`utils.py`](types/utils.py): Functions for generating and fetching type objects
-* [`validation/`](validation): Subpackage for type checking and syntax verification logic
-  * [`base.py`](validation/base.py): Base validation class
-  * [`local.py`](validation/local.py): Validates the local namespace of each function within a contract
-  * [`module.py`](validation/module.py): Validates the module namespace of a contract.
-  * [`utils.py`](validation/utils.py): Functions for comparing and validating types
+* [`analysis/`](analysis): Subpackage for type checking and syntax verification logic
+  * [`annotation.py`](analysis/annotation.py): Annotates statements and expressions with the appropriate type information
+  * [`base.py`](analysis/base.py): Base validation class
+  * [`common.py`](analysis/common.py): Base AST visitor class
+  * [`data_positions`](analysis/data_positions.py): Functions for tracking storage variables and allocating storage slots
+  * [`levenhtein_utils.py`](analysis/levenshtein_utils.py): Helper for better error messages
+  * [`local.py`](analysis/local.py): Validates the local namespace of each function within a contract
+  * [`module.py`](analysis/module.py): Validates the module namespace of a contract.
+  * [`utils.py`](analysis/utils.py): Functions for comparing and validating types
+* [`data_locations.py`](data_locations.py): `DataLocation` object for type location information
 * [`environment.py`](environment.py): Environment variables and builtin constants
 * [`namespace.py`](namespace.py): `Namespace` object, a `dict` subclass representing the namespace of a contract
 
 ## Control Flow
 
-The [`validation`](validation) subpackage contains the top-level `validate_semantics`
+The [`analysis`](analysis) subpackage contains the top-level `validate_semantics`
 function. This function is used to verify and type-check a contract. The process
 consists of three steps:
 
 1. Preparing the builtin namespace
 2. Validating the module-level scope
-3. Validating local scopes
+3. Annotating and validating local scopes
 
 ### 1. Preparing the builtin namespace
 
 The [`Namespace`](namespace.py) object represents the namespace for a contract.
 Builtins are added upon initialization of the object. This includes:
 
-* Adding primitive type classes from the [`types/`](types) subpackage
+* Adding type classes from the [`types/`](types) subpackage
 * Adding environment variables and builtin constants from [`environment.py`](environment.py)
-* Adding builtin functions from the [`functions`](../builtin_functions/functions.py) package
+* Adding builtin functions from the [`functions`](../builtins/functions.py) package
 * Adding / resetting `self` and `log`
 
 ### 2. Validating the Module Scope
 
 [`validation/module.py`](validation/module.py) validates the module-level scope
 of a contract. This includes:
 
 * Generating user-defined types (e.g. structs and interfaces)
 * Creating type definitions for storage variables, user-defined constants, events
 and functions
 * Validating import statements and function signatures
 
-### 3. Validating the Local Scopes
+### 3. Annotating and validating the Local Scopes
 
 [`validation/local.py`](validation/local.py) validates the local scope within each
 function in a contract. `FunctionNodeVisitor` is used to iterate over the statement
-nodes in each function body and apply appropriate checks.
+nodes in each function body, annotate them and apply appropriate checks.
 
 To learn more about the checks on each node type, read the docstrings on the methods
 of `FunctionNodeVisitor`.
 
 ## Design
 
 ### Type Checking
@@ -102,67 +98,28 @@
 4. The left-hand and right-hand types are compared and found to be matching.
 5. A new type definition `int128[2]` is added to the namespace with the name `foo`.
 
 ### Types Classes
 
 All type classes are found within the [`semantics/types/`](types) subpackage.
 
-Type classes rely on inheritance to define their structure and functionlity.
-Vyper uses three broad categories to represent types within the compiler.
-
-#### Primitive Types
-
-A **primitive type** (or just primitive) defines the base attributes of a given type.
-There is only one primitive type object created for each Vyper type. All primitive
-classes are subclasses of `BasePrimitive`.
-
-Along with the builtin primitive types, user-defined ones may be created. These
-primitives are defined in the modules within [`semantics/types/user`](types/user).
-See the docstrings there for more information.
-
-#### Type Definitions
-
-A **type definition** (or just definition) is a type that has been assigned to a
-specific variable, literal, or other value. Definition objects are typically derived
-from primitives. They include additional information such as the constancy,
-visibility and scope of the associated value.
-
-A primitive type always has a corresponding type definition. However, not all
-type definitions have a primitive type, e.g. arrays and tuples.
-
-Comparing a definition to it's related primitive type will always evaluate `True`.
-Comparing two definitions of the same class can sometimes evaluate false depending
-on certain attributes. All definition classes are subclasses of `BaseTypeDefinition`.
-
-Additionally, literal values sometimes have multiple _potential type definitions_.
-In this case, a membership check determines if the literal is valid by comparing
-the list of potential types against a specific type.
-
-#### Abstract Types
-
-An **abstract type** is an inherited class shared by two or more definition
-classes. Abstract types do not implement any functionality and may not be directly
-assigned to any values. They are used for broad type checking, in cases where
-e.g. a function expects any numeric value, or any bytes value. All abstract type
-classes are subclasses of `AbstractDataType`.
-
 ### Namespace
 
 [`namespace.py`](namespace.py) contains the `Namespace` object. `Namespace` is a
 `dict` subclass representing the namespace of a contract. It imposes several
 additional restrictions:
 
 * Attempting to replace an existing field raises `NamespaceCollision`
 * Attempting to access a key that does not exist raises `UndeclaredDefinition`
 
 To ensure that only one copy of `Namespace` exists throughout the package, you
 should access it using the `get_namespace` method:
 
 ```python
-from brownie.context.namespace import get_namespace
+from vyper.semantics.namespace import get_namespace
 
 namespace = get_namespace()
 ```
 
 #### Scoping and Namespace as a Context Manager
 
 Each smart contract in Vyper uses a unique namespace, and has three primary scopes:
@@ -186,65 +143,62 @@
 namespace['foo']  # this raises an UndeclaredDefinition
 ```
 
 ### Validation
 
 Validation is handled by calling methods within each type object. In general:
 
-* Primitive type objects include one or both of `from_annotation` and `from_literal`
-methods, which validate an AST node and a produce definition object
-* Definition objects include a variety of `get_<thing>` and `validate_<action>` methods,
+* Type objects include one or both of `from_annotation` and `from_literal`
+methods, which validate an AST node and produce a type object
+* Type objects include a variety of `get_<thing>` and `validate_<action>` methods,
 which are used to validate interactions and obtain new types based on AST nodes
 
-All possible methods for primitives and definitions are outlined within the base
+All possible methods for type objects are outlined within the base
 classes in [`types/bases.py`](types/bases.py). The functionality within the methods
 of the base classes is typically to raise and give a meaningful explanation
 for _why_ the syntax not valid.
 
 Here are some examples:
 
 #### 1. Declaring a Variable
 
 ```python
 foo: int128
 ```
 
-1. We look up `int128` in `namespace`. We retrieve an `Int128Primitive` object.
-2. We call `Int128Primitive.from_annotation` with the AST node of the statement. This
-method validates the statement and returns an `Int128Definition` object.
+1. We look up `int128` in `namespace`. We retrieve an `IntegerT` object.
 3. We store the new definition under the key `foo` within `namespace`.
 
 #### 2. Modifying the value of a variable
 
 ```python
 foo += 6
 ```
 
-1. We look up `foo` in `namespace` and retrieve the `Int128Definition`.
+1. We look up `foo` in `namespace` and retrieve an `IntegerT` with `_is_signed=True` and `_bits=128`.
 2. We call `get_potential_types_from_node` with the target node
 and are returned a list of types that are valid for the literal `6`. In this
-case, the list includes `Int128Definition`. The type check for the statement
-passes.
+case, the list includes an `IntegerT` with `_is_signed=True` and `_bits=128`. The type check for the statement passes.
 3. We call the `validate_modification` method on the definition object
 for `foo` to confirm that it is a value that may be modified (not a constant).
 4. Because the statement involves a mathematical operator, we also call the
-`validate_numeric_operation` method on `foo` to confirm that the operation is
+`validate_numeric_op` method on `foo` to confirm that the operation is
 allowed.
 
 #### 3. Calling a builtin function
 
 ```python
 bar: bytes32 = sha256(b"hash me!")
 ```
 
 1. We look up `sha256` in `namespace` and retrieve the definition for the builtin
 function.
 2. We call `fetch_call_return` on the function definition object, with the AST
 node representing the call. This method validates the input arguments, and returns
-a `Bytes32Definition`.
+a `BytesM_T` with `m=32`.
 3. We validation of the delcaration of `bar` in the same manner as the first
 example, and compare the generated type to that returned by `sha256`.
 
 ### Exceptions
 
 In general, the following list of exceptions is preferred for type-checking
 errors. When more than one reason applies, the earliest exception in the list
```

### Comparing `vyper-0.3.7/vyper/semantics/namespace.py` & `vyper-0.3.8/vyper/semantics/namespace.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,18 +1,17 @@
 import contextlib
 import re
 
-from vyper.evm.opcodes import OPCODES
 from vyper.exceptions import (
     CompilerPanic,
     NamespaceCollision,
     StructureException,
     UndeclaredDefinition,
 )
-from vyper.semantics.validation.levenshtein_utils import get_levenshtein_error_suggestions
+from vyper.semantics.analysis.levenshtein_utils import get_levenshtein_error_suggestions
 
 
 class Namespace(dict):
     """
     Dictionary subclass that represents the namespace of a contract.
 
     Attributes
@@ -21,29 +20,32 @@
         List of sets containing the key names for each scope
     """
 
     def __init__(self):
         super().__init__()
         self._scopes = []
         # NOTE cyclic imports!
-        from vyper.builtin_functions.functions import get_builtin_functions
+        # TODO: break this cycle by providing an `init_vyper_namespace` in 3rd module
+        from vyper.builtins.functions import get_builtin_functions
         from vyper.semantics import environment
-        from vyper.semantics.types import get_types
+        from vyper.semantics.analysis.base import VarInfo
+        from vyper.semantics.types import PRIMITIVE_TYPES
 
-        self.update(get_types())
+        self.update(PRIMITIVE_TYPES)
         self.update(environment.get_constant_vars())
-        self.update(get_builtin_functions())
+        self.update({k: VarInfo(b) for (k, b) in get_builtin_functions().items()})
 
     def __eq__(self, other):
         return self is other
 
     def __setitem__(self, attr, obj):
         if self._scopes:
             self.validate_assignment(attr)
             self._scopes[-1].add(attr)
+        assert isinstance(attr, str), f"not a string: {attr}"
         super().__setitem__(attr, obj)
 
     def __getitem__(self, key):
         if key not in self:
             suggestions_str = get_levenshtein_error_suggestions(key, self, 0.2)
             raise UndeclaredDefinition(f"'{key}' has not been declared. {suggestions_str}")
         return super().__getitem__(key)
@@ -82,14 +84,15 @@
 
     def clear(self):
         super().clear()
         self.__init__()
 
     def validate_assignment(self, attr):
         validate_identifier(attr)
+
         if attr in self:
             obj = super().__getitem__(attr)
             raise NamespaceCollision(f"'{attr}' has already been declared as a {obj}")
 
 
 def get_namespace():
     """
@@ -113,70 +116,92 @@
         yield
     finally:
         # unclobber
         _namespace = tmp
 
 
 def validate_identifier(attr):
-    namespace = get_namespace()
-    if attr in namespace and attr not in [x for i in namespace._scopes for x in i]:
-        raise NamespaceCollision(f"Cannot assign to '{attr}', it is a builtin")
-    if attr.lower() in RESERVED_KEYWORDS or attr.upper() in OPCODES:
-        raise StructureException(f"'{attr}' is a reserved keyword")
     if not re.match("^[_a-zA-Z][a-zA-Z0-9_]*$", attr):
         raise StructureException(f"'{attr}' contains invalid character(s)")
+    if attr.lower() in RESERVED_KEYWORDS:
+        raise StructureException(f"'{attr}' is a reserved keyword")
 
 
+# https://docs.python.org/3/reference/lexical_analysis.html#keywords
+# note we don't technically need to block all python reserved keywords,
+# but do it for hygiene
+_PYTHON_RESERVED_KEYWORDS = {
+    "False",
+    "None",
+    "True",
+    "and",
+    "as",
+    "assert",
+    "async",
+    "await",
+    "break",
+    "class",
+    "continue",
+    "def",
+    "del",
+    "elif",
+    "else",
+    "except",
+    "finally",
+    "for",
+    "from",
+    "global",
+    "if",
+    "import",
+    "in",
+    "is",
+    "lambda",
+    "nonlocal",
+    "not",
+    "or",
+    "pass",
+    "raise",
+    "return",
+    "try",
+    "while",
+    "with",
+    "yield",
+}
+_PYTHON_RESERVED_KEYWORDS = {s.lower() for s in _PYTHON_RESERVED_KEYWORDS}
+
 # Cannot be used for variable or member naming
-RESERVED_KEYWORDS = {
+RESERVED_KEYWORDS = _PYTHON_RESERVED_KEYWORDS | {
     # decorators
     "public",
     "external",
     "nonpayable",
     "constant",
     "immutable",
+    "transient",
     "internal",
     "payable",
     "nonreentrant",
-    # control flow
-    "if",
-    "for",
-    "while",
-    "until",
-    "pass",
-    "def",
+    # "class" keywords
+    "interface",
+    "struct",
+    "event",
+    "enum",
     # EVM operations
-    "send",
-    "selfdestruct",
-    "assert",
-    "raise",
-    "throw",
+    "unreachable",
     # special functions (no name mangling)
     "init",
     "_init_",
     "___init___",
     "____init____",
     "default",
     "_default_",
     "___default___",
     "____default____",
-    # environment variables
-    "chainid",
-    "blockhash",
-    "timestamp",
-    "timedelta",
-    # boolean literals
-    "true",
-    "false",
     # more control flow and special operations
-    "this",
-    "continue",
     "range",
-    # None sentinal value
-    "none",
     # more special operations
     "indexed",
     # denominations
     "ether",
     "wei",
     "finney",
     "szabo",
@@ -185,23 +210,16 @@
     "ada",
     "babbage",
     "gwei",
     "kwei",
     "mwei",
     "twei",
     "pwei",
-    # `address` members
-    "balance",
-    "codesize",
-    "codehash",
-    "code",
-    "is_contract",
-    # units
-    "units",
     # sentinal constant values
+    # TODO remove when these are removed from the language
     "zero_address",
     "empty_bytes32",
     "max_int128",
     "min_int128",
     "max_decimal",
     "min_decimal",
     "max_uint256",
```

### Comparing `vyper-0.3.7/vyper/semantics/types/bases.py` & `vyper-0.3.8/vyper/semantics/analysis/local.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,666 +1,609 @@
-import copy
-from collections import OrderedDict
-from enum import Enum
-from typing import Any, Dict, List, Optional, Tuple, Type, Union
+from typing import Optional
 
 from vyper import ast as vy_ast
-from vyper.abi_types import ABIType
+from vyper.ast.metadata import NodeMetadata
+from vyper.ast.validation import validate_call_args
 from vyper.exceptions import (
-    CompilerPanic,
+    ExceptionList,
+    FunctionDeclarationException,
     ImmutableViolation,
     InvalidLiteral,
     InvalidOperation,
-    NamespaceCollision,
+    InvalidType,
+    IteratorException,
+    NonPayableViolation,
     StateAccessViolation,
     StructureException,
-    UnexpectedNodeType,
-    UnexpectedValue,
-    UnknownAttribute,
+    TypeMismatch,
+    VariableDeclarationException,
+    VyperException,
 )
-from vyper.semantics.types.abstract import AbstractDataType
-from vyper.semantics.validation.levenshtein_utils import get_levenshtein_error_suggestions
-
+from vyper.semantics.analysis.annotation import StatementAnnotationVisitor
+from vyper.semantics.analysis.base import VarInfo
+from vyper.semantics.analysis.common import VyperNodeVisitorBase
+from vyper.semantics.analysis.utils import (
+    get_common_types,
+    get_exact_type_from_node,
+    get_expr_info,
+    get_possible_types_from_node,
+    validate_expected_type,
+)
+from vyper.semantics.data_locations import DataLocation
 
-class DataLocation(Enum):
-    UNSET = 0
-    MEMORY = 1
-    STORAGE = 2
-    CALLDATA = 3
-    CODE = 4
+# TODO consolidate some of these imports
+from vyper.semantics.environment import CONSTANT_ENVIRONMENT_VARS, MUTABLE_ENVIRONMENT_VARS
+from vyper.semantics.namespace import get_namespace
+from vyper.semantics.types import (
+    AddressT,
+    BoolT,
+    DArrayT,
+    EventT,
+    HashMapT,
+    IntegerT,
+    SArrayT,
+    StringT,
+    StructT,
+    TupleT,
+    is_type_t,
+)
+from vyper.semantics.types.function import ContractFunctionT, MemberFunctionT, StateMutability
+from vyper.semantics.types.utils import type_from_annotation
 
 
-class DataPosition:
-    _location: DataLocation
+def validate_functions(vy_module: vy_ast.Module) -> None:
+    """Analyzes a vyper ast and validates the function-level namespaces."""
 
+    err_list = ExceptionList()
+    namespace = get_namespace()
+    for node in vy_module.get_children(vy_ast.FunctionDef):
+        with namespace.enter_scope():
+            try:
+                FunctionNodeVisitor(vy_module, node, namespace)
+            except VyperException as e:
+                err_list.append(e)
 
-class CalldataOffset(DataPosition):
-    __slots__ = ("dynamic_offset", "static_offset")
-    _location = DataLocation.CALLDATA
+    err_list.raise_if_not_empty()
 
-    def __init__(self, static_offset, dynamic_offset=None):
-        self.static_offset = static_offset
-        self.dynamic_offset = dynamic_offset
 
-    def __repr__(self):
-        if self.dynamic_offset is not None:
-            return f"<CalldataOffset: static {self.static_offset}, dynamic {self.dynamic_offset})>"
-        else:
-            return f"<CalldataOffset: static {self.static_offset}, no dynamic>"
+def _is_terminus_node(node: vy_ast.VyperNode) -> bool:
+    if getattr(node, "_is_terminus", None):
+        return True
+    if isinstance(node, vy_ast.Expr) and isinstance(node.value, vy_ast.Call):
+        func = get_exact_type_from_node(node.value.func)
+        if getattr(func, "_is_terminus", None):
+            return True
+    return False
 
 
-class MemoryOffset(DataPosition):
-    __slots__ = ("offset",)
-    _location = DataLocation.MEMORY
-
-    def __init__(self, offset):
-        self.offset = offset
-
-    def __repr__(self):
-        return f"<MemoryOffset: {self.offset}>"
-
-
-class StorageSlot(DataPosition):
-    __slots__ = ("position",)
-    _location = DataLocation.STORAGE
-
-    def __init__(self, position):
-        self.position = position
-
-    def __repr__(self):
-        return f"<StorageSlot: {self.position}>"
-
-
-class CodeOffset(DataPosition):
-    __slots__ = ("offset",)
-    _location = DataLocation.CODE
-
-    def __init__(self, offset):
-        self.offset = offset
-
-    def __repr__(self):
-        return f"<CodeOffset: {self.offset}>"
-
-
-class BasePrimitive:
-    """
-    Base class for primitive type classes.
-
-    Primitives are objects that are invoked when applying a type to a variable.
-    They must contain a `from_annotation` (and optionally `from_literal`) method
-    that returns their equivalent `BaseTypeDefinition` object.
-
-    Attributes
-    ----------
-    _id : str
-        The name of the type.
-    _type : BaseTypeDefinition
-        The related `BaseTypeDefinition` class generated from this primitive
-    _as_array: bool, optional
-        If `True`, this type can be used as the base member for an array.
-    _valid_literal : Tuple
-        A tuple of Vyper ast classes that may be assigned this type.
-    """
-
-    _id: str
-    _type: Type["BaseTypeDefinition"]
-    _valid_literal: Tuple
-
-    @classmethod
-    def from_annotation(
-        cls,
-        node: Union[vy_ast.Name, vy_ast.Call],
-        location: DataLocation = DataLocation.UNSET,
-        is_constant: bool = False,
-        is_public: bool = False,
-        is_immutable: bool = False,
-    ) -> "BaseTypeDefinition":
-        """
-        Generate a `BaseTypeDefinition` instance of this type from `VariableDecl.annotation`
-        or `AnnAssign.annotation`
-
-        Arguments
-        ---------
-        node : VyperNode
-            Vyper ast node from the `annotation` member of a `VariableDecl` or `AnnAssign` node.
-
-        Returns
-        -------
-        BaseTypeDefinition
-            BaseTypeDefinition related to the primitive that the method was called on.
-        """
-        if not isinstance(node, vy_ast.Name):
-            raise StructureException("Invalid type assignment", node)
-        if node.id != cls._id:
-            raise UnexpectedValue("Node id does not match type name")
-        return cls._type(location, is_constant, is_public, is_immutable)
-
-    @classmethod
-    def from_literal(cls, node: vy_ast.Constant) -> "BaseTypeDefinition":
-        """
-        Generate a `BaseTypeDefinition` instance of this type from a literal constant.
-
-        This method is called on every primitive class in order to determine
-        potential types for a `Constant` AST node.
-
-        Types that may be assigned from literals should include a `_valid_literal`
-        attribute, containing a list of AST node classes that may be valid for
-        this type. If the `_valid_literal` attribute is not included, the type
-        cannot be assigned to a literal.
-
-        Arguments
-        ---------
-        node : VyperNode
-            `Constant` Vyper ast node, or a list or tuple of constants.
-
-        Returns
-        -------
-        BaseTypeDefinition
-            BaseTypeDefinition related to the primitive that the method was called on.
-        """
-        if not isinstance(node, vy_ast.Constant):
-            raise UnexpectedNodeType(f"Attempted to validate a '{node.ast_type}' node.")
-        if not isinstance(node, cls._valid_literal):
-            raise InvalidLiteral(f"Invalid literal type for {cls.__name__}", node)
-        return cls._type()
-
-    @classmethod
-    def compare_type(
-        cls, other: Union["BaseTypeDefinition", "BasePrimitive", AbstractDataType]
-    ) -> bool:
-        """
-        Compare this type object against another type object.
-
-        Failed comparisons must return `False`, not raise an exception.
-
-        This method is not intended to be called directly. Type comparisons
-        are handled by methods in `vyper.context.validation.utils`
-
-        Arguments
-        ---------
-        other : BaseTypeDefinition
-            Another type object to be compared against this one.
-
-        Returns
-        -------
-        bool
-            Indicates if the types are equivalent.
-        """
-        return isinstance(other, cls._type)
-
-    @classmethod
-    def fetch_call_return(self, node: vy_ast.Call) -> "BaseTypeDefinition":
-        """
-        Validate a call to this type and return the result.
-
-        This method must raise if the type is not callable, or the call arguments
-        are not valid.
-
-        Arguments
-        ---------
-        node : Call
-            Vyper ast node of call action to validate.
-
-        Returns
-        -------
-        BaseTypeDefinition, optional
-            Type generated as a result of the call.
-        """
-        raise StructureException("Type is not callable", node)
-
-    @classmethod
-    def get_subscripted_type(self, node: vy_ast.Index) -> None:
-        # always raises - do not implement in inherited classes
-        raise StructureException("Types cannot be indexed", node)
-
-    @classmethod
-    def get_member(cls, key: str, node: vy_ast.Attribute) -> None:
-        raise StructureException(f"{cls} does not have members", node)
-
-    @classmethod
-    def validate_modification(
-        cls, node: Union[vy_ast.Assign, vy_ast.AugAssign], mutability: Any
-    ) -> None:
-        # always raises - do not implement in inherited classes
-        raise InvalidOperation("Cannot assign to a type", node)
+def check_for_terminus(node_list: list) -> bool:
+    if next((i for i in node_list if _is_terminus_node(i)), None):
+        return True
+    for node in [i for i in node_list if isinstance(i, vy_ast.If)][::-1]:
+        if not node.orelse or not check_for_terminus(node.orelse):
+            continue
+        if not check_for_terminus(node.body):
+            continue
+        return True
+    return False
 
 
-class BaseTypeDefinition:
-    """
-    Base class for type definition classes.
-
-    Type definitions are objects that represent the type of a specific object
-    within a contract. They are usually derived from a `BasePrimitive` counterpart.
-
-    Class Attributes
-    -----------------
-    _id : str
-        The name of the type.
-    _is_callable : bool, optional
-        If `True`, attempts to assign this value without calling it will raise
-        a more expressive error message recommending that the user performs a
-        function call.
-
-    Object Attributes
-    -----------------
-    is_constant : bool, optional
-        If `True`, the value of this object cannot be modified after assignment.
-    size_in_bytes: int
-        The number of bytes that are required to store this type.
-    """
+def _check_iterator_modification(
+    target_node: vy_ast.VyperNode, search_node: vy_ast.VyperNode
+) -> Optional[vy_ast.VyperNode]:
+    similar_nodes = [
+        n
+        for n in search_node.get_descendants(type(target_node))
+        if vy_ast.compare_nodes(target_node, n)
+    ]
+
+    for node in similar_nodes:
+        # raise if the node is the target of an assignment statement
+        assign_node = node.get_ancestor((vy_ast.Assign, vy_ast.AugAssign))
+        # note the use of get_descendants() blocks statements like
+        # self.my_array[i] = x
+        if assign_node and node in assign_node.target.get_descendants(include_self=True):
+            return node
+
+        attr_node = node.get_ancestor(vy_ast.Attribute)
+        # note the use of get_descendants() blocks statements like
+        # self.my_array[i].append(x)
+        if (
+            attr_node is not None
+            and node in attr_node.value.get_descendants(include_self=True)
+            and attr_node.attr in ("append", "pop", "extend")
+        ):
+            return node
+
+    return None
+
+
+def _validate_revert_reason(msg_node: vy_ast.VyperNode) -> None:
+    if msg_node:
+        if isinstance(msg_node, vy_ast.Str):
+            if not msg_node.value.strip():
+                raise StructureException("Reason string cannot be empty", msg_node)
+        elif not (isinstance(msg_node, vy_ast.Name) and msg_node.id == "UNREACHABLE"):
+            try:
+                validate_expected_type(msg_node, StringT(1024))
+            except TypeMismatch as e:
+                raise InvalidType("revert reason must fit within String[1024]") from e
+
+
+def _validate_address_code_attribute(node: vy_ast.Attribute) -> None:
+    value_type = get_exact_type_from_node(node.value)
+    if isinstance(value_type, AddressT) and node.attr == "code":
+        # Validate `slice(<address>.code, start, length)` where `length` is constant
+        parent = node.get_ancestor()
+        if isinstance(parent, vy_ast.Call):
+            ok_func = isinstance(parent.func, vy_ast.Name) and parent.func.id == "slice"
+            ok_args = len(parent.args) == 3 and isinstance(parent.args[2], vy_ast.Int)
+            if ok_func and ok_args:
+                return
+        raise StructureException(
+            "(address).code is only allowed inside of a slice function with a constant length", node
+        )
+
+
+def _validate_msg_data_attribute(node: vy_ast.Attribute) -> None:
+    if isinstance(node.value, vy_ast.Name) and node.value.id == "msg" and node.attr == "data":
+        parent = node.get_ancestor()
+        allowed_builtins = ("slice", "len", "raw_call")
+        if not isinstance(parent, vy_ast.Call) or parent.get("func.id") not in allowed_builtins:
+            raise StructureException(
+                "msg.data is only allowed inside of the slice or len functions", node
+            )
+        if parent.get("func.id") == "slice":
+            ok_args = len(parent.args) == 3 and isinstance(parent.args[2], vy_ast.Int)
+            if not ok_args:
+                raise StructureException(
+                    "slice(msg.data) must use a compile-time constant for length argument", parent
+                )
 
-    # TODO CMC 2022-01-08 `is_dynamic_size` probably unused
-    is_dynamic_size = False
 
-    size_in_bytes = 32
-    _id: str
+class FunctionNodeVisitor(VyperNodeVisitorBase):
+    ignored_types = (vy_ast.Constant, vy_ast.Pass)
+    scope_name = "function"
 
     def __init__(
-        self,
-        location: DataLocation = DataLocation.UNSET,
-        is_constant: bool = False,
-        is_public: bool = False,
-        is_immutable: bool = False,
+        self, vyper_module: vy_ast.Module, fn_node: vy_ast.FunctionDef, namespace: dict
     ) -> None:
-        self.location = location
-        self.is_constant = is_constant
-        self.is_public = is_public
-        self.is_immutable = is_immutable
-
-        self._modification_count = 0
-
-    @property
-    def abi_type(self) -> ABIType:
-        """
-        The ABI type corresponding to this type
-        """
-        raise CompilerPanic("Method must be implemented by the inherited class")
-
-    @property
-    def canonical_abi_type(self) -> str:
-        """
-        The canonical name of this type. Used for ABI types and generating function signatures.
-        """
-        return self.abi_type.selector_name()
-
-    def to_abi_dict(self, name: str = "") -> Dict[str, Any]:
-        """
-        The JSON ABI description of this type. Note for complex types,
-        the implementation is overridden to be compliant with the spec:
-        https://docs.soliditylang.org/en/v0.8.14/abi-spec.html#json
-        > An object with members name, type and potentially components
-          describes a typed variable. The canonical type is determined
-          until a tuple type is reached and the string description up to
-          that point is stored in type prefix with the word tuple, i.e.
-          it will be tuple followed by a sequence of [] and [k] with
-          integers k. The components of the tuple are then stored in the
-          member components, which is of array type and has the same
-          structure as the top-level object except that indexed is not
-          allowed there.
-        """
-        return {"name": name, "type": self.canonical_abi_type}
-
-    def from_annotation(self, node: vy_ast.VyperNode, *args: Any, **kwargs: Any) -> None:
-        # always raises, user should have used a primitive
-        raise StructureException("Value is not a type", node)
-
-    def set_position(self, position: DataPosition) -> None:
-        if hasattr(self, "position"):
-            raise CompilerPanic("Position was already assigned")
-        if self.location != position._location:
-            if self.location == DataLocation.UNSET:
-                self.location = position._location
-            else:
-                raise CompilerPanic("Incompatible locations")
-        self.position = position
+        self.vyper_module = vyper_module
+        self.fn_node = fn_node
+        self.namespace = namespace
+        self.func = fn_node._metadata["type"]
+        self.annotation_visitor = StatementAnnotationVisitor(fn_node, namespace)
+        self.expr_visitor = _LocalExpressionVisitor()
+        for arg in self.func.arguments:
+            namespace[arg.name] = VarInfo(
+                arg.typ, location=DataLocation.CALLDATA, is_immutable=True
+            )
 
-    def compare_type(
-        self, other: Union["BaseTypeDefinition", BasePrimitive, AbstractDataType]
-    ) -> bool:
-        """
-        Compare this type object against another type object.
-
-        Failed comparisons must return `False`, not raise an exception.
-
-        This method is not intended to be called directly. Type comparisons
-        are handled by methods in `vyper.context.validation.utils`
-
-        Arguments
-        ---------
-        other : BaseTypeDefinition
-            Another type object to be compared against this one.
-
-        Returns
-        -------
-        bool
-            Indicates if the types are equivalent.
-        """
-        return isinstance(other, type(self))
+        for node in fn_node.body:
+            self.visit(node)
+        if self.func.return_type:
+            if not check_for_terminus(fn_node.body):
+                raise FunctionDeclarationException(
+                    f"Missing or unmatched return statements in function '{fn_node.name}'", fn_node
+                )
 
-    def validate_numeric_op(
-        self, node: Union[vy_ast.UnaryOp, vy_ast.BinOp, vy_ast.AugAssign]
-    ) -> None:
-        """
-        Validate a numeric operation for this type.
+        if self.func.mutability == StateMutability.PURE:
+            node_list = fn_node.get_descendants(
+                vy_ast.Attribute,
+                {
+                    "value.id": set(CONSTANT_ENVIRONMENT_VARS.keys()).union(
+                        set(MUTABLE_ENVIRONMENT_VARS.keys())
+                    )
+                },
+            )
 
-        Arguments
-        ---------
-        node : UnaryOp | BinOp | AugAssign
-            Vyper ast node of the numeric operation to be validated.
-
-        Returns
-        -------
-        None. A failed validation must raise an exception.
-        """
-        raise InvalidOperation(f"Cannot perform {node.op.description} on {self}", node)
-
-    def validate_boolean_op(self, node: vy_ast.BoolOp) -> None:
-        """
-        Validate a boolean operation for this type.
-
-        Arguments
-        ---------
-        node : BoolOp
-            Vyper ast node of the boolean operation to be validated.
-
-        Returns
-        -------
-        None. A failed validation must raise an exception.
-        """
-        raise InvalidOperation(f"Invalid type for operand: {self}", node)
-
-    def validate_comparator(self, node: vy_ast.Compare) -> None:
-        """
-        Validate a comparator for this type.
-
-        Arguments
-        ---------
-        node : Compare
-            Vyper ast node of the comparator to be validated.
-
-        Returns
-        -------
-        None. A failed validation must raise an exception.
-        """
-        if not isinstance(node.op, (vy_ast.Eq, vy_ast.NotEq)):
-            raise InvalidOperation(
-                f"Cannot perform {node.op.description} comparison on {self}", node
+            # Add references to `self` as standalone address
+            self_references = fn_node.get_descendants(vy_ast.Name, {"id": "self"})
+            standalone_self = [
+                n for n in self_references if not isinstance(n.get_ancestor(), vy_ast.Attribute)
+            ]
+            node_list.extend(standalone_self)  # type: ignore
+
+            for node in node_list:
+                t = node._metadata.get("type")
+                if isinstance(t, ContractFunctionT) and t.mutability == StateMutability.PURE:
+                    # allowed
+                    continue
+                raise StateAccessViolation(
+                    "not allowed to query contract or environment variables in pure functions",
+                    node_list[0],
+                )
+        if self.func.mutability is not StateMutability.PAYABLE:
+            node_list = fn_node.get_descendants(
+                vy_ast.Attribute, {"value.id": "msg", "attr": "value"}
             )
+            if node_list:
+                raise NonPayableViolation(
+                    "msg.value is not allowed in non-payable functions", node_list[0]
+                )
 
-    def validate_implements(self, node: vy_ast.AnnAssign) -> None:
-        """
-        Validate an implements statement.
-
-        This method is unique to user-defined interfaces. It should not be
-        included in other types.
-
-        Arguments
-        ---------
-        node : AnnAssign
-            Vyper ast node of the implements statement being validated.
-
-        Returns
-        -------
-        None. A failed validation must raise an exception.
-        """
-        raise StructureException("Value is not an interface", node)
-
-    def fetch_call_return(self, node: vy_ast.Call) -> Union["BaseTypeDefinition", None]:
-        """
-        Validate a call to this value and return the result.
-
-        This method must raise if the value is not callable, or the call arguments
-        are not valid.
-
-        Arguments
-        ---------
-        node : Call
-            Vyper ast node of call action to validate.
-
-        Returns
-        -------
-        BaseTypeDefinition, optional
-            Type generated as a result of the call.
-        """
-        raise StructureException("Value is not callable", node)
-
-    def infer_arg_types(self, node: vy_ast.Call) -> List[Union["BaseTypeDefinition", None]]:
-        """
-        Performs the necessary type inference and returns the call's arguments' types.
-
-        This method must raise if the value is not callable, or the type for a call
-        argument cannot be determined.
-
-        Arguments
-        ---------
-        node : Call
-            Vyper ast node of call action to perform type inference.
-
-        Returns
-        -------
-        BaseTypeDefinition, optional
-            List of types for the call's arguments.
-        """
-        raise StructureException("Value is not callable", node)
-
-    def validate_index_type(self, node: vy_ast.Index) -> None:
-        """
-        Validate an index reference, e.g. x[1]. Raises if the index is invalid.
-
-        Arguments
-        ---------
-        node : Index
-            Vyper ast node from the `slice` member of a Subscript node.
-        """
-        raise StructureException(f"Type '{self}' does not support indexing", node)
-
-    def get_subscripted_type(self, node: vy_ast.Index) -> "BaseTypeDefinition":
-        """
-        Return the type of a subscript expression, e.g. x[1]
-
-        Arguments
-        ---------
-        node: Index
-            Vyper ast node from the `slice` member of a Subscript node
-
-        Returns
-        -------
-        BaseTypeDefinition
-            Type object for value at the given index.
-        """
-        raise StructureException(f"Type '{self}' does not support indexing", node)
-
-    def get_member(self, key: str, node: vy_ast.Attribute) -> "BaseTypeDefinition":
-        """
-        Validate an attribute reference and return the given type for the member.
-
-        Arguments
-        ---------
-        key : str
-            Name of the member being accessed.
-        node: Attribute
-            Vyper ast Attribute node representing the member being accessed.
-
-        Returns
-        -------
-        BaseTypeDefinition
-            A type object for the value of the given member. Raises if the member
-            does not exist for the given type.
-        """
-        raise StructureException(f"Type '{self}' does not support members", node)
-
-    def validate_modification(
-        self,
-        node: Union[vy_ast.Assign, vy_ast.AugAssign, vy_ast.Call],
-        mutability: Any,  # should be StateMutability, import cycle
-    ) -> None:
-        """
-        Validate an attempt to modify this value.
+    def visit(self, node):
+        super().visit(node)
+        self.annotation_visitor.visit(node)
+
+    def visit_AnnAssign(self, node):
+        name = node.get("target.id")
+        if name is None:
+            raise VariableDeclarationException("Invalid assignment", node)
+
+        if not node.value:
+            raise VariableDeclarationException(
+                "Memory variables must be declared with an initial value", node
+            )
 
-        Raises if the value is a constant or involves an invalid operation.
+        type_ = type_from_annotation(node.annotation, DataLocation.MEMORY)
+        validate_expected_type(node.value, type_)
 
-        Arguments
-        ---------
-        node : Assign | AugAssign | Call
-            Vyper ast node of the modifying action.
-        mutability: StateMutability
-            The mutability of the context (e.g., pure function) we are currently in
-        """
-        # TODO: break this cycle, probably by moving this to validation module
-        from vyper.semantics.types.function import StateMutability
-
-        if mutability <= StateMutability.VIEW and self.location == DataLocation.STORAGE:
-            raise StateAccessViolation(
-                f"Cannot modify storage in a {mutability.value} function", node
+        try:
+            self.namespace[name] = VarInfo(type_, location=DataLocation.MEMORY)
+        except VyperException as exc:
+            raise exc.with_annotation(node) from None
+        self.expr_visitor.visit(node.value)
+
+    def visit_Assign(self, node):
+        if isinstance(node.value, vy_ast.Tuple):
+            raise StructureException("Right-hand side of assignment cannot be a tuple", node.value)
+
+        target = get_expr_info(node.target)
+        if isinstance(target.typ, HashMapT):
+            raise StructureException(
+                "Left-hand side of assignment cannot be a HashMap without a key", node
             )
 
-        if self.location == DataLocation.CALLDATA:
-            raise ImmutableViolation("Cannot write to calldata", node)
-        if self.is_constant:
-            raise ImmutableViolation("Constant value cannot be written to", node)
-        if self.is_immutable:
-            if node.get_ancestor(vy_ast.FunctionDef).get("name") != "__init__":
-                raise ImmutableViolation("Immutable value cannot be written to", node)
-            if self._modification_count:
-                raise ImmutableViolation(
-                    "Immutable value cannot be modified after assignment", node
-                )
-            self._modification_count += 1
+        validate_expected_type(node.value, target.typ)
+        target.validate_modification(node, self.func.mutability)
 
-        if isinstance(node, vy_ast.AugAssign):
-            self.validate_numeric_op(node)
+        self.expr_visitor.visit(node.value)
+        self.expr_visitor.visit(node.target)
 
-    def get_signature(self) -> Tuple[Tuple, Optional["BaseTypeDefinition"]]:
-        """
-        The getter signature for this type
-        """
-        raise CompilerPanic("Method must be implemented by the inherited class")
-
-    def compare_signature(self, other: "BaseTypeDefinition") -> bool:
-        """
-        Compare the signature of this type with another type.
-
-        Used when determining if an interface has been implemented. This method
-        should not be directly implemented by any inherited classes.
-        """
-
-        if not self.is_public:
-            return False
-
-        arguments, return_type = self.get_signature()
-        other_arguments, other_return_type = other.get_signature()
-
-        if len(arguments) != len(other_arguments):
-            return False
-        for a, b in zip(arguments, other_arguments):
-            if not a.compare_type(b):
-                return False
-        if return_type and not return_type.compare_type(other_return_type):  # type: ignore
-            return False
+    def visit_AugAssign(self, node):
+        if isinstance(node.value, vy_ast.Tuple):
+            raise StructureException("Right-hand side of assignment cannot be a tuple", node.value)
+
+        lhs_info = get_expr_info(node.target)
+
+        validate_expected_type(node.value, lhs_info.typ)
+        lhs_info.validate_modification(node, self.func.mutability)
+
+        self.expr_visitor.visit(node.value)
+        self.expr_visitor.visit(node.target)
+
+    def visit_Raise(self, node):
+        if node.exc:
+            _validate_revert_reason(node.exc)
+            self.expr_visitor.visit(node.exc)
+
+    def visit_Assert(self, node):
+        if node.msg:
+            _validate_revert_reason(node.msg)
+            self.expr_visitor.visit(node.msg)
+
+        try:
+            validate_expected_type(node.test, BoolT())
+        except InvalidType:
+            raise InvalidType("Assertion test value must be a boolean", node.test)
+        self.expr_visitor.visit(node.test)
+
+    def visit_Continue(self, node):
+        for_node = node.get_ancestor(vy_ast.For)
+        if for_node is None:
+            raise StructureException("`continue` must be enclosed in a `for` loop", node)
+
+    def visit_Break(self, node):
+        for_node = node.get_ancestor(vy_ast.For)
+        if for_node is None:
+            raise StructureException("`break` must be enclosed in a `for` loop", node)
+
+    def visit_Return(self, node):
+        values = node.value
+        if values is None:
+            if self.func.return_type:
+                raise FunctionDeclarationException("Return statement is missing a value", node)
+            return
+        elif self.func.return_type is None:
+            raise FunctionDeclarationException("Function does not return any values", node)
+
+        if isinstance(values, vy_ast.Tuple):
+            values = values.elements
+            if not isinstance(self.func.return_type, TupleT):
+                raise FunctionDeclarationException("Function only returns a single value", node)
+            if self.func.return_type.length != len(values):
+                raise FunctionDeclarationException(
+                    f"Incorrect number of return values: "
+                    f"expected {self.func.return_type.length}, got {len(values)}",
+                    node,
+                )
+            for given, expected in zip(values, self.func.return_type.member_types):
+                validate_expected_type(given, expected)
+        else:
+            validate_expected_type(values, self.func.return_type)
+        self.expr_visitor.visit(node.value)
 
-        return True
+    def visit_If(self, node):
+        validate_expected_type(node.test, BoolT())
+        self.expr_visitor.visit(node.test)
+        with self.namespace.enter_scope():
+            for n in node.body:
+                self.visit(n)
+        with self.namespace.enter_scope():
+            for n in node.orelse:
+                self.visit(n)
+
+    def visit_For(self, node):
+        if isinstance(node.iter, vy_ast.Subscript):
+            raise StructureException("Cannot iterate over a nested list", node.iter)
+
+        if isinstance(node.iter, vy_ast.Call):
+            # iteration via range()
+            if node.iter.get("func.id") != "range":
+                raise IteratorException(
+                    "Cannot iterate over the result of a function call", node.iter
+                )
+            validate_call_args(node.iter, (1, 2))
 
+            args = node.iter.args
+            if len(args) == 1:
+                # range(CONSTANT)
+                if not isinstance(args[0], vy_ast.Num):
+                    raise StateAccessViolation("Value must be a literal", node)
+                if args[0].value <= 0:
+                    raise StructureException("For loop must have at least 1 iteration", args[0])
+                validate_expected_type(args[0], IntegerT.any())
+                type_list = get_possible_types_from_node(args[0])
+            else:
+                validate_expected_type(args[0], IntegerT.any())
+                type_list = get_common_types(*args)
+                if not isinstance(args[0], vy_ast.Constant):
+                    # range(x, x + CONSTANT)
+                    if not isinstance(args[1], vy_ast.BinOp) or not isinstance(
+                        args[1].op, vy_ast.Add
+                    ):
+                        raise StructureException(
+                            "Second element must be the first element plus a literal value", args[0]
+                        )
+                    if not vy_ast.compare_nodes(args[0], args[1].left):
+                        raise StructureException(
+                            "First and second variable must be the same", args[1].left
+                        )
+                    if not isinstance(args[1].right, vy_ast.Int):
+                        raise InvalidLiteral("Literal must be an integer", args[1].right)
+                    if args[1].right.value < 1:
+                        raise StructureException(
+                            f"For loop has invalid number of iterations ({args[1].right.value}),"
+                            " the value must be greater than zero",
+                            args[1].right,
+                        )
+                else:
+                    # range(CONSTANT, CONSTANT)
+                    if not isinstance(args[1], vy_ast.Int):
+                        raise InvalidType("Value must be a literal integer", args[1])
+                    validate_expected_type(args[1], IntegerT.any())
+                    if args[0].value >= args[1].value:
+                        raise StructureException("Second value must be > first value", args[1])
 
-class ValueTypeDefinition(BaseTypeDefinition):
-    """
-    Base class for types representing a single value. The getter
-    for these types takes 0 arguments and returns the entire value.
-
-    Class attributes
-    ----------------
-    _valid_literal: VyperNode | Tuple
-        A vyper ast class or tuple of ast classes that can represent valid literals
-        for the given type. Including this attribute will allow literal values to be
-        assigned this type.
-    """
-
-    def __repr__(self):
-        return self._id
-
-    def get_signature(self):
-        return (), self
-
-
-class MemberTypeDefinition(BaseTypeDefinition):
-    """
-    Base class for types that have accessible members.
-
-    Class attributes
-    ----------------
-    _type_members : Dict[str, BaseType]
-        Dictionary of members common to all values of this type.
-
-    Object attributes
-    -----------------
-    members : OrderedDict[str, BaseType]
-        Dictionary of members for the given type.
-    """
+                if not type_list:
+                    raise TypeMismatch("Iterator values are of different types", node.iter)
 
-    _type_members: Dict
+        else:
+            # iteration over a variable or literal list
+            if isinstance(node.iter, vy_ast.List) and len(node.iter.elements) == 0:
+                raise StructureException("For loop must have at least 1 iteration", node.iter)
+
+            type_list = [
+                i.value_type
+                for i in get_possible_types_from_node(node.iter)
+                if isinstance(i, (DArrayT, SArrayT))
+            ]
+
+        if not type_list:
+            raise InvalidType("Not an iterable type", node.iter)
+
+        if isinstance(node.iter, (vy_ast.Name, vy_ast.Attribute)):
+            # check for references to the iterated value within the body of the loop
+            assign = _check_iterator_modification(node.iter, node)
+            if assign:
+                raise ImmutableViolation("Cannot modify array during iteration", assign)
+
+        # Check if `iter` is a storage variable. get_descendants` is used to check for
+        # nested `self` (e.g. structs)
+        iter_is_storage_var = (
+            isinstance(node.iter, vy_ast.Attribute)
+            and len(node.iter.get_descendants(vy_ast.Name, {"id": "self"})) > 0
+        )
+
+        if iter_is_storage_var:
+            # check if iterated value may be modified by function calls inside the loop
+            iter_name = node.iter.attr
+            for call_node in node.get_descendants(vy_ast.Call, {"func.value.id": "self"}):
+                fn_name = call_node.func.attr
+
+                fn_node = self.vyper_module.get_children(vy_ast.FunctionDef, {"name": fn_name})[0]
+                if _check_iterator_modification(node.iter, fn_node):
+                    # check for direct modification
+                    raise ImmutableViolation(
+                        f"Cannot call '{fn_name}' inside for loop, it potentially "
+                        f"modifies iterated storage variable '{iter_name}'",
+                        call_node,
+                    )
+
+                for name in self.namespace["self"].typ.members[fn_name].recursive_calls:
+                    # check for indirect modification
+                    fn_node = self.vyper_module.get_children(vy_ast.FunctionDef, {"name": name})[0]
+                    if _check_iterator_modification(node.iter, fn_node):
+                        raise ImmutableViolation(
+                            f"Cannot call '{fn_name}' inside for loop, it may call to '{name}' "
+                            f"which potentially modifies iterated storage variable '{iter_name}'",
+                            call_node,
+                        )
+        self.expr_visitor.visit(node.iter)
+
+        if not isinstance(node.target, vy_ast.Name):
+            raise StructureException("Invalid syntax for loop iterator", node.target)
+
+        for_loop_exceptions = []
+        iter_name = node.target.id
+        for type_ in type_list:
+            # type check the for loop body using each possible type for iterator value
+
+            with self.namespace.enter_scope():
+                try:
+                    self.namespace[iter_name] = VarInfo(type_, is_constant=True)
+                except VyperException as exc:
+                    raise exc.with_annotation(node) from None
+
+                try:
+                    with NodeMetadata.enter_typechecker_speculation():
+                        for n in node.body:
+                            self.visit(n)
+                except (TypeMismatch, InvalidOperation) as exc:
+                    for_loop_exceptions.append(exc)
+                else:
+                    # type information is applied directly here because the
+                    # scope is closed prior to the call to
+                    # `StatementAnnotationVisitor`
+                    node.target._metadata["type"] = type_
+
+                    # success -- bail out instead of error handling.
+                    return
+
+        # if we have gotten here, there was an error for
+        # every type tried for the iterator
+
+        if len(set(str(i) for i in for_loop_exceptions)) == 1:
+            # if every attempt at type checking raised the same exception
+            raise for_loop_exceptions[0]
+
+        # return an aggregate TypeMismatch that shows all possible exceptions
+        # depending on which type is used
+        types_str = [str(i) for i in type_list]
+        given_str = f"{', '.join(types_str[:1])} or {types_str[-1]}"
+        raise TypeMismatch(
+            f"Iterator value '{iter_name}' may be cast as {given_str}, "
+            "but type checking fails with all possible types:",
+            node,
+            *(
+                (f"Casting '{iter_name}' as {type_}: {exc.message}", exc.annotations[0])
+                for type_, exc in zip(type_list, for_loop_exceptions)
+            ),
+        )
+
+    def visit_Expr(self, node):
+        if not isinstance(node.value, vy_ast.Call):
+            raise StructureException("Expressions without assignment are disallowed", node)
+
+        fn_type = get_exact_type_from_node(node.value.func)
+        if is_type_t(fn_type, EventT):
+            raise StructureException("To call an event you must use the `log` statement", node)
+
+        if is_type_t(fn_type, StructT):
+            raise StructureException("Struct creation without assignment is disallowed", node)
+
+        if isinstance(fn_type, ContractFunctionT):
+            if (
+                fn_type.mutability > StateMutability.VIEW
+                and self.func.mutability <= StateMutability.VIEW
+            ):
+                raise StateAccessViolation(
+                    f"Cannot call a mutating function from a {self.func.mutability.value} function",
+                    node,
+                )
 
-    def __init__(
-        self,
-        location: DataLocation = DataLocation.UNSET,
-        is_constant: bool = False,
-        is_public: bool = False,
-        is_immutable: bool = False,
-    ) -> None:
-        super().__init__(location, is_constant, is_public, is_immutable)
-        self.members: OrderedDict = OrderedDict()
+            if (
+                self.func.mutability == StateMutability.PURE
+                and fn_type.mutability != StateMutability.PURE
+            ):
+                raise StateAccessViolation(
+                    "Cannot call non-pure function from a pure function", node
+                )
+
+        if isinstance(fn_type, MemberFunctionT) and fn_type.is_modifying:
+            # it's a dotted function call like dynarray.pop()
+            expr_info = get_expr_info(node.value.func.value)
+            expr_info.validate_modification(node, self.func.mutability)
+
+        # NOTE: fetch_call_return validates call args.
+        return_value = fn_type.fetch_call_return(node.value)
+        if (
+            return_value
+            and not isinstance(fn_type, MemberFunctionT)
+            and not isinstance(fn_type, ContractFunctionT)
+        ):
+            raise StructureException(
+                f"Function '{fn_type._id}' cannot be called without assigning the result", node
+            )
+        self.expr_visitor.visit(node.value)
 
-    def add_member(self, name: str, type_: BaseTypeDefinition) -> None:
-        if name in self.members:
-            raise NamespaceCollision(f"Member '{name}' already exists in {self}")
-        if name in getattr(self, "_type_members", []):
-            raise NamespaceCollision(f"Member '{name}' already exists in {self}")
-        self.members[name] = type_
-
-    def get_member(self, key: str, node: vy_ast.VyperNode) -> BaseTypeDefinition:
-        if key in self.members:
-            return self.members[key]
-        elif key in getattr(self, "_type_members", []):
-            type_ = copy.deepcopy(self._type_members[key])
-            type_.location = self.location
-            type_.is_constant = self.is_constant
-            return type_
-        suggestions_str = get_levenshtein_error_suggestions(key, self.members, 0.3)
-        raise UnknownAttribute(f"{self} has no member '{key}'. {suggestions_str}", node)
-
-    def __repr__(self):
-        return self._id
-
-
-class IndexableTypeDefinition(BaseTypeDefinition):
-    """
-    Base class for indexable types such as arrays and mappings.
-
-    Attributes
-    ----------
-    key_type: BaseType
-        Type representing the index value for this object.
-    value_type : BaseType
-        Type representing the value(s) contained in this object.
-    _id : str
-        Name of the type.
-    """
+    def visit_Log(self, node):
+        if not isinstance(node.value, vy_ast.Call):
+            raise StructureException("Log must call an event", node)
+        f = get_exact_type_from_node(node.value.func)
+        if not is_type_t(f, EventT):
+            raise StructureException("Value is not an event", node.value)
+        if self.func.mutability <= StateMutability.VIEW:
+            raise StructureException(
+                f"Cannot emit logs from {self.func.mutability.value.lower()} functions", node
+            )
+        f.fetch_call_return(node.value)
+        self.expr_visitor.visit(node.value)
 
-    def __init__(
-        self,
-        value_type: BaseTypeDefinition,
-        key_type: BaseTypeDefinition,
-        _id: str,
-        location: DataLocation = DataLocation.UNSET,
-        is_constant: bool = False,
-        is_public: bool = False,
-        is_immutable: bool = False,
-    ) -> None:
-        super().__init__(location, is_constant, is_public, is_immutable)
-        self.value_type = value_type
-        self.key_type = key_type
-        self._id = _id
-
-    def get_signature(self) -> Tuple[Tuple, Optional[BaseTypeDefinition]]:
-        new_args, return_type = self.value_type.get_signature()
-        return (self.key_type,) + new_args, return_type
 
-    def get_index_type(self):
-        return self.key_type
+class _LocalExpressionVisitor(VyperNodeVisitorBase):
+    ignored_types = (vy_ast.Constant, vy_ast.Name)
+    scope_name = "function"
+
+    def visit_Attribute(self, node: vy_ast.Attribute) -> None:
+        self.visit(node.value)
+        _validate_msg_data_attribute(node)
+        _validate_address_code_attribute(node)
+
+    def visit_BinOp(self, node: vy_ast.BinOp) -> None:
+        self.visit(node.left)
+        self.visit(node.right)
+
+    def visit_BoolOp(self, node: vy_ast.BoolOp) -> None:
+        for value in node.values:  # type: ignore[attr-defined]
+            self.visit(value)
+
+    def visit_Call(self, node: vy_ast.Call) -> None:
+        self.visit(node.func)
+        for arg in node.args:
+            self.visit(arg)
+        for kwarg in node.keywords:
+            self.visit(kwarg.value)
+
+    def visit_Compare(self, node: vy_ast.Compare) -> None:
+        self.visit(node.left)  # type: ignore[attr-defined]
+        self.visit(node.right)  # type: ignore[attr-defined]
+
+    def visit_Dict(self, node: vy_ast.Dict) -> None:
+        for key in node.keys:
+            self.visit(key)
+        for value in node.values:
+            self.visit(value)
+
+    def visit_Index(self, node: vy_ast.Index) -> None:
+        self.visit(node.value)
+
+    def visit_List(self, node: vy_ast.List) -> None:
+        for element in node.elements:
+            self.visit(element)
+
+    def visit_Subscript(self, node: vy_ast.Subscript) -> None:
+        self.visit(node.value)
+        self.visit(node.slice)
+
+    def visit_Tuple(self, node: vy_ast.Tuple) -> None:
+        for element in node.elements:
+            self.visit(element)
+
+    def visit_UnaryOp(self, node: vy_ast.UnaryOp) -> None:
+        self.visit(node.operand)  # type: ignore[attr-defined]
+
+    def visit_IfExp(self, node: vy_ast.IfExp) -> None:
+        self.visit(node.test)
+        self.visit(node.body)
+        self.visit(node.orelse)
```

### Comparing `vyper-0.3.7/vyper/semantics/types/function.py` & `vyper-0.3.8/vyper/semantics/types/function.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,205 +1,181 @@
 import re
 import warnings
-from collections import OrderedDict
-from typing import Any, Dict, List, Optional, Set, Tuple
+from dataclasses import dataclass
+from functools import cached_property
+from typing import Any, Dict, List, Optional, Tuple
 
 from vyper import ast as vy_ast
 from vyper.ast.validation import validate_call_args
 from vyper.exceptions import (
     ArgumentException,
     CallViolation,
     CompilerPanic,
     FunctionDeclarationException,
     InvalidType,
-    NamespaceCollision,
     StateAccessViolation,
     StructureException,
 )
-from vyper.semantics.namespace import get_namespace
-from vyper.semantics.types.bases import BaseTypeDefinition, DataLocation, StorageSlot
-from vyper.semantics.types.indexable.sequence import TupleDefinition
-from vyper.semantics.types.utils import (
-    KwargSettings,
-    StringEnum,
-    check_kwargable,
-    get_type_from_abi,
-    get_type_from_annotation,
-)
-from vyper.semantics.types.value.boolean import BoolDefinition
-from vyper.semantics.types.value.numeric import Uint256Definition  # type: ignore
-from vyper.semantics.validation.utils import validate_expected_type
-from vyper.utils import keccak256
-
-
-class FunctionVisibility(StringEnum):
-    EXTERNAL = StringEnum.auto()
-    INTERNAL = StringEnum.auto()
-
-
-class StateMutability(StringEnum):
-    PURE = StringEnum.auto()
-    VIEW = StringEnum.auto()
-    NONPAYABLE = StringEnum.auto()
-    PAYABLE = StringEnum.auto()
+from vyper.semantics.analysis.base import FunctionVisibility, StateMutability, StorageSlot
+from vyper.semantics.analysis.utils import check_kwargable, validate_expected_type
+from vyper.semantics.data_locations import DataLocation
+from vyper.semantics.types.base import KwargSettings, VyperType
+from vyper.semantics.types.primitives import BoolT
+from vyper.semantics.types.shortcuts import UINT256_T
+from vyper.semantics.types.subscriptable import TupleT
+from vyper.semantics.types.utils import type_from_abi, type_from_annotation
+from vyper.utils import OrderedSet, keccak256
+
+
+@dataclass
+class _FunctionArg:
+    name: str
+    typ: VyperType
 
-    @classmethod
-    def from_abi(cls, abi_dict: Dict) -> "StateMutability":
-        """
-        Extract stateMutability from an entry in a contract's ABI
-        """
-        if "stateMutability" in abi_dict:
-            return cls(abi_dict["stateMutability"])
-        elif abi_dict.get("payable"):
-            return StateMutability.PAYABLE
-        elif "constant" in abi_dict and abi_dict["constant"]:
-            return StateMutability.VIEW
-        else:  # Assume nonpayable if neither field is there, or constant/payable not set
-            return StateMutability.NONPAYABLE
-        # NOTE: The state mutability nonpayable is reflected in Solidity by not
-        #       specifying a state mutability modifier at all. Do the same here.
 
+@dataclass
+class PositionalArg(_FunctionArg):
+    ast_source: Optional[vy_ast.VyperNode] = None
 
-class ContractFunction(BaseTypeDefinition):
+
+@dataclass
+class KeywordArg(_FunctionArg):
+    default_value: vy_ast.VyperNode
+    ast_source: Optional[vy_ast.VyperNode] = None
+
+
+class ContractFunctionT(VyperType):
     """
     Contract function type.
 
     Functions compare false against all types and so cannot be assigned without
     being called. Calls are validated by `fetch_call_return`, check the call
-    arguments against `arguments`, and return `return_type`.
+    arguments against `positional_args` and `keyword_arg`, and return `return_type`.
 
     Attributes
     ----------
     name : str
         The name of the function.
-    arguments : OrderedDict
-        Function input arguments as {'name': BaseType}
-    min_arg_count : int
-        The minimum number of required input arguments.
-    max_arg_count : int
-        The maximum number of required input arguments. When a function has no
-        default arguments, this value is the same as `min_arg_count`.
-    kwarg_keys : List
-        List of optional input argument keys.
+    positional_args: list[PositionalArg]
+        Positional args for this function
+    keyword_args: list[KeywordArg]
+        Keyword args for this function
+    return_type: Optional[VyperType]
+        Type of return value
     function_visibility : FunctionVisibility
         enum indicating the external visibility of a function.
     state_mutability : StateMutability
         enum indicating the authority a function has to mutate it's own state.
-    nonreentrant : str
+    nonreentrant : Optional[str]
         Re-entrancy lock name.
     """
 
     _is_callable = True
 
     def __init__(
         self,
         name: str,
-        arguments: OrderedDict,
-        # TODO rename to something like positional_args, keyword_args
-        min_arg_count: int,
-        max_arg_count: int,
-        return_type: Optional[BaseTypeDefinition],
+        positional_args: list[PositionalArg],
+        keyword_args: list[KeywordArg],
+        return_type: Optional[VyperType],
         function_visibility: FunctionVisibility,
         state_mutability: StateMutability,
         nonreentrant: Optional[str] = None,
     ) -> None:
-        super().__init__(
-            # A function definition type only exists while compiling
-            DataLocation.UNSET,
-            # A function definition type is immutable once created
-            is_constant=True,
-            # A function definition type is public if it's visibility is public
-            is_public=(function_visibility == FunctionVisibility.EXTERNAL),
-        )
+        super().__init__()
+
         self.name = name
-        self.arguments = arguments
-        self.min_arg_count = min_arg_count
-        self.max_arg_count = max_arg_count
+        self.positional_args = positional_args
+        self.keyword_args = keyword_args
         self.return_type = return_type
-        self.kwarg_keys = []
-        if min_arg_count < max_arg_count:
-            self.kwarg_keys = list(self.arguments)[min_arg_count:]
         self.visibility = function_visibility
         self.mutability = state_mutability
         self.nonreentrant = nonreentrant
 
         # a list of internal functions this function calls
-        self.called_functions: Set["ContractFunction"] = set()
+        self.called_functions = OrderedSet()
 
+        # to be populated during codegen
+        self._ir_info: Any = None
+
+    @cached_property
+    def call_site_kwargs(self):
         # special kwargs that are allowed in call site
-        self.call_site_kwargs = {
-            "gas": KwargSettings(Uint256Definition(), "gas"),
-            "value": KwargSettings(Uint256Definition(), 0),
-            "skip_contract_check": KwargSettings(BoolDefinition(), False, require_literal=True),
-            "default_return_value": KwargSettings(return_type, None),
+        return {
+            "gas": KwargSettings(UINT256_T, "gas"),
+            "value": KwargSettings(UINT256_T, 0),
+            "skip_contract_check": KwargSettings(BoolT(), False, require_literal=True),
+            "default_return_value": KwargSettings(self.return_type, None),
         }
 
     def __repr__(self):
-        arg_types = ",".join(repr(a) for a in self.arguments.values())
+        arg_types = ",".join(repr(a) for a in self.argument_types)
         return f"contract function {self.name}({arg_types})"
 
+    def __str__(self):
+        ret_sig = "" if not self.return_type else f" -> {self.return_type}"
+        args_sig = ",".join([str(t) for t in self.argument_types])
+        return f"def {self.name} {args_sig}{ret_sig}:"
+
+    # override parent implementation. function type equality does not
+    # make too much sense.
+    def __eq__(self, other):
+        return self is other
+
+    def __hash__(self):
+        return hash(id(self))
+
     @classmethod
-    def from_abi(cls, abi: Dict) -> "ContractFunction":
+    def from_abi(cls, abi: Dict) -> "ContractFunctionT":
         """
-        Generate a `ContractFunction` object from an ABI interface.
+        Generate a `ContractFunctionT` object from an ABI interface.
 
         Arguments
         ---------
         abi : dict
             An object from a JSON ABI interface, representing a function.
 
         Returns
         -------
-        ContractFunction object.
+        ContractFunctionT object.
         """
-
-        arguments = OrderedDict()
+        positional_args = []
         for item in abi["inputs"]:
-            arguments[item["name"]] = get_type_from_abi(
-                item, location=DataLocation.CALLDATA, is_constant=True
-            )
+            positional_args.append(PositionalArg(item["name"], type_from_abi(item)))
         return_type = None
         if len(abi["outputs"]) == 1:
-            return_type = get_type_from_abi(
-                abi["outputs"][0], location=DataLocation.CALLDATA, is_constant=True
-            )
+            return_type = type_from_abi(abi["outputs"][0])
         elif len(abi["outputs"]) > 1:
-            return_type = TupleDefinition(
-                tuple(
-                    get_type_from_abi(i, location=DataLocation.CALLDATA, is_constant=True)
-                    for i in abi["outputs"]
-                )
-            )
+            return_type = TupleT(tuple(type_from_abi(i) for i in abi["outputs"]))
         return cls(
             abi["name"],
-            arguments,
-            len(arguments),
-            len(arguments),
+            positional_args,
+            [],
             return_type,
             function_visibility=FunctionVisibility.EXTERNAL,
             state_mutability=StateMutability.from_abi(abi),
         )
 
     @classmethod
     def from_FunctionDef(
         cls, node: vy_ast.FunctionDef, is_interface: Optional[bool] = False
-    ) -> "ContractFunction":
+    ) -> "ContractFunctionT":
         """
-        Generate a `ContractFunction` object from a `FunctionDef` node.
+        Generate a `ContractFunctionT` object from a `FunctionDef` node.
 
         Arguments
         ---------
         node : FunctionDef
             Vyper ast node to generate the function definition from.
         is_interface: bool, optional
             Boolean indicating if the function definition is part of an interface.
 
         Returns
         -------
-        ContractFunction
+        ContractFunctionT
         """
         kwargs: Dict[str, Any] = {}
         if is_interface:
             # FunctionDef with stateMutability in body (Interface defintions)
             if (
                 len(node.body) == 1
                 and isinstance(node.body[0], vy_ast.Expr)
@@ -219,18 +195,16 @@
                 )
             else:
                 raise StructureException(
                     "Body must only contain state mutability label", node.body[0]
                 )
 
         else:
-
             # FunctionDef with decorators (normal functions)
             for decorator in node.decorator_list:
-
                 if isinstance(decorator, vy_ast.Call):
                     if "nonreentrant" in kwargs:
                         raise StructureException(
                             "nonreentrant decorator is already set with key: "
                             f"{kwargs['nonreentrant']}",
                             node,
                         )
@@ -296,192 +270,251 @@
         if "state_mutability" not in kwargs:
             # Assume nonpayable if not set at all (cannot accept Ether, but can modify state)
             kwargs["state_mutability"] = StateMutability.NONPAYABLE
 
         if kwargs["state_mutability"] == StateMutability.PURE and "nonreentrant" in kwargs:
             raise StructureException("Cannot use reentrancy guard on pure functions", node)
 
-        # call arguments
-        if node.args.defaults and node.name == "__init__":
-            raise FunctionDeclarationException(
-                "Constructor may not use default arguments", node.args.defaults[0]
-            )
+        if node.name == "__init__":
+            if (
+                kwargs["state_mutability"] in (StateMutability.PURE, StateMutability.VIEW)
+                or kwargs["function_visibility"] == FunctionVisibility.INTERNAL
+            ):
+                raise FunctionDeclarationException(
+                    "Constructor cannot be marked as `@pure`, `@view` or `@internal`", node
+                )
 
-        arguments = OrderedDict()
-        max_arg_count = len(node.args.args)
-        min_arg_count = max_arg_count - len(node.args.defaults)
-        defaults = [None] * min_arg_count + node.args.defaults
-
-        namespace = get_namespace()
-        for arg, value in zip(node.args.args, defaults):
-            if arg.arg in ("gas", "value", "skip_contract_check", "default_return_value"):
+            # call arguments
+            if node.args.defaults:
+                raise FunctionDeclarationException(
+                    "Constructor may not use default arguments", node.args.defaults[0]
+                )
+
+        argnames = set()  # for checking uniqueness
+        n_total_args = len(node.args.args)
+        n_positional_args = n_total_args - len(node.args.defaults)
+
+        positional_args: list[PositionalArg] = []
+        keyword_args: list[KeywordArg] = []
+
+        for i, arg in enumerate(node.args.args):
+            argname = arg.arg
+            if argname in ("gas", "value", "skip_contract_check", "default_return_value"):
                 raise ArgumentException(
-                    f"Cannot use '{arg.arg}' as a variable name in a function input", arg
+                    f"Cannot use '{argname}' as a variable name in a function input", arg
                 )
-            if arg.arg in arguments:
-                raise ArgumentException(f"Function contains multiple inputs named {arg.arg}", arg)
-            if arg.arg in namespace:
-                raise NamespaceCollision(arg.arg, arg)
+            if argname in argnames:
+                raise ArgumentException(f"Function contains multiple inputs named {argname}", arg)
 
             if arg.annotation is None:
-                raise ArgumentException(f"Function argument '{arg.arg}' is missing a type", arg)
+                raise ArgumentException(f"Function argument '{argname}' is missing a type", arg)
 
-            type_definition = get_type_from_annotation(
-                arg.annotation, location=DataLocation.CALLDATA, is_constant=True
-            )
-            if value is not None:
+            type_ = type_from_annotation(arg.annotation, DataLocation.CALLDATA)
+
+            if i < n_positional_args:
+                positional_args.append(PositionalArg(argname, type_, ast_source=arg))
+            else:
+                value = node.args.defaults[i - n_positional_args]
                 if not check_kwargable(value):
                     raise StateAccessViolation(
                         "Value must be literal or environment variable", value
                     )
-                validate_expected_type(value, type_definition)
+                validate_expected_type(value, type_)
+                keyword_args.append(KeywordArg(argname, type_, value, ast_source=arg))
 
-            arguments[arg.arg] = type_definition
+            argnames.add(argname)
 
         # return types
         if node.returns is None:
             return_type = None
         elif node.name == "__init__":
             raise FunctionDeclarationException(
                 "Constructor may not have a return type", node.returns
             )
-        elif isinstance(node.returns, (vy_ast.Name, vy_ast.Call, vy_ast.Subscript)):
-            return_type = get_type_from_annotation(node.returns, location=DataLocation.MEMORY)
-        elif isinstance(node.returns, vy_ast.Tuple):
-            tuple_types: Tuple = ()
-            for n in node.returns.elements:
-                tuple_types += (get_type_from_annotation(n, location=DataLocation.MEMORY),)
-            return_type = TupleDefinition(tuple_types)
+        elif isinstance(node.returns, (vy_ast.Name, vy_ast.Subscript, vy_ast.Tuple)):
+            # note: consider, for cleanliness, adding DataLocation.RETURN_VALUE
+            return_type = type_from_annotation(node.returns, DataLocation.MEMORY)
         else:
             raise InvalidType("Function return value must be a type name or tuple", node.returns)
 
-        return cls(node.name, arguments, min_arg_count, max_arg_count, return_type, **kwargs)
+        return cls(node.name, positional_args, keyword_args, return_type, **kwargs)
 
     def set_reentrancy_key_position(self, position: StorageSlot) -> None:
         if hasattr(self, "reentrancy_key_position"):
             raise CompilerPanic("Position was already assigned")
         if self.nonreentrant is None:
             raise CompilerPanic(f"No reentrant key {self}")
         # sanity check even though implied by the type
         if position._location != DataLocation.STORAGE:
             raise CompilerPanic("Non-storage reentrant key")
         self.reentrancy_key_position = position
 
     @classmethod
-    def getter_from_VariableDecl(cls, node: vy_ast.VariableDecl) -> "ContractFunction":
+    def getter_from_VariableDecl(cls, node: vy_ast.VariableDecl) -> "ContractFunctionT":
         """
-        Generate a `ContractFunction` object from an `VariableDecl` node.
+        Generate a `ContractFunctionT` object from an `VariableDecl` node.
 
         Used to create getter functions for public variables.
 
         Arguments
         ---------
         node : VariableDecl
             Vyper ast node to generate the function definition from.
 
         Returns
         -------
-        ContractFunction
+        ContractFunctionT
         """
         if not node.is_public:
             raise CompilerPanic("getter generated for non-public function")
-        location = DataLocation.CODE if node.is_immutable else DataLocation.STORAGE
-        type_ = get_type_from_annotation(node.annotation, location=location)
-        arguments, return_type = type_.get_signature()
-        args_dict: OrderedDict = OrderedDict()
-        for item in arguments:
-            args_dict[f"arg{len(args_dict)}"] = item
+        type_ = type_from_annotation(node.annotation, DataLocation.STORAGE)
+        arguments, return_type = type_.getter_signature
+        args = []
+        for i, item in enumerate(arguments):
+            args.append(PositionalArg(f"arg{i}", item))
+
         return cls(
             node.target.id,
-            args_dict,
-            len(arguments),
-            len(arguments),
+            args,
+            [],
             return_type,
             function_visibility=FunctionVisibility.EXTERNAL,
             state_mutability=StateMutability.VIEW,
         )
 
     @property
+    # convenience property for compare_signature, as it would
+    # appear in a public interface
+    def _iface_sig(self) -> Tuple[Tuple, Optional[VyperType]]:
+        return tuple(self.argument_types), self.return_type
+
+    def implements(self, other: "ContractFunctionT") -> bool:
+        """
+        Checks if this function implements the signature of another
+        function.
+
+        Used when determining if an interface has been implemented. This method
+        should not be directly implemented by any inherited classes.
+        """
+
+        if not self.is_external:
+            return False
+
+        arguments, return_type = self._iface_sig
+        other_arguments, other_return_type = other._iface_sig
+
+        if len(arguments) != len(other_arguments):
+            return False
+        for atyp, btyp in zip(arguments, other_arguments):
+            if not atyp.compare_type(btyp):
+                return False
+
+        if return_type and not return_type.compare_type(other_return_type):  # type: ignore
+            return False
+
+        if self.mutability > other.mutability:
+            return False
+
+        return True
+
+    @cached_property
+    def default_values(self) -> dict[str, vy_ast.VyperNode]:
+        return {arg.name: arg.default_value for arg in self.keyword_args}
+
+    # for backwards compatibility
+    @cached_property
+    def arguments(self) -> list[_FunctionArg]:
+        return self.positional_args + self.keyword_args  # type: ignore
+
+    @cached_property
+    def argument_types(self) -> list[VyperType]:
+        return [arg.typ for arg in self.arguments]
+
+    @property
+    def n_positional_args(self) -> int:
+        return len(self.positional_args)
+
+    @property
+    def n_keyword_args(self) -> int:
+        return len(self.keyword_args)
+
+    @cached_property
+    def n_total_args(self) -> int:
+        return self.n_positional_args + self.n_keyword_args
+
+    @property
     def is_external(self) -> bool:
         return self.visibility == FunctionVisibility.EXTERNAL
 
     @property
     def is_internal(self) -> bool:
         return self.visibility == FunctionVisibility.INTERNAL
 
     @property
+    def is_mutable(self) -> bool:
+        return self.mutability > StateMutability.VIEW
+
+    @property
+    def is_payable(self) -> bool:
+        return self.mutability == StateMutability.PAYABLE
+
+    @property
+    def is_constructor(self) -> bool:
+        return self.name == "__init__"
+
+    @property
+    def is_fallback(self) -> bool:
+        return self.name == "__default__"
+
+    @property
     def method_ids(self) -> Dict[str, int]:
         """
         Dict of `{signature: four byte selector}` for this function.
 
         * For functions without default arguments the dict contains one item.
         * For functions with default arguments, there is one key for each
           function signature.
         """
-        arg_types = [i.canonical_abi_type for i in self.arguments.values()]
+        arg_types = [i.canonical_abi_type for i in self.argument_types]
 
-        if not self.has_default_args:
+        if self.n_keyword_args == 0:
             return _generate_method_id(self.name, arg_types)
 
         method_ids = {}
-        for i in range(self.min_arg_count, self.max_arg_count + 1):
+        for i in range(self.n_positional_args, self.n_total_args + 1):
             method_ids.update(_generate_method_id(self.name, arg_types[:i]))
         return method_ids
 
-    # for caller-fills-args calling convention
-    def get_args_buffer_offset(self) -> int:
-        """
-        Get the location of the args buffer in the function frame (caller sets)
-        """
-        return 0
-
-    # TODO is this needed?
-    def get_args_buffer_len(self) -> int:
-        """
-        Get the length of the argument buffer in the function frame
-        """
-        return sum(arg_t.size_in_bytes() for arg_t in self.arguments.values())
-
-    @property
-    def is_constructor(self) -> bool:
-        return self.name == "__init__"
-
-    @property
-    def is_fallback(self) -> bool:
-        return self.name == "__default__"
-
-    @property
-    def has_default_args(self) -> bool:
-        return self.min_arg_count < self.max_arg_count
-
-    def get_signature(self) -> Tuple[Tuple, Optional[BaseTypeDefinition]]:
-        return tuple(self.arguments.values()), self.return_type
-
-    def fetch_call_return(self, node: vy_ast.Call) -> Optional[BaseTypeDefinition]:
+    def fetch_call_return(self, node: vy_ast.Call) -> Optional[VyperType]:
         if node.get("func.value.id") == "self" and self.visibility == FunctionVisibility.EXTERNAL:
             raise CallViolation("Cannot call external functions via 'self'", node)
 
         # for external calls, include gas and value as optional kwargs
-        kwarg_keys = self.kwarg_keys.copy()
-        if node.get("func.value.id") != "self":
+        kwarg_keys = [arg.name for arg in self.keyword_args]
+        if not self.is_internal:
             kwarg_keys += list(self.call_site_kwargs.keys())
-        validate_call_args(node, (self.min_arg_count, self.max_arg_count), kwarg_keys)
+        validate_call_args(node, (self.n_positional_args, self.n_total_args), kwarg_keys)
 
         if self.mutability < StateMutability.PAYABLE:
             kwarg_node = next((k for k in node.keywords if k.arg == "value"), None)
             if kwarg_node is not None:
                 raise CallViolation("Cannot send ether to nonpayable function", kwarg_node)
 
-        for arg, expected in zip(node.args, self.arguments.values()):
+        for arg, expected in zip(node.args, self.argument_types):
             validate_expected_type(arg, expected)
 
         # TODO this should be moved to validate_call_args
         for kwarg in node.keywords:
             if kwarg.arg in self.call_site_kwargs:
                 kwarg_settings = self.call_site_kwargs[kwarg.arg]
+                if kwarg.arg == "default_return_value" and self.return_type is None:
+                    raise ArgumentException(
+                        f"`{kwarg.arg}=` specified but {self.name}() does not return anything",
+                        kwarg.value,
+                    )
                 validate_expected_type(kwarg.value, kwarg_settings.typ)
                 if kwarg_settings.require_literal:
                     if not isinstance(kwarg.value, vy_ast.Constant):
                         raise InvalidType(
                             f"{kwarg.arg} must be literal {kwarg_settings.typ}", kwarg.value
                         )
             else:
@@ -504,49 +537,54 @@
                         + f". {error_suggestion}"
                     ),
                     kwarg,
                 )
 
         return self.return_type
 
-    def to_abi_dict(self):
+    def to_toplevel_abi_dict(self):
         abi_dict: Dict = {"stateMutability": self.mutability.value}
 
         if self.is_fallback:
             abi_dict["type"] = "fallback"
             return [abi_dict]
 
         if self.is_constructor:
             abi_dict["type"] = "constructor"
         else:
             abi_dict["type"] = "function"
             abi_dict["name"] = self.name
 
-        abi_dict["inputs"] = [v.to_abi_dict(name=k) for k, v in self.arguments.items()]
+        abi_dict["inputs"] = [arg.typ.to_abi_arg(name=arg.name) for arg in self.arguments]
 
         typ = self.return_type
         if typ is None:
             abi_dict["outputs"] = []
-        elif isinstance(typ, TupleDefinition) and len(typ.value_type) > 1:  # type: ignore
-            abi_dict["outputs"] = [t.to_abi_dict() for t in typ.value_type]  # type: ignore
+        elif isinstance(typ, TupleT) and len(typ.member_types) > 1:
+            abi_dict["outputs"] = [t.to_abi_arg() for t in typ.member_types]
         else:
-            abi_dict["outputs"] = [typ.to_abi_dict()]
+            abi_dict["outputs"] = [typ.to_abi_arg()]
 
-        if self.has_default_args:
+        if self.n_keyword_args > 0:
             # for functions with default args, return a dict for each possible arg count
             result = []
-            for i in range(self.min_arg_count, self.max_arg_count + 1):
+            for i in range(self.n_positional_args, self.n_total_args + 1):
                 result.append(abi_dict.copy())
                 result[-1]["inputs"] = result[-1]["inputs"][:i]
             return result
         else:
             return [abi_dict]
 
+    # calculate the abi signature for a given set of kwargs
+    def abi_signature_for_kwargs(self, kwargs: list[KeywordArg]) -> str:
+        args = self.positional_args + kwargs  # type: ignore
+        return self.name + "(" + ",".join([arg.typ.abi_type.selector_name() for arg in args]) + ")"
+
 
-class MemberFunctionDefinition(BaseTypeDefinition):
+class MemberFunctionT(VyperType):
     """
     Member function type definition.
 
     This class has no corresponding primitive.
 
     (examples for (x <DynArray[int128, 3]>).append(1))
 
@@ -555,33 +593,38 @@
         name: the name of this method. ex. "append"
         arg_types: the argument types this method accepts. ex. [int128]
         return_type: the return type of this method. ex. None
     """
 
     _is_callable = True
 
+    # keep LGTM linter happy
+    def __eq__(self, other):
+        return super().__eq__(other)
+
     def __init__(
         self,
-        underlying_type: BaseTypeDefinition,
+        underlying_type: VyperType,
         name: str,
-        arg_types: List[BaseTypeDefinition],
-        return_type: Optional[BaseTypeDefinition],
+        arg_types: List[VyperType],
+        return_type: Optional[VyperType],
         is_modifying: bool,
     ) -> None:
-        super().__init__(DataLocation.UNSET)
+        super().__init__()
+
         self.underlying_type = underlying_type
         self.name = name
         self.arg_types = arg_types
         self.return_type = return_type
         self.is_modifying = is_modifying
 
     def __repr__(self):
         return f"{self.underlying_type._id} member function '{self.name}'"
 
-    def fetch_call_return(self, node: vy_ast.Call) -> Optional[BaseTypeDefinition]:
+    def fetch_call_return(self, node: vy_ast.Call) -> Optional[VyperType]:
         validate_call_args(node, len(self.arg_types))
 
         assert len(node.args) == len(self.arg_types)  # validate_call_args postcondition
         for arg, expected_type in zip(node.args, self.arg_types):
             # CMC 2022-04-01 this should probably be in the validation module
             validate_expected_type(arg, expected_type)
```

### Comparing `vyper-0.3.7/vyper/semantics/types/indexable/sequence.py` & `vyper-0.3.8/vyper/semantics/types/subscriptable.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,316 +1,369 @@
+import warnings
 from typing import Any, Dict, Optional, Tuple, Union
 
 from vyper import ast as vy_ast
 from vyper.abi_types import ABI_DynamicArray, ABI_StaticArray, ABI_Tuple, ABIType
 from vyper.exceptions import ArrayIndexException, InvalidType, StructureException
-from vyper.semantics import validation
-from vyper.semantics.types.abstract import IntegerAbstractType
-from vyper.semantics.types.bases import (
-    BasePrimitive,
-    BaseTypeDefinition,
-    DataLocation,
-    IndexableTypeDefinition,
-    MemberTypeDefinition,
-)
-from vyper.semantics.types.value.numeric import Uint256Definition  # type: ignore
+from vyper.semantics.data_locations import DataLocation
+from vyper.semantics.types.base import VyperType
+from vyper.semantics.types.primitives import IntegerT
+from vyper.semantics.types.shortcuts import UINT256_T
+from vyper.semantics.types.utils import get_index_value, type_from_annotation
 
 
-class _SequenceDefinition(IndexableTypeDefinition):
+class _SubscriptableT(VyperType):
     """
-    Private base class for sequence types.
+    Base class for subscriptable types such as arrays and mappings.
+
+    Attributes
+    ----------
+    key_type: VyperType
+        Type representing the index for this object.
+    value_type : VyperType
+        Type representing the value(s) contained in this object.
+    """
+
+    def __init__(self, key_type: VyperType, value_type: VyperType) -> None:
+        super().__init__()
+        self.key_type = key_type
+        self.value_type = value_type
+
+    @property
+    def getter_signature(self) -> Tuple[Tuple, Optional[VyperType]]:
+        child_keys, return_type = self.value_type.getter_signature
+        return (self.key_type,) + child_keys, return_type
+
+    def validate_index_type(self, node):
+        # TODO: break this cycle
+        from vyper.semantics.analysis.utils import validate_expected_type
+
+        validate_expected_type(node, self.key_type)
+
+
+class HashMapT(_SubscriptableT):
+    _id = "HashMap"
+
+    _equality_attrs = ("key_type", "value_type")
+
+    # disallow everything but storage
+    _invalid_locations = (
+        DataLocation.UNSET,
+        DataLocation.CALLDATA,
+        DataLocation.CODE,
+        DataLocation.MEMORY,
+    )
+
+    def __repr__(self):
+        return f"HashMap[{self.key_type}, {self.value_type}]"
+
+    # TODO not sure this is used?
+    def compare_type(self, other):
+        return (
+            super().compare_type(other)
+            and self.key_type == other.key_type
+            and self.value_type == other.value_type
+        )
+
+    def get_subscripted_type(self, node):
+        return self.value_type
+
+    @classmethod
+    def from_annotation(cls, node: Union[vy_ast.Name, vy_ast.Call, vy_ast.Subscript]) -> "HashMapT":
+        if (
+            not isinstance(node, vy_ast.Subscript)
+            or not isinstance(node.slice, vy_ast.Index)
+            or not isinstance(node.slice.value, vy_ast.Tuple)
+            or len(node.slice.value.elements) != 2
+        ):
+            raise StructureException(
+                (
+                    "HashMap must be defined with a key type and a value type, "
+                    "e.g. my_hashmap: HashMap[k, v]"
+                ),
+                node,
+            )
+
+        k_ast, v_ast = node.slice.value.elements
+        key_type = type_from_annotation(k_ast, DataLocation.STORAGE)
+        if not key_type._as_hashmap_key:
+            raise InvalidType("can only use primitive types as HashMap key!", k_ast)
+
+        value_type = type_from_annotation(v_ast, DataLocation.STORAGE)
+
+        return cls(key_type, value_type)
+
+
+class _SequenceT(_SubscriptableT):
+    """
+    Private base class for sequence types (i.e., index is an int)
 
     Arguments
     ---------
     length : int
         Number of items in the type.
     """
 
-    def __init__(
-        self,
-        value_type: BaseTypeDefinition,
-        length: int,
-        _id: str,
-        location: DataLocation = DataLocation.UNSET,
-        is_constant: bool = False,
-        is_public: bool = False,
-        is_immutable: bool = False,
-    ) -> None:
-        if not 0 < length < 2 ** 256:
+    _equality_attrs: tuple = ("value_type", "length")
+
+    _is_array_type: bool = True
+
+    def __init__(self, value_type: VyperType, length: int):
+        if not 0 < length < 2**256:
             raise InvalidType("Array length is invalid")
-        super().__init__(
-            value_type,
-            IntegerAbstractType(),  # type: ignore
-            _id,
-            location=location,
-            is_constant=is_constant,
-            is_public=is_public,
-            is_immutable=is_immutable,
-        )
+
+        if length >= 2**64:
+            warnings.warn("Use of large arrays can be unsafe!")
+
+        super().__init__(UINT256_T, value_type)
         self.length = length
 
-    def get_signature(self) -> Tuple[Tuple, Optional[BaseTypeDefinition]]:
-        # override the default behavior to return `Uint256Definition`
-        # an external interface cannot use `IntegerAbstractType` because
-        # abstract types have no canonical type
-        new_args, return_type = self.value_type.get_signature()
-        return (Uint256Definition(),) + new_args, return_type
-
-    def get_index_type(self) -> BaseTypeDefinition:
-        # override the default behaviour to return `Uint256Definition` for
-        # type annotation
-        return Uint256Definition()
+    @property
+    def count(self):
+        """
+        Alias for API compatibility
+        """
+        return self.length
+
+    def validate_index_type(self, node):
+        # TODO break this cycle
+        from vyper.semantics.analysis.utils import validate_expected_type
+
+        if isinstance(node, vy_ast.Int):
+            if node.value < 0:
+                raise ArrayIndexException("Vyper does not support negative indexing", node)
+            if node.value >= self.length:
+                raise ArrayIndexException("Index out of range", node)
+
+        validate_expected_type(node, IntegerT.any())
+
+    def get_subscripted_type(self, node):
+        return self.value_type
 
 
 # override value at `k` with `val`, but inserting it before other keys
 # for formatting reasons. besides insertion order, equivalent to
 # `{k: val, **xs}`
 def _set_first_key(xs: Dict[str, Any], k: str, val: Any) -> dict:
     xs.pop(k, None)
     return {k: val, **xs}
 
 
-# TODO rename me to StaticArrayDefinition?
-class ArrayDefinition(_SequenceDefinition):
+class SArrayT(_SequenceT):
     """
-    Array type definition.
-
-    This class has no corresponding primitive. It is initialized
-    during `context.types.utils.get_type_from_annotation`
+    Static array type
     """
 
-    def __init__(
-        self,
-        value_type: BaseTypeDefinition,
-        length: int,
-        location: DataLocation = DataLocation.UNSET,
-        is_constant: bool = False,
-        is_public: bool = False,
-        is_immutable: bool = False,
-    ) -> None:
-        super().__init__(
-            value_type,
-            length,
-            f"{value_type}[{length}]",
-            location,
-            is_constant,
-            is_public,
-            is_immutable,
-        )
+    def __init__(self, value_type: VyperType, length: int) -> None:
+        super().__init__(value_type, length)
 
     def __repr__(self):
         return f"{self.value_type}[{self.length}]"
 
     @property
+    def _as_array(self):
+        # a static array is arrayable if its value_type is arrayble.
+        return self.value_type._as_array
+
+    @property
     def abi_type(self) -> ABIType:
         return ABI_StaticArray(self.value_type.abi_type, self.length)
 
-    def to_abi_dict(self, name: str = "") -> Dict[str, Any]:
-        ret = self.value_type.to_abi_dict()
+    def to_abi_arg(self, name: str = "") -> Dict[str, Any]:
+        ret = self.value_type.to_abi_arg()
         # modify the child name in place
         ret["type"] += f"[{self.length}]"
         return _set_first_key(ret, "name", name)
 
-    @property
-    def is_dynamic_size(self):
-        return self.value_type.is_dynamic_size
-
+    # TODO rename to `memory_bytes_required`
     @property
     def size_in_bytes(self):
         return self.value_type.size_in_bytes * self.length
 
-    def validate_index_type(self, node):
-        if isinstance(node, vy_ast.Int):
-            if node.value < 0:
-                raise ArrayIndexException("Vyper does not support negative indexing", node)
-            if node.value >= self.length:
-                raise ArrayIndexException("Index out of range", node)
-
-        validation.utils.validate_expected_type(node, IntegerAbstractType())
+    @property
+    def subtype(self):
+        """
+        Alias for API compatibility with codegen
+        """
+        return self.value_type
 
     def get_subscripted_type(self, node):
         return self.value_type
 
     def compare_type(self, other):
         if not isinstance(self, type(other)):
             return False
         if self.length != other.length:
             return False
         return self.value_type.compare_type(other.value_type)
 
+    @classmethod
+    def from_annotation(cls, node: vy_ast.Subscript) -> "SArrayT":
+        if not isinstance(node, vy_ast.Subscript) or not isinstance(node.slice, vy_ast.Index):
+            raise StructureException(
+                "Arrays must be defined with base type and length, e.g. bool[5]", node
+            )
+
+        value_type = type_from_annotation(node.value)
+
+        if not value_type._as_array:
+            raise StructureException(f"arrays of {value_type} are not allowed!")
+
+        # note: validates index is a vy_ast.Int.
+        length = get_index_value(node.slice)
+        return cls(value_type, length)
 
-class DynamicArrayDefinition(_SequenceDefinition, MemberTypeDefinition):
+
+class DArrayT(_SequenceT):
     """
-    Dynamic array type definition.
+    Dynamic array type
     """
 
-    def __init__(
-        self,
-        value_type: BaseTypeDefinition,
-        length: int,
-        location: DataLocation = DataLocation.UNSET,
-        is_constant: bool = False,
-        is_public: bool = False,
-        is_immutable: bool = False,
-    ) -> None:
+    _valid_literal = (vy_ast.List,)
+    _as_array = True
+    _id = "DynArray"
 
-        super().__init__(
-            value_type, length, "DynArray", location, is_constant, is_public, is_immutable
-        )
+    def __init__(self, value_type: VyperType, length: int) -> None:
+        super().__init__(value_type, length)
 
-        # Adding members here as otherwise MemberFunctionDefinition is not yet defined
-        # if added as _type_members
-        from vyper.semantics.types.function import MemberFunctionDefinition
+        from vyper.semantics.types.function import MemberFunctionT
 
-        self.add_member(
-            "append", MemberFunctionDefinition(self, "append", [self.value_type], None, True)
-        )
-        self.add_member("pop", MemberFunctionDefinition(self, "pop", [], self.value_type, True))
+        self.add_member("append", MemberFunctionT(self, "append", [self.value_type], None, True))
+        self.add_member("pop", MemberFunctionT(self, "pop", [], self.value_type, True))
 
     def __repr__(self):
         return f"DynArray[{self.value_type}, {self.length}]"
 
     @property
+    def subtype(self):
+        """
+        Alias for backwards compatibility.
+        """
+        return self.value_type
+
+    @property
+    def count(self):
+        """
+        Alias for backwards compatibility.
+        """
+        return self.length
+
+    @property
     def abi_type(self) -> ABIType:
         return ABI_DynamicArray(self.value_type.abi_type, self.length)
 
-    def to_abi_dict(self, name: str = "") -> Dict[str, Any]:
-        ret = self.value_type.to_abi_dict()
+    def to_abi_arg(self, name: str = "") -> Dict[str, Any]:
+        ret = self.value_type.to_abi_arg()
         # modify the child name in place.
         ret["type"] += "[]"
         return _set_first_key(ret, "name", name)
 
-    @property
-    def is_dynamic_size(self):
-        return True
-
     # TODO rename me to memory_bytes_required
     @property
     def size_in_bytes(self):
         # one length word + size of the array items
         return 32 + self.value_type.size_in_bytes * self.length
 
-    def validate_index_type(self, node):
-        if isinstance(node, vy_ast.Int):
-            if node.value < 0:
-                raise ArrayIndexException("Vyper does not support negative indexing", node)
-            if node.value >= self.length:
-                raise ArrayIndexException("Index out of range", node)
-        else:
-            validation.utils.validate_expected_type(node, IntegerAbstractType())
-
-    def get_subscripted_type(self, node):
-        return self.value_type
-
     def compare_type(self, other):
         # TODO allow static array to be assigned to dyn array?
-        # if not isinstance(other, (DynamicArrayDefinition, ArrayDefinition)):
+        # if not isinstance(other, (DArrayT, SArrayT)):
         if not isinstance(self, type(other)):
             return False
         if self.length < other.length:
             return False
         return self.value_type.compare_type(other.value_type)
 
-    def fetch_call_return(self, node: vy_ast.Call) -> None:
-        pass
-
-
-class DynamicArrayPrimitive(BasePrimitive):
-    _id = "DynArray"
-    _type = DynamicArrayDefinition
-    _valid_literal = (vy_ast.List,)
-    _as_array = True
-
     @classmethod
-    def from_annotation(
-        cls,
-        node: Union[vy_ast.Name, vy_ast.Call, vy_ast.Subscript],
-        location: DataLocation = DataLocation.UNSET,
-        is_constant: bool = False,
-        is_public: bool = False,
-        is_immutable: bool = False,
-    ) -> DynamicArrayDefinition:
-        # TODO fix circular import
-        from vyper.semantics.types.utils import get_type_from_annotation
-
+    def from_annotation(cls, node: vy_ast.Subscript) -> "DArrayT":
         if (
             not isinstance(node, vy_ast.Subscript)
             or not isinstance(node.slice, vy_ast.Index)
             or not isinstance(node.slice.value, vy_ast.Tuple)
             or not isinstance(node.slice.value.elements[1], vy_ast.Int)
             or len(node.slice.value.elements) != 2
         ):
             raise StructureException(
                 "DynArray must be defined with base type and max length, e.g. DynArray[bool, 5]",
                 node,
             )
 
-        value_type = get_type_from_annotation(
-            node.slice.value.elements[0], location, is_constant, is_public, is_immutable
-        )
+        value_type = type_from_annotation(node.slice.value.elements[0])
+        if not value_type._as_darray:
+            raise StructureException(f"Arrays of {value_type} are not allowed", node)
 
         max_length = node.slice.value.elements[1].value
-        return DynamicArrayDefinition(
-            value_type, max_length, location, is_constant, is_public, is_immutable
-        )
+        return cls(value_type, max_length)
 
 
-class TupleDefinition(_SequenceDefinition):
+class TupleT(VyperType):
     """
     Tuple type definition.
 
-    This class has no corresponding primitive. It is used to represent
-    multiple return values from `types.function.ContractFunction`.
+    This class is used to represent multiple return values from functions.
     """
 
-    def __init__(self, value_type: Tuple[BaseTypeDefinition, ...]) -> None:
-        # always use the most restrictive location re: modification
-        location = sorted((i.location for i in value_type), key=lambda k: k.value)[-1]
-        is_constant = any((getattr(i, "is_constant", False) for i in value_type))
-        super().__init__(
-            # TODO fix the typing on value_type
-            value_type,  # type: ignore
-            len(value_type),
-            f"{value_type}",
-            location,
-            is_constant,
-        )
+    _equality_attrs = ("members",)
 
-        # fixes mypy error, TODO revisit typing on value_type
-        self._member_types = value_type
+    # note: docs say that tuples are not instantiable but they
+    # are in fact instantiable and the codegen works. if we
+    # wanted to be stricter in the typechecker, we could
+    # add _invalid_locations = everything but UNSET and RETURN_VALUE.
+    # (we would need to add a DataLocation.RETURN_VALUE in order for
+    # tuples to be instantiable as return values but not in memory).
+    # _invalid_locations = ...
+
+    def __init__(self, member_types: Tuple[VyperType, ...]) -> None:
+        super().__init__()
+        self.member_types = member_types
+        self.key_type = UINT256_T  # API Compatibility
 
     def __repr__(self):
-        return self._id
+        return "(" + ", ".join(repr(t) for t in self.member_types) + ")"
 
     @property
-    def is_dynamic_size(self):
-        return any(t.is_dynamic_size for t in self.value_type)
+    def length(self):
+        return len(self.member_types)
+
+    def tuple_members(self):
+        return [v for (_k, v) in self.tuple_items()]
+
+    def tuple_keys(self):
+        return [k for (k, _v) in self.tuple_items()]
+
+    def tuple_items(self):
+        return list(enumerate(self.member_types))
+
+    @classmethod
+    def from_annotation(cls, node: vy_ast.Tuple) -> VyperType:
+        values = node.elements
+        types = tuple(type_from_annotation(v) for v in values)
+        return cls(types)
 
     @property
     def abi_type(self) -> ABIType:
-        return ABI_Tuple([t.abi_type for t in self._member_types])
+        return ABI_Tuple([t.abi_type for t in self.member_types])
 
-    def to_abi_dict(self, name: str = "") -> dict:
-        components = [t.to_abi_dict() for t in self._member_types]
+    def to_abi_arg(self, name: str = "") -> dict:
+        components = [t.to_abi_arg() for t in self.member_types]
         return {"name": name, "type": "tuple", "components": components}
 
     @property
     def size_in_bytes(self):
-        return sum(i.size_in_bytes for i in self.value_type)
+        return sum(i.size_in_bytes for i in self.member_types)
 
     def validate_index_type(self, node):
         if not isinstance(node, vy_ast.Int):
             raise InvalidType("Tuple indexes must be literals", node)
         if node.value < 0:
             raise ArrayIndexException("Vyper does not support negative indexing", node)
         if node.value >= self.length:
             raise ArrayIndexException("Index out of range", node)
 
     def get_subscripted_type(self, node):
-        return self.value_type[node.value]
+        return self.member_types[node.value]
 
     def compare_type(self, other):
         if not isinstance(self, type(other)):
             return False
         if self.length != other.length:
             return False
-        return all(self.value_type[i].compare_type(other.value_type[i]) for i in range(self.length))
+        return all(a.compare_type(b) for (a, b) in zip(self.member_types, other.member_types))
```

### Comparing `vyper-0.3.7/vyper/semantics/types/value/array_value.py` & `vyper-0.3.8/vyper/semantics/types/bytestrings.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,20 +1,16 @@
-from typing import Type
-
 from vyper import ast as vy_ast
 from vyper.abi_types import ABI_Bytes, ABI_String, ABIType
-from vyper.exceptions import CompilerPanic, StructureException, UnexpectedValue
-from vyper.semantics import validation
+from vyper.exceptions import CompilerPanic, StructureException, UnexpectedNodeType, UnexpectedValue
+from vyper.semantics.types.base import VyperType
+from vyper.semantics.types.utils import get_index_value
 from vyper.utils import ceil32
 
-from ..abstract import ArrayValueAbstractType, BytesAbstractType
-from ..bases import BasePrimitive, DataLocation, ValueTypeDefinition
-
 
-class _ArrayValueDefinition(ValueTypeDefinition):
+class _BytestringT(VyperType):
     """
     Private base class for single-value types which occupy multiple memory slots
     and where a maximum length must be given via a subscript (string, bytes).
 
     Types for literals have an inferred minimum length. For example, `b"hello"`
     has a length of 5 of more and so can be used in an operation with `bytes[5]`
     or `bytes[10]`, but not `bytes[4]`. Upon comparison to a fixed length type,
@@ -26,41 +22,55 @@
     _length : int
         The maximum allowable length of the data within the type.
     _min_length: int
         The minimum length of the data within the type. Used when the type
         is applied to a literal definition.
     """
 
-    is_dynamic_size = True
+    # this is a carveout because currently we allow dynamic arrays of
+    # bytestrings, but not static arrays of bytestrings
+    _as_darray = True
+    _as_hashmap_key = True
+    _equality_attrs = ("_length", "_min_length")
+    _is_bytestring: bool = True
 
-    def __repr__(self):
-        return f"{self._id}[{self.length}]"
+    def __init__(self, length: int = 0) -> None:
+        super().__init__()
 
-    def __init__(
-        self,
-        length: int = 0,
-        location: DataLocation = DataLocation.MEMORY,
-        is_constant: bool = False,
-        is_public: bool = False,
-        is_immutable: bool = False,
-    ) -> None:
-        super().__init__(location, is_constant, is_public, is_immutable)
         self._length = length
         self._min_length = length
 
+    def __repr__(self):
+        return f"{self._id}[{self.length}]"
+
     @property
     def length(self):
         """
         Property method used to check the length of a type.
         """
         if self._length:
             return self._length
         return self._min_length
 
     @property
+    def maxlen(self):
+        """
+        Alias for backwards compatibility.
+        """
+        return self.length
+
+    def validate_literal(self, node: vy_ast.Constant) -> None:
+        super().validate_literal(node)
+
+        if len(node.value) != self.length:
+            # should always be constructed with correct length
+            # at the point that validate_literal is calle.d
+            raise CompilerPanic("unreachable")
+
+    @property
     def size_in_bytes(self):
         # the first slot (32 bytes) stores the actual length, and then we reserve
         # enough additional slots to store the data if it uses the max available length
         # because this data type is single-bytes, we make it so it takes the max 32 byte
         # boundary as it's size, instead of giving it a size that is not cleanly divisble by 32
 
         return 32 + ceil32(self.length)
@@ -107,68 +117,46 @@
         if self._length:
             if not other._length:
                 other.set_length(max(self._length, other._min_length))
             return self._length >= other._length
 
         return other.compare_type(self)
 
-
-class _ArrayValuePrimitive(BasePrimitive):
-    _type: Type[_ArrayValueDefinition]  # type: ignore
-
     @classmethod
-    def from_annotation(
-        cls,
-        node: vy_ast.VyperNode,
-        location: DataLocation = DataLocation.MEMORY,
-        is_constant: bool = False,
-        is_public: bool = False,
-        is_immutable: bool = False,
-    ) -> _ArrayValueDefinition:
-        if not isinstance(node, vy_ast.Subscript):
+    def from_annotation(cls, node: vy_ast.VyperNode) -> "_BytestringT":
+        if not isinstance(node, vy_ast.Subscript) or not isinstance(node.slice, vy_ast.Index):
             raise StructureException(
-                f"Cannot declare {cls._id} type without a maximum length", node
+                f"Cannot declare {cls._id} type without a maximum length, e.g. {cls._id}[5]", node
             )
-        if len(node.get_descendants(vy_ast.Subscript, include_self=True)) > 1:
-            raise StructureException(f"Multidimensional {cls._id} arrays are not supported", node)
+
         if node.get("value.id") != cls._id:
             raise UnexpectedValue("Node id does not match type name")
 
-        length = validation.utils.get_index_value(node.slice)  # type: ignore
-        return cls._type(length, location, is_constant, is_public, is_immutable)
+        length = get_index_value(node.slice)  # type: ignore
+        # return cls._type(length, location, is_constant, is_public, is_immutable)
+        return cls(length)
 
     @classmethod
-    def from_literal(cls, node: vy_ast.Constant) -> _ArrayValueDefinition:
-        super().from_literal(node)
-        length = len(node.value)
+    def from_literal(cls, node: vy_ast.Constant) -> "_BytestringT":
+        if not isinstance(node, cls._valid_literal):
+            raise UnexpectedNodeType(f"Not a {cls._id}: {node}")
+        t = cls()
+        t.set_min_length(len(node.value))
+        return t
 
-        obj = cls._type()
-        obj.set_min_length(length)
-        return obj
 
-
-class BytesArrayDefinition(BytesAbstractType, ArrayValueAbstractType, _ArrayValueDefinition):
+class BytesT(_BytestringT):
     _id = "Bytes"
+    _valid_literal = (vy_ast.Bytes,)
 
     @property
     def abi_type(self) -> ABIType:
         return ABI_Bytes(self.length)
 
 
-class StringDefinition(ArrayValueAbstractType, _ArrayValueDefinition):
+class StringT(_BytestringT):
     _id = "String"
+    _valid_literal = (vy_ast.Str,)
 
     @property
     def abi_type(self) -> ABIType:
         return ABI_String(self.length)
-
-
-class BytesArrayPrimitive(_ArrayValuePrimitive):
-    _id = "Bytes"
-    _type = BytesArrayDefinition
-    _valid_literal = (vy_ast.Bytes,)
-
-
-class StringPrimitive(_ArrayValuePrimitive):
-    _id = "String"
-    _type = StringDefinition
-    _valid_literal = (vy_ast.Str,)
```

### Comparing `vyper-0.3.7/vyper/semantics/validation/annotation.py` & `vyper-0.3.8/vyper/semantics/analysis/annotation.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,20 +1,16 @@
 from vyper import ast as vy_ast
-from vyper.exceptions import StructureException
-from vyper.semantics.types import ArrayDefinition
-from vyper.semantics.types.function import ContractFunction, MemberFunctionDefinition
-from vyper.semantics.types.user.enum import EnumDefinition
-from vyper.semantics.types.user.event import Event
-from vyper.semantics.types.user.struct import StructPrimitive
-from vyper.semantics.types.utils import TypeTypeDefinition
-from vyper.semantics.validation.utils import (
+from vyper.exceptions import StructureException, TypeCheckFailure
+from vyper.semantics.analysis.utils import (
     get_common_types,
     get_exact_type_from_node,
     get_possible_types_from_node,
 )
+from vyper.semantics.types import TYPE_T, BoolT, EnumT, EventT, SArrayT, StructT, is_type_t
+from vyper.semantics.types.function import ContractFunctionT, MemberFunctionT
 
 
 class _AnnotationVisitorBase:
 
     """
     Annotation visitor base class.
 
@@ -36,25 +32,24 @@
             if visitor_fn:
                 visitor_fn(node, *args)
                 return
         raise StructureException(f"Cannot annotate: {node.ast_type}", node)
 
 
 class StatementAnnotationVisitor(_AnnotationVisitorBase):
-
     ignored_types = (vy_ast.Break, vy_ast.Continue, vy_ast.Pass, vy_ast.Raise)
 
     def __init__(self, fn_node: vy_ast.FunctionDef, namespace: dict) -> None:
         self.func = fn_node._metadata["type"]
         self.namespace = namespace
         self.expr_visitor = ExpressionAnnotationVisitor(self.func)
 
-        assert len(self.func.kwarg_keys) == len(fn_node.args.defaults)
-        for kw, val in zip(self.func.kwarg_keys, fn_node.args.defaults):
-            self.expr_visitor.visit(val, self.func.arguments[kw])
+        assert self.func.n_keyword_args == len(fn_node.args.defaults)
+        for kwarg in self.func.keyword_args:
+            self.expr_visitor.visit(kwarg.default_value, kwarg.typ)
 
     def visit(self, node):
         super().visit(node)
 
     def visit_AnnAssign(self, node):
         type_ = get_exact_type_from_node(node.target)
         self.expr_visitor.visit(node.target, type_)
@@ -90,36 +85,35 @@
     def visit_For(self, node):
         if isinstance(node.iter, (vy_ast.Name, vy_ast.Attribute)):
             self.expr_visitor.visit(node.iter)
         # typecheck list literal as static array
         if isinstance(node.iter, vy_ast.List):
             value_type = get_common_types(*node.iter.elements).pop()
             len_ = len(node.iter.elements)
-            self.expr_visitor.visit(node.iter, ArrayDefinition(value_type, len_))
+            self.expr_visitor.visit(node.iter, SArrayT(value_type, len_))
 
         if isinstance(node.iter, vy_ast.Call) and node.iter.func.id == "range":
             iter_type = node.target._metadata["type"]
             for a in node.iter.args:
                 self.expr_visitor.visit(a, iter_type)
 
 
 class ExpressionAnnotationVisitor(_AnnotationVisitorBase):
-
     ignored_types = ()
 
-    def __init__(self, fn_node: ContractFunction):
+    def __init__(self, fn_node: ContractFunctionT):
         self.func = fn_node
 
     def visit(self, node, type_=None):
         # the statement visitor sometimes passes type information about expressions
         super().visit(node, type_)
 
     def visit_Attribute(self, node, type_):
-        base_type = get_exact_type_from_node(node.value)
-        node._metadata["type"] = base_type.get_member(node.attr, node)
+        type_ = get_exact_type_from_node(node)
+        node._metadata["type"] = type_
         self.visit(node.value, None)
 
     def visit_BinOp(self, node, type_):
         if type_ is None:
             type_ = get_common_types(node.left, node.right)
             if len(type_) == 1:
                 type_ = type_.pop()
@@ -128,38 +122,42 @@
         self.visit(node.left, type_)
         self.visit(node.right, type_)
 
     def visit_BoolOp(self, node, type_):
         for value in node.values:
             self.visit(value)
 
-    def visit_Bytes(self, node, type_):
-        node._metadata["type"] = type_
-
     def visit_Call(self, node, type_):
         call_type = get_exact_type_from_node(node.func)
         node_type = type_ or call_type.fetch_call_return(node)
         node._metadata["type"] = node_type
         self.visit(node.func)
 
-        if isinstance(call_type, ContractFunction) and call_type.is_internal:
-            self.func.called_functions.add(call_type)
-
-        if isinstance(call_type, (Event, ContractFunction)):
-            # events and function calls
-            for arg, arg_type in zip(node.args, list(call_type.arguments.values())):
-                self.visit(arg, arg_type)
+        if isinstance(call_type, ContractFunctionT):
+            # function calls
+            if call_type.is_internal:
+                self.func.called_functions.add(call_type)
+            for arg, typ in zip(node.args, call_type.argument_types):
+                self.visit(arg, typ)
             for kwarg in node.keywords:
                 # We should only see special kwargs
                 self.visit(kwarg.value, call_type.call_site_kwargs[kwarg.arg].typ)
-        elif isinstance(call_type, StructPrimitive):
-            # literal structs
-            for value, arg_type in zip(node.args[0].values, list(call_type.members.values())):
+
+        elif is_type_t(call_type, EventT):
+            # events have no kwargs
+            for arg, typ in zip(node.args, list(call_type.typedef.arguments.values())):
+                self.visit(arg, typ)
+        elif is_type_t(call_type, StructT):
+            # struct ctors
+            # ctors have no kwargs
+            for value, arg_type in zip(
+                node.args[0].values, list(call_type.typedef.members.values())
+            ):
                 self.visit(value, arg_type)
-        elif isinstance(call_type, MemberFunctionDefinition):
+        elif isinstance(call_type, MemberFunctionT):
             assert len(node.args) == len(call_type.arg_types)
             for arg, arg_type in zip(node.args, call_type.arg_types):
                 self.visit(arg, arg_type)
         else:
             # builtin functions
             arg_types = call_type.infer_arg_types(node)
             for arg, arg_type in zip(node.args, arg_types):
@@ -170,19 +168,19 @@
 
     def visit_Compare(self, node, type_):
         if isinstance(node.op, (vy_ast.In, vy_ast.NotIn)):
             if isinstance(node.right, vy_ast.List):
                 type_ = get_common_types(node.left, *node.right.elements).pop()
                 self.visit(node.left, type_)
                 rlen = len(node.right.elements)
-                self.visit(node.right, ArrayDefinition(type_, rlen))
+                self.visit(node.right, SArrayT(type_, rlen))
             else:
                 type_ = get_exact_type_from_node(node.right)
                 self.visit(node.right, type_)
-                if isinstance(type_, EnumDefinition):
+                if isinstance(type_, EnumT):
                     self.visit(node.left, type_)
                 else:
                     # array membership
                     self.visit(node.left, type_.value_type)
         else:
             type_ = get_common_types(node.left, node.right).pop()
             self.visit(node.left, type_)
@@ -194,75 +192,89 @@
             if len(possible_types) == 1:
                 type_ = possible_types.pop()
         node._metadata["type"] = type_
 
     def visit_Dict(self, node, type_):
         node._metadata["type"] = type_
 
-    def visit_Hex(self, node, type_):
-        node._metadata["type"] = type_
-
     def visit_Index(self, node, type_):
         self.visit(node.value, type_)
 
-    def visit_Int(self, node, type_):
-        node._metadata["type"] = type_
-
     def visit_List(self, node, type_):
         if type_ is None:
             type_ = get_possible_types_from_node(node)
             # CMC 2022-04-14 this seems sus. try to only annotate
             # if get_possible_types only returns 1 type
             if len(type_) >= 1:
                 type_ = type_.pop()
         node._metadata["type"] = type_
         for element in node.elements:
             self.visit(element, type_.value_type)
 
     def visit_Name(self, node, type_):
-        if isinstance(type_, TypeTypeDefinition):
+        if isinstance(type_, TYPE_T):
             node._metadata["type"] = type_
         else:
             node._metadata["type"] = get_exact_type_from_node(node)
 
     def visit_Subscript(self, node, type_):
         node._metadata["type"] = type_
 
-        if isinstance(type_, TypeTypeDefinition):
+        if isinstance(type_, TYPE_T):
             # don't recurse; can't annotate AST children of type definition
             return
 
         if isinstance(node.value, vy_ast.List):
             possible_base_types = get_possible_types_from_node(node.value)
 
             if len(possible_base_types) == 1:
                 base_type = possible_base_types.pop()
 
             elif type_ is not None and len(possible_base_types) > 1:
                 for possible_type in possible_base_types:
-                    if isinstance(possible_type.value_type, type(type_)):
+                    if type_.compare_type(possible_type.value_type):
                         base_type = possible_type
                         break
+                else:
+                    # this should have been caught in
+                    # `get_possible_types_from_node` but wasn't.
+                    raise TypeCheckFailure(f"Expected {type_} but it is not a possible type", node)
 
         else:
             base_type = get_exact_type_from_node(node.value)
 
-        self.visit(node.slice, base_type.get_index_type())
+        # get the correct type for the index, it might
+        # not be base_type.key_type
+        index_types = get_possible_types_from_node(node.slice.value)
+        index_type = index_types.pop()
+
+        self.visit(node.slice, index_type)
         self.visit(node.value, base_type)
 
     def visit_Tuple(self, node, type_):
         node._metadata["type"] = type_
 
-        if isinstance(type_, TypeTypeDefinition):
+        if isinstance(type_, TYPE_T):
             # don't recurse; can't annotate AST children of type definition
             return
 
-        for element, subtype in zip(node.elements, type_.value_type):
+        for element, subtype in zip(node.elements, type_.member_types):
             self.visit(element, subtype)
 
     def visit_UnaryOp(self, node, type_):
         if type_ is None:
             type_ = get_possible_types_from_node(node.operand)
             if len(type_) == 1:
                 type_ = type_.pop()
         node._metadata["type"] = type_
         self.visit(node.operand, type_)
+
+    def visit_IfExp(self, node, type_):
+        if type_ is None:
+            ts = get_common_types(node.body, node.orelse)
+            if len(type_) == 1:
+                type_ = ts.pop()
+
+        node._metadata["type"] = type_
+        self.visit(node.test, BoolT())
+        self.visit(node.body, type_)
+        self.visit(node.orelse, type_)
```

### Comparing `vyper-0.3.7/vyper/semantics/validation/base.py` & `vyper-0.3.8/vyper/semantics/analysis/common.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,14 +1,13 @@
 from typing import Tuple
 
 from vyper.exceptions import StructureException
 
 
 class VyperNodeVisitorBase:
-
     ignored_types: Tuple = ()
     scope_name = ""
 
     def visit(self, node, *args):
         if isinstance(node, self.ignored_types):
             return
         node_type = type(node).__name__
```

### Comparing `vyper-0.3.7/vyper/semantics/validation/data_positions.py` & `vyper-0.3.8/vyper/semantics/analysis/data_positions.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,15 +1,15 @@
-# TODO this doesn't really belong in "validation"
-import math
+# TODO this module doesn't really belong in "validation"
 from typing import Dict, List
 
 from vyper import ast as vy_ast
 from vyper.exceptions import StorageLayoutException
-from vyper.semantics.types.bases import CodeOffset, StorageSlot
+from vyper.semantics.analysis.base import CodeOffset, StorageSlot
 from vyper.typing import StorageLayout
+from vyper.utils import ceil32
 
 
 def set_data_positions(
     vyper_module: vy_ast.Module, storage_layout_overrides: StorageLayout = None
 ) -> StorageLayout:
     """
     Parse the annotated Vyper AST, determine data positions for all variables,
@@ -49,15 +49,15 @@
         self._reserve_slots(list_to_check, var_name)
 
     def _reserve_slots(self, slots: List[int], var_name: str) -> None:
         for slot in slots:
             self._reserve_slot(slot, var_name)
 
     def _reserve_slot(self, slot: int, var_name: str) -> None:
-        if slot < 0 or slot >= 2 ** 256:
+        if slot < 0 or slot >= 2**256:
             raise StorageLayoutException(
                 f"Invalid storage slot for var {var_name}, out of bounds: {slot}"
             )
         if slot in self.occupied_slots:
             collided_var = self.occupied_slots[slot]
             raise StorageLayoutException(
                 f"Storage collision! Tried to assign '{var_name}' to slot {slot} but it has "
@@ -108,50 +108,63 @@
                 f"Could not find storage_slot for {variable_name}. "
                 "Have you used the correct storage layout file?",
                 node,
             )
 
     # Iterate through variables
     for node in vyper_module.get_children(vy_ast.VariableDecl):
-
         # Ignore immutable parameters
         if node.get("annotation.func.id") == "immutable":
             continue
 
-        type_ = node.target._metadata["type"]
+        varinfo = node.target._metadata["varinfo"]
 
         # Expect to find this variable within the storage layout overrides
         if node.target.id in storage_layout_overrides:
             var_slot = storage_layout_overrides[node.target.id]["slot"]
-            # Calculate how many storage slots are required
-            storage_length = math.ceil(type_.size_in_bytes / 32)
+            storage_length = varinfo.typ.storage_size_in_words
             # Ensure that all required storage slots are reserved, and prevents other variables
             # from using these slots
             reserved_slots.reserve_slot_range(var_slot, storage_length, node.target.id)
-            type_.set_position(StorageSlot(var_slot))
+            varinfo.set_position(StorageSlot(var_slot))
 
-            ret[node.target.id] = {"type": str(type_), "slot": var_slot}
+            ret[node.target.id] = {"type": str(varinfo.typ), "slot": var_slot}
         else:
             raise StorageLayoutException(
                 f"Could not find storage_slot for {node.target.id}. "
                 "Have you used the correct storage layout file?",
                 node,
             )
 
     return ret
 
 
+class SimpleStorageAllocator:
+    def __init__(self, starting_slot: int = 0):
+        self._slot = starting_slot
+
+    def allocate_slot(self, n, var_name):
+        ret = self._slot
+        if self._slot + n >= 2**256:
+            raise StorageLayoutException(
+                f"Invalid storage slot for var {var_name}, tried to allocate"
+                f" slots {self._slot} through {self._slot + n}"
+            )
+        self._slot += n
+        return ret
+
+
 def set_storage_slots(vyper_module: vy_ast.Module) -> StorageLayout:
     """
     Parse module-level Vyper AST to calculate the layout of storage variables.
     Returns the layout as a dict of variable name -> variable info
     """
     # Allocate storage slots from 0
     # note storage is word-addressable, not byte-addressable
-    storage_slot = 0
+    allocator = SimpleStorageAllocator()
 
     ret: Dict[str, Dict] = {}
 
     for node in vyper_module.get_children(vy_ast.FunctionDef):
         type_ = node._metadata["type"]
         if type_.nonreentrant is None:
             continue
@@ -162,64 +175,67 @@
         # only takes one slot. after the first time we see it, do not
         # increment the storage slot.
         if variable_name in ret:
             _slot = ret[variable_name]["slot"]
             type_.set_reentrancy_key_position(StorageSlot(_slot))
             continue
 
-        type_.set_reentrancy_key_position(StorageSlot(storage_slot))
-
-        # TODO this could have better typing but leave it untyped until
-        # we nail down the format better
-        ret[variable_name] = {"type": "nonreentrant lock", "slot": storage_slot}
-
         # TODO use one byte - or bit - per reentrancy key
         # requires either an extra SLOAD or caching the value of the
         # location in memory at entrance
-        storage_slot += 1
+        slot = allocator.allocate_slot(1, variable_name)
 
-    for node in vyper_module.get_children(vy_ast.VariableDecl):
+        type_.set_reentrancy_key_position(StorageSlot(slot))
+
+        # TODO this could have better typing but leave it untyped until
+        # we nail down the format better
+        ret[variable_name] = {"type": "nonreentrant lock", "slot": slot}
 
+    for node in vyper_module.get_children(vy_ast.VariableDecl):
         # skip non-storage variables
         if node.is_constant or node.is_immutable:
             continue
 
-        type_ = node.target._metadata["type"]
-        type_.set_position(StorageSlot(storage_slot))
-
-        # this could have better typing but leave it untyped until
-        # we understand the use case better
-        ret[node.target.id] = {"type": str(type_), "slot": storage_slot}
+        varinfo = node.target._metadata["varinfo"]
+        type_ = varinfo.typ
 
         # CMC 2021-07-23 note that HashMaps get assigned a slot here.
         # I'm not sure if it's safe to avoid allocating that slot
         # for HashMaps because downstream code might use the slot
         # ID as a salt.
-        storage_slot += math.ceil(type_.size_in_bytes / 32)
+        n_slots = type_.storage_size_in_words
+        slot = allocator.allocate_slot(n_slots, node.target.id)
+
+        varinfo.set_position(StorageSlot(slot))
+
+        # this could have better typing but leave it untyped until
+        # we understand the use case better
+        ret[node.target.id] = {"type": str(type_), "slot": slot}
 
     return ret
 
 
 def set_calldata_offsets(fn_node: vy_ast.FunctionDef) -> None:
     pass
 
 
 def set_memory_offsets(fn_node: vy_ast.FunctionDef) -> None:
     pass
 
 
 def set_code_offsets(vyper_module: vy_ast.Module) -> Dict:
-
     ret = {}
     offset = 0
+
     for node in vyper_module.get_children(vy_ast.VariableDecl, filters={"is_immutable": True}):
-        type_ = node._metadata["type"]
-        type_.set_position(CodeOffset(offset))
+        varinfo = node.target._metadata["varinfo"]
+        type_ = varinfo.typ
+        varinfo.set_position(CodeOffset(offset))
 
-        len_ = math.ceil(type_.size_in_bytes / 32) * 32
+        len_ = ceil32(type_.size_in_bytes)
 
         # this could have better typing but leave it untyped until
         # we understand the use case better
         ret[node.target.id] = {"type": str(type_), "offset": offset, "length": len_}
 
         offset += len_
```

### Comparing `vyper-0.3.7/vyper/semantics/validation/levenshtein_utils.py` & `vyper-0.3.8/vyper/semantics/analysis/levenshtein_utils.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/vyper/semantics/validation/module.py` & `vyper-0.3.8/vyper/semantics/analysis/module.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,45 +1,52 @@
 import importlib
 import pkgutil
 from typing import Optional, Union
 
-import vyper.builtin_interfaces
+import vyper.builtins.interfaces
 from vyper import ast as vy_ast
+from vyper.evm.opcodes import version_check
 from vyper.exceptions import (
     CallViolation,
     CompilerPanic,
     ExceptionList,
     InvalidLiteral,
     InvalidType,
     NamespaceCollision,
     StateAccessViolation,
     StructureException,
     SyntaxException,
     UndeclaredDefinition,
     VariableDeclarationException,
     VyperException,
 )
-from vyper.semantics.namespace import get_namespace
-from vyper.semantics.types.bases import DataLocation
-from vyper.semantics.types.function import ContractFunction
-from vyper.semantics.types.user.enum import EnumPrimitive
-from vyper.semantics.types.user.event import Event
-from vyper.semantics.types.utils import check_constant, get_type_from_annotation
-from vyper.semantics.validation.base import VyperNodeVisitorBase
-from vyper.semantics.validation.levenshtein_utils import get_levenshtein_error_suggestions
-from vyper.semantics.validation.utils import validate_expected_type, validate_unique_method_ids
+from vyper.semantics.analysis.base import VarInfo
+from vyper.semantics.analysis.common import VyperNodeVisitorBase
+from vyper.semantics.analysis.levenshtein_utils import get_levenshtein_error_suggestions
+from vyper.semantics.analysis.utils import (
+    check_constant,
+    validate_expected_type,
+    validate_unique_method_ids,
+)
+from vyper.semantics.data_locations import DataLocation
+from vyper.semantics.namespace import Namespace, get_namespace
+from vyper.semantics.types import EnumT, EventT, InterfaceT, StructT
+from vyper.semantics.types.function import ContractFunctionT
+from vyper.semantics.types.utils import type_from_annotation
 from vyper.typing import InterfaceDict
 
 
 def add_module_namespace(vy_module: vy_ast.Module, interface_codes: InterfaceDict) -> None:
-
-    """Analyzes a Vyper ast and adds all module-level objects to the namespace."""
+    """
+    Analyze a Vyper module AST node, add all module-level objects to the
+    namespace and validate top-level correctness
+    """
 
     namespace = get_namespace()
-    ModuleNodeVisitor(vy_module, interface_codes, namespace)
+    ModuleAnalyzer(vy_module, interface_codes, namespace)
 
 
 def _find_cyclic_call(fn_names: list, self_members: dict) -> Optional[list]:
     if fn_names[-1] not in self_members:
         return None
     internal_calls = self_members[fn_names[-1]].internal_calls
     for name in internal_calls:
@@ -47,25 +54,25 @@
             return fn_names + [name]
         sequence = _find_cyclic_call(fn_names + [name], self_members)
         if sequence:
             return sequence
     return None
 
 
-class ModuleNodeVisitor(VyperNodeVisitorBase):
-
+class ModuleAnalyzer(VyperNodeVisitorBase):
     scope_name = "module"
 
     def __init__(
-        self, module_node: vy_ast.Module, interface_codes: InterfaceDict, namespace: dict
+        self, module_node: vy_ast.Module, interface_codes: InterfaceDict, namespace: Namespace
     ) -> None:
         self.ast = module_node
         self.interface_codes = interface_codes or {}
         self.namespace = namespace
 
+        # TODO: Move computation out of constructor
         module_nodes = module_node.body.copy()
         while module_nodes:
             count = len(module_nodes)
             err_list = ExceptionList()
             for node in list(module_nodes):
                 try:
                     self.visit(node)
@@ -78,43 +85,45 @@
                     err_list.append(e)
 
             # Only raise if no nodes were successfully processed. This allows module
             # level logic to parse regardless of the ordering of code elements.
             if count == len(module_nodes):
                 err_list.raise_if_not_empty()
 
+        # generate an `InterfaceT` from the top-level node - used for building the ABI
+        interface = InterfaceT.from_ast(module_node)
+        module_node._metadata["type"] = interface
+        self.interface = interface  # this is useful downstream
+
+        # attach namespace to the module for downstream use.
+        _ns = Namespace()
+        # note that we don't just copy the namespace because
+        # there are constructor issues.
+        _ns.update({k: namespace[k] for k in namespace._scopes[-1]})
+        module_node._metadata["namespace"] = _ns
+
         # check for collisions between 4byte function selectors
         # internal functions are intentionally included in this check, to prevent breaking
         # changes in in case of a future change to their calling convention
-        self_members = namespace["self"].members
-        functions = [i for i in self_members.values() if isinstance(i, ContractFunction)]
+        self_members = namespace["self"].typ.members
+        functions = [i for i in self_members.values() if isinstance(i, ContractFunctionT)]
         validate_unique_method_ids(functions)
 
-        # generate an `InterfacePrimitive` from the top-level node - used for building the ABI
-        interface = namespace["interface"].build_primitive_from_node(module_node)
-        module_node._metadata["type"] = interface
-
         # get list of internal function calls made by each function
         function_defs = self.ast.get_children(vy_ast.FunctionDef)
         function_names = set(node.name for node in function_defs)
         for node in function_defs:
             calls_to_self = set(
                 i.func.attr for i in node.get_descendants(vy_ast.Call, {"func.value.id": "self"})
             )
             # anything that is not a function call will get semantically checked later
             calls_to_self = calls_to_self.intersection(function_names)
             self_members[node.name].internal_calls = calls_to_self
-            if node.name in self_members[node.name].internal_calls:
-                self_node = node.get_descendants(
-                    vy_ast.Attribute, {"value.id": "self", "attr": node.name}
-                )[0]
-                raise CallViolation(f"Function '{node.name}' calls into itself", self_node)
 
         for fn_name in sorted(function_names):
-
             if fn_name not in self_members:
                 # the referenced function does not exist - this is an issue, but we'll report
                 # it later when parsing the function so we can give more meaningful output
                 continue
 
             # check for circular function calls
             sequence = _find_cyclic_call([fn_name], self_members)
@@ -136,30 +145,30 @@
                 expanded |= function_set
                 if expanded == function_set:
                     break
                 function_set = expanded
 
             self_members[fn_name].recursive_calls = function_set
 
-    def visit_AnnAssign(self, node):
-        name = node.get("target.id")
-        if name == "implements":
-            interface_name = node.annotation.id
-            self.namespace[interface_name].validate_implements(node)
-            return
+    def visit_ImplementsDecl(self, node):
+        type_ = type_from_annotation(node.annotation)
+        if not isinstance(type_, InterfaceT):
+            raise StructureException("Invalid interface name", node.annotation)
+
+        type_.validate_implements(node)
 
     def visit_VariableDecl(self, node):
         name = node.get("target.id")
         if name is None:
             raise VariableDeclarationException("Invalid module-level assignment", node)
 
         if node.is_public:
             # generate function type and add to metadata
             # we need this when building the public getter
-            node._metadata["func_type"] = ContractFunction.getter_from_VariableDecl(node)
+            node._metadata["func_type"] = ContractFunctionT.getter_from_VariableDecl(node)
 
         if node.is_immutable:
             # mutability is checked automatically preventing assignment
             # outside of the constructor, here we just check a value is assigned,
             # not necessarily where
             assignments = self.ast.get_descendants(
                 vy_ast.Assign, filters={"target.id": node.target.id}
@@ -172,82 +181,117 @@
                 message = (
                     "Immutable variables must be accessed without 'self'"
                     if len(wrong_self_attribute) > 0
                     else "Immutable definition requires an assignment in the constructor"
                 )
                 raise SyntaxException(message, node.node_source_code, node.lineno, node.col_offset)
 
-        data_loc = DataLocation.CODE if node.is_immutable else DataLocation.STORAGE
-        type_definition = get_type_from_annotation(
-            node.annotation, data_loc, node.is_constant, node.is_public, node.is_immutable
+        data_loc = (
+            DataLocation.CODE
+            if node.is_immutable
+            else DataLocation.UNSET
+            if node.is_constant
+            # XXX: needed if we want separate transient allocator
+            # else DataLocation.TRANSIENT
+            # if node.is_transient
+            else DataLocation.STORAGE
         )
-        node._metadata["type"] = type_definition
+
+        type_ = type_from_annotation(node.annotation, data_loc)
+
+        if node.is_transient and not version_check(begin="cancun"):
+            raise StructureException("`transient` is not available pre-cancun", node.annotation)
+
+        var_info = VarInfo(
+            type_,
+            decl_node=node,
+            location=data_loc,
+            is_constant=node.is_constant,
+            is_public=node.is_public,
+            is_immutable=node.is_immutable,
+            is_transient=node.is_transient,
+        )
+        node.target._metadata["varinfo"] = var_info  # TODO maybe put this in the global namespace
+        node._metadata["type"] = type_
+
+        def _finalize():
+            # add the variable name to `self` namespace if the variable is either
+            # 1. a public constant or immutable; or
+            # 2. a storage variable, whether private or public
+            if (node.is_constant or node.is_immutable) and not node.is_public:
+                return
+
+            try:
+                self.namespace["self"].typ.add_member(name, var_info)
+                node.target._metadata["type"] = type_
+            except NamespaceCollision:
+                raise NamespaceCollision(
+                    f"Value '{name}' has already been declared", node
+                ) from None
+            except VyperException as exc:
+                raise exc.with_annotation(node) from None
+
+        def _validate_self_namespace():
+            # block globals if storage variable already exists
+            try:
+                if name in self.namespace["self"].typ.members:
+                    raise NamespaceCollision(
+                        f"Value '{name}' has already been declared", node
+                    ) from None
+                self.namespace[name] = var_info
+            except VyperException as exc:
+                raise exc.with_annotation(node) from None
 
         if node.is_constant:
             if not node.value:
                 raise VariableDeclarationException("Constant must be declared with a value", node)
             if not check_constant(node.value):
                 raise StateAccessViolation("Value must be a literal", node.value)
 
-            validate_expected_type(node.value, type_definition)
-            try:
-                self.namespace[name] = type_definition
-            except VyperException as exc:
-                raise exc.with_annotation(node) from None
-            return
+            validate_expected_type(node.value, type_)
+            _validate_self_namespace()
+
+            return _finalize()
 
         if node.value:
             var_type = "Immutable" if node.is_immutable else "Storage"
             raise VariableDeclarationException(
                 f"{var_type} variables cannot have an initial value", node.value
             )
 
         if node.is_immutable:
-            try:
-                # block immutable if storage variable already exists
-                if name in self.namespace["self"].members:
-                    raise NamespaceCollision(
-                        f"Value '{name}' has already been declared", node
-                    ) from None
-                self.namespace[name] = type_definition
-            except VyperException as exc:
-                raise exc.with_annotation(node) from None
-            return
+            _validate_self_namespace()
+            return _finalize()
 
         try:
             self.namespace.validate_assignment(name)
         except NamespaceCollision as exc:
             raise exc.with_annotation(node) from None
-        try:
-            self.namespace["self"].add_member(name, type_definition)
-            node.target._metadata["type"] = type_definition
-        except NamespaceCollision:
-            raise NamespaceCollision(f"Value '{name}' has already been declared", node) from None
-        except VyperException as exc:
-            raise exc.with_annotation(node) from None
+
+        return _finalize()
 
     def visit_EnumDef(self, node):
-        obj = EnumPrimitive.from_EnumDef(node)
+        obj = EnumT.from_EnumDef(node)
         try:
             self.namespace[node.name] = obj
         except VyperException as exc:
             raise exc.with_annotation(node) from None
 
     def visit_EventDef(self, node):
-        obj = Event.from_EventDef(node)
+        obj = EventT.from_EventDef(node)
         try:
             self.namespace[node.name] = obj
         except VyperException as exc:
             raise exc.with_annotation(node) from None
 
     def visit_FunctionDef(self, node):
-        func = ContractFunction.from_FunctionDef(node)
+        func = ContractFunctionT.from_FunctionDef(node)
 
         try:
-            self.namespace["self"].add_member(func.name, func)
+            self.namespace["self"].typ.add_member(func.name, func)
             node._metadata["type"] = func
         except VyperException as exc:
             raise exc.with_annotation(node) from None
 
     def visit_Import(self, node):
         if not node.alias:
             raise StructureException("Import requires an accompanying `as` statement", node)
@@ -260,24 +304,24 @@
             node.name,
             node.alias or node.name,
             self.interface_codes,
             self.namespace,
         )
 
     def visit_InterfaceDef(self, node):
-        obj = self.namespace["interface"].build_primitive_from_node(node)
+        obj = InterfaceT.from_ast(node)
         try:
             self.namespace[node.name] = obj
         except VyperException as exc:
             raise exc.with_annotation(node) from None
 
     def visit_StructDef(self, node):
-        obj = self.namespace["struct"].build_primitive_from_node(node)
+        struct_t = StructT.from_ast_def(node)
         try:
-            self.namespace[node.name] = obj
+            self.namespace[node.name] = struct_t
         except VyperException as exc:
             raise exc.with_annotation(node) from None
 
 
 def _add_import(
     node: Union[vy_ast.Import, vy_ast.ImportFrom],
     module: str,
@@ -290,28 +334,28 @@
         interface_codes = _get_builtin_interfaces()
     if name not in interface_codes:
         suggestions_str = get_levenshtein_error_suggestions(name, _get_builtin_interfaces(), 1.0)
         raise UndeclaredDefinition(f"Unknown interface: {name}. {suggestions_str}", node)
 
     if interface_codes[name]["type"] == "vyper":
         interface_ast = vy_ast.parse_to_ast(interface_codes[name]["code"], contract_name=name)
-        type_ = namespace["interface"].build_primitive_from_node(interface_ast)
+        type_ = InterfaceT.from_ast(interface_ast)
     elif interface_codes[name]["type"] == "json":
-        type_ = namespace["interface"].build_primitive_from_abi(name, interface_codes[name]["code"])
+        type_ = InterfaceT.from_json_abi(name, interface_codes[name]["code"])  # type: ignore
     else:
         raise CompilerPanic(f"Unknown interface format: {interface_codes[name]['type']}")
 
     try:
         namespace[alias] = type_
     except VyperException as exc:
         raise exc.with_annotation(node) from None
 
 
 def _get_builtin_interfaces():
-    interface_names = [i.name for i in pkgutil.iter_modules(vyper.builtin_interfaces.__path__)]
+    interface_names = [i.name for i in pkgutil.iter_modules(vyper.builtins.interfaces.__path__)]
     return {
         name: {
             "type": "vyper",
-            "code": importlib.import_module(f"vyper.builtin_interfaces.{name}").interface_code,
+            "code": importlib.import_module(f"vyper.builtins.interfaces.{name}").interface_code,
         }
         for name in interface_names
     }
```

### Comparing `vyper-0.3.7/vyper/semantics/validation/utils.py` & `vyper-0.3.8/vyper/semantics/analysis/utils.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,276 +1,360 @@
 import itertools
 from typing import Callable, List
 
 from vyper import ast as vy_ast
 from vyper.exceptions import (
-    ArrayIndexException,
+    CompilerPanic,
     InvalidLiteral,
     InvalidOperation,
     InvalidReference,
     InvalidType,
     OverflowException,
     StructureException,
     TypeMismatch,
     UndeclaredDefinition,
     UnknownAttribute,
     VyperException,
     ZeroDivisionException,
 )
 from vyper.semantics import types
+from vyper.semantics.analysis.base import ExprInfo, VarInfo
+from vyper.semantics.analysis.levenshtein_utils import get_levenshtein_error_suggestions
 from vyper.semantics.namespace import get_namespace
-from vyper.semantics.types.abstract import IntegerAbstractType
-from vyper.semantics.types.bases import BaseTypeDefinition
-from vyper.semantics.types.indexable.sequence import (
-    ArrayDefinition,
-    DynamicArrayDefinition,
-    TupleDefinition,
-)
-from vyper.semantics.types.value.address import AddressDefinition
-from vyper.semantics.types.value.boolean import BoolDefinition
-from vyper.semantics.types.value.bytes_fixed import Bytes20Definition  # type: ignore
-from vyper.semantics.validation.levenshtein_utils import get_levenshtein_error_suggestions
+from vyper.semantics.types.base import TYPE_T, VyperType
+from vyper.semantics.types.bytestrings import BytesT, StringT
+from vyper.semantics.types.primitives import AddressT, BoolT, BytesM_T, IntegerT
+from vyper.semantics.types.subscriptable import DArrayT, SArrayT, TupleT
 from vyper.utils import checksum_encode
 
 
 def _validate_op(node, types_list, validation_fn_name):
     if not types_list:
+        # TODO raise a better error here: say which types.
         raise TypeMismatch(f"Cannot perform {node.op.description} between dislike types", node)
 
-    if len(types_list) == 1:
-        getattr(types_list[0], validation_fn_name)(node)
-        return types_list
-
-    for type_ in types_list.copy():
+    ret = []
+    err_list = []
+    for type_ in types_list:
+        _validate_fn = getattr(type_, validation_fn_name)
         try:
-            getattr(type_, validation_fn_name)(node)
-        except InvalidOperation:
-            types_list.remove(type_)
+            _validate_fn(node)
+            ret.append(type_)
+        except InvalidOperation as e:
+            err_list.append(e)
 
-    if types_list:
-        return types_list
-    raise InvalidOperation(f"Cannot perform {node.op.description} on value", node)
+    if ret:
+        return ret
 
+    raise err_list[0]
 
-class _ExprTypeChecker:
+
+class _ExprAnalyser:
     """
     Node type-checker class.
 
     Type-check logic is implemented in `type_from_<NODE_CLASS>` methods, organized
     according to the Vyper ast node class. Calls to `get_exact_type_from_node` and
     `get_possible_types_from_node` are forwarded to this class, where the node
     class's method resolution order is examined to decide which method to call.
     """
 
     def __init__(self):
         self.namespace = get_namespace()
 
-    def get_exact_type_from_node(self, node, only_definitions=True):
+    def get_expr_info(self, node: vy_ast.VyperNode) -> ExprInfo:
+        t = self.get_exact_type_from_node(node)
+
+        # if it's a Name, we have varinfo for it
+        if isinstance(node, vy_ast.Name):
+            varinfo = self.namespace[node.id]
+            return ExprInfo.from_varinfo(varinfo)
+
+        if isinstance(node, vy_ast.Attribute):
+            # if it's an Attr, we check the parent exprinfo and
+            # propagate the parent exprinfo members down into the new expr
+            # note: Attribute(expr value, identifier attr)
+
+            name = node.attr
+            info = self.get_expr_info(node.value)
+
+            t = info.typ.get_member(name, node)
+
+            # it's a top-level variable
+            if isinstance(t, VarInfo):
+                return ExprInfo.from_varinfo(t)
+
+            # it's something else, like my_struct.foo
+            return info.copy_with_type(t)
+
+        if isinstance(node, vy_ast.Tuple):
+            # always use the most restrictive location re: modification
+            # kludge! for validate_modification in local analysis of Assign
+            types = [self.get_expr_info(n) for n in node.elements]
+            location = sorted((i.location for i in types), key=lambda k: k.value)[-1]
+            is_constant = any((getattr(i, "is_constant", False) for i in types))
+            is_immutable = any((getattr(i, "is_immutable", False) for i in types))
+
+            return ExprInfo(
+                t, location=location, is_constant=is_constant, is_immutable=is_immutable
+            )
+
+        # If it's a Subscript, propagate the subscriptable varinfo
+        if isinstance(node, vy_ast.Subscript):
+            info = self.get_expr_info(node.value)
+            return info.copy_with_type(t)
+
+        return ExprInfo(t)
+
+    def get_exact_type_from_node(self, node, include_type_exprs=False):
         """
         Find exactly one type for a given node.
 
         Raises StructureException if a single type cannot be determined.
 
         Arguments
         ---------
         node : VyperNode
             The vyper AST node to find a type for.
-        only_definitions: bool, optional
-            If True, raises when the return value is not a type definition
-            e.g a primitive, meta type, or function call
 
         Returns
         -------
         Type object
         """
-        types_list = self.get_possible_types_from_node(node, only_definitions)
+        types_list = self.get_possible_types_from_node(node, include_type_exprs=include_type_exprs)
 
         if len(types_list) > 1:
             raise StructureException("Ambiguous type", node)
+
         return types_list[0]
 
-    def get_possible_types_from_node(self, node, only_definitions=True):
+    def get_possible_types_from_node(self, node, include_type_exprs=False):
         """
         Find all possible types for a given node.
         If the node's metadata contains type information propagated from constant folding,
         then that type is returned.
 
         Arguments
         ---------
         node : VyperNode
             The vyper AST node to find a type for.
-        only_definitions: bool, optional
-            If True, raises when the return value is not a type definition
-            e.g a primitive, meta type, or function call
 
         Returns
         -------
         List
             A list of type objects
         """
         # Early termination if typedef is propagated in metadata
         if "type" in node._metadata:
             return [node._metadata["type"]]
 
-        fn = self._find_fn(node)
-        types_list = fn(node)
-        if only_definitions:
-            invalid = next((i for i in types_list if not isinstance(i, BaseTypeDefinition)), None)
-            if invalid:
-                if isinstance(invalid, type) and types.BasePrimitive in invalid.mro():
-                    raise InvalidReference(
-                        f"'{invalid._id}' is a type - expected a literal or variable", node
-                    )
-                else:
-                    raise InvalidReference("Expected a literal or variable", node)
+        # this method is a perf hotspot, so we cache the result and
+        # try to return it if found.
+        k = f"possible_types_from_node_{include_type_exprs}"
+        if k not in node._metadata:
+            fn = self._find_fn(node)
+            ret = fn(node)
+
+            if not include_type_exprs:
+                invalid = next((i for i in ret if isinstance(i, TYPE_T)), None)
+                if invalid is not None:
+                    raise InvalidReference(f"not a variable or literal: '{invalid.typedef}'", node)
+
+            if all(isinstance(i, IntegerT) for i in ret):
+                # for numeric types, sort according by number of bits descending
+                # this ensures literals are cast with the largest possible type
+                ret.sort(key=lambda k: (k.bits, not k.is_signed), reverse=True)
 
-        if all(isinstance(i, IntegerAbstractType) for i in types_list):
-            # for numeric types, sort according by number of bits descending
-            # we do this to ensure literals are cast with the largest possible type
-            return sorted(types_list, key=lambda k: (k._bits, not k._is_signed), reverse=True)
-        return types_list
+            node._metadata[k] = ret
+
+        return node._metadata[k].copy()
 
     def _find_fn(self, node):
         # look for a type-check method for each class in the given class mro
         for name in [i.__name__ for i in type(node).mro()]:
             if name == "VyperNode":
                 break
             fn = getattr(self, f"types_from_{name}", None)
             if fn is not None:
                 return fn
 
         raise StructureException("Cannot determine type of this object", node)
 
     def types_from_Attribute(self, node):
         # variable attribute, e.g. `foo.bar`
-        var = self.get_exact_type_from_node(node.value, only_definitions=False)
+        t = self.get_exact_type_from_node(node.value, include_type_exprs=True)
         name = node.attr
         try:
-            return [var.get_member(name, node)]
+            s = t.get_member(name, node)
+            if isinstance(s, VyperType):
+                # ex. foo.bar(). bar() is a ContractFunctionT
+                return [s]
+            # general case. s is a VarInfo, e.g. self.foo
+            return [s.typ]
         except UnknownAttribute:
             if node.get("value.id") != "self":
                 raise
             if name in self.namespace:
                 raise InvalidReference(
                     f"'{name}' is not a storage variable, it should not be prepended with self",
                     node,
                 ) from None
 
-            suggestions_str = get_levenshtein_error_suggestions(name, var.members, 0.4)
+            suggestions_str = get_levenshtein_error_suggestions(name, t.members, 0.4)
             raise UndeclaredDefinition(
                 f"Storage variable '{name}' has not been declared. {suggestions_str}", node
             ) from None
 
     def types_from_BinOp(self, node):
         # binary operation: `x + y`
-        types_list = get_common_types(node.left, node.right)
+        if isinstance(node.op, (vy_ast.LShift, vy_ast.RShift)):
+            # ad-hoc handling for LShift and RShift, since operands
+            # can be different types
+            types_list = get_possible_types_from_node(node.left)
+            # check rhs is unsigned integer
+            validate_expected_type(node.right, IntegerT.unsigneds())
+        else:
+            types_list = get_common_types(node.left, node.right)
 
         if (
             isinstance(node.op, (vy_ast.Div, vy_ast.Mod))
             and isinstance(node.right, vy_ast.Num)
             and not node.right.value
         ):
             raise ZeroDivisionException(f"{node.op.description} by zero", node)
 
         return _validate_op(node, types_list, "validate_numeric_op")
 
     def types_from_BoolOp(self, node):
         # boolean operation: `x and y`
         types_list = get_common_types(*node.values)
         _validate_op(node, types_list, "validate_boolean_op")
-        return [BoolDefinition()]
+        return [BoolT()]
 
     def types_from_Compare(self, node):
         # comparisons, e.g. `x < y`
 
         # TODO fixme circular import
-        from vyper.semantics.types.user.enum import EnumDefinition
+        from vyper.semantics.types.user import EnumT
 
         if isinstance(node.op, (vy_ast.In, vy_ast.NotIn)):
             # x in y
             left = self.get_possible_types_from_node(node.left)
             right = self.get_possible_types_from_node(node.right)
-            if any(isinstance(t, EnumDefinition) for t in left):
+            if any(isinstance(t, EnumT) for t in left):
                 types_list = get_common_types(node.left, node.right)
                 _validate_op(node, types_list, "validate_comparator")
-                return [BoolDefinition()]
+                return [BoolT()]
 
-            if any(isinstance(i, ArrayDefinition) for i in left):
+            if any(isinstance(i, SArrayT) for i in left):
                 raise InvalidOperation(
                     "Left operand in membership comparison cannot be Array type", node.left
                 )
-            if any(not isinstance(i, (DynamicArrayDefinition, ArrayDefinition)) for i in right):
+            if any(not isinstance(i, (DArrayT, SArrayT)) for i in right):
                 raise InvalidOperation(
                     "Right operand must be Array for membership comparison", node.right
                 )
             types_list = [i for i in left if _is_type_in_list(i, [i.value_type for i in right])]
             if not types_list:
                 raise TypeMismatch(
                     "Cannot perform membership comparison between dislike types", node
                 )
         else:
             types_list = get_common_types(node.left, node.right)
             _validate_op(node, types_list, "validate_comparator")
-        return [BoolDefinition()]
+        return [BoolT()]
 
     def types_from_Call(self, node):
-        # function calls, e.g. `foo()`
-        var = self.get_exact_type_from_node(node.func, False)
+        # function calls, e.g. `foo()` or `MyStruct()`
+        var = self.get_exact_type_from_node(node.func, include_type_exprs=True)
         return_value = var.fetch_call_return(node)
         if return_value:
             return [return_value]
         raise InvalidType(f"{var} did not return a value", node)
 
     def types_from_Constant(self, node):
         # literal value (integer, string, etc)
         types_list = []
-        for primitive in types.get_primitive_types().values():
+        for t in types.PRIMITIVE_TYPES.values():
             try:
-                obj = primitive.from_literal(node)
-                types_list.append(obj)
+                # clarity and perf note: will be better to construct a
+                # map from node types to valid vyper types
+                if not isinstance(node, t._valid_literal):
+                    continue
+
+                # special handling for bytestrings since their
+                # class objects are in the type map, not the type itself
+                # (worth rethinking this design at some point.)
+                if t in (BytesT, StringT):
+                    t = t.from_literal(node)
+
+                # any more validation which needs to occur
+                t.validate_literal(node)
+                types_list.append(t)
             except VyperException:
                 continue
+
         if types_list:
             return types_list
 
+        # failed; prepare a good error message
         if isinstance(node, vy_ast.Num):
             raise OverflowException(
                 "Numeric literal is outside of allowable range for number types", node
             )
         raise InvalidLiteral(f"Could not determine type for literal value '{node.value}'", node)
 
     def types_from_List(self, node):
-
         # literal array
         if _is_empty_list(node):
             # empty list literal `[]`
+            ret = []
             # subtype can be anything
-            types_list = types.get_types()
-            # 1 is minimum possible length for dynarray, assignable to anything
-            ret = [DynamicArrayDefinition(v, 1) for v in types_list.values()]
+            for t in types.PRIMITIVE_TYPES.values():
+                # 1 is minimum possible length for dynarray,
+                # can be assigned to anything
+                if isinstance(t, VyperType):
+                    ret.append(DArrayT(t, 1))
+                elif isinstance(t, type) and issubclass(t, VyperType):
+                    # for typeclasses like bytestrings, use a generic type acceptor
+                    ret.append(DArrayT(t.any(), 1))
+                else:
+                    raise CompilerPanic("busted type {t}", node)
             return ret
+
         types_list = get_common_types(*node.elements)
 
         if len(types_list) > 0:
             count = len(node.elements)
             ret = []
-            ret.extend([ArrayDefinition(t, count) for t in types_list])
-            ret.extend([DynamicArrayDefinition(t, count) for t in types_list])
+            ret.extend([SArrayT(t, count) for t in types_list])
+            ret.extend([DArrayT(t, count) for t in types_list])
             return ret
         raise InvalidLiteral("Array contains multiple, incompatible types", node)
 
     def types_from_Name(self, node):
         # variable name, e.g. `foo`
         name = node.id
-        if name not in self.namespace and name in self.namespace["self"].members:
+        if (
+            name not in self.namespace
+            and "self" in self.namespace
+            and name in self.namespace["self"].typ.members
+        ):
             raise InvalidReference(
                 f"'{name}' is a storage variable, access it as self.{name}", node
             )
         try:
-            return [self.namespace[node.id]]
+            t = self.namespace[node.id]
+            # when this is a type, we want to lower it
+            if isinstance(t, VyperType):
+                # TYPE_T is used to handle cases where a type can occur in call or
+                # attribute conditions, like Enum.foo or MyStruct({...})
+                return [TYPE_T(t)]
+
+            return [t.typ]
         except VyperException as exc:
             raise exc.with_annotation(node) from None
 
     def types_from_Subscript(self, node):
         # index access, e.g. `foo[1]`
         if isinstance(node.value, vy_ast.List):
             types_list = self.get_possible_types_from_node(node.value)
@@ -282,23 +366,32 @@
 
         t = self.get_exact_type_from_node(node.value)
         t.validate_index_type(node.slice.value)
         return [t.get_subscripted_type(node.slice.value)]
 
     def types_from_Tuple(self, node):
         types_list = [self.get_exact_type_from_node(i) for i in node.elements]
-        # for item, type_ in zip(node.elements, types_list):
-        #     if not isinstnace(BaseTypeDefinition
-        return [TupleDefinition(types_list)]
+        return [TupleT(types_list)]
 
     def types_from_UnaryOp(self, node):
         # unary operation: `-foo`
         types_list = self.get_possible_types_from_node(node.operand)
         return _validate_op(node, types_list, "validate_numeric_op")
 
+    def types_from_IfExp(self, node):
+        validate_expected_type(node.test, BoolT())
+        types_list = get_common_types(node.body, node.orelse)
+
+        if not types_list:
+            a = get_possible_types_from_node(node.body)[0]
+            b = get_possible_types_from_node(node.orelse)[0]
+            raise TypeMismatch(f"Dislike types: {a} and {b}", node)
+
+        return types_list
+
 
 def _is_empty_list(node):
     # Checks if a node is a `List` node with an empty list for `elements`,
     # including any nested `List` nodes. ex. `[]` or `[[]]` will return True,
     # [1] will return False.
     if not isinstance(node, vy_ast.List):
         return False
@@ -309,14 +402,15 @@
 
 
 def _is_type_in_list(obj, types_list):
     # check if a type object is in a list of types
     return any(i.compare_type(obj) for i in types_list)
 
 
+# NOTE: dead fn
 def _filter(type_, fn_name, node):
     # filter function used when evaluating boolean ops and comparators
     try:
         getattr(type_, fn_name)(node)
         return True
     except InvalidOperation:
         return False
@@ -334,15 +428,15 @@
         A vyper ast node.
 
     Returns
     -------
     List
         List of one or more BaseType objects.
     """
-    return _ExprTypeChecker().get_possible_types_from_node(node, False)
+    return _ExprAnalyser().get_possible_types_from_node(node, include_type_exprs=True)
 
 
 def get_exact_type_from_node(node):
     """
     Return exactly one type for a given node.
 
     Raises if there is more than one possible type.
@@ -353,16 +447,19 @@
         A vyper ast node.
 
     Returns
     -------
     BaseType
         Type object.
     """
+    return _ExprAnalyser().get_exact_type_from_node(node, include_type_exprs=True)
 
-    return _ExprTypeChecker().get_exact_type_from_node(node, False)
+
+def get_expr_info(node: vy_ast.VyperNode) -> ExprInfo:
+    return _ExprAnalyser().get_expr_info(node)
 
 
 def get_common_types(*nodes: vy_ast.VyperNode, filter_fn: Callable = None) -> List:
     """
     Return a list of common possible types between one or more nodes.
 
     Arguments
@@ -373,38 +470,39 @@
         If given, results are filtered by this function prior to returning.
 
     Returns
     -------
     list
         List of zero or more `BaseType` objects.
     """
-    common_types = _ExprTypeChecker().get_possible_types_from_node(nodes[0])
+    common_types = _ExprAnalyser().get_possible_types_from_node(nodes[0])
 
     for item in nodes[1:]:
-        new_types = _ExprTypeChecker().get_possible_types_from_node(item)
+        new_types = _ExprAnalyser().get_possible_types_from_node(item)
 
         common = [i for i in common_types if _is_type_in_list(i, new_types)]
+
         rejected = [i for i in common_types if i not in common]
         common += [i for i in new_types if _is_type_in_list(i, rejected)]
 
         common_types = common
 
     if filter_fn is not None:
         common_types = [i for i in common_types if filter_fn(i)]
 
     return common_types
 
 
+# TODO push this into `ArrayT.validate_literal()`
 def _validate_literal_array(node, expected):
-
     # validate that every item within an array has the same type
-    if isinstance(expected, ArrayDefinition):
+    if isinstance(expected, SArrayT):
         if len(node.elements) != expected.length:
             return False
-    if isinstance(expected, DynamicArrayDefinition):
+    if isinstance(expected, DArrayT):
         if len(node.elements) > expected.length:
             return False
 
     for item in node.elements:
         try:
             validate_expected_type(item, expected.value_type)
         except (InvalidType, TypeMismatch):
@@ -426,22 +524,23 @@
     expected_type : Tuple | BaseType
         A type object, or tuple of type objects
 
     Returns
     -------
     None
     """
-    given_types = _ExprTypeChecker().get_possible_types_from_node(node)
+    given_types = _ExprAnalyser().get_possible_types_from_node(node)
+
     if not isinstance(expected_type, tuple):
         expected_type = (expected_type,)
 
-    if isinstance(node, (vy_ast.List, vy_ast.Tuple)):
-        # special case - for literal arrays or tuples we individually validate each item
+    if isinstance(node, vy_ast.List):
+        # special case - for literal arrays we individually validate each item
         for expected in expected_type:
-            if not isinstance(expected, (DynamicArrayDefinition, ArrayDefinition)):
+            if not isinstance(expected, (DArrayT, SArrayT)):
                 continue
             if _validate_literal_array(node, expected):
                 return
     else:
         for given, expected in itertools.product(given_types, expected_type):
             if expected.compare_type(given):
                 return
@@ -466,68 +565,87 @@
         if len(given_types) == 1:
             given_str = str(given_types[0])
         else:
             types_str = sorted(str(i) for i in given_types)
             given_str = f"{', '.join(types_str[:1])} or {types_str[-1]}"
 
         suggestion_str = ""
-        if isinstance(expected_type[0], AddressDefinition) and isinstance(
-            given_types[0], Bytes20Definition
-        ):
+        if expected_type[0] == AddressT() and given_types[0] == BytesM_T(20):
             suggestion_str = f" Did you mean {checksum_encode(node.value)}?"
 
         # CMC 2022-02-14 maybe TypeMismatch would make more sense here
         raise InvalidType(
             f"Expected {expected_str} but literal can only be cast as {given_str}.{suggestion_str}",
             node,
         )
 
 
-def get_index_value(node: vy_ast.Index) -> int:
+def validate_unique_method_ids(functions: List) -> None:
     """
-    Return the literal value for a `Subscript` index.
+    Check for collisions between the 4byte function selectors
+    of each function within a contract.
 
     Arguments
     ---------
-    node : vy_ast.Index
-        Vyper ast node from the `slice` member of a Subscript node. Must be an
-        `Index` object (Vyper does not support `Slice` or `ExtSlice`).
-
-    Returns
-    -------
-    int
-        Literal integer value.
+    functions : List[ContractFunctionT]
+        A list of ContractFunctionT objects.
     """
+    method_ids = [x for i in functions for x in i.method_ids.values()]
+    seen = set()
+    for method_id in method_ids:
+        if method_id in seen:
+            collision_str = ", ".join(i.name for i in functions if method_id in i.method_ids)
+            raise StructureException(f"Methods have conflicting IDs: {collision_str}")
+        seen.add(method_id)
 
-    if not isinstance(node.get("value"), vy_ast.Int):
-        if hasattr(node, "value"):
-            # even though the subscript is an invalid type, first check if it's a valid _something_
-            # this gives a more accurate error in case of e.g. a typo in a constant variable name
-            try:
-                get_possible_types_from_node(node.value)
-            except StructureException:
-                # StructureException is a very broad error, better to raise InvalidType in this case
-                pass
 
-        raise InvalidType("Subscript must be a literal integer", node)
+def check_kwargable(node: vy_ast.VyperNode) -> bool:
+    """
+    Check if the given node can be used as a default arg
+    """
+    if _check_literal(node):
+        return True
+    if isinstance(node, (vy_ast.Tuple, vy_ast.List)):
+        return all(check_kwargable(item) for item in node.elements)
+    if isinstance(node, vy_ast.Call):
+        args = node.args
+        if len(args) == 1 and isinstance(args[0], vy_ast.Dict):
+            return all(check_kwargable(v) for v in args[0].values)
 
-    if node.value.value <= 0:
-        raise ArrayIndexException("Subscript must be greater than 0", node)
+        call_type = get_exact_type_from_node(node.func)
+        if getattr(call_type, "_kwargable", False):
+            return True
 
-    return node.value.value
+    value_type = get_expr_info(node)
+    # is_constant here actually means not_assignable, and is to be renamed
+    return value_type.is_constant
 
 
-def validate_unique_method_ids(functions: List) -> None:
+def _check_literal(node: vy_ast.VyperNode) -> bool:
     """
-    Check for collisions between the 4byte function selectors
-    of each function within a contract.
+    Check if the given node is a literal value.
+    """
+    if isinstance(node, vy_ast.Constant):
+        return True
+    elif isinstance(node, (vy_ast.Tuple, vy_ast.List)):
+        return all(_check_literal(item) for item in node.elements)
+    return False
 
-    Arguments
-    ---------
-    functions : List[ContractFunction]
-        A list of ContractFunction objects.
+
+def check_constant(node: vy_ast.VyperNode) -> bool:
     """
-    method_ids = [x for i in functions for x in i.method_ids.values()]
-    collision = next((i for i in method_ids if method_ids.count(i) > 1), None)
-    if collision:
-        collision_str = ", ".join(i.name for i in functions if collision in i.method_ids)
-        raise StructureException(f"Methods have conflicting IDs: {collision_str}")
+    Check if the given node is a literal or constant value.
+    """
+    if _check_literal(node):
+        return True
+    if isinstance(node, (vy_ast.Tuple, vy_ast.List)):
+        return all(check_constant(item) for item in node.elements)
+    if isinstance(node, vy_ast.Call):
+        args = node.args
+        if len(args) == 1 and isinstance(args[0], vy_ast.Dict):
+            return all(check_constant(v) for v in args[0].values)
+
+        call_type = get_exact_type_from_node(node.func)
+        if getattr(call_type, "_kwargable", False):
+            return True
+
+    return False
```

### Comparing `vyper-0.3.7/vyper/typing.py` & `vyper-0.3.8/vyper/typing.py`

 * *Files identical despite different names*

### Comparing `vyper-0.3.7/vyper/utils.py` & `vyper-0.3.8/vyper/utils.py`

 * *Files 3% similar despite different names*

```diff
@@ -7,14 +7,27 @@
 import traceback
 import warnings
 from typing import List, Union
 
 from vyper.exceptions import DecimalOverrideException, InvalidLiteral
 
 
+class OrderedSet(dict):
+    """
+    a minimal "ordered set" class. this is needed in some places
+    because, while dict guarantees you can recover insertion order
+    vanilla sets do not.
+    no attempt is made to fully implement the set API, will add
+    functionality as needed.
+    """
+
+    def add(self, item):
+        self[item] = None
+
+
 class DecimalContextOverride(decimal.Context):
     def __setattr__(self, name, value):
         if name == "prec":
             if value < 78:
                 # definitely don't want this to happen
                 raise DecimalOverrideException("Overriding decimal precision disabled")
             elif value > 78:
@@ -33,53 +46,53 @@
 
     keccak256 = lambda x: keccak.new(digest_bits=256, data=x).digest()  # noqa: E731
 except ImportError:
     import sha3 as _sha3
 
     keccak256 = lambda x: _sha3.sha3_256(x).digest()  # noqa: E731
 
-try:
-    # available py3.8+
-    from functools import cached_property
-except ImportError:
-    from cached_property import cached_property  # type: ignore
-
 
 # Converts four bytes to an integer
 def fourbytes_to_int(inp):
     return (inp[0] << 24) + (inp[1] << 16) + (inp[2] << 8) + inp[3]
 
 
+# Converts an integer to four bytes
+def int_to_fourbytes(n: int) -> bytes:
+    assert n < 2**32
+    return n.to_bytes(4, byteorder="big")
+
+
 def signed_to_unsigned(int_, bits, strict=False):
     """
     Reinterpret a signed integer with n bits as an unsigned integer.
     The implementation is unforgiving in that it assumes the input is in
     bounds for int<bits>, in order to fail more loudly (and not hide
     errors in modular reasoning in consumers of this function).
     """
     if strict:
         lo, hi = int_bounds(signed=True, bits=bits)
         assert lo <= int_ <= hi
     if int_ < 0:
-        return int_ + 2 ** bits
+        return int_ + 2**bits
     return int_
 
 
 def unsigned_to_signed(int_, bits, strict=False):
     """
     Reinterpret an unsigned integer with n bits as a signed integer.
     The implementation is unforgiving in that it assumes the input is in
     bounds for uint<bits>, in order to fail more loudly (and not hide
     errors in modular reasoning in consumers of this function).
     """
     if strict:
         lo, hi = int_bounds(signed=False, bits=bits)
         assert lo <= int_ <= hi
     if int_ > (2 ** (bits - 1)) - 1:
-        return int_ - (2 ** bits)
+        return int_ - (2**bits)
     return int_
 
 
 def is_power_of_two(n: int) -> bool:
     # busted for ints wider than 53 bits:
     # t = math.log(n, 2)
     # return math.ceil(t) == math.floor(t)
@@ -102,16 +115,21 @@
 # print a warning
 def vyper_warn(msg, prefix="Warning: ", file_=sys.stderr):
     print(f"{prefix}{msg}", file=file_)
 
 
 # converts a signature like Func(bool,uint256,address) to its 4 byte method ID
 # TODO replace manual calculations in codebase with this
-def abi_method_id(method_sig):
-    return fourbytes_to_int(keccak256(bytes(method_sig, "utf-8"))[:4])
+def method_id_int(method_sig: str) -> int:
+    method_id_bytes = method_id(method_sig)
+    return fourbytes_to_int(method_id_bytes)
+
+
+def method_id(method_str: str) -> bytes:
+    return keccak256(bytes(method_str, "utf-8"))[:4]
 
 
 # map a string to only-alphanumeric chars
 def mkalphanum(s):
     return "".join([c if c.isalnum() else "_" for c in s])
 
 
@@ -179,33 +197,33 @@
 GAS_IDENTITY = 15
 GAS_IDENTITYWORD = 3
 GAS_CODECOPY_WORD = 3
 GAS_CALLDATACOPY_WORD = 3
 
 # A decimal value can store multiples of 1/DECIMAL_DIVISOR
 MAX_DECIMAL_PLACES = 10
-DECIMAL_DIVISOR = 10 ** MAX_DECIMAL_PLACES
+DECIMAL_DIVISOR = 10**MAX_DECIMAL_PLACES
 DECIMAL_EPSILON = decimal.Decimal(1) / DECIMAL_DIVISOR
 
 
 def int_bounds(signed, bits):
     """
     calculate the bounds on an integer type
-    ex. int_bounds(8, True) -> (-128, 127)
-        int_bounds(8, False) -> (0, 255)
+    ex. int_bounds(True, 8) -> (-128, 127)
+        int_bounds(False, 8) -> (0, 255)
     """
     if signed:
         return -(2 ** (bits - 1)), (2 ** (bits - 1)) - 1
-    return 0, (2 ** bits) - 1
+    return 0, (2**bits) - 1
 
 
 # e.g. -1 -> -(2**256 - 1)
 def evm_twos_complement(x: int) -> int:
     # return ((o + 2 ** 255) % 2 ** 256) - 2 ** 255
-    return ((2 ** 256 - 1) ^ x) + 1
+    return ((2**256 - 1) ^ x) + 1
 
 
 # EVM div semantics as a python function
 def evm_div(x, y):
     if y == 0:
         return 0
     # NOTE: should be same as: round_towards_zero(Decimal(x)/Decimal(y))
@@ -222,56 +240,39 @@
     return sign * (abs(x) % abs(y))  # adapted from py-evm
 
 
 # EVM pow which wraps instead of hanging on "large" numbers
 # (which can generated, for ex. in the unevaluated branch of the Shift builtin)
 def evm_pow(x, y):
     assert x >= 0 and y >= 0
-    return pow(x, y, 2 ** 256)
+    return pow(x, y, 2**256)
 
 
 # memory used for system purposes, not for variables
 class MemoryPositions:
     FREE_VAR_SPACE = 0
     FREE_VAR_SPACE2 = 32
     RESERVED_MEMORY = 64
 
 
 # Sizes of different data types. Used to clamp types.
 class SizeLimits:
-    MAX_INT128 = 2 ** 127 - 1
-    MIN_INT128 = -(2 ** 127)
-    MAX_INT256 = 2 ** 255 - 1
-    MIN_INT256 = -(2 ** 255)
-    MAXDECIMAL = 2 ** 167 - 1  # maxdecimal as EVM value
-    MINDECIMAL = -(2 ** 167)  # mindecimal as EVM value
+    MAX_INT128 = 2**127 - 1
+    MIN_INT128 = -(2**127)
+    MAX_INT256 = 2**255 - 1
+    MIN_INT256 = -(2**255)
+    MAXDECIMAL = 2**167 - 1  # maxdecimal as EVM value
+    MINDECIMAL = -(2**167)  # mindecimal as EVM value
     # min decimal allowed as Python value
-    MIN_AST_DECIMAL = -decimal.Decimal(2 ** 167) / DECIMAL_DIVISOR
+    MIN_AST_DECIMAL = -decimal.Decimal(2**167) / DECIMAL_DIVISOR
     # max decimal allowed as Python value
-    MAX_AST_DECIMAL = decimal.Decimal(2 ** 167 - 1) / DECIMAL_DIVISOR
-    MAX_UINT8 = 2 ** 8 - 1
-    MAX_UINT256 = 2 ** 256 - 1
-
-    @classmethod
-    def in_bounds(cls, type_str, value):
-        # TODO: fix this circular import
-        from vyper.codegen.types import parse_decimal_info, parse_integer_typeinfo
-
-        assert isinstance(type_str, str)
-        if type_str == "decimal":
-            info = parse_decimal_info(type_str)
-        else:
-            info = parse_integer_typeinfo(type_str)
+    MAX_AST_DECIMAL = decimal.Decimal(2**167 - 1) / DECIMAL_DIVISOR
+    MAX_UINT8 = 2**8 - 1
+    MAX_UINT256 = 2**256 - 1
 
-        (lo, hi) = int_bounds(info.is_signed, info.bits)
-        return lo <= value <= hi
-
-
-# Otherwise reserved words that are whitelisted for function declarations
-FUNCTION_WHITELIST = {"send"}
 
 # List of valid IR macros.
 # TODO move this somewhere else, like ir_node.py
 VALID_IR_MACROS = {
     "assert",
     "break",
     "iload",
@@ -432,10 +433,7 @@
     else:
         num_lines = end_offset - start_offset + 1
 
     cleanup_lines = [line.rstrip() for line in location_repr.splitlines()]
     cleanup_lines += [""] * (num_lines - len(cleanup_lines))
 
     return "\n".join(cleanup_lines)
-
-
-__all__ = ["cached_property"]
```

### Comparing `vyper-0.3.7/vyper.egg-info/PKG-INFO` & `vyper-0.3.8/vyper.egg-info/PKG-INFO`

 * *Files 5% similar despite different names*

```diff
@@ -1,41 +1,40 @@
 Metadata-Version: 2.1
 Name: vyper
-Version: 0.3.7
+Version: 0.3.8
 Summary: Vyper: the Pythonic Programming Language for the EVM
 Home-page: https://github.com/vyperlang/vyper
 Author: Vyper Team
 Author-email: 
 License: Apache License 2.0
 Keywords: ethereum evm smart contract language
 Classifier: Intended Audience :: Developers
 Classifier: License :: OSI Approved :: Apache Software License
-Classifier: Programming Language :: Python :: 3.8
-Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
-Requires-Python: >=3.7,<3.11
+Classifier: Programming Language :: Python :: 3.11
+Requires-Python: >=3.10,<4
 Description-Content-Type: text/markdown
 Provides-Extra: test
 Provides-Extra: lint
 Provides-Extra: docs
 Provides-Extra: dev
 License-File: LICENSE
 
 
 <img src="https://raw.githubusercontent.com/vyperlang/vyper/master/logo/vyper-logo-transparent.svg?sanitize=true" alt="" width="110">
 
-[![Build Status](https://github.com/vyperlang/vyper/workflows/Test/badge.svg)](https://github.com/vyperlang/vyper/actions)
+[![Build Status](https://github.com/vyperlang/vyper/workflows/Test/badge.svg)](https://github.com/vyperlang/vyper/actions/workflows/test.yml)
 [![Documentation Status](https://readthedocs.org/projects/vyper/badge/?version=latest)](http://vyper.readthedocs.io/en/latest/?badge=latest "ReadTheDocs")
 [![Discord](https://img.shields.io/discord/969926564286459934.svg?label=%23vyper)](https://discord.gg/6tw7PTM7C2)
 
 [![PyPI](https://badge.fury.io/py/vyper.svg)](https://pypi.org/project/vyper "PyPI")
-[![Docker](https://images.microbadger.com/badges/version/vyperlang/vyper.svg)](https://hub.docker.com/r/vyperlang/vyper "DockerHub")
+[![Docker](https://img.shields.io/docker/cloud/build/vyperlang/vyper)](https://hub.docker.com/r/vyperlang/vyper "DockerHub")
 
 [![Coverage Status](https://codecov.io/gh/vyperlang/vyper/branch/master/graph/badge.svg)](https://codecov.io/gh/vyperlang/vyper "Codecov")
-[![Language grade: Python](https://img.shields.io/lgtm/grade/python/g/vyperlang/vyper.svg?logo=lgtm&logoWidth=18)](https://lgtm.com/projects/g/vyperlang/vyper/context:python)
+[![Language grade: Python](https://github.com/vyperlang/vyper/workflows/CodeQL/badge.svg)](https://github.com/vyperlang/vyper/actions/workflows/codeql.yml)
 
 # Getting Started
 See [Installing Vyper](http://vyper.readthedocs.io/en/latest/installing-vyper.html) to install vyper.
 See [Tools and Resources](https://github.com/vyperlang/vyper/wiki/Vyper-tools-and-resources) for an additional list of framework and tools with vyper support.
 See [Documentation](http://vyper.readthedocs.io/en/latest/index.html) for the documentation and overall design goals of the Vyper language.
 
 See [Learn.Vyperlang.org](https://learn.vyperlang.org/) for **learning Vyper by building a Pokmon game**.
@@ -48,14 +47,21 @@
 for build instructions.
 
 # Compiling a contract
 To compile a contract, use:
 ```bash
 vyper your_file_name.vy
 ```
+***generate bytecode***
+
+    vyper -f bytecode file-name.vy > file-name.bin
+
+***generate abi***
+
+    vyper -f abi file-name.vy > file-name.abi
 
 There is also an [online compiler](https://vyper.online/) available you can use to experiment with
 the language and compile to ``bytecode`` and/or ``IR``.
 
 **Note: While the vyper version of the online compiler is updated on a regular basis it might
 be a bit behind the latest version found in the master branch of this repository.**
```

### Comparing `vyper-0.3.7/vyper.egg-info/SOURCES.txt` & `vyper-0.3.8/vyper.egg-info/SOURCES.txt`

 * *Files 5% similar despite different names*

```diff
@@ -14,14 +14,17 @@
 setup.cfg
 setup.py
 tox.ini
 .github/PULL_REQUEST_TEMPLATE.md
 .github/ISSUE_TEMPLATE/bug.md
 .github/ISSUE_TEMPLATE/vip.md
 .github/workflows/build.yml
+.github/workflows/codeql.yml
+.github/workflows/era-tester.yml
+.github/workflows/ghcr.yml
 .github/workflows/publish.yml
 .github/workflows/test.yml
 docs/Makefile
 docs/built-in-functions.rst
 docs/compiler-exceptions.rst
 docs/compiling-a-contract.rst
 docs/conf.py
@@ -32,14 +35,15 @@
 docs/event-logging.rst
 docs/index.rst
 docs/installing-vyper.rst
 docs/interfaces.rst
 docs/make.bat
 docs/natspec.rst
 docs/release-notes.rst
+docs/resources.rst
 docs/scoping-and-declarations.rst
 docs/statements.rst
 docs/structure-of-a-contract.rst
 docs/style-guide.rst
 docs/testing-contracts-brownie.rst
 docs/testing-contracts-ethtester.rst
 docs/testing-contracts.rst
@@ -91,14 +95,24 @@
 tests/ast/nodes/test_evaluate_subscript.py
 tests/ast/nodes/test_evaluate_unaryop.py
 tests/ast/nodes/test_from_node.py
 tests/ast/nodes/test_get_children.py
 tests/ast/nodes/test_get_descendants.py
 tests/ast/nodes/test_hex.py
 tests/ast/nodes/test_replace_in_tree.py
+tests/builtins/folding/test_abs.py
+tests/builtins/folding/test_addmod_mulmod.py
+tests/builtins/folding/test_bitwise.py
+tests/builtins/folding/test_epsilon.py
+tests/builtins/folding/test_floor_ceil.py
+tests/builtins/folding/test_fold_as_wei_value.py
+tests/builtins/folding/test_keccak_sha.py
+tests/builtins/folding/test_len.py
+tests/builtins/folding/test_min_max.py
+tests/builtins/folding/test_powmod.py
 tests/cli/outputs/test_storage_layout.py
 tests/cli/outputs/test_storage_layout_overrides.py
 tests/cli/vyper_compile/test_compile_files.py
 tests/cli/vyper_compile/test_import_paths.py
 tests/cli/vyper_compile/test_parse_args.py
 tests/cli/vyper_json/test_compile_from_input_dict.py
 tests/cli/vyper_json/test_compile_json.py
@@ -112,14 +126,15 @@
 tests/compiler/test_bytecode_runtime.py
 tests/compiler/test_calldatacopy.py
 tests/compiler/test_compile_code.py
 tests/compiler/test_opcodes.py
 tests/compiler/test_pre_parser.py
 tests/compiler/test_sha3_32.py
 tests/compiler/test_source_map.py
+tests/compiler/asm/test_asm_optimizer.py
 tests/compiler/ir/__init__.py
 tests/compiler/ir/test_compile_ir.py
 tests/compiler/ir/test_optimize_ir.py
 tests/compiler/ir/test_repeat.py
 tests/compiler/ir/test_with.py
 tests/examples/conftest.py
 tests/examples/auctions/test_blind_auction.py
@@ -139,57 +154,49 @@
 tests/examples/voting/test_ballot.py
 tests/examples/wallet/test_wallet.py
 tests/fixtures/__init__.py
 tests/fixtures/memorymock.py
 tests/functional/test_storage_slots.py
 tests/functional/codegen/test_struct_return.py
 tests/functional/codegen/test_tuple_return.py
-tests/functional/context/conftest.py
-tests/functional/context/test_namespace.py
-tests/functional/context/types/test_event.py
-tests/functional/context/types/test_pure_types.py
-tests/functional/context/types/test_size_in_bytes.py
-tests/functional/context/types/test_type_from_abi.py
-tests/functional/context/types/test_type_from_annotation.py
-tests/functional/context/validation/test_array_index.py
-tests/functional/context/validation/test_cyclic_function_calls.py
-tests/functional/context/validation/test_for_loop.py
-tests/functional/context/validation/test_potential_types.py
-tests/functions/folding/test_abs.py
-tests/functions/folding/test_addmod_mulmod.py
-tests/functions/folding/test_bitwise.py
-tests/functions/folding/test_epsilon.py
-tests/functions/folding/test_floor_ceil.py
-tests/functions/folding/test_fold_as_wei_value.py
-tests/functions/folding/test_keccak_sha.py
-tests/functions/folding/test_len.py
-tests/functions/folding/test_min_max.py
-tests/functions/folding/test_powmod.py
+tests/functional/semantics/conftest.py
+tests/functional/semantics/test_namespace.py
+tests/functional/semantics/analysis/test_array_index.py
+tests/functional/semantics/analysis/test_cyclic_function_calls.py
+tests/functional/semantics/analysis/test_for_loop.py
+tests/functional/semantics/analysis/test_potential_types.py
+tests/functional/semantics/types/test_event.py
+tests/functional/semantics/types/test_pure_types.py
+tests/functional/semantics/types/test_size_in_bytes.py
+tests/functional/semantics/types/test_type_from_abi.py
+tests/functional/semantics/types/test_type_from_annotation.py
 tests/fuzzing/test_exponents.py
 tests/grammar/test_grammar.py
+tests/parser/test_call_graph_stability.py
 tests/parser/ast_utils/test_ast.py
 tests/parser/ast_utils/test_ast_dict.py
 tests/parser/exceptions/__init__.py
 tests/parser/exceptions/test_argument_exception.py
 tests/parser/exceptions/test_call_violation.py
 tests/parser/exceptions/test_constancy_exception.py
 tests/parser/exceptions/test_function_declaration_exception.py
+tests/parser/exceptions/test_instantiation_exception.py
 tests/parser/exceptions/test_invalid_literal_exception.py
-tests/parser/exceptions/test_invalid_operation.py
 tests/parser/exceptions/test_invalid_payable.py
 tests/parser/exceptions/test_invalid_reference.py
 tests/parser/exceptions/test_invalid_type_exception.py
 tests/parser/exceptions/test_namespace_collision.py
 tests/parser/exceptions/test_overflow_exception.py
 tests/parser/exceptions/test_structure_exception.py
 tests/parser/exceptions/test_syntax_exception.py
 tests/parser/exceptions/test_type_mismatch_exception.py
 tests/parser/exceptions/test_undeclared_definition.py
 tests/parser/exceptions/test_variable_declaration_exception.py
 tests/parser/exceptions/test_vyper_exception_pos.py
+tests/parser/features/test_address_balance.py
 tests/parser/features/test_assert.py
 tests/parser/features/test_assert_unreachable.py
 tests/parser/features/test_assignment.py
 tests/parser/features/test_bytes_map_keys.py
 tests/parser/features/test_clampers.py
 tests/parser/features/test_comments.py
 tests/parser/features/test_comparison.py
@@ -200,15 +207,19 @@
 tests/parser/features/test_init.py
 tests/parser/features/test_internal_call.py
 tests/parser/features/test_logging.py
 tests/parser/features/test_logging_bytes_extended.py
 tests/parser/features/test_logging_from_call.py
 tests/parser/features/test_memory_dealloc.py
 tests/parser/features/test_packing.py
+tests/parser/features/test_reverting.py
 tests/parser/features/test_short_circuiting.py
+tests/parser/features/test_string_map_keys.py
+tests/parser/features/test_ternary.py
+tests/parser/features/test_transient.py
 tests/parser/features/arithmetic/test_division.py
 tests/parser/features/arithmetic/test_modulo.py
 tests/parser/features/decorators/test_nonreentrant.py
 tests/parser/features/decorators/test_payable.py
 tests/parser/features/decorators/test_private.py
 tests/parser/features/decorators/test_public.py
 tests/parser/features/decorators/test_pure.py
@@ -216,20 +227,22 @@
 tests/parser/features/external_contracts/test_erc20_abi.py
 tests/parser/features/external_contracts/test_external_contract_calls.py
 tests/parser/features/external_contracts/test_modifiable_external_contract_calls.py
 tests/parser/features/external_contracts/test_self_call_struct.py
 tests/parser/features/iteration/test_break.py
 tests/parser/features/iteration/test_continue.py
 tests/parser/features/iteration/test_for_in_list.py
+tests/parser/features/iteration/test_for_range.py
 tests/parser/features/iteration/test_range_in.py
-tests/parser/features/iteration/test_repeater.py
 tests/parser/functions/__init__.py
 tests/parser/functions/test_abi.py
 tests/parser/functions/test_abi_decode.py
 tests/parser/functions/test_abi_encode.py
+tests/parser/functions/test_addmod.py
+tests/parser/functions/test_as_wei_value.py
 tests/parser/functions/test_bitwise.py
 tests/parser/functions/test_block.py
 tests/parser/functions/test_block_number.py
 tests/parser/functions/test_ceil.py
 tests/parser/functions/test_concat.py
 tests/parser/functions/test_convert.py
 tests/parser/functions/test_create_functions.py
@@ -244,14 +257,15 @@
 tests/parser/functions/test_is_contract.py
 tests/parser/functions/test_keccak256.py
 tests/parser/functions/test_length.py
 tests/parser/functions/test_method_id.py
 tests/parser/functions/test_minmax.py
 tests/parser/functions/test_minmax_value.py
 tests/parser/functions/test_mkstr.py
+tests/parser/functions/test_mulmod.py
 tests/parser/functions/test_raw_call.py
 tests/parser/functions/test_return.py
 tests/parser/functions/test_return_struct.py
 tests/parser/functions/test_return_tuple.py
 tests/parser/functions/test_send.py
 tests/parser/functions/test_sha256.py
 tests/parser/functions/test_slice.py
@@ -271,23 +285,23 @@
 tests/parser/syntax/test_ann_assign.py
 tests/parser/syntax/test_as_uint256.py
 tests/parser/syntax/test_as_wei_value.py
 tests/parser/syntax/test_block.py
 tests/parser/syntax/test_blockscope.py
 tests/parser/syntax/test_bool.py
 tests/parser/syntax/test_bool_ops.py
-tests/parser/syntax/test_byte_string.py
 tests/parser/syntax/test_bytes.py
 tests/parser/syntax/test_chainid.py
 tests/parser/syntax/test_code_size.py
 tests/parser/syntax/test_codehash.py
 tests/parser/syntax/test_concat.py
 tests/parser/syntax/test_conditionals.py
 tests/parser/syntax/test_constants.py
 tests/parser/syntax/test_create_with_code_of.py
+tests/parser/syntax/test_dynamic_array.py
 tests/parser/syntax/test_enum.py
 tests/parser/syntax/test_extract32.py
 tests/parser/syntax/test_for_range.py
 tests/parser/syntax/test_functions_call.py
 tests/parser/syntax/test_immutables.py
 tests/parser/syntax/test_interfaces.py
 tests/parser/syntax/test_invalids.py
@@ -306,14 +320,15 @@
 tests/parser/syntax/test_return_tuple.py
 tests/parser/syntax/test_self_balance.py
 tests/parser/syntax/test_selfdestruct.py
 tests/parser/syntax/test_send.py
 tests/parser/syntax/test_slice.py
 tests/parser/syntax/test_string.py
 tests/parser/syntax/test_structs.py
+tests/parser/syntax/test_ternary.py
 tests/parser/syntax/test_tuple_assign.py
 tests/parser/syntax/test_unbalanced_return.py
 tests/parser/syntax/utils/test_event_names.py
 tests/parser/syntax/utils/test_function_names.py
 tests/parser/syntax/utils/test_variable_names.py
 tests/parser/types/test_bytes.py
 tests/parser/types/test_bytes_literal.py
@@ -333,15 +348,14 @@
 tests/parser/types/numbers/test_unsigned_ints.py
 tests/parser/types/value/test_as_wei_value.py
 tests/signatures/test_invalid_function_decorators.py
 tests/signatures/test_method_id_conflicts.py
 vyper/__init__.py
 vyper/__main__.py
 vyper/abi_types.py
-vyper/address_space.py
 vyper/exceptions.py
 vyper/typing.py
 vyper/utils.py
 vyper/version.py
 vyper/vyper_git_commithash.txt
 vyper/warnings.py
 vyper.egg-info/PKG-INFO
@@ -354,34 +368,32 @@
 vyper/ast/__init__.py
 vyper/ast/__init__.pyi
 vyper/ast/annotation.py
 vyper/ast/expansion.py
 vyper/ast/folding.py
 vyper/ast/grammar.lark
 vyper/ast/grammar.py
+vyper/ast/metadata.py
 vyper/ast/natspec.py
 vyper/ast/nodes.py
 vyper/ast/nodes.pyi
 vyper/ast/pre_parser.py
 vyper/ast/utils.py
 vyper/ast/validation.py
-vyper/ast/signatures/__init__.py
-vyper/ast/signatures/function_signature.py
-vyper/ast/signatures/interface.py
-vyper/builtin_functions/__init__.py
-vyper/builtin_functions/convert.py
-vyper/builtin_functions/functions.py
-vyper/builtin_functions/signatures.py
-vyper/builtin_functions/utils.py
-vyper/builtin_interfaces/ERC165.py
-vyper/builtin_interfaces/ERC20.py
-vyper/builtin_interfaces/ERC20Detailed.py
-vyper/builtin_interfaces/ERC4626.py
-vyper/builtin_interfaces/ERC721.py
-vyper/builtin_interfaces/__init__.py
+vyper/builtins/__init__.py
+vyper/builtins/_convert.py
+vyper/builtins/_signatures.py
+vyper/builtins/_utils.py
+vyper/builtins/functions.py
+vyper/builtins/interfaces/ERC165.py
+vyper/builtins/interfaces/ERC20.py
+vyper/builtins/interfaces/ERC20Detailed.py
+vyper/builtins/interfaces/ERC4626.py
+vyper/builtins/interfaces/ERC721.py
+vyper/builtins/interfaces/__init__.py
 vyper/cli/__init__.py
 vyper/cli/utils.py
 vyper/cli/vyper_compile.py
 vyper/cli/vyper_ir.py
 vyper/cli/vyper_json.py
 vyper/cli/vyper_serve.py
 vyper/codegen/__init__.py
@@ -401,54 +413,44 @@
 vyper/codegen/self_call.py
 vyper/codegen/stmt.py
 vyper/codegen/function_definitions/__init__.py
 vyper/codegen/function_definitions/common.py
 vyper/codegen/function_definitions/external_function.py
 vyper/codegen/function_definitions/internal_function.py
 vyper/codegen/function_definitions/utils.py
-vyper/codegen/types/__init__.py
-vyper/codegen/types/convert.py
-vyper/codegen/types/types.py
 vyper/compiler/README.md
 vyper/compiler/__init__.py
 vyper/compiler/output.py
 vyper/compiler/phases.py
 vyper/compiler/settings.py
 vyper/compiler/utils.py
 vyper/evm/__init__.py
+vyper/evm/address_space.py
 vyper/evm/opcodes.py
 vyper/ir/README.md
 vyper/ir/__init__.py
 vyper/ir/compile_ir.py
 vyper/ir/optimizer.py
 vyper/ir/s_expressions.py
 vyper/semantics/README.md
 vyper/semantics/__init__.py
+vyper/semantics/data_locations.py
 vyper/semantics/environment.py
 vyper/semantics/namespace.py
+vyper/semantics/analysis/__init__.py
+vyper/semantics/analysis/annotation.py
+vyper/semantics/analysis/base.py
+vyper/semantics/analysis/common.py
+vyper/semantics/analysis/data_positions.py
+vyper/semantics/analysis/levenshtein_utils.py
+vyper/semantics/analysis/local.py
+vyper/semantics/analysis/module.py
+vyper/semantics/analysis/utils.py
 vyper/semantics/types/__init__.py
-vyper/semantics/types/abstract.py
-vyper/semantics/types/bases.py
+vyper/semantics/types/base.py
+vyper/semantics/types/bytestrings.py
 vyper/semantics/types/function.py
-vyper/semantics/types/utils.py
-vyper/semantics/types/indexable/__init__.py
-vyper/semantics/types/indexable/mapping.py
-vyper/semantics/types/indexable/sequence.py
-vyper/semantics/types/user/__init__.py
-vyper/semantics/types/user/enum.py
-vyper/semantics/types/user/event.py
-vyper/semantics/types/user/interface.py
-vyper/semantics/types/user/struct.py
-vyper/semantics/types/value/__init__.py
-vyper/semantics/types/value/address.py
-vyper/semantics/types/value/array_value.py
-vyper/semantics/types/value/boolean.py
-vyper/semantics/types/value/bytes_fixed.py
-vyper/semantics/types/value/numeric.py
-vyper/semantics/validation/__init__.py
-vyper/semantics/validation/annotation.py
-vyper/semantics/validation/base.py
-vyper/semantics/validation/data_positions.py
-vyper/semantics/validation/levenshtein_utils.py
-vyper/semantics/validation/local.py
-vyper/semantics/validation/module.py
-vyper/semantics/validation/utils.py
+vyper/semantics/types/primitives.py
+vyper/semantics/types/shortcuts.py
+vyper/semantics/types/subscriptable.py
+vyper/semantics/types/user.py
+vyper/semantics/types/utils.py
```

### Comparing `vyper-0.3.7/vyper.egg-info/requires.txt` & `vyper-0.3.8/vyper.egg-info/requires.txt`

 * *Files 26% similar despite different names*

```diff
@@ -1,64 +1,61 @@
-asttokens==2.0.5
+asttokens<3,>=2.0.5
 pycryptodome<4,>=3.5.1
 semantic-version<3,>=2.10
-wheel
-
-[:python_version < "3.8"]
-cached-property==1.5.2
 importlib-metadata
+wheel
 
 [dev]
 pytest<7.0,>=6.2.5
 pytest-cov<3.0,>=2.10
 pytest-instafail<1.0,>=0.4
 pytest-xdist<3.0,>=2.5
 pytest-split<1.0,>=0.7.0
 pytest-rerunfailures<11,>=10.2
-eth-tester[py-evm]<0.7,>=0.6.0b6
-py-evm<0.6,>=0.5.0a3
-web3==5.27.0
+eth-tester[py-evm]<0.10,>=0.9.0b1
+py-evm<0.8,>=0.7.0a1
+web3==6.0.0
 tox<4.0,>=3.15
 lark==1.1.2
 hypothesis[lark]<6.0,>=5.37.1
-black==21.9b0
-click<8.1.0
+eth-stdlib==0.2.6
+black==23.3.0
 flake8==3.9.2
 flake8-bugbear==20.1.4
 flake8-use-fstring==1.1
 isort==5.9.3
 mypy==0.910
 recommonmark
-sphinx<4.0,>=3.0
-sphinx_rtd_theme<0.6,>=0.5
+sphinx<7.0,>=6.0
+sphinx_rtd_theme<1.3,>=1.2
 ipython
 pre-commit
 pyinstaller
 twine
 
 [docs]
 recommonmark
-sphinx<4.0,>=3.0
-sphinx_rtd_theme<0.6,>=0.5
+sphinx<7.0,>=6.0
+sphinx_rtd_theme<1.3,>=1.2
 
 [lint]
-black==21.9b0
-click<8.1.0
+black==23.3.0
 flake8==3.9.2
 flake8-bugbear==20.1.4
 flake8-use-fstring==1.1
 isort==5.9.3
 mypy==0.910
 
 [test]
 pytest<7.0,>=6.2.5
 pytest-cov<3.0,>=2.10
 pytest-instafail<1.0,>=0.4
 pytest-xdist<3.0,>=2.5
 pytest-split<1.0,>=0.7.0
 pytest-rerunfailures<11,>=10.2
-eth-tester[py-evm]<0.7,>=0.6.0b6
-py-evm<0.6,>=0.5.0a3
-web3==5.27.0
+eth-tester[py-evm]<0.10,>=0.9.0b1
+py-evm<0.8,>=0.7.0a1
+web3==6.0.0
 tox<4.0,>=3.15
 lark==1.1.2
 hypothesis[lark]<6.0,>=5.37.1
+eth-stdlib==0.2.6
```

